[
    {
        "id": 3560,
        "slug": "find-minimum-log-transportation-cost",
        "url": "https://leetcode.com/problems/find-minimum-log-transportation-cost/",
        "titulo": "Find Minimum Log Transportation Cost",
        "enunciado": "You are given integers \nn\n, \nm\n, and \nk\n.\n\n\nThere are two logs of lengths \nn\n and \nm\n units, which need to be transported in three trucks where each truck can carry one log with length \nat most\n \nk\n units.\n\n\nYou may cut the logs into smaller pieces, where the cost of cutting a log of length \nx\n into logs of length \nlen1\n and \nlen2\n is \ncost = len1 * len2\n such that \nlen1 + len2 = x\n.\n\n\nReturn the \nminimum total cost\n to distribute the logs onto the trucks. If the logs don't need to be cut, the total cost is 0.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 6, m = 5, k = 5\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\nCut the log with length 6 into logs with length 1 and 5, at a cost equal to \n1 * 5 == 5\n. Now the three logs of length 1, 5, and 5 can fit in one truck each.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 4, m = 4, k = 6\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe two logs can fit in the trucks already, hence we don't need to cut the logs.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= k <= 10\n5\n\n\n1 <= n, m <= 2 * k\n\n\nThe input is generated such that it is always possible to transport the logs.",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3541,
        "slug": "find-most-frequent-vowel-and-consonant",
        "url": "https://leetcode.com/problems/find-most-frequent-vowel-and-consonant/",
        "titulo": "Find Most Frequent Vowel and Consonant",
        "enunciado": "You are given a string \ns\n consisting of lowercase English letters (\n'a'\n to \n'z'\n). \n\n\nYour task is to:\n\n\n\n\nFind the vowel (one of \n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, or \n'u'\n) with the \nmaximum\n frequency.\n\n\nFind the consonant (all other letters excluding vowels) with the \nmaximum\n frequency.\n\n\n\n\nReturn the sum of the two frequencies.\n\n\nNote\n: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.\n\nThe \nfrequency\n of a letter \nx\n is the number of times it occurs in the string.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"successes\"\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\n\nThe vowels are: \n'u'\n (frequency 1), \n'e'\n (frequency 2). The maximum frequency is 2.\n\n\nThe consonants are: \n's'\n (frequency 4), \n'c'\n (frequency 2). The maximum frequency is 4.\n\n\nThe output is \n2 + 4 = 6\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"aeiaeia\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nThe vowels are: \n'a'\n (frequency 3), \n'e'\n ( frequency 2), \n'i'\n (frequency 2). The maximum frequency is 3.\n\n\nThere are no consonants in \ns\n. Hence, maximum consonant frequency = 0.\n\n\nThe output is \n3 + 0 = 3\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of lowercase English letters only.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3545,
        "slug": "minimum-deletions-for-at-most-k-distinct-characters",
        "url": "https://leetcode.com/problems/minimum-deletions-for-at-most-k-distinct-characters/",
        "titulo": "Minimum Deletions for At Most K Distinct Characters",
        "enunciado": "You are given a string \ns\n consisting of lowercase English letters, and an integer \nk\n.\n\n\nYour task is to delete some (possibly none) of the characters in the string so that the number of \ndistinct\n characters in the resulting string is \nat most\n \nk\n.\n\n\nReturn the \nminimum\n number of deletions required to achieve this.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"abc\", k = 2\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\ns\n has three distinct characters: \n'a'\n, \n'b'\n and \n'c'\n, each with a frequency of 1.\n\n\nSince we can have at most \nk = 2\n distinct characters, remove all occurrences of any one character from the string.\n\n\nFor example, removing all occurrences of \n'c'\n results in at most \nk\n distinct characters. Thus, the answer is 1.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"aabb\", k = 2\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\ns\n has two distinct characters (\n'a'\n and \n'b'\n) with frequencies of 2 and 2, respectively.\n\n\nSince we can have at most \nk = 2\n distinct characters, no deletions are required. Thus, the answer is 0.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"yyyzz\", k = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\ns\n has two distinct characters (\n'y'\n and \n'z'\n) with frequencies of 3 and 2, respectively.\n\n\nSince we can have at most \nk = 1\n distinct character, remove all occurrences of any one character from the string.\n\n\nRemoving all \n'z'\n results in at most \nk\n distinct characters. Thus, the answer is 2.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 16\n\n\n1 <= k <= 16\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Greedy",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3550,
        "slug": "smallest-index-with-digit-sum-equal-to-index",
        "url": "https://leetcode.com/problems/smallest-index-with-digit-sum-equal-to-index/",
        "titulo": "Smallest Index With Digit Sum Equal to Index",
        "enunciado": "You are given an integer array \nnums\n.\n\n\nReturn the \nsmallest\n index \ni\n such that the sum of the digits of \nnums[i]\n is equal to \ni\n.\n\n\nIf no such index exists, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,3,2]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nFor \nnums[2] = 2\n, the sum of digits is 2, which is equal to index \ni = 2\n. Thus, the output is 2.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,10,11]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nFor \nnums[1] = 10\n, the sum of digits is \n1 + 0 = 1\n, which is equal to index \ni = 1\n.\n\n\nFor \nnums[2] = 11\n, the sum of digits is \n1 + 1 = 2\n, which is equal to index \ni = 2\n.\n\n\nSince index 1 is the smallest, the output is 1.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\n\n\nSince no index satisfies the condition, the output is -1.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3536,
        "slug": "maximum-product-of-two-digits",
        "url": "https://leetcode.com/problems/maximum-product-of-two-digits/",
        "titulo": "Maximum Product of Two Digits",
        "enunciado": "You are given a positive integer \nn\n.\n\n\nReturn the \nmaximum\n product of any two digits in \nn\n.\n\n\nNote:\n You may use the \nsame\n digit twice if it appears more than once in \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 31\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nThe digits of \nn\n are \n[3, 1]\n.\n\n\nThe possible products of any two digits are: \n3 * 1 = 3\n.\n\n\nThe maximum product is 3.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 22\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\n\n\nThe digits of \nn\n are \n[2, 2]\n.\n\n\nThe possible products of any two digits are: \n2 * 2 = 4\n.\n\n\nThe maximum product is 4.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 124\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\nThe digits of \nn\n are \n[1, 2, 4]\n.\n\n\nThe possible products of any two digits are: \n1 * 2 = 2\n, \n1 * 4 = 4\n, \n2 * 4 = 8\n.\n\n\nThe maximum product is 8.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n10 <= n <= 10\n9",
        "temas": [
            "Math",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3512,
        "slug": "minimum-operations-to-make-array-sum-divisible-by-k",
        "url": "https://leetcode.com/problems/minimum-operations-to-make-array-sum-divisible-by-k/",
        "titulo": "Minimum Operations to Make Array Sum Divisible by K",
        "enunciado": "You are given an integer array \nnums\n and an integer \nk\n. You can perform the following operation any number of times:\n\n\n\n\nSelect an index \ni\n and replace \nnums[i]\n with \nnums[i] - 1\n.\n\n\n\n\nReturn the \nminimum\n number of operations required to make the sum of the array divisible by \nk\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [3,9,7], k = 5\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\n\n\nPerform 4 operations on \nnums[1] = 9\n. Now, \nnums = [3, 5, 7]\n.\n\n\nThe sum is 15, which is divisible by 5.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,3], k = 4\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\nThe sum is 8, which is already divisible by 4. Hence, no operations are needed.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [3,2], k = 6\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\n\n\nPerform 3 operations on \nnums[0] = 3\n and 2 operations on \nnums[1] = 2\n. Now, \nnums = [0, 0]\n.\n\n\nThe sum is 0, which is divisible by 6.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 1000\n\n\n1 <= k <= 100",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3502,
        "slug": "minimum-cost-to-reach-every-position",
        "url": "https://leetcode.com/problems/minimum-cost-to-reach-every-position/",
        "titulo": "Minimum Cost to Reach Every Position",
        "enunciado": "You are given an integer array \ncost\n of size \nn\n. You are currently at position \nn\n (at the end of the line) in a line of \nn + 1\n people (numbered from 0 to \nn\n).\n\n\nYou wish to move forward in the line, but each person in front of you charges a specific amount to \nswap\n places. The cost to swap with person \ni\n is given by \ncost[i]\n.\n\n\nYou are allowed to swap places with people as follows:\n\n\n\n\nIf they are in front of you, you \nmust\n pay them \ncost[i]\n to swap with them.\n\n\nIf they are behind you, they can swap with you for free.\n\n\n\n\nReturn an array \nanswer\n of size \nn\n, where \nanswer[i]\n is the \nminimum\n total cost to reach each position \ni\n in the line\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncost = [5,3,4,1,3,2]\n\n\nOutput:\n \n[5,3,3,1,1,1]\n\n\nExplanation:\n\n\nWe can get to each position in the following way:\n\n\n\n\ni = 0\n. We can swap with person 0 for a cost of 5.\n\n\ni = \n1\n. We can swap with person 1 for a cost of 3.\n\n\ni = 2\n. We can swap with person 1 for a cost of 3, then swap with person 2 for free.\n\n\ni = 3\n. We can swap with person 3 for a cost of 1.\n\n\ni = 4\n. We can swap with person 3 for a cost of 1, then swap with person 4 for free.\n\n\ni = 5\n. We can swap with person 3 for a cost of 1, then swap with person 5 for free.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncost = [1,2,4,6,7]\n\n\nOutput:\n \n[1,1,1,1,1]\n\n\nExplanation:\n\n\nWe can swap with person 0 for a cost of \n1, then we will be able to reach any position \ni\n for free.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == cost.length <= 100\n\n\n1 <= cost[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3516,
        "slug": "find-closest-person",
        "url": "https://leetcode.com/problems/find-closest-person/",
        "titulo": "Find Closest Person",
        "enunciado": "You are given three integers \nx\n, \ny\n, and \nz\n, representing the positions of three people on a number line:\n\n\n\n\nx\n is the position of Person 1.\n\n\ny\n is the position of Person 2.\n\n\nz\n is the position of Person 3, who does \nnot\n move.\n\n\n\n\nBoth Person 1 and Person 2 move toward Person 3 at the \nsame\n speed.\n\n\nDetermine which person reaches Person 3 \nfirst\n:\n\n\n\n\nReturn 1 if Person 1 arrives first.\n\n\nReturn 2 if Person 2 arrives first.\n\n\nReturn 0 if both arrive at the \nsame\n time.\n\n\n\n\nReturn the result accordingly.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nx = 2, y = 7, z = 4\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nPerson 1 is at position 2 and can reach Person 3 (at position 4) in 2 steps.\n\n\nPerson 2 is at position 7 and can reach Person 3 in 3 steps.\n\n\n\n\nSince Person 1 reaches Person 3 first, the output is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nx = 2, y = 5, z = 6\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nPerson 1 is at position 2 and can reach Person 3 (at position 6) in 4 steps.\n\n\nPerson 2 is at position 5 and can reach Person 3 in 1 step.\n\n\n\n\nSince Person 2 reaches Person 3 first, the output is 2.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nx = 1, y = 5, z = 3\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\nPerson 1 is at position 1 and can reach Person 3 (at position 3) in 2 steps.\n\n\nPerson 2 is at position 5 and can reach Person 3 in 2 steps.\n\n\n\n\nSince both Person 1 and Person 2 reach Person 3 at the same time, the output is 0.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= x, y, z <= 100",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3492,
        "slug": "maximum-containers-on-a-ship",
        "url": "https://leetcode.com/problems/maximum-containers-on-a-ship/",
        "titulo": "Maximum Containers on a Ship",
        "enunciado": "You are given a positive integer \nn\n representing an \nn x n\n cargo deck on a ship. Each cell on the deck can hold one container with a weight of \nexactly\n \nw\n.\n\n\nHowever, the total weight of all containers, if loaded onto the deck, must not exceed the ship's maximum weight capacity, \nmaxWeight\n.\n\n\nReturn the \nmaximum\n number of containers that can be loaded onto the ship.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 2, w = 3, maxWeight = 15\n\n\nOutput:\n 4\n\n\nExplanation: \n\n\nThe deck has 4 cells, and each container weighs 3. The total weight of loading all containers is 12, which does not exceed \nmaxWeight\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, w = 5, maxWeight = 20\n\n\nOutput:\n \n4\n\n\nExplanation: \n\n\nThe deck has 9 cells, and each container weighs 5. The maximum number of containers that can be loaded without exceeding \nmaxWeight\n is 4.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n1 <= w <= 1000\n\n\n1 <= maxWeight <= 10\n9",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3498,
        "slug": "reverse-degree-of-a-string",
        "url": "https://leetcode.com/problems/reverse-degree-of-a-string/",
        "titulo": "Reverse Degree of a String",
        "enunciado": "Given a string \ns\n, calculate its \nreverse degree\n.\n\n\nThe \nreverse degree\n is calculated as follows:\n\n\n\n\nFor each character, multiply its position in the \nreversed\n alphabet (\n'a'\n = 26, \n'b'\n = 25, ..., \n'z'\n = 1) with its position in the string \n(1-indexed)\n.\n\n\nSum these products for all characters in the string.\n\n\n\n\nReturn the \nreverse degree\n of \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"abc\"\n\n\nOutput:\n \n148\n\n\nExplanation:\n\n\n\n\n\n\n\n\nLetter\n\n\nIndex in Reversed Alphabet\n\n\nIndex in String\n\n\nProduct\n\n\n\n\n\n\n'a'\n\n\n26\n\n\n1\n\n\n26\n\n\n\n\n\n\n'b'\n\n\n25\n\n\n2\n\n\n50\n\n\n\n\n\n\n'c'\n\n\n24\n\n\n3\n\n\n72\n\n\n\n\n\n\n\n\nThe reversed degree is \n26 + 50 + 72 = 148\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"zaza\"\n\n\nOutput:\n \n160\n\n\nExplanation:\n\n\n\n\n\n\n\n\nLetter\n\n\nIndex in Reversed Alphabet\n\n\nIndex in String\n\n\nProduct\n\n\n\n\n\n\n'z'\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\n'a'\n\n\n26\n\n\n2\n\n\n52\n\n\n\n\n\n\n'z'\n\n\n1\n\n\n3\n\n\n3\n\n\n\n\n\n\n'a'\n\n\n26\n\n\n4\n\n\n104\n\n\n\n\n\n\n\n\nThe reverse degree is \n1 + 52 + 3 + 104 = 160\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n contains only lowercase English letters.",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3483,
        "slug": "unique-3-digit-even-numbers",
        "url": "https://leetcode.com/problems/unique-3-digit-even-numbers/",
        "titulo": "Unique 3-Digit Even Numbers",
        "enunciado": "You are given an array of digits called \ndigits\n. Your task is to determine the number of \ndistinct\n three-digit even numbers that can be formed using these digits.\n\n\nNote\n: Each \ncopy\n of a digit can only be used \nonce per number\n, and there may \nnot\n be leading zeros.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ndigits = [1,2,3,4]\n\n\nOutput:\n \n12\n\n\nExplanation:\n The 12 distinct 3-digit even numbers that can be formed are 124, 132, 134, 142, 214, 234, 312, 314, 324, 342, 412, and 432. Note that 222 cannot be formed because there is only 1 copy of the digit 2.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ndigits = [0,2,2]\n\n\nOutput:\n \n2\n\n\nExplanation:\n The only 3-digit even numbers that can be formed are 202 and 220. Note that the digit 2 can be used twice because it appears twice in the array.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ndigits = [6,6,6]\n\n\nOutput:\n \n1\n\n\nExplanation:\n Only 666 can be formed.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ndigits = [1,3,5]\n\n\nOutput:\n \n0\n\n\nExplanation:\n No even 3-digit numbers can be formed.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= digits.length <= 10\n\n\n0 <= digits[i] <= 9",
        "temas": [
            "Array",
            "Hash Table",
            "Recursion",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3477,
        "slug": "fruits-into-baskets-ii",
        "url": "https://leetcode.com/problems/fruits-into-baskets-ii/",
        "titulo": "Fruits Into Baskets II",
        "enunciado": "You are given two arrays of integers, \nfruits\n and \nbaskets\n, each of length \nn\n, where \nfruits[i]\n represents the \nquantity\n of the \ni\nth\n type of fruit, and \nbaskets[j]\n represents the \ncapacity\n of the \nj\nth\n basket.\n\n\nFrom left to right, place the fruits according to these rules:\n\n\n\n\nEach fruit type must be placed in the \nleftmost available basket\n with a capacity \ngreater than or equal\n to the quantity of that fruit type.\n\n\nEach basket can hold \nonly one\n type of fruit.\n\n\nIf a fruit type \ncannot be placed\n in any basket, it remains \nunplaced\n.\n\n\n\n\nReturn the number of fruit types that remain unplaced after all possible allocations are made.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nfruits = [4,2,5], baskets = [3,5,4]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nfruits[0] = 4\n is placed in \nbaskets[1] = 5\n.\n\n\nfruits[1] = 2\n is placed in \nbaskets[0] = 3\n.\n\n\nfruits[2] = 5\n cannot be placed in \nbaskets[2] = 4\n.\n\n\n\n\nSince one fruit type remains unplaced, we return 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nfruits = [3,6,1], baskets = [6,4,7]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\nfruits[0] = 3\n is placed in \nbaskets[0] = 6\n.\n\n\nfruits[1] = 6\n cannot be placed in \nbaskets[1] = 4\n (insufficient capacity) but can be placed in the next available basket, \nbaskets[2] = 7\n.\n\n\nfruits[2] = 1\n is placed in \nbaskets[1] = 4\n.\n\n\n\n\nSince all fruits are successfully placed, we return 0.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == fruits.length == baskets.length\n\n\n1 <= n <= 100\n\n\n1 <= fruits[i], baskets[i] <= 1000",
        "temas": [
            "Array",
            "Binary Search",
            "Segment Tree",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3487,
        "slug": "maximum-unique-subarray-sum-after-deletion",
        "url": "https://leetcode.com/problems/maximum-unique-subarray-sum-after-deletion/",
        "titulo": "Maximum Unique Subarray Sum After Deletion",
        "enunciado": "You are given an integer array \nnums\n.\n\n\nYou are allowed to delete any number of elements from \nnums\n without making it \nempty\n. After performing the deletions, select a \nsubarray\n of \nnums\n such that:\n\n\n\n\nAll elements in the subarray are \nunique\n.\n\n\nThe sum of the elements in the subarray is \nmaximized\n.\n\n\n\n\nReturn the \nmaximum sum\n of such a subarray.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,5]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\nSelect the entire array without deleting any element to obtain the maximum sum.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,0,1,1]\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\nDelete the element \nnums[0] == 1\n, \nnums[1] == 1\n, \nnums[2] == 0\n, and \nnums[3] == 1\n. Select the entire array \n[1]\n to obtain the maximum sum.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,-1,-2,1,0,-1]\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\nDelete the elements \nnums[2] == -1\n and \nnums[3] == -2\n, and select the subarray \n[2, 1]\n from \n[1, 2, 1, 0, -1]\n to obtain the maximum sum.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3467,
        "slug": "transform-array-by-parity",
        "url": "https://leetcode.com/problems/transform-array-by-parity/",
        "titulo": "Transform Array by Parity",
        "enunciado": "You are given an integer array \nnums\n. Transform \nnums\n by performing the following operations in the \nexact\n order specified:\n\n\n\n\nReplace each even number with 0.\n\n\nReplace each odd numbers with 1.\n\n\nSort the modified array in \nnon-decreasing\n order.\n\n\n\n\nReturn the resulting array after performing these operations.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [4,3,2,1]\n\n\nOutput:\n \n[0,0,1,1]\n\n\nExplanation:\n\n\n\n\nReplace the even numbers (4 and 2) with 0 and the odd numbers (3 and 1) with 1. Now, \nnums = [0, 1, 0, 1]\n.\n\n\nAfter sorting \nnums\n in non-descending order, \nnums = [0, 0, 1, 1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,5,1,4,2]\n\n\nOutput:\n \n[0,0,1,1,1]\n\n\nExplanation:\n\n\n\n\nReplace the even numbers (4 and 2) with 0 and the odd numbers (1, 5 and 1) with 1. Now, \nnums = [1, 1, 1, 0, 0]\n.\n\n\nAfter sorting \nnums\n in non-descending order, \nnums = [0, 0, 1, 1, 1]\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3507,
        "slug": "minimum-pair-removal-to-sort-array-i",
        "url": "https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/",
        "titulo": "Minimum Pair Removal to Sort Array I",
        "enunciado": "Given an array \nnums\n, you can perform the following operation any number of times:\n\n\n\n\nSelect the \nadjacent\n pair with the \nminimum\n sum in \nnums\n. If multiple such pairs exist, choose the leftmost one.\n\n\nReplace the pair with their sum.\n\n\n\n\nReturn the \nminimum number of operations\n needed to make the array \nnon-decreasing\n.\n\n\nAn array is said to be \nnon-decreasing\n if each element is greater than or equal to its previous element (if it exists).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [5,2,3,1]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nThe pair \n(3,1)\n has the minimum sum of 4. After replacement, \nnums = [5,2,4]\n.\n\n\nThe pair \n(2,4)\n has the minimum sum of 6. After replacement, \nnums = [5,6]\n.\n\n\n\n\nThe array \nnums\n became non-decreasing in two operations.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,2]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe array \nnums\n is already sorted.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n-1000 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Hash Table",
            "Linked List",
            "Heap (Priority Queue)",
            "Simulation",
            "Doubly-Linked List",
            "Ordered Set"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3461,
        "slug": "check-if-digits-are-equal-in-string-after-operations-i",
        "url": "https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/",
        "titulo": "Check If Digits Are Equal in String After Operations I",
        "enunciado": "You are given a string \ns\n consisting of digits. Perform the following operation repeatedly until the string has \nexactly\n two digits:\n\n\n\n\nFor each pair of consecutive digits in \ns\n, starting from the first digit, calculate a new digit as the sum of the two digits \nmodulo\n 10.\n\n\nReplace \ns\n with the sequence of newly calculated digits, \nmaintaining the order\n in which they are computed.\n\n\n\n\nReturn \ntrue\n if the final two digits in \ns\n are the \nsame\n; otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"3902\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nInitially, \ns = \"3902\"\n\n\nFirst operation:\n\t\n\n\n(s[0] + s[1]) % 10 = (3 + 9) % 10 = 2\n\n\n(s[1] + s[2]) % 10 = (9 + 0) % 10 = 9\n\n\n(s[2] + s[3]) % 10 = (0 + 2) % 10 = 2\n\n\ns\n becomes \n\"292\"\n\n\n\n\n\n\nSecond operation:\n\t\n\n\n(s[0] + s[1]) % 10 = (2 + 9) % 10 = 1\n\n\n(s[1] + s[2]) % 10 = (9 + 2) % 10 = 1\n\n\ns\n becomes \n\"11\"\n\n\n\n\n\n\nSince the digits in \n\"11\"\n are the same, the output is \ntrue\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"34789\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nInitially, \ns = \"34789\"\n.\n\n\nAfter the first operation, \ns = \"7157\"\n.\n\n\nAfter the second operation, \ns = \"862\"\n.\n\n\nAfter the third operation, \ns = \"48\"\n.\n\n\nSince \n'4' != '8'\n, the output is \nfalse\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 100\n\n\ns\n consists of only digits.",
        "temas": [
            "Math",
            "String",
            "Simulation",
            "Combinatorics",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3442,
        "slug": "maximum-difference-between-even-and-odd-frequency-i",
        "url": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i/",
        "titulo": "Maximum Difference Between Even and Odd Frequency I",
        "enunciado": "You are given a string \ns\n consisting of lowercase English letters. \n\n\nYour task is to find the \nmaximum\n difference \ndiff = a\n1\n - a\n2\n between the frequency of characters \na\n1\n and \na\n2\n in the string such that:\n\n\n\n\na\n1\n has an \nodd frequency\n in the string.\n\n\na\n2\n has an \neven frequency\n in the string.\n\n\n\n\nReturn this \nmaximum\n difference.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"aaaaabbc\"\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nThe character \n'a'\n has an \nodd frequency\n of \n5\n,\n and \n'b'\n has an \neven frequency\n of \n2\n.\n\n\nThe maximum difference is \n5 - 2 = 3\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"abcabcab\"\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\n\n\nThe character \n'a'\n has an \nodd frequency\n of \n3\n,\n and \n'c'\n has an \neven frequency\n of \n2\n.\n\n\nThe maximum difference is \n3 - 2 = 1\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters.\n\n\ns\n contains at least one character with an odd frequency and one with an even frequency.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3423,
        "slug": "maximum-difference-between-adjacent-elements-in-a-circular-array",
        "url": "https://leetcode.com/problems/maximum-difference-between-adjacent-elements-in-a-circular-array/",
        "titulo": "Maximum Difference Between Adjacent Elements in a Circular Array",
        "enunciado": "Given a \ncircular\n array \nnums\n, find the \nmaximum\n absolute difference between adjacent elements.\n\n\nNote\n: In a circular array, the first and last elements are adjacent.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,4]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nBecause \nnums\n is circular, \nnums[0]\n and \nnums[2]\n are adjacent. They have the maximum absolute difference of \n|4 - 1| = 3\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [-5,-10,-5]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\nThe adjacent elements \nnums[0]\n and \nnums[1]\n have the maximum absolute difference of \n|-5 - (-10)| = 5\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3438,
        "slug": "find-valid-pair-of-adjacent-digits-in-string",
        "url": "https://leetcode.com/problems/find-valid-pair-of-adjacent-digits-in-string/",
        "titulo": "Find Valid Pair of Adjacent Digits in String",
        "enunciado": "You are given a string \ns\n consisting only of digits. A \nvalid pair\n is defined as two \nadjacent\n digits in \ns\n such that:\n\n\n\n\nThe first digit is \nnot equal\n to the second.\n\n\nEach digit in the pair appears in \ns\n \nexactly\n as many times as its numeric value.\n\n\n\n\nReturn the first \nvalid pair\n found in the string \ns\n when traversing from left to right. If no valid pair exists, return an empty string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"2523533\"\n\n\nOutput:\n \n\"23\"\n\n\nExplanation:\n\n\nDigit \n'2'\n appears 2 times and digit \n'3'\n appears 3 times. Each digit in the pair \n\"23\"\n appears in \ns\n exactly as many times as its numeric value. Hence, the output is \n\"23\"\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"221\"\n\n\nOutput:\n \n\"21\"\n\n\nExplanation:\n\n\nDigit \n'2'\n appears 2 times and digit \n'1'\n appears 1 time. Hence, the output is \n\"21\"\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"22\"\n\n\nOutput:\n \n\"\"\n\n\nExplanation:\n\n\nThere are no valid adjacent pairs.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 100\n\n\ns\n only consists of digits from \n'1'\n to \n'9'\n.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3427,
        "slug": "sum-of-variable-length-subarrays",
        "url": "https://leetcode.com/problems/sum-of-variable-length-subarrays/",
        "titulo": "Sum of Variable Length Subarrays",
        "enunciado": "You are given an integer array \nnums\n of size \nn\n. For \neach\n index \ni\n where \n0 <= i < n\n, define a \nsubarray\n \nnums[start ... i]\n where \nstart = max(0, i - nums[i])\n.\n\n\nReturn the total sum of all elements from the subarray defined for each index in the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,3,1]\n\n\nOutput:\n \n11\n\n\nExplanation:\n\n\n\n\n\n\n\n\ni\n\n\nSubarray\n\n\nSum\n\n\n\n\n\n\n0\n\n\nnums[0] = [2]\n\n\n2\n\n\n\n\n\n\n1\n\n\nnums[0 ... 1] = [2, 3]\n\n\n5\n\n\n\n\n\n\n2\n\n\nnums[1 ... 2] = [3, 1]\n\n\n4\n\n\n\n\n\n\nTotal Sum\n\n\n \n\n\n11\n\n\n\n\n\n\n\n\nThe total sum is 11. Hence, 11 is the output.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [3,1,1,2]\n\n\nOutput:\n \n13\n\n\nExplanation:\n\n\n\n\n\n\n\n\ni\n\n\nSubarray\n\n\nSum\n\n\n\n\n\n\n0\n\n\nnums[0] = [3]\n\n\n3\n\n\n\n\n\n\n1\n\n\nnums[0 ... 1] = [3, 1]\n\n\n4\n\n\n\n\n\n\n2\n\n\nnums[1 ... 2] = [1, 1]\n\n\n2\n\n\n\n\n\n\n3\n\n\nnums[1 ... 3] = [1, 1, 2]\n\n\n4\n\n\n\n\n\n\nTotal Sum\n\n\n \n\n\n13\n\n\n\n\n\n\n\n\nThe total sum is 13. Hence, 13 is the output.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 100\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3452,
        "slug": "sum-of-good-numbers",
        "url": "https://leetcode.com/problems/sum-of-good-numbers/",
        "titulo": "Sum of Good Numbers",
        "enunciado": "Given an array of integers \nnums\n and an integer \nk\n, an element \nnums[i]\n is considered \ngood\n if it is \nstrictly\n greater than the elements at indices \ni - k\n and \ni + k\n (if those indices exist). If neither of these indices \nexists\n, \nnums[i]\n is still considered \ngood\n.\n\n\nReturn the \nsum\n of all the \ngood\n elements in the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,3,2,1,5,4], k = 2\n\n\nOutput:\n \n12\n\n\nExplanation:\n\n\nThe good numbers are \nnums[1] = 3\n, \nnums[4] = 5\n, and \nnums[5] = 4\n because they are strictly greater than the numbers at indices \ni - k\n and \ni + k\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,1], k = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe only good number is \nnums[0] = 2\n because it is strictly greater than \nnums[1]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 1000\n\n\n1 <= k <= floor(nums.length / 2)",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3456,
        "slug": "find-special-substring-of-length-k",
        "url": "https://leetcode.com/problems/find-special-substring-of-length-k/",
        "titulo": "Find Special Substring of Length K",
        "enunciado": "You are given a string \ns\n and an integer \nk\n.\n\n\nDetermine if there exists a \nsubstring\n of length \nexactly\n \nk\n in \ns\n that satisfies the following conditions:\n\n\n\n\nThe substring consists of \nonly one distinct character\n (e.g., \n\"aaa\"\n or \n\"bbb\"\n).\n\n\nIf there is a character \nimmediately before\n the substring, it must be different from the character in the substring.\n\n\nIf there is a character \nimmediately after\n the substring, it must also be different from the character in the substring.\n\n\n\n\nReturn \ntrue\n if such a substring exists. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"aaabaaa\", k = 3\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe substring \ns[4..6] == \"aaa\"\n satisfies the conditions.\n\n\n\n\nIt has a length of 3.\n\n\nAll characters are the same.\n\n\nThe character before \n\"aaa\"\n is \n'b'\n, which is different from \n'a'\n.\n\n\nThere is no character after \n\"aaa\"\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"abc\", k = 2\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nThere is no substring of length 2 that consists of one distinct character and satisfies the conditions.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= s.length <= 100\n\n\ns\n consists of lowercase English letters only.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3417,
        "slug": "zigzag-grid-traversal-with-skip",
        "url": "https://leetcode.com/problems/zigzag-grid-traversal-with-skip/",
        "titulo": "Zigzag Grid Traversal With Skip",
        "enunciado": "You are given an \nm x n\n 2D array \ngrid\n of \npositive\n integers.\n\n\nYour task is to traverse \ngrid\n in a \nzigzag\n pattern while skipping every \nalternate\n cell.\n\n\nZigzag pattern traversal is defined as following the below actions:\n\n\n\n\nStart at the top-left cell \n(0, 0)\n.\n\n\nMove \nright\n within a row until the end of the row is reached.\n\n\nDrop down to the next row, then traverse \nleft\n until the beginning of the row is reached.\n\n\nContinue \nalternating\n between right and left traversal until every row has been traversed.\n\n\n\n\nNote \nthat you \nmust skip\n every \nalternate\n cell during the traversal.\n\n\nReturn an array of integers \nresult\n containing, \nin order\n, the value of the cells visited during the zigzag traversal with skips.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,2],[3,4]]\n\n\nOutput:\n \n[1,4]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[2,1],[2,1],[2,1]]\n\n\nOutput:\n \n[2,1,2]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1,2,3],[4,5,6],[7,8,9]]\n\n\nOutput:\n \n[1,3,5,7,9]\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == grid.length <= 50\n\n\n2 <= m == grid[i].length <= 50\n\n\n1 <= grid[i][j] <= 2500",
        "temas": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3471,
        "slug": "find-the-largest-almost-missing-integer",
        "url": "https://leetcode.com/problems/find-the-largest-almost-missing-integer/",
        "titulo": "Find the Largest Almost Missing Integer",
        "enunciado": "You are given an integer array \nnums\n and an integer \nk\n.\n\n\nAn integer \nx\n is \nalmost missing\n from \nnums\n if \nx\n appears in \nexactly\n one subarray of size \nk\n within \nnums\n.\n\n\nReturn the \nlargest\n \nalmost missing\n integer from \nnums\n. If no such integer exists, return \n-1\n.\n\nA \nsubarray\n is a contiguous sequence of elements within an array.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [3,9,2,1,7], k = 3\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\n\n\n1 appears in 2 subarrays of size 3: \n[9, 2, 1]\n and \n[2, 1, 7]\n.\n\n\n2 appears in 3 subarrays of size 3: \n[3, 9, 2]\n, \n[9, 2, 1]\n, \n[2, 1, 7]\n.\n\n\n3 appears in 1 subarray of size 3: \n[3, 9, 2]\n.\n\n\n7 appears in 1 subarray of size 3: \n[2, 1, 7]\n.\n\n\n9 appears in 2 subarrays of size 3: \n[3, 9, 2]\n, and \n[9, 2, 1]\n.\n\n\n\n\nWe return 7 since it is the largest integer that appears in exactly one subarray of size \nk\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [3,9,7,2,1,7], k = 4\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\n1 appears in 2 subarrays of size 4: \n[9, 7, 2, 1]\n, \n[7, 2, 1, 7]\n.\n\n\n2 appears in 3 subarrays of size 4: \n[3, 9, 7, 2]\n, \n[9, 7, 2, 1]\n, \n[7, 2, 1, 7]\n.\n\n\n3 appears in 1 subarray of size 4: \n[3, 9, 7, 2]\n.\n\n\n7 appears in 3 subarrays of size 4: \n[3, 9, 7, 2]\n, \n[9, 7, 2, 1]\n, \n[7, 2, 1, 7]\n.\n\n\n9 appears in 2 subarrays of size 4: \n[3, 9, 7, 2]\n, \n[9, 7, 2, 1]\n.\n\n\n\n\nWe return 3 since it is the largest and only integer that appears in exactly one subarray of size \nk\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [0,0], k = 1\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nThere is no integer that appears in only one subarray of size 1.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n0 <= nums[i] <= 50\n\n\n1 <= k <= nums.length",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3432,
        "slug": "count-partitions-with-even-sum-difference",
        "url": "https://leetcode.com/problems/count-partitions-with-even-sum-difference/",
        "titulo": "Count Partitions with Even Sum Difference",
        "enunciado": "You are given an integer array \nnums\n of length \nn\n.\n\n\nA \npartition\n is defined as an index \ni\n where \n0 <= i < n - 1\n, splitting the array into two \nnon-empty\n subarrays such that:\n\n\n\n\nLeft subarray contains indices \n[0, i]\n.\n\n\nRight subarray contains indices \n[i + 1, n - 1]\n.\n\n\n\n\nReturn the number of \npartitions\n where the \ndifference\n between the \nsum\n of the left and right subarrays is \neven\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [10,10,3,7,6]\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nThe 4 partitions are:\n\n\n\n\n[10]\n, \n[10, 3, 7, 6]\n with a sum difference of \n10 - 26 = -16\n, which is even.\n\n\n[10, 10]\n, \n[3, 7, 6]\n with a sum difference of \n20 - 16 = 4\n, which is even.\n\n\n[10, 10, 3]\n, \n[7, 6]\n with a sum difference of \n23 - 13 = 10\n, which is even.\n\n\n[10, 10, 3, 7]\n, \n[6]\n with a sum difference of \n30 - 6 = 24\n, which is even.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,2]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo partition results in an even sum difference.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [2,4,6,8]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nAll partitions result in an even sum difference.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Math",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3411,
        "slug": "maximum-subarray-with-equal-products",
        "url": "https://leetcode.com/problems/maximum-subarray-with-equal-products/",
        "titulo": "Maximum Subarray With Equal Products",
        "enunciado": "You are given an array of \npositive\n integers \nnums\n.\n\n\nAn array \narr\n is called \nproduct equivalent\n if \nprod(arr) == lcm(arr) * gcd(arr)\n, where:\n\n\n\n\nprod(arr)\n is the product of all elements of \narr\n.\n\n\ngcd(arr)\n is the \nGCD\n of all elements of \narr\n.\n\n\nlcm(arr)\n is the \nLCM\n of all elements of \narr\n.\n\n\n\n\nReturn the length of the \nlongest\n \nproduct equivalent\n \nsubarray\n of \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,1,2,1,1,1]\n\n\nOutput:\n \n5\n\n\nExplanation:\n \n\n\nThe longest product equivalent subarray is \n[1, 2, 1, 1, 1]\n, where \nprod([1, 2, 1, 1, 1]) = 2\n, \ngcd([1, 2, 1, 1, 1]) = 1\n, and \nlcm([1, 2, 1, 1, 1]) = 2\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,3,4,5,6]\n\n\nOutput:\n \n3\n\n\nExplanation:\n \n\n\nThe longest product equivalent subarray is \n[3, 4, 5].\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3,1,4,5,1]\n\n\nOutput:\n \n5\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 10",
        "temas": [
            "Array",
            "Math",
            "Sliding Window",
            "Enumeration",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3402,
        "slug": "minimum-operations-to-make-columns-strictly-increasing",
        "url": "https://leetcode.com/problems/minimum-operations-to-make-columns-strictly-increasing/",
        "titulo": "Minimum Operations to Make Columns Strictly Increasing",
        "enunciado": "You are given a \nm x n\n matrix \ngrid\n consisting of \nnon-negative\n integers.\n\n\nIn one operation, you can increment the value of any \ngrid[i][j]\n by 1.\n\n\nReturn the \nminimum\n number of operations needed to make all columns of \ngrid\n \nstrictly increasing\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[3,2],[1,3],[3,4],[0,1]]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\n\n\nTo make the \n0\nth\n column strictly increasing, we can apply 3 operations on \ngrid[1][0]\n, 2 operations on \ngrid[2][0]\n, and 6 operations on \ngrid[3][0]\n.\n\n\nTo make the \n1\nst\n column strictly increasing, we can apply 4 operations on \ngrid[3][1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[3,2,1],[2,1,0],[1,2,3]]\n\n\nOutput:\n \n12\n\n\nExplanation:\n\n\n\n\nTo make the \n0\nth\n column strictly increasing, we can apply 2 operations on \ngrid[1][0]\n, and 4 operations on \ngrid[2][0]\n.\n\n\nTo make the \n1\nst\n column strictly increasing, we can apply 2 operations on \ngrid[1][1]\n, and 2 operations on \ngrid[2][1]\n.\n\n\nTo make the \n2\nnd\n column strictly increasing, we can apply 2 operations on \ngrid[1][2]\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= grid[i][j] < 2500",
        "temas": [
            "Array",
            "Greedy",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3392,
        "slug": "count-subarrays-of-length-three-with-a-condition",
        "url": "https://leetcode.com/problems/count-subarrays-of-length-three-with-a-condition/",
        "titulo": "Count Subarrays of Length Three With a Condition",
        "enunciado": "Given an integer array \nnums\n, return the number of \nsubarrays\n of length 3 such that the sum of the first and third numbers equals \nexactly\n half of the second number.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,1,4,1]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nOnly the subarray \n[1,4,1]\n contains exactly 3 elements where the sum of the first and third numbers equals half the middle number.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,1]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n[1,1,1]\n is the only subarray of length 3. However, its first and third numbers do not add to half the middle number.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 100\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3407,
        "slug": "substring-matching-pattern",
        "url": "https://leetcode.com/problems/substring-matching-pattern/",
        "titulo": "Substring Matching Pattern",
        "enunciado": "You are given a string \ns\n and a pattern string \np\n, where \np\n contains \nexactly one\n \n'*'\n character.\n\n\nThe \n'*'\n in \np\n can be replaced with any sequence of zero or more characters.\n\n\nReturn \ntrue\n if \np\n can be made a \nsubstring\n of \ns\n, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"leetcode\", p = \"ee*e\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nBy replacing the \n'*'\n with \n\"tcod\"\n, the substring \n\"eetcode\"\n matches the pattern.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"car\", p = \"c*v\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nThere is no substring matching the pattern.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"luck\", p = \"u*\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe substrings \n\"u\"\n, \n\"uc\"\n, and \n\"uck\"\n match the pattern.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 50\n\n\n1 <= p.length <= 50 \n\n\ns\n contains only lowercase English letters.\n\n\np\n contains only lowercase English letters and exactly one \n'*'",
        "temas": [
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3370,
        "slug": "smallest-number-with-all-set-bits",
        "url": "https://leetcode.com/problems/smallest-number-with-all-set-bits/",
        "titulo": "Smallest Number With All Set Bits",
        "enunciado": "You are given a \npositive\n number \nn\n.\n\n\nReturn the \nsmallest\n number \nx\n \ngreater than\n or \nequal to\n \nn\n, such that the binary representation of \nx\n contains only \nset bits\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\nThe binary representation of 7 is \n\"111\"\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 10\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\nThe binary representation of 15 is \n\"1111\"\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 3\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe binary representation of 3 is \n\"11\"\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
        "temas": [
            "Math",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3396,
        "slug": "minimum-number-of-operations-to-make-elements-in-array-distinct",
        "url": "https://leetcode.com/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/",
        "titulo": "Minimum Number of Operations to Make Elements in Array Distinct",
        "enunciado": "You are given an integer array \nnums\n. You need to ensure that the elements in the array are \ndistinct\n. To achieve this, you can perform the following operation any number of times:\n\n\n\n\nRemove 3 elements from the beginning of the array. If the array has fewer than 3 elements, remove all remaining elements.\n\n\n\n\nNote\n that an empty array is considered to have distinct elements. Return the \nminimum\n number of operations needed to make the elements in the array distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,2,3,3,5,7]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nIn the first operation, the first 3 elements are removed, resulting in the array \n[4, 2, 3, 3, 5, 7]\n.\n\n\nIn the second operation, the next 3 elements are removed, resulting in the array \n[3, 5, 7]\n, which has distinct elements.\n\n\n\n\nTherefore, the answer is 2.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,5,6,4,4]\n\n\nOutput:\n 2\n\n\nExplanation:\n\n\n\n\nIn the first operation, the first 3 elements are removed, resulting in the array \n[4, 4]\n.\n\n\nIn the second operation, all remaining elements are removed, resulting in an empty array.\n\n\n\n\nTherefore, the answer is 2.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [6,7,8,9]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe array already contains distinct elements. Therefore, the answer is 0.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3379,
        "slug": "transformed-array",
        "url": "https://leetcode.com/problems/transformed-array/",
        "titulo": "Transformed Array",
        "enunciado": "You are given an integer array \nnums\n that represents a circular array. Your task is to create a new array \nresult\n of the \nsame\n size, following these rules:\n\nFor each index \ni\n (where \n0 <= i < nums.length\n), perform the following \nindependent\n actions:\n\n\n\n\nIf \nnums[i] > 0\n: Start at index \ni\n and move \nnums[i]\n steps to the \nright\n in the circular array. Set \nresult[i]\n to the value of the index where you land.\n\n\nIf \nnums[i] < 0\n: Start at index \ni\n and move \nabs(nums[i])\n steps to the \nleft\n in the circular array. Set \nresult[i]\n to the value of the index where you land.\n\n\nIf \nnums[i] == 0\n: Set \nresult[i]\n to \nnums[i]\n.\n\n\n\n\nReturn the new array \nresult\n.\n\n\nNote:\n Since \nnums\n is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [3,-2,1,1]\n\n\nOutput:\n \n[1,1,1,3]\n\n\nExplanation:\n\n\n\n\nFor \nnums[0]\n that is equal to 3, If we move 3 steps to right, we reach \nnums[3]\n. So \nresult[0]\n should be 1.\n\n\nFor \nnums[1]\n that is equal to -2, If we move 2 steps to left, we reach \nnums[3]\n. So \nresult[1]\n should be 1.\n\n\nFor \nnums[2]\n that is equal to 1, If we move 1 step to right, we reach \nnums[3]\n. So \nresult[2]\n should be 1.\n\n\nFor \nnums[3]\n that is equal to 1, If we move 1 step to right, we reach \nnums[0]\n. So \nresult[3]\n should be 3.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [-1,4,-1]\n\n\nOutput:\n \n[-1,-1,4]\n\n\nExplanation:\n\n\n\n\nFor \nnums[0]\n that is equal to -1, If we move 1 step to left, we reach \nnums[2]\n. So \nresult[0]\n should be -1.\n\n\nFor \nnums[1]\n that is equal to 4, If we move 4 steps to right, we reach \nnums[2]\n. So \nresult[1]\n should be -1.\n\n\nFor \nnums[2]\n that is equal to -1, If we move 1 step to left, we reach \nnums[1]\n. So \nresult[2]\n should be 4.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3364,
        "slug": "minimum-positive-sum-subarray",
        "url": "https://leetcode.com/problems/minimum-positive-sum-subarray/",
        "titulo": "Minimum Positive Sum Subarray ",
        "enunciado": "You are given an integer array \nnums\n and \ntwo\n integers \nl\n and \nr\n. Your task is to find the \nminimum\n sum of a \nsubarray\n whose size is between \nl\n and \nr\n (inclusive) and whose sum is greater than 0.\n\n\nReturn the \nminimum\n sum of such a subarray. If no such subarray exists, return -1.\n\n\nA \nsubarray\n is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [3, -2, 1, 4], l = 2, r = 3\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe subarrays of length between \nl = 2\n and \nr = 3\n where the sum is greater than 0 are:\n\n\n\n\n[3, -2]\n with a sum of 1\n\n\n[1, 4]\n with a sum of 5\n\n\n[3, -2, 1]\n with a sum of 2\n\n\n[-2, 1, 4]\n with a sum of 3\n\n\n\n\nOut of these, the subarray \n[3, -2]\n has a sum of 1, which is the smallest positive sum. Hence, the answer is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [-2, 2, -3, 1], l = 2, r = 3\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nThere is no subarray of length between \nl\n and \nr\n that has a sum greater than 0. So, the answer is -1.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1, 2, 3, 4], l = 2, r = 4\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe subarray \n[1, 2]\n has a length of 2 and the minimum sum greater than 0. So, the answer is 3.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= l <= r <= nums.length\n\n\n-1000 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Sliding Window",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3340,
        "slug": "check-balanced-string",
        "url": "https://leetcode.com/problems/check-balanced-string/",
        "titulo": "Check Balanced String",
        "enunciado": "You are given a string \nnum\n consisting of only digits. A string of digits is called \nbalanced \nif the sum of the digits at even indices is equal to the sum of digits at odd indices.\n\n\nReturn \ntrue\n if \nnum\n is \nbalanced\n, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num\n = \"1234\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nThe sum of digits at even indices is \n1 + 3 == 4\n, and the sum of digits at odd indices is \n2 + 4 == 6\n.\n\n\nSince 4 is not equal to 6, \nnum\n is not balanced.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n num\n = \"24123\"\n\n\nOutput:\n true\n\n\nExplanation:\n\n\n\n\nThe sum of digits at even indices is \n2 + 1 + 3 == 6\n, and the sum of digits at odd indices is \n4 + 2 == 6\n.\n\n\nSince both are equal the \nnum\n is balanced.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= num.length <= 100\n\n\nnum\n consists of digits only",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3386,
        "slug": "button-with-longest-push-time",
        "url": "https://leetcode.com/problems/button-with-longest-push-time/",
        "titulo": "Button with Longest Push Time",
        "enunciado": "You are given a 2D array \nevents\n which represents a sequence of events where a child pushes a series of buttons on a keyboard.\n\n\nEach \nevents[i] = [index\ni\n, time\ni\n]\n indicates that the button at index \nindex\ni\n was pressed at time \ntime\ni\n.\n\n\n\n\nThe array is \nsorted\n in increasing order of \ntime\n.\n\n\nThe time taken to press a button is the difference in time between consecutive button presses. The time for the first button is simply the time at which it was pressed.\n\n\n\n\nReturn the \nindex\n of the button that took the \nlongest\n time to push. If multiple buttons have the same longest time, return the button with the \nsmallest\n \nindex\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nevents = [[1,2],[2,5],[3,9],[1,15]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nButton with index 1 is pressed at time 2.\n\n\nButton with index 2 is pressed at time 5, so it took \n5 - 2 = 3\n units of time.\n\n\nButton with index 3 is pressed at time 9, so it took \n9 - 5 = 4\n units of time.\n\n\nButton with index 1 is pressed again at time 15, so it took \n15 - 9 = 6\n units of time.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nevents = [[10,5],[1,7]]\n\n\nOutput:\n \n10\n\n\nExplanation:\n\n\n\n\nButton with index 10 is pressed at time 5.\n\n\nButton with index 1 is pressed at time 7, so it took \n7 - 5 = 2\n units of time.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= events.length <= 1000\n\n\nevents[i] == [index\ni\n, time\ni\n]\n\n\n1 <= index\ni\n, time\ni\n <= 10\n5\n\n\nThe input is generated such that \nevents\n is sorted in increasing order of \ntime\ni\n.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3345,
        "slug": "smallest-divisible-digit-product-i",
        "url": "https://leetcode.com/problems/smallest-divisible-digit-product-i/",
        "titulo": "Smallest Divisible Digit Product I",
        "enunciado": "You are given two integers \nn\n and \nt\n. Return the \nsmallest\n number greater than or equal to \nn\n such that the \nproduct of its digits\n is divisible by \nt\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 10, t = 2\n\n\nOutput:\n \n10\n\n\nExplanation:\n\n\nThe digit product of 10 is 0, which is divisible by 2, making it the smallest number greater than or equal to 10 that satisfies the condition.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 15, t = 3\n\n\nOutput:\n \n16\n\n\nExplanation:\n\n\nThe digit product of 16 is 6, which is divisible by 3, making it the smallest number greater than or equal to 15 that satisfies the condition.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n1 <= t <= 10",
        "temas": [
            "Math",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3360,
        "slug": "stone-removal-game",
        "url": "https://leetcode.com/problems/stone-removal-game/",
        "titulo": "Stone Removal Game",
        "enunciado": "Alice and Bob are playing a game where they take turns removing stones from a pile, with \nAlice going first\n.\n\n\n\n\nAlice starts by removing \nexactly\n 10 stones on her first turn.\n\n\nFor each subsequent turn, each player removes \nexactly\n 1 fewer\n \nstone\n \nthan the previous opponent.\n\n\n\n\nThe player who cannot make a move loses the game.\n\n\nGiven a positive integer \nn\n, return \ntrue\n if Alice wins the game and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 12\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nAlice removes 10 stones on her first turn, leaving 2 stones for Bob.\n\n\nBob cannot remove 9 stones, so Alice wins.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 1\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nAlice cannot remove 10 stones, so Alice loses.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 50",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3375,
        "slug": "minimum-operations-to-make-array-values-equal-to-k",
        "url": "https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/",
        "titulo": "Minimum Operations to Make Array Values Equal to K",
        "enunciado": "You are given an integer array \nnums\n and an integer \nk\n.\n\n\nAn integer \nh\n is called \nvalid\n if all values in the array that are \nstrictly greater\n than \nh\n are \nidentical\n.\n\n\nFor example, if \nnums = [10, 8, 10, 8]\n, a \nvalid\n integer is \nh = 9\n because all \nnums[i] > 9\n are equal to 10, but 5 is not a \nvalid\n integer.\n\n\nYou are allowed to perform the following operation on \nnums\n:\n\n\n\n\nSelect an integer \nh\n that is \nvalid\n for the \ncurrent\n values in \nnums\n.\n\n\nFor each index \ni\n where \nnums[i] > h\n, set \nnums[i]\n to \nh\n.\n\n\n\n\nReturn the \nminimum\n number of operations required to make every element in \nnums\n \nequal\n to \nk\n. If it is impossible to make all elements equal to \nk\n, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [5,2,5,4,5], k = 2\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe operations can be performed in order using valid integers 4 and then 2.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,1,2], k = 2\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nIt is impossible to make all the values equal to 2.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [9,7,5,3], k = 1\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nThe operations can be performed using valid integers in the order 7, 5, 3, and 1.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100 \n\n\n1 <= nums[i] <= 100\n\n\n1 <= k <= 100",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3330,
        "slug": "find-the-original-typed-string-i",
        "url": "https://leetcode.com/problems/find-the-original-typed-string-i/",
        "titulo": "Find the Original Typed String I",
        "enunciado": "Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and \nmay\n press a key for too long, resulting in a character being typed \nmultiple\n times.\n\n\nAlthough Alice tried to focus on her typing, she is aware that she may still have done this \nat most\n \nonce\n.\n\n\nYou are given a string \nword\n, which represents the \nfinal\n output displayed on Alice's screen.\n\n\nReturn the total number of \npossible\n original strings that Alice \nmight\n have intended to type.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nword = \"abbcccc\"\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\nThe possible strings are: \n\"abbcccc\"\n, \n\"abbccc\"\n, \n\"abbcc\"\n, \n\"abbc\"\n, and \n\"abcccc\"\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nword = \"abcd\"\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe only possible string is \n\"abcd\"\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nword = \"aaaa\"\n\n\nOutput:\n \n4\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 100\n\n\nword\n consists only of lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3354,
        "slug": "make-array-elements-equal-to-zero",
        "url": "https://leetcode.com/problems/make-array-elements-equal-to-zero/",
        "titulo": "Make Array Elements Equal to Zero",
        "enunciado": "You are given an integer array \nnums\n.\n\n\nStart by selecting a starting position \ncurr\n such that \nnums[curr] == 0\n, and choose a movement \ndirection\n of either left or right.\n\n\nAfter that, you repeat the following process:\n\n\n\n\nIf \ncurr\n is out of the range \n[0, n - 1]\n, this process ends.\n\n\nIf \nnums[curr] == 0\n, move in the current direction by \nincrementing\n \ncurr\n if you are moving right, or \ndecrementing\n \ncurr\n if you are moving left.\n\n\nElse if \nnums[curr] > 0\n:\n\t\n\n\nDecrement \nnums[curr]\n by 1.\n\n\nReverse\n your movement direction (left becomes right and vice versa).\n\n\nTake a step in your new direction.\n\n\n\n\n\n\n\n\nA selection of the initial position \ncurr\n and movement direction is considered \nvalid\n if every element in \nnums\n becomes 0 by the end of the process.\n\n\nReturn the number of possible \nvalid\n selections.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,0,2,0,3]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe only possible valid selections are the following:\n\n\n\n\nChoose \ncurr = 3\n, and a movement direction to the left.\n\n\t\n\n\n[1,0,2,\n0\n,3] -> [1,0,\n2\n,0,3] -> [1,0,1,\n0\n,3] -> [1,0,1,0,\n3\n] -> [1,0,1,\n0\n,2] -> [1,0,\n1\n,0,2] -> [1,0,0,\n0\n,2] -> [1,0,0,0,\n2\n] -> [1,0,0,\n0\n,1] -> [1,0,\n0\n,0,1] -> [1,\n0\n,0,0,1] -> [\n1\n,0,0,0,1] -> [0,\n0\n,0,0,1] -> [0,0,\n0\n,0,1] -> [0,0,0,\n0\n,1] -> [0,0,0,0,\n1\n] -> [0,0,0,0,0]\n.\n\n\n\n\n\n\nChoose \ncurr = 3\n, and a movement direction to the right.\n\t\n\n\n[1,0,2,\n0\n,3] -> [1,0,2,0,\n3\n] -> [1,0,2,\n0\n,2] -> [1,0,\n2\n,0,2] -> [1,0,1,\n0\n,2] -> [1,0,1,0,\n2\n] -> [1,0,1,\n0\n,1] -> [1,0,\n1\n,0,1] -> [1,0,0,\n0\n,1] -> [1,0,0,0,\n1\n] -> [1,0,0,\n0\n,0] -> [1,0,\n0\n,0,0] -> [1,\n0\n,0,0,0] -> [\n1\n,0,0,0,0] -> [0,0,0,0,0].\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,3,4,0,4,1,0]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThere are no possible valid selections.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100\n\n\nThere is at least one element \ni\n where \nnums[i] == 0\n.",
        "temas": [
            "Array",
            "Simulation",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3349,
        "slug": "adjacent-increasing-subarrays-detection-i",
        "url": "https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i/",
        "titulo": "Adjacent Increasing Subarrays Detection I",
        "enunciado": "Given an array \nnums\n of \nn\n integers and an integer \nk\n, determine whether there exist \ntwo\n \nadjacent\n \nsubarrays\n of length \nk\n such that both subarrays are \nstrictly\n \nincreasing\n. Specifically, check if there are \ntwo\n subarrays starting at indices \na\n and \nb\n (\na < b\n), where:\n\n\n\n\nBoth subarrays \nnums[a..a + k - 1]\n and \nnums[b..b + k - 1]\n are \nstrictly increasing\n.\n\n\nThe subarrays must be \nadjacent\n, meaning \nb = a + k\n.\n\n\n\n\nReturn \ntrue\n if it is \npossible\n to find \ntwo \nsuch subarrays, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,5,7,8,9,2,3,4,3,1], k = 3\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nThe subarray starting at index \n2\n is \n[7, 8, 9]\n, which is strictly increasing.\n\n\nThe subarray starting at index \n5\n is \n[2, 3, 4]\n, which is also strictly increasing.\n\n\nThese two subarrays are adjacent, so the result is \ntrue\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,4,4,4,5,6,7], k = 5\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 < 2 * k <= nums.length\n\n\n-1000 <= nums[i] <= 1000",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3318,
        "slug": "find-x-sum-of-all-k-long-subarrays-i",
        "url": "https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/",
        "titulo": "Find X-Sum of All K-Long Subarrays I",
        "enunciado": "You are given an array \nnums\n of \nn\n integers and two integers \nk\n and \nx\n.\n\n\nThe \nx-sum\n of an array is calculated by the following procedure:\n\n\n\n\nCount the occurrences of all elements in the array.\n\n\nKeep only the occurrences of the top \nx\n most frequent elements. If two elements have the same number of occurrences, the element with the \nbigger\n value is considered more frequent.\n\n\nCalculate the sum of the resulting array.\n\n\n\n\nNote\n that if an array has less than \nx\n distinct elements, its \nx-sum\n is the sum of the array.\n\n\nReturn an integer array \nanswer\n of length \nn - k + 1\n where \nanswer[i]\n is the \nx-sum\n of the \nsubarray\n \nnums[i..i + k - 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,1,2,2,3,4,2,3], k = 6, x = 2\n\n\nOutput:\n \n[6,10,12]\n\n\nExplanation:\n\n\n\n\nFor subarray \n[1, 1, 2, 2, 3, 4]\n, only elements 1 and 2 will be kept in the resulting array. Hence, \nanswer[0] = 1 + 1 + 2 + 2\n.\n\n\nFor subarray \n[1, 2, 2, 3, 4, 2]\n, only elements 2 and 4 will be kept in the resulting array. Hence, \nanswer[1] = 2 + 2 + 2 + 4\n. Note that 4 is kept in the array since it is bigger than 3 and 1 which occur the same number of times.\n\n\nFor subarray \n[2, 2, 3, 4, 2, 3]\n, only elements 2 and 3 are kept in the resulting array. Hence, \nanswer[2] = 2 + 2 + 2 + 3 + 3\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [3,8,7,8,7,5], k = 2, x = 2\n\n\nOutput:\n \n[11,15,15,15,12]\n\n\nExplanation:\n\n\nSince \nk == x\n, \nanswer[i]\n is equal to the sum of the subarray \nnums[i..i + k - 1]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 50\n\n\n1 <= nums[i] <= 50\n\n\n1 <= x <= k <= nums.length",
        "temas": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3300,
        "slug": "minimum-element-after-replacement-with-digit-sum",
        "url": "https://leetcode.com/problems/minimum-element-after-replacement-with-digit-sum/",
        "titulo": "Minimum Element After Replacement With Digit Sum",
        "enunciado": "You are given an integer array \nnums\n.\n\n\nYou replace each element in \nnums\n with the \nsum\n of its digits.\n\n\nReturn the \nminimum\n element in \nnums\n after all replacements.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [10,12,13,14]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nnums\n becomes \n[1, 3, 4, 5]\n after all replacements, with minimum element 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nnums\n becomes \n[1, 2, 3, 4]\n after all replacements, with minimum element 1.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [999,19,199]\n\n\nOutput:\n \n10\n\n\nExplanation:\n\n\nnums\n becomes \n[27, 10, 19]\n after all replacements, with minimum element 10.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3314,
        "slug": "construct-the-minimum-bitwise-array-i",
        "url": "https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/",
        "titulo": "Construct the Minimum Bitwise Array I",
        "enunciado": "You are given an array \nnums\n consisting of \nn\n \nprime\n integers.\n\n\nYou need to construct an array \nans\n of length \nn\n, such that, for each index \ni\n, the bitwise \nOR\n of \nans[i]\n and \nans[i] + 1\n is equal to \nnums[i]\n, i.e. \nans[i] OR (ans[i] + 1) == nums[i]\n.\n\n\nAdditionally, you must \nminimize\n each value of \nans[i]\n in the resulting array.\n\n\nIf it is \nnot possible\n to find such a value for \nans[i]\n that satisfies the \ncondition\n, then set \nans[i] = -1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,3,5,7]\n\n\nOutput:\n \n[-1,1,4,3]\n\n\nExplanation:\n\n\n\n\nFor \ni = 0\n, as there is no value for \nans[0]\n that satisfies \nans[0] OR (ans[0] + 1) = 2\n, so \nans[0] = -1\n.\n\n\nFor \ni = 1\n, the smallest \nans[1]\n that satisfies \nans[1] OR (ans[1] + 1) = 3\n is \n1\n, because \n1 OR (1 + 1) = 3\n.\n\n\nFor \ni = 2\n, the smallest \nans[2]\n that satisfies \nans[2] OR (ans[2] + 1) = 5\n is \n4\n, because \n4 OR (4 + 1) = 5\n.\n\n\nFor \ni = 3\n, the smallest \nans[3]\n that satisfies \nans[3] OR (ans[3] + 1) = 7\n is \n3\n, because \n3 OR (3 + 1) = 7\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [11,13,31]\n\n\nOutput:\n \n[9,12,15]\n\n\nExplanation:\n\n\n\n\nFor \ni = 0\n, the smallest \nans[0]\n that satisfies \nans[0] OR (ans[0] + 1) = 11\n is \n9\n, because \n9 OR (9 + 1) = 11\n.\n\n\nFor \ni = 1\n, the smallest \nans[1]\n that satisfies \nans[1] OR (ans[1] + 1) = 13\n is \n12\n, because \n12 OR (12 + 1) = 13\n.\n\n\nFor \ni = 2\n, the smallest \nans[2]\n that satisfies \nans[2] OR (ans[2] + 1) = 31\n is \n15\n, because \n15 OR (15 + 1) = 31\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n2 <= nums[i] <= 1000\n\n\nnums[i]\n is a prime number.",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3304,
        "slug": "find-the-k-th-character-in-string-game-i",
        "url": "https://leetcode.com/problems/find-the-k-th-character-in-string-game-i/",
        "titulo": "Find the K-th Character in String Game I",
        "enunciado": "Alice and Bob are playing a game. Initially, Alice has a string \nword = \"a\"\n.\n\n\nYou are given a \npositive\n integer \nk\n.\n\n\nNow Bob will ask Alice to perform the following operation \nforever\n:\n\n\n\n\nGenerate a new string by \nchanging\n each character in \nword\n to its \nnext\n character in the English alphabet, and \nappend\n it to the \noriginal\n \nword\n.\n\n\n\n\nFor example, performing the operation on \n\"c\"\n generates \n\"cd\"\n and performing the operation on \n\"zb\"\n generates \n\"zbac\"\n.\n\n\nReturn the value of the \nk\nth\n character in \nword\n, after enough operations have been done for \nword\n to have \nat least\n \nk\n characters.\n\n\nNote\n that the character \n'z'\n can be changed to \n'a'\n in the operation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nk = 5\n\n\nOutput:\n \n\"b\"\n\n\nExplanation:\n\n\nInitially, \nword = \"a\"\n. We need to do the operation three times:\n\n\n\n\nGenerated string is \n\"b\"\n, \nword\n becomes \n\"ab\"\n.\n\n\nGenerated string is \n\"bc\"\n, \nword\n becomes \n\"abbc\"\n.\n\n\nGenerated string is \n\"bccd\"\n, \nword\n becomes \n\"abbcbccd\"\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nk = 10\n\n\nOutput:\n \n\"c\"\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= 500",
        "temas": [
            "Math",
            "Bit Manipulation",
            "Recursion",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3285,
        "slug": "find-indices-of-stable-mountains",
        "url": "https://leetcode.com/problems/find-indices-of-stable-mountains/",
        "titulo": "Find Indices of Stable Mountains",
        "enunciado": "There are \nn\n mountains in a row, and each mountain has a height. You are given an integer array \nheight\n where \nheight[i]\n represents the height of mountain \ni\n, and an integer \nthreshold\n.\n\n\nA mountain is called \nstable\n if the mountain just before it (\nif it exists\n) has a height \nstrictly greater\n than \nthreshold\n. \nNote\n that mountain 0 is \nnot\n stable.\n\n\nReturn an array containing the indices of \nall\n \nstable\n mountains in \nany\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nheight = [1,2,3,4,5], threshold = 2\n\n\nOutput:\n \n[3,4]\n\n\nExplanation:\n\n\n\n\nMountain 3 is stable because \nheight[2] == 3\n is greater than \nthreshold == 2\n.\n\n\nMountain 4 is stable because \nheight[3] == 4\n is greater than \nthreshold == 2\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nheight = [10,1,10,1,10], threshold = 3\n\n\nOutput:\n \n[1,3]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nheight = [10,1,10,1,10], threshold = 10\n\n\nOutput:\n \n[]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == height.length <= 100\n\n\n1 <= height[i] <= 100\n\n\n1 <= threshold <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3289,
        "slug": "the-two-sneaky-numbers-of-digitville",
        "url": "https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/",
        "titulo": "The Two Sneaky Numbers of Digitville",
        "enunciado": "In the town of Digitville, there was a list of numbers called \nnums\n containing integers from \n0\n to \nn - 1\n. Each number was supposed to appear \nexactly once\n in the list, however, \ntwo\n mischievous numbers sneaked in an \nadditional time\n, making the list longer than usual.\n\n\nAs the town detective, your task is to find these two sneaky numbers. Return an array of size \ntwo\n containing the two numbers (in \nany order\n), so peace can return to Digitville.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [0,1,1,0]\n\n\nOutput:\n \n[0,1]\n\n\nExplanation:\n\n\nThe numbers 0 and 1 each appear twice in the array.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [0,3,2,1,3,2]\n\n\nOutput:\n \n[2,3]\n\n\nExplanation: \n\n\nThe numbers 2 and 3 each appear twice in the array.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [7,1,5,4,3,4,6,0,9,5,8,2]\n\n\nOutput:\n \n[4,5]\n\n\nExplanation: \n\n\nThe numbers 4 and 5 each appear twice in the array.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\nnums.length == n + 2\n\n\n0 <= nums[i] < n\n\n\nThe input is generated such that \nnums\n contains \nexactly\n two repeated elements.",
        "temas": [
            "Array",
            "Hash Table",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3270,
        "slug": "find-the-key-of-the-numbers",
        "url": "https://leetcode.com/problems/find-the-key-of-the-numbers/",
        "titulo": "Find the Key of the Numbers",
        "enunciado": "You are given three \npositive\n integers \nnum1\n, \nnum2\n, and \nnum3\n.\n\n\nThe \nkey\n of \nnum1\n, \nnum2\n, and \nnum3\n is defined as a four-digit number such that:\n\n\n\n\nInitially, if any number has \nless than\n four digits, it is padded with \nleading zeros\n.\n\n\nThe \ni\nth\n digit (\n1 <= i <= 4\n) of the \nkey\n is generated by taking the \nsmallest\n digit among the \ni\nth\n digits of \nnum1\n, \nnum2\n, and \nnum3\n.\n\n\n\n\nReturn the \nkey\n of the three numbers \nwithout\n leading zeros (\nif any\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnum1 = 1, num2 = 10, num3 = 1000\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nOn padding, \nnum1\n becomes \n\"0001\"\n, \nnum2\n becomes \n\"0010\"\n, and \nnum3\n remains \n\"1000\"\n.\n\n\n\n\nThe \n1\nst\n digit of the \nkey\n is \nmin(0, 0, 1)\n.\n\n\nThe \n2\nnd\n digit of the \nkey\n is \nmin(0, 0, 0)\n.\n\n\nThe \n3\nrd\n digit of the \nkey\n is \nmin(0, 1, 0)\n.\n\n\nThe \n4\nth\n digit of the \nkey\n is \nmin(1, 0, 0)\n.\n\n\n\n\nHence, the \nkey\n is \n\"0000\"\n, i.e. 0.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnum1 = 987, num2 = 879, num3 = 798\n\n\nOutput:\n \n777\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnum1 = 1, num2 = 2, num3 = 3\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num1, num2, num3 <= 9999",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3280,
        "slug": "convert-date-to-binary",
        "url": "https://leetcode.com/problems/convert-date-to-binary/",
        "titulo": "Convert Date to Binary",
        "enunciado": "You are given a string \ndate\n representing a Gregorian calendar date in the \nyyyy-mm-dd\n format.\n\n\ndate\n can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in \nyear-month-day\n format.\n\n\nReturn the \nbinary\n representation of \ndate\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ndate = \"2080-02-29\"\n\n\nOutput:\n \n\"100000100000-10-11101\"\n\n\nExplanation:\n\n\n100000100000, 10, and 11101 are the binary representations of 2080, 02, and 29 respectively.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ndate = \"1900-01-01\"\n\n\nOutput:\n \n\"11101101100-1-1\"\n\n\nExplanation:\n\n\n11101101100, 1, and 1 are the binary representations of 1900, 1, and 1 respectively.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\ndate.length == 10\n\n\ndate[4] == date[7] == '-'\n, and all other \ndate[i]\n's are digits.\n\n\nThe input is generated such that \ndate\n represents a valid Gregorian calendar date between Jan 1\nst\n, 1900 and Dec 31\nst\n, 2100 (both inclusive).",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3264,
        "slug": "final-array-state-after-k-multiplication-operations-i",
        "url": "https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/",
        "titulo": "Final Array State After K Multiplication Operations I",
        "enunciado": "You are given an integer array \nnums\n, an integer \nk\n, and an integer \nmultiplier\n.\n\n\nYou need to perform \nk\n operations on \nnums\n. In each operation:\n\n\n\n\nFind the \nminimum\n value \nx\n in \nnums\n. If there are multiple occurrences of the minimum value, select the one that appears \nfirst\n.\n\n\nReplace the selected minimum value \nx\n with \nx * multiplier\n.\n\n\n\n\nReturn an integer array denoting the \nfinal state\n of \nnums\n after performing all \nk\n operations.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,1,3,5,6], k = 5, multiplier = 2\n\n\nOutput:\n \n[8,4,6,5,6]\n\n\nExplanation:\n\n\n\n\n\n\n\n\nOperation\n\n\nResult\n\n\n\n\n\n\nAfter operation 1\n\n\n[2, 2, 3, 5, 6]\n\n\n\n\n\n\nAfter operation 2\n\n\n[4, 2, 3, 5, 6]\n\n\n\n\n\n\nAfter operation 3\n\n\n[4, 4, 3, 5, 6]\n\n\n\n\n\n\nAfter operation 4\n\n\n[4, 4, 6, 5, 6]\n\n\n\n\n\n\nAfter operation 5\n\n\n[8, 4, 6, 5, 6]\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2], k = 3, multiplier = 4\n\n\nOutput:\n \n[16,8]\n\n\nExplanation:\n\n\n\n\n\n\n\n\nOperation\n\n\nResult\n\n\n\n\n\n\nAfter operation 1\n\n\n[4, 2]\n\n\n\n\n\n\nAfter operation 2\n\n\n[4, 8]\n\n\n\n\n\n\nAfter operation 3\n\n\n[16, 8]\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100\n\n\n1 <= k <= 10\n\n\n1 <= multiplier <= 5",
        "temas": [
            "Array",
            "Math",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3274,
        "slug": "check-if-two-chessboard-squares-have-the-same-color",
        "url": "https://leetcode.com/problems/check-if-two-chessboard-squares-have-the-same-color/",
        "titulo": "Check if Two Chessboard Squares Have the Same Color",
        "enunciado": "You are given two strings, \ncoordinate1\n and \ncoordinate2\n, representing the coordinates of a square on an \n8 x 8\n chessboard.\n\n\nBelow is the chessboard for reference.\n\n\n\n\nReturn \ntrue\n if these two squares have the same color and \nfalse\n otherwise.\n\n\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncoordinate1 = \"a1\", coordinate2 = \"c3\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nBoth squares are black.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncoordinate1 = \"a1\", coordinate2 = \"h3\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nSquare \n\"a1\"\n is black and \n\"h3\"\n is white.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\ncoordinate1.length == coordinate2.length == 2\n\n\n'a' <= coordinate1[0], coordinate2[0] <= 'h'\n\n\n'1' <= coordinate1[1], coordinate2[1] <= '8'",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3258,
        "slug": "count-substrings-that-satisfy-k-constraint-i",
        "url": "https://leetcode.com/problems/count-substrings-that-satisfy-k-constraint-i/",
        "titulo": "Count Substrings That Satisfy K-Constraint I",
        "enunciado": "You are given a \nbinary\n string \ns\n and an integer \nk\n.\n\n\nA \nbinary string\n satisfies the \nk-constraint\n if \neither\n of the following conditions holds:\n\n\n\n\nThe number of \n0\n's in the string is at most \nk\n.\n\n\nThe number of \n1\n's in the string is at most \nk\n.\n\n\n\n\nReturn an integer denoting the number of \nsubstrings\n of \ns\n that satisfy the \nk-constraint\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"10101\", k = 1\n\n\nOutput:\n \n12\n\n\nExplanation:\n\n\nEvery substring of \ns\n except the substrings \n\"1010\"\n, \n\"10101\"\n, and \n\"0101\"\n satisfies the k-constraint.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"1010101\", k = 2\n\n\nOutput:\n \n25\n\n\nExplanation:\n\n\nEvery substring of \ns\n except the substrings with a length greater than 5 satisfies the k-constraint.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"11111\", k = 1\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\nAll substrings of \ns\n satisfy the k-constraint.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 50 \n\n\n1 <= k <= s.length\n\n\ns[i]\n is either \n'0'\n or \n'1'\n.",
        "temas": [
            "String",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3248,
        "slug": "snake-in-matrix",
        "url": "https://leetcode.com/problems/snake-in-matrix/",
        "titulo": "Snake in Matrix",
        "enunciado": "There is a snake in an \nn x n\n matrix \ngrid\n and can move in \nfour possible directions\n. Each cell in the \ngrid\n is identified by the position: \ngrid[i][j] = (i * n) + j\n.\n\n\nThe snake starts at cell 0 and follows a sequence of commands.\n\n\nYou are given an integer \nn\n representing the size of the \ngrid\n and an array of strings \ncommands\n where each \ncommand[i]\n is either \n\"UP\"\n, \n\"RIGHT\"\n, \n\"DOWN\"\n, and \n\"LEFT\"\n. It's guaranteed that the snake will remain within the \ngrid\n boundaries throughout its movement.\n\n\nReturn the position of the final cell where the snake ends up after executing \ncommands\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 2, commands = [\"RIGHT\",\"DOWN\"]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n\n\n\n\n2\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n\n\n\n\n2\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n\n\n\n\n2\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, commands = [\"DOWN\",\"RIGHT\",\"UP\"]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n\n\n\n\n3\n\n\n4\n\n\n5\n\n\n\n\n\n\n6\n\n\n7\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n\n\n\n\n3\n\n\n4\n\n\n5\n\n\n\n\n\n\n6\n\n\n7\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n\n\n\n\n3\n\n\n4\n\n\n5\n\n\n\n\n\n\n6\n\n\n7\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n\n\n\n\n3\n\n\n4\n\n\n5\n\n\n\n\n\n\n6\n\n\n7\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n\n\n1 <= commands.length <= 100\n\n\ncommands\n consists only of \n\"UP\"\n, \n\"RIGHT\"\n, \n\"DOWN\"\n, and \n\"LEFT\"\n.\n\n\nThe input is generated such the snake will not move outside of the boundaries.",
        "temas": [
            "Array",
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3238,
        "slug": "find-the-number-of-winning-players",
        "url": "https://leetcode.com/problems/find-the-number-of-winning-players/",
        "titulo": "Find the Number of Winning Players",
        "enunciado": "You are given an integer \nn\n representing the number of players in a game and a 2D array \npick\n where \npick[i] = [x\ni\n, y\ni\n]\n represents that the player \nx\ni\n picked a ball of color \ny\ni\n.\n\n\nPlayer \ni\n \nwins\n the game if they pick \nstrictly more\n than \ni\n balls of the \nsame\n color. In other words,\n\n\n\n\nPlayer 0 wins if they pick any ball.\n\n\nPlayer 1 wins if they pick at least two balls of the \nsame\n color.\n\n\n...\n\n\nPlayer \ni\n wins if they pick at least\ni + 1\n balls of the \nsame\n color.\n\n\n\n\nReturn the number of players who \nwin\n the game.\n\n\nNote\n that \nmultiple\n players can win the game.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nPlayer 0 and player 1 win the game, while players 2 and 3 do not win.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 5, pick = [[1,1],[1,2],[1,3],[1,4]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo player wins the game.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 5, pick = [[1,1],[2,4],[2,4],[2,4]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nPlayer 2 wins the game by picking 3 balls with color 4.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n\n\n1 <= pick.length <= 100\n\n\npick[i].length == 2\n\n\n0 <= x\ni\n <= n - 1 \n\n\n0 <= y\ni\n <= 10",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3242,
        "slug": "design-neighbor-sum-service",
        "url": "https://leetcode.com/problems/design-neighbor-sum-service/",
        "titulo": "Design Neighbor Sum Service",
        "enunciado": "You are given a \nn x n\n 2D array \ngrid\n containing \ndistinct\n elements in the range \n[0, n\n2\n - 1]\n.\n\n\nImplement the \nNeighborSum\n class:\n\n\n\n\nNeighborSum(int [][]grid)\n initializes the object.\n\n\nint adjacentSum(int value)\n returns the \nsum\n of elements which are adjacent neighbors of \nvalue\n, that is either to the top, left, right, or bottom of \nvalue\n in \ngrid\n.\n\n\nint diagonalSum(int value)\n returns the \nsum\n of elements which are diagonal neighbors of \nvalue\n, that is either to the top-left, top-right, bottom-left, or bottom-right of \nvalue\n in \ngrid\n.\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n\n\n[\"NeighborSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\"]\n\n\n[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]\n\n\nOutput:\n [null, 6, 16, 16, 4]\n\n\nExplanation:\n\n\n\n\n\n\nThe adjacent neighbors of 1 are 0, 2, and 4.\n\n\nThe adjacent neighbors of 4 are 1, 3, 5, and 7.\n\n\nThe diagonal neighbors of 4 are 0, 2, 6, and 8.\n\n\nThe diagonal neighbor of 8 is 4.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n\n\n[\"NeighborSum\", \"adjacentSum\", \"diagonalSum\"]\n\n\n[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]\n\n\nOutput:\n [null, 23, 45]\n\n\nExplanation:\n\n\n\n\n\n\nThe adjacent neighbors of 15 are 0, 10, 7, and 6.\n\n\nThe diagonal neighbors of 9 are 4, 12, 14, and 15.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n == grid.length == grid[0].length <= 10\n\n\n0 <= grid[i][j] <= n\n2\n - 1\n\n\nAll \ngrid[i][j]\n are distinct.\n\n\nvalue\n in \nadjacentSum\n and \ndiagonalSum\n will be in the range \n[0, n\n2\n - 1]\n.\n\n\nAt most \n2 * n\n2\n calls will be made to \nadjacentSum\n and \ndiagonalSum\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Design",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3232,
        "slug": "find-if-digit-game-can-be-won",
        "url": "https://leetcode.com/problems/find-if-digit-game-can-be-won/",
        "titulo": "Find if Digit Game Can Be Won",
        "enunciado": "You are given an array of \npositive\n integers \nnums\n.\n\n\nAlice and Bob are playing a game. In the game, Alice can choose \neither\n all single-digit numbers or all double-digit numbers from \nnums\n, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is \nstrictly greater\n than the sum of Bob's numbers.\n\n\nReturn \ntrue\n if Alice can win this game, otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,10]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAlice cannot win by choosing either single-digit or double-digit numbers.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,5,14]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nAlice can win by choosing single-digit numbers which have a sum equal to 15.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [5,5,5,25]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nAlice can win by choosing double-digit numbers which have a sum equal to 25.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 99",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3222,
        "slug": "find-the-winning-player-in-coin-game",
        "url": "https://leetcode.com/problems/find-the-winning-player-in-coin-game/",
        "titulo": "Find the Winning Player in Coin Game",
        "enunciado": "You are given two \npositive\n integers \nx\n and \ny\n, denoting the number of coins with values 75 and 10 \nrespectively\n.\n\n\nAlice and Bob are playing a game. Each turn, starting with \nAlice\n, the player must pick up coins with a \ntotal\n value 115. If the player is unable to do so, they \nlose\n the game.\n\n\nReturn the \nname\n of the player who wins the game if both players play \noptimally\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nx = 2, y = 7\n\n\nOutput:\n \n\"Alice\"\n\n\nExplanation:\n\n\nThe game ends in a single turn:\n\n\n\n\nAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nx = 4, y = 11\n\n\nOutput:\n \n\"Bob\"\n\n\nExplanation:\n\n\nThe game ends in 2 turns:\n\n\n\n\nAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\nBob picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= x, y <= 100",
        "temas": [
            "Math",
            "Simulation",
            "Game Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3226,
        "slug": "number-of-bit-changes-to-make-two-integers-equal",
        "url": "https://leetcode.com/problems/number-of-bit-changes-to-make-two-integers-equal/",
        "titulo": "Number of Bit Changes to Make Two Integers Equal",
        "enunciado": "You are given two positive integers \nn\n and \nk\n.\n\n\nYou can choose \nany\n bit in the \nbinary representation\n of \nn\n that is equal to 1 and change it to 0.\n\n\nReturn the \nnumber of changes\n needed to make \nn\n equal to \nk\n. If it is impossible, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 13, k = 4\n\n\nOutput:\n \n2\n\n\nExplanation:\n\nInitially, the binary representations of \nn\n and \nk\n are \nn = (1101)\n2\n and \nk = (0100)\n2\n.\n\nWe can change the first and fourth bits of \nn\n. The resulting integer is \nn = (\n0\n10\n0\n)\n2\n = k\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 21, k = 21\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nn\n and \nk\n are already equal, so no changes are needed.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 14, k = 13\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\nIt is not possible to make \nn\n equal to \nk\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, k <= 10\n6",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 3216,
        "slug": "lexicographically-smallest-string-after-a-swap",
        "url": "https://leetcode.com/problems/lexicographically-smallest-string-after-a-swap/",
        "titulo": "Lexicographically Smallest String After a Swap",
        "enunciado": "Given a string \ns\n containing only digits, return the \nlexicographically smallest string\n that can be obtained after swapping \nadjacent\n digits in \ns\n with the same \nparity\n at most \nonce\n.\n\n\nDigits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"45320\"\n\n\nOutput:\n \n\"43520\"\n\n\nExplanation: \n\n\ns[1] == '5'\n and \ns[2] == '3'\n both have the same parity, and swapping them results in the lexicographically smallest string.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"001\"\n\n\nOutput:\n \n\"001\"\n\n\nExplanation:\n\n\nThere is no need to perform a swap because \ns\n is already the lexicographically smallest.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 100\n\n\ns\n consists only of digits.",
        "temas": [
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3190,
        "slug": "find-minimum-operations-to-make-all-elements-divisible-by-three",
        "url": "https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/",
        "titulo": "Find Minimum Operations to Make All Elements Divisible by Three",
        "enunciado": "You are given an integer array \nnums\n. In one operation, you can add or subtract 1 from \nany\n element of \nnums\n.\n\n\nReturn the \nminimum\n number of operations to make all elements of \nnums\n divisible by 3.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nAll array elements can be made divisible by 3 using 3 operations:\n\n\n\n\nSubtract 1 from 1.\n\n\nAdd 1 to 2.\n\n\nSubtract 1 from 4.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [3,6,9]\n\n\nOutput:\n \n0\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3194,
        "slug": "minimum-average-of-smallest-and-largest-elements",
        "url": "https://leetcode.com/problems/minimum-average-of-smallest-and-largest-elements/",
        "titulo": "Minimum Average of Smallest and Largest Elements",
        "enunciado": "You have an array of floating point numbers \naverages\n which is initially empty. You are given an array \nnums\n of \nn\n integers where \nn\n is even.\n\n\nYou repeat the following procedure \nn / 2\n times:\n\n\n\n\nRemove the \nsmallest\n element, \nminElement\n, and the \nlargest\n element \nmaxElement\n, from \nnums\n.\n\n\nAdd \n(minElement + maxElement) / 2\n to \naverages\n.\n\n\n\n\nReturn the \nminimum\n element in \naverages\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [7,8,3,4,15,13,4,1]\n\n\nOutput:\n \n5.5\n\n\nExplanation:\n\n\n\n\n\n\n\n\nstep\n\n\nnums\n\n\naverages\n\n\n\n\n\n\n0\n\n\n[7,8,3,4,15,13,4,1]\n\n\n[]\n\n\n\n\n\n\n1\n\n\n[7,8,3,4,13,4]\n\n\n[8]\n\n\n\n\n\n\n2\n\n\n[7,8,4,4]\n\n\n[8,8]\n\n\n\n\n\n\n3\n\n\n[7,4]\n\n\n[8,8,6]\n\n\n\n\n\n\n4\n\n\n[]\n\n\n[8,8,6,5.5]\n\n\n\n\n\n\n\nThe smallest element of averages, 5.5, is returned.\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,9,8,3,10,5]\n\n\nOutput:\n \n5.5\n\n\nExplanation:\n\n\n\n\n\n\n\n\nstep\n\n\nnums\n\n\naverages\n\n\n\n\n\n\n0\n\n\n[1,9,8,3,10,5]\n\n\n[]\n\n\n\n\n\n\n1\n\n\n[9,8,3,5]\n\n\n[5.5]\n\n\n\n\n\n\n2\n\n\n[8,5]\n\n\n[5.5,6]\n\n\n\n\n\n\n3\n\n\n[]\n\n\n[5.5,6,6.5]\n\n\n\n\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3,7,8,9]\n\n\nOutput:\n \n5.0\n\n\nExplanation:\n\n\n\n\n\n\n\n\nstep\n\n\nnums\n\n\naverages\n\n\n\n\n\n\n0\n\n\n[1,2,3,7,8,9]\n\n\n[]\n\n\n\n\n\n\n1\n\n\n[2,3,7,8]\n\n\n[5]\n\n\n\n\n\n\n2\n\n\n[3,7]\n\n\n[5,5]\n\n\n\n\n\n\n3\n\n\n[]\n\n\n[5,5,5]\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == nums.length <= 50\n\n\nn\n is even.\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3200,
        "slug": "maximum-height-of-a-triangle",
        "url": "https://leetcode.com/problems/maximum-height-of-a-triangle/",
        "titulo": "Maximum Height of a Triangle",
        "enunciado": "You are given two integers \nred\n and \nblue\n representing the count of red and blue colored balls. You have to arrange these balls to form a triangle such that the 1\nst\n row will have 1 ball, the 2\nnd\n row will have 2 balls, the 3\nrd\n row will have 3 balls, and so on.\n\n\nAll the balls in a particular row should be the \nsame\n color, and adjacent rows should have \ndifferent\n colors.\n\n\nReturn the \nmaximum\n height of the triangle\n that can be achieved.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nred = 2, blue = 4\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nThe only possible arrangement is shown above.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nred = 2, blue = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\nThe only possible arrangement is shown above.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nred = 1, blue = 1\n\n\nOutput:\n \n1\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nred = 10, blue = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\nThe only possible arrangement is shown above.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= red, blue <= 100",
        "temas": [
            "Array",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3210,
        "slug": "find-the-encrypted-string",
        "url": "https://leetcode.com/problems/find-the-encrypted-string/",
        "titulo": "Find the Encrypted String",
        "enunciado": "You are given a string \ns\n and an integer \nk\n. Encrypt the string using the following algorithm:\n\n\n\n\nFor each character \nc\n in \ns\n, replace \nc\n with the \nk\nth\n character after \nc\n in the string (in a cyclic manner).\n\n\n\n\nReturn the \nencrypted string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"dart\", k = 3\n\n\nOutput:\n \n\"tdar\"\n\n\nExplanation:\n\n\n\n\nFor \ni = 0\n, the 3\nrd\n character after \n'd'\n is \n't'\n.\n\n\nFor \ni = 1\n, the 3\nrd\n character after \n'a'\n is \n'd'\n.\n\n\nFor \ni = 2\n, the 3\nrd\n character after \n'r'\n is \n'a'\n.\n\n\nFor \ni = 3\n, the 3\nrd\n character after \n't'\n is \n'r'\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"aaa\", k = 1\n\n\nOutput:\n \n\"aaa\"\n\n\nExplanation:\n\n\nAs all the characters are the same, the encrypted string will also be the same.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\n1 <= k <= 10\n4\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3206,
        "slug": "alternating-groups-i",
        "url": "https://leetcode.com/problems/alternating-groups-i/",
        "titulo": "Alternating Groups I",
        "enunciado": "There is a circle of red and blue tiles. You are given an array of integers \ncolors\n. The color of tile \ni\n is represented by \ncolors[i]\n:\n\n\n\n\ncolors[i] == 0\n means that tile \ni\n is \nred\n.\n\n\ncolors[i] == 1\n means that tile \ni\n is \nblue\n.\n\n\n\n\nEvery 3 contiguous tiles in the circle with \nalternating\n colors (the middle tile has a different color from its \nleft\n and \nright\n tiles) is called an \nalternating\n group.\n\n\nReturn the number of \nalternating\n groups.\n\n\nNote\n that since \ncolors\n represents a \ncircle\n, the \nfirst\n and the \nlast\n tiles are considered to be next to each other.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncolors = [1,1,1]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncolors = [0,1,0,0,1]\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nAlternating groups:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= colors.length <= 100\n\n\n0 <= colors[i] <= 1",
        "temas": [
            "Array",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3178,
        "slug": "find-the-child-who-has-the-ball-after-k-seconds",
        "url": "https://leetcode.com/problems/find-the-child-who-has-the-ball-after-k-seconds/",
        "titulo": "Find the Child Who Has the Ball After K Seconds",
        "enunciado": "You are given two \npositive\n integers \nn\n and \nk\n. There are \nn\n children numbered from \n0\n to \nn - 1\n standing in a queue \nin order\n from left to right.\n\n\nInitially, child 0 holds a ball and the direction of passing the ball is towards the right direction. After each second, the child holding the ball passes it to the child next to them. Once the ball reaches \neither\n end of the line, i.e. child 0 or child \nn - 1\n, the direction of passing is \nreversed\n.\n\n\nReturn the number of the child who receives the ball after \nk\n seconds.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 3, k = 5\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\n\n\n\n\nTime elapsed\n\n\nChildren\n\n\n\n\n\n\n0\n\n\n[\n0\n, 1, 2]\n\n\n\n\n\n\n1\n\n\n[0, \n1\n, 2]\n\n\n\n\n\n\n2\n\n\n[0, 1, \n2\n]\n\n\n\n\n\n\n3\n\n\n[0, \n1\n, 2]\n\n\n\n\n\n\n4\n\n\n[\n0\n, 1, 2]\n\n\n\n\n\n\n5\n\n\n[0, \n1\n, 2]\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 5, k = 6\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\n\n\nTime elapsed\n\n\nChildren\n\n\n\n\n\n\n0\n\n\n[\n0\n, 1, 2, 3, 4]\n\n\n\n\n\n\n1\n\n\n[0, \n1\n, 2, 3, 4]\n\n\n\n\n\n\n2\n\n\n[0, 1, \n2\n, 3, 4]\n\n\n\n\n\n\n3\n\n\n[0, 1, 2, \n3\n, 4]\n\n\n\n\n\n\n4\n\n\n[0, 1, 2, 3, \n4\n]\n\n\n\n\n\n\n5\n\n\n[0, 1, 2, \n3\n, 4]\n\n\n\n\n\n\n6\n\n\n[0, 1, \n2\n, 3, 4]\n\n\n\n\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 4, k = 2\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\n\n\nTime elapsed\n\n\nChildren\n\n\n\n\n\n\n0\n\n\n[\n0\n, 1, 2, 3]\n\n\n\n\n\n\n1\n\n\n[0, \n1\n, 2, 3]\n\n\n\n\n\n\n2\n\n\n[0, 1, \n2\n, 3]\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 50\n\n\n1 <= k <= 50\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 2582: Pass the Pillow.",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3174,
        "slug": "clear-digits",
        "url": "https://leetcode.com/problems/clear-digits/",
        "titulo": "Clear Digits",
        "enunciado": "You are given a string \ns\n.\n\n\nYour task is to remove \nall\n digits by doing this operation repeatedly:\n\n\n\n\nDelete the \nfirst\n digit and the \nclosest\n \nnon-digit\n character to its \nleft\n.\n\n\n\n\nReturn the resulting string after removing all digits.\n\n\nNote\n that the operation \ncannot\n be performed on a digit that does not have any non-digit character to its left.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"abc\"\n\n\nOutput:\n \n\"abc\"\n\n\nExplanation:\n\n\nThere is no digit in the string.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"cb34\"\n\n\nOutput:\n \n\"\"\n\n\nExplanation:\n\n\nFirst, we apply the operation on \ns[2]\n, and \ns\n becomes \n\"c4\"\n.\n\n\nThen we apply the operation on \ns[1]\n, and \ns\n becomes \n\"\"\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters and digits.\n\n\nThe input is generated such that it is possible to delete all digits.",
        "temas": [
            "String",
            "Stack",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3162,
        "slug": "find-the-number-of-good-pairs-i",
        "url": "https://leetcode.com/problems/find-the-number-of-good-pairs-i/",
        "titulo": "Find the Number of Good Pairs I",
        "enunciado": "You are given 2 integer arrays \nnums1\n and \nnums2\n of lengths \nn\n and \nm\n respectively. You are also given a \npositive\n integer \nk\n.\n\n\nA pair \n(i, j)\n is called \ngood\n if \nnums1[i]\n is divisible by \nnums2[j] * k\n (\n0 <= i <= n - 1\n, \n0 <= j <= m - 1\n).\n\n\nReturn the total number of \ngood\n pairs.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums1 = [1,3,4], nums2 = [1,3,4], k = 1\n\n\nOutput:\n \n5\n\n\nExplanation:\n\nThe 5 good pairs are \n(0, 0)\n, \n(1, 0)\n, \n(1, 1)\n, \n(2, 0)\n, and \n(2, 2)\n.\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums1 = [1,2,4,12], nums2 = [2,4], k = 3\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe 2 good pairs are \n(3, 0)\n and \n(3, 1)\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 50\n\n\n1 <= nums1[i], nums2[j] <= 50\n\n\n1 <= k <= 50",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3151,
        "slug": "special-array-i",
        "url": "https://leetcode.com/problems/special-array-i/",
        "titulo": "Special Array I",
        "enunciado": "An array is considered \nspecial\n if the \nparity\n of every pair of adjacent elements is different. In other words, one element in each pair \nmust\n be even, and the other \nmust\n be odd.\n\n\nYou are given an array of integers \nnums\n. Return \ntrue\n if \nnums\n is a \nspecial\n array, otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThere is only one element. So the answer is \ntrue\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,1,4]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThere is only two pairs: \n(2,1)\n and \n(1,4)\n, and both of them contain numbers with different parity. So the answer is \ntrue\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [4,3,1,6]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nnums[1]\n and \nnums[2]\n are both odd. So the answer is \nfalse\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3158,
        "slug": "find-the-xor-of-numbers-which-appear-twice",
        "url": "https://leetcode.com/problems/find-the-xor-of-numbers-which-appear-twice/",
        "titulo": "Find the XOR of Numbers Which Appear Twice",
        "enunciado": "You are given an array \nnums\n, where each number in the array appears \neither\n \nonce\n \nor\n \ntwice.\n\n\nReturn the bitwise\n \nXOR\n of all the numbers that appear twice in the array, or 0 if no number appears twice.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,1,3]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe only number that appears twice in \nnums\n is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo number appears twice in \nnums\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,2,1]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nNumbers 1 and 2 appeared twice. \n1 XOR 2 == 3\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 50\n\n\nEach number in \nnums\n appears either once or twice.",
        "temas": [
            "Array",
            "Hash Table",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3168,
        "slug": "minimum-number-of-chairs-in-a-waiting-room",
        "url": "https://leetcode.com/problems/minimum-number-of-chairs-in-a-waiting-room/",
        "titulo": "Minimum Number of Chairs in a Waiting Room",
        "enunciado": "You are given a string \ns\n. Simulate events at each second \ni\n:\n\n\n\n\nIf \ns[i] == 'E'\n, a person enters the waiting room and takes one of the chairs in it.\n\n\nIf \ns[i] == 'L'\n, a person leaves the waiting room, freeing up a chair.\n\n\n\n\nReturn the \nminimum \nnumber of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially \nempty\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"EEEEEEE\"\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\nAfter each second, a person enters the waiting room and no person leaves it. Therefore, a minimum of 7 chairs is needed.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"ELELEEL\"\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nLet's consider that there are 2 chairs in the waiting room. The table below shows the state of the waiting room at each second.\n\n\n\n\n\n\n\n\n\n\nSecond\n\n\nEvent\n\n\nPeople in the Waiting Room\n\n\nAvailable Chairs\n\n\n\n\n\n\n0\n\n\nEnter\n\n\n1\n\n\n1\n\n\n\n\n\n\n1\n\n\nLeave\n\n\n0\n\n\n2\n\n\n\n\n\n\n2\n\n\nEnter\n\n\n1\n\n\n1\n\n\n\n\n\n\n3\n\n\nLeave\n\n\n0\n\n\n2\n\n\n\n\n\n\n4\n\n\nEnter\n\n\n1\n\n\n1\n\n\n\n\n\n\n5\n\n\nEnter\n\n\n2\n\n\n0\n\n\n\n\n\n\n6\n\n\nLeave\n\n\n1\n\n\n1\n\n\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"ELEELEELLL\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nLet's consider that there are 3 chairs in the waiting room. The table below shows the state of the waiting room at each second.\n\n\n\n\n\n\n\n\n\n\nSecond\n\n\nEvent\n\n\nPeople in the Waiting Room\n\n\nAvailable Chairs\n\n\n\n\n\n\n0\n\n\nEnter\n\n\n1\n\n\n2\n\n\n\n\n\n\n1\n\n\nLeave\n\n\n0\n\n\n3\n\n\n\n\n\n\n2\n\n\nEnter\n\n\n1\n\n\n2\n\n\n\n\n\n\n3\n\n\nEnter\n\n\n2\n\n\n1\n\n\n\n\n\n\n4\n\n\nLeave\n\n\n1\n\n\n2\n\n\n\n\n\n\n5\n\n\nEnter\n\n\n2\n\n\n1\n\n\n\n\n\n\n6\n\n\nEnter\n\n\n3\n\n\n0\n\n\n\n\n\n\n7\n\n\nLeave\n\n\n2\n\n\n1\n\n\n\n\n\n\n8\n\n\nLeave\n\n\n1\n\n\n2\n\n\n\n\n\n\n9\n\n\nLeave\n\n\n0\n\n\n3\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 50\n\n\ns\n consists only of the letters \n'E'\n and \n'L'\n.\n\n\ns\n represents a valid sequence of entries and exits.",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3184,
        "slug": "count-pairs-that-form-a-complete-day-i",
        "url": "https://leetcode.com/problems/count-pairs-that-form-a-complete-day-i/",
        "titulo": "Count Pairs That Form a Complete Day I",
        "enunciado": "Given an integer array \nhours\n representing times in \nhours\n, return an integer denoting the number of pairs \ni\n, \nj\n where \ni < j\n and \nhours[i] + hours[j]\n forms a \ncomplete day\n.\n\n\nA \ncomplete day\n is defined as a time duration that is an \nexact\n \nmultiple\n of 24 hours.\n\n\nFor example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nhours = [12,12,30,24,24]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe pairs of indices that form a complete day are \n(0, 1)\n and \n(3, 4)\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nhours = [72,48,24,3]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe pairs of indices that form a complete day are \n(0, 1)\n, \n(0, 2)\n, and \n(1, 2)\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= hours.length <= 100\n\n\n1 <= hours[i] <= 10\n9",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3142,
        "slug": "check-if-grid-satisfies-conditions",
        "url": "https://leetcode.com/problems/check-if-grid-satisfies-conditions/",
        "titulo": "Check if Grid Satisfies Conditions",
        "enunciado": "You are given a 2D matrix \ngrid\n of size \nm x n\n. You need to check if each cell \ngrid[i][j]\n is:\n\n\n\n\nEqual to the cell below it, i.e. \ngrid[i][j] == grid[i + 1][j]\n (if it exists).\n\n\nDifferent from the cell to its right, i.e. \ngrid[i][j] != grid[i][j + 1]\n (if it exists).\n\n\n\n\nReturn \ntrue\n if \nall\n the cells satisfy these conditions, otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,0,2],[1,0,2]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nAll the cells in the grid satisfy the conditions.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,1,1],[0,0,0]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nAll cells in the first row are equal.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1],[2],[3]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nCells in the first column have different values.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 10\n\n\n0 <= grid[i][j] <= 9",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3146,
        "slug": "permutation-difference-between-two-strings",
        "url": "https://leetcode.com/problems/permutation-difference-between-two-strings/",
        "titulo": "Permutation Difference between Two Strings",
        "enunciado": "You are given two strings \ns\n and \nt\n such that every character occurs at most once in \ns\n and \nt\n is a permutation of \ns\n.\n\n\nThe \npermutation difference\n between \ns\n and \nt\n is defined as the \nsum\n of the absolute difference between the index of the occurrence of each character in \ns\n and the index of the occurrence of the same character in \nt\n.\n\n\nReturn the \npermutation difference\n between \ns\n and \nt\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"abc\", t = \"bac\"\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nFor \ns = \"abc\"\n and \nt = \"bac\"\n, the permutation difference of \ns\n and \nt\n is equal to the sum of:\n\n\n\n\nThe absolute difference between the index of the occurrence of \n\"a\"\n in \ns\n and the index of the occurrence of \n\"a\"\n in \nt\n.\n\n\nThe absolute difference between the index of the occurrence of \n\"b\"\n in \ns\n and the index of the occurrence of \n\"b\"\n in \nt\n.\n\n\nThe absolute difference between the index of the occurrence of \n\"c\"\n in \ns\n and the index of the occurrence of \n\"c\"\n in \nt\n.\n\n\n\n\nThat is, the permutation difference between \ns\n and \nt\n is equal to \n|0 - 1| + |1 - 0| + |2 - 2| = 2\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"abcde\", t = \"edbac\"\n\n\nOutput:\n \n12\n\n\nExplanation:\n The permutation difference between \ns\n and \nt\n is equal to \n|0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 26\n\n\nEach character occurs at most once in \ns\n.\n\n\nt\n is a permutation of \ns\n.\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3120,
        "slug": "count-the-number-of-special-characters-i",
        "url": "https://leetcode.com/problems/count-the-number-of-special-characters-i/",
        "titulo": "Count the Number of Special Characters I",
        "enunciado": "You are given a string \nword\n. A letter is called \nspecial\n if it appears \nboth\n in lowercase and uppercase in \nword\n.\n\n\nReturn the number of\n \nspecial\n letters in\n \nword\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nword = \"aaAbcBC\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe special characters in \nword\n are \n'a'\n, \n'b'\n, and \n'c'\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nword = \"abc\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo character in \nword\n appears in uppercase.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nword = \"abBCab\"\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\nThe only special character in \nword\n is \n'b'\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 50\n\n\nword\n consists of only lowercase and uppercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3127,
        "slug": "make-a-square-with-the-same-color",
        "url": "https://leetcode.com/problems/make-a-square-with-the-same-color/",
        "titulo": "Make a Square with the Same Color",
        "enunciado": "You are given a 2D matrix \ngrid\n of size \n3 x 3\n consisting only of characters \n'B'\n and \n'W'\n. Character \n'W'\n represents the white color\n, and character \n'B'\n represents the black color\n.\n\n\nYour task is to change the color of \nat most one\n cell\n so that the matrix has a \n2 x 2\n square where all cells are of the same color.\n\n\nReturn \ntrue\n if it is possible to create a \n2 x 2\n square of the same color, otherwise, return \nfalse\n.\n\n\n \n\n\n\n\n\n\nExample 1:\n\n\n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\nInput:\n \ngrid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nIt can be done by changing the color of the \ngrid[0][2]\n.\n\n\n\n\nExample 2:\n\n\n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\nInput:\n \ngrid = [[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nIt cannot be done by changing at most one cell.\n\n\n\n\nExample 3:\n\n\n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\nInput:\n \ngrid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"W\"]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe \ngrid\n already contains a \n2 x 2\n square of the same color.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\ngrid.length == 3\n\n\ngrid[i].length == 3\n\n\ngrid[i][j]\n is either \n'W'\n or \n'B'\n.",
        "temas": [
            "Array",
            "Matrix",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3131,
        "slug": "find-the-integer-added-to-array-i",
        "url": "https://leetcode.com/problems/find-the-integer-added-to-array-i/",
        "titulo": "Find the Integer Added to Array I",
        "enunciado": "You are given two arrays of equal length, \nnums1\n and \nnums2\n.\n\n\nEach element in \nnums1\n has been increased (or decreased in the case of negative) by an integer, represented by the variable \nx\n.\n\n\nAs a result, \nnums1\n becomes \nequal\n to \nnums2\n. Two arrays are considered \nequal\n when they contain the same integers with the same frequencies.\n\n\nReturn the integer \nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums1 = [2,6,4], nums2 = [9,7,5]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe integer added to each element of \nnums1\n is 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums1 = [10], nums2 = [5]\n\n\nOutput:\n \n-5\n\n\nExplanation:\n\n\nThe integer added to each element of \nnums1\n is -5.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums1 = [1,1,1,1], nums2 = [1,1,1,1]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe integer added to each element of \nnums1\n is 0.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length == nums2.length <= 100\n\n\n0 <= nums1[i], nums2[i] <= 1000\n\n\nThe test cases are generated in a way that there is an integer \nx\n such that \nnums1\n can become equal to \nnums2\n by adding \nx\n to each element of \nnums1\n.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3136,
        "slug": "valid-word",
        "url": "https://leetcode.com/problems/valid-word/",
        "titulo": "Valid Word",
        "enunciado": "A word is considered \nvalid\n if:\n\n\n\n\nIt contains a \nminimum\n of 3 characters.\n\n\nIt contains only digits (0-9), and English letters (uppercase and lowercase).\n\n\nIt includes \nat least\n one \nvowel\n.\n\n\nIt includes \nat least\n one \nconsonant\n.\n\n\n\n\nYou are given a string \nword\n.\n\n\nReturn \ntrue\n if \nword\n is valid, otherwise, return \nfalse\n.\n\n\nNotes:\n\n\n\n\n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, \n'u'\n, and their uppercases are \nvowels\n.\n\n\nA \nconsonant\n is an English letter that is not a vowel.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nword = \"234Adas\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThis word satisfies the conditions.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nword = \"b3\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nThe length of this word is fewer than 3, and does not have a vowel.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nword = \"a3$e\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nThis word contains a \n'$'\n character and does not have a consonant.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 20\n\n\nword\n consists of English uppercase and lowercase letters, digits, \n'@'\n, \n'#'\n, and \n'$'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3095,
        "slug": "shortest-subarray-with-or-at-least-k-i",
        "url": "https://leetcode.com/problems/shortest-subarray-with-or-at-least-k-i/",
        "titulo": "Shortest Subarray With OR at Least K I",
        "enunciado": "You are given an array \nnums\n of \nnon-negative\n integers and an integer \nk\n.\n\n\nAn array is called \nspecial\n if the bitwise \nOR\n of all of its elements is \nat least\n \nk\n.\n\n\nReturn \nthe length of the \nshortest\n \nspecial\n \nnon-empty\n \nsubarray\n of\n \nnums\n, \nor return\n \n-1\n \nif no special subarray exists\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3], k = 2\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe subarray \n[3]\n has \nOR\n value of \n3\n. Hence, we return \n1\n.\n\n\nNote that \n[2]\n is also a special subarray.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,1,8], k = 10\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe subarray \n[2,1,8]\n has \nOR\n value of \n11\n. Hence, we return \n3\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2], k = 0\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe subarray \n[1]\n has \nOR\n value of \n1\n. Hence, we return \n1\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n0 <= nums[i] <= 50\n\n\n0 <= k < 64",
        "temas": [
            "Array",
            "Bit Manipulation",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3110,
        "slug": "score-of-a-string",
        "url": "https://leetcode.com/problems/score-of-a-string/",
        "titulo": "Score of a String",
        "enunciado": "You are given a string \ns\n. The \nscore\n of a string is defined as the sum of the absolute difference between the \nASCII\n values of adjacent characters.\n\n\nReturn the \nscore\n of\n \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"hello\"\n\n\nOutput:\n \n13\n\n\nExplanation:\n\n\nThe \nASCII\n values of the characters in \ns\n are: \n'h' = 104\n, \n'e' = 101\n, \n'l' = 108\n, \n'o' = 111\n. So, the score of \ns\n would be \n|104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"zaz\"\n\n\nOutput:\n \n50\n\n\nExplanation:\n\n\nThe \nASCII\n values of the characters in \ns\n are: \n'z' = 122\n, \n'a' = 97\n. So, the score of \ns\n would be \n|122 - 97| + |97 - 122| = 25 + 25 = 50\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3105,
        "slug": "longest-strictly-increasing-or-strictly-decreasing-subarray",
        "url": "https://leetcode.com/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/",
        "titulo": "Longest Strictly Increasing or Strictly Decreasing Subarray",
        "enunciado": "You are given an array of integers \nnums\n. Return \nthe length of the \nlongest\n \nsubarray\n of \nnums\n which is either \nstrictly increasing\n or \nstrictly decreasing\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,4,3,3,2]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe strictly increasing subarrays of \nnums\n are \n[1]\n, \n[2]\n, \n[3]\n, \n[3]\n, \n[4]\n, and \n[1,4]\n.\n\n\nThe strictly decreasing subarrays of \nnums\n are \n[1]\n, \n[2]\n, \n[3]\n, \n[3]\n, \n[4]\n, \n[3,2]\n, and \n[4,3]\n.\n\n\nHence, we return \n2\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [3,3,3,3]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe strictly increasing subarrays of \nnums\n are \n[3]\n, \n[3]\n, \n[3]\n, and \n[3]\n.\n\n\nThe strictly decreasing subarrays of \nnums\n are \n[3]\n, \n[3]\n, \n[3]\n, and \n[3]\n.\n\n\nHence, we return \n1\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [3,2,1]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe strictly increasing subarrays of \nnums\n are \n[3]\n, \n[2]\n, and \n[1]\n.\n\n\nThe strictly decreasing subarrays of \nnums\n are \n[3]\n, \n[2]\n, \n[1]\n, \n[3,2]\n, \n[2,1]\n, and \n[3,2,1]\n.\n\n\nHence, we return \n3\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3099,
        "slug": "harshad-number",
        "url": "https://leetcode.com/problems/harshad-number/",
        "titulo": "Harshad Number",
        "enunciado": "An integer divisible by the \nsum\n of its digits is said to be a \nHarshad\n number. You are given an integer \nx\n. Return\n the sum of the digits \nof\n \nx\n \nif\n \nx\n \nis a \nHarshad\n number, otherwise, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nx = 18\n\n\nOutput:\n \n9\n\n\nExplanation:\n\n\nThe sum of digits of \nx\n is \n9\n. \n18\n is divisible by \n9\n. So \n18\n is a Harshad number and the answer is \n9\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nx = 23\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nThe sum of digits of \nx\n is \n5\n. \n23\n is not divisible by \n5\n. So \n23\n is not a Harshad number and the answer is \n-1\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= x <= 100",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3079,
        "slug": "find-the-sum-of-encrypted-integers",
        "url": "https://leetcode.com/problems/find-the-sum-of-encrypted-integers/",
        "titulo": "Find the Sum of Encrypted Integers",
        "enunciado": "You are given an integer array \nnums\n containing \npositive\n integers. We define a function \nencrypt\n such that \nencrypt(x)\n replaces \nevery\n digit in \nx\n with the \nlargest\n digit in \nx\n. For example, \nencrypt(523) = 555\n and \nencrypt(213) = 333\n.\n\n\nReturn \nthe \nsum \nof encrypted elements\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput: \nnums = [1,2,3]\n\n\nOutput: \n6\n\n\nExplanation:\n The encrypted elements are \n[1,2,3]\n. The sum of encrypted elements is \n1 + 2 + 3 == 6\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput: \nnums = [10,21,31]\n\n\nOutput: \n66\n\n\nExplanation:\n The encrypted elements are \n[11,22,33]\n. The sum of encrypted elements is \n11 + 22 + 33 == 66\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3114,
        "slug": "latest-time-you-can-obtain-after-replacing-characters",
        "url": "https://leetcode.com/problems/latest-time-you-can-obtain-after-replacing-characters/",
        "titulo": "Latest Time You Can Obtain After Replacing Characters",
        "enunciado": "You are given a string \ns\n representing a 12-hour format time where some of the digits (possibly none) are replaced with a \n\"?\"\n.\n\n\n12-hour times are formatted as \n\"HH:MM\"\n, where \nHH\n is between \n00\n and \n11\n, and \nMM\n is between \n00\n and \n59\n. The earliest 12-hour time is \n00:00\n, and the latest is \n11:59\n.\n\n\nYou have to replace \nall\n the \n\"?\"\n characters in \ns\n with digits such that the time we obtain by the resulting string is a \nvalid\n 12-hour format time and is the \nlatest\n possible.\n\n\nReturn \nthe resulting string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"1?:?4\"\n\n\nOutput:\n \n\"11:54\"\n\n\nExplanation:\n The latest 12-hour format time we can achieve by replacing \n\"?\"\n characters is \n\"11:54\"\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"0?:5?\"\n\n\nOutput:\n \n\"09:59\"\n\n\nExplanation:\n The latest 12-hour format time we can achieve by replacing \n\"?\"\n characters is \n\"09:59\"\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\ns.length == 5\n\n\ns[2]\n is equal to the character \n\":\"\n.\n\n\nAll characters except \ns[2]\n are digits or \n\"?\"\n characters.\n\n\nThe input is generated such that there is \nat least\n one time between \n\"00:00\"\n and \n\"11:59\"\n that you can obtain after replacing the \n\"?\"\n characters.",
        "temas": [
            "String",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3083,
        "slug": "existence-of-a-substring-in-a-string-and-its-reverse",
        "url": "https://leetcode.com/problems/existence-of-a-substring-in-a-string-and-its-reverse/",
        "titulo": "Existence of a Substring in a String and Its Reverse",
        "enunciado": "Given a\n \nstring \ns\n, find any \nsubstring\n of length \n2\n which is also present in the reverse of \ns\n.\n\n\nReturn \ntrue\n if such a substring exists, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput: \ns = \"leetcode\"\n\n\nOutput: \ntrue\n\n\nExplanation:\n Substring \n\"ee\"\n is of length \n2\n which is also present in \nreverse(s) == \"edocteel\"\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput: \ns = \"abcba\"\n\n\nOutput: \ntrue\n\n\nExplanation:\n All of the substrings of length \n2\n \n\"ab\"\n, \n\"bc\"\n, \n\"cb\"\n, \n\"ba\"\n are also present in \nreverse(s) == \"abcba\"\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput: \ns = \"abcd\"\n\n\nOutput: \nfalse\n\n\nExplanation:\n There is no substring of length \n2\n in \ns\n, which is also present in the reverse of \ns\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3090,
        "slug": "maximum-length-substring-with-two-occurrences",
        "url": "https://leetcode.com/problems/maximum-length-substring-with-two-occurrences/",
        "titulo": "Maximum Length Substring With Two Occurrences",
        "enunciado": "Given a string \ns\n, return the \nmaximum\n length of a \nsubstring\n such that it contains \nat most two occurrences\n of each character.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"bcbbbcba\"\n\n\nOutput:\n \n4\n\n\nExplanation:\n\nThe following substring has a length of 4 and contains at most two occurrences of each character: \n\"bcbb\nbcba\n\"\n.\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"aaaa\"\n\n\nOutput:\n \n2\n\n\nExplanation:\n\nThe following substring has a length of 2 and contains at most two occurrences of each character: \n\"\naa\naa\"\n.\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 3069,
        "slug": "distribute-elements-into-two-arrays-i",
        "url": "https://leetcode.com/problems/distribute-elements-into-two-arrays-i/",
        "titulo": "Distribute Elements Into Two Arrays I",
        "enunciado": "You are given a \n1-indexed\n array of \ndistinct\n integers \nnums\n of length \nn\n.\n\n\nYou need to distribute all the elements of \nnums\n between two arrays \narr1\n and \narr2\n using \nn\n operations. In the first operation, append \nnums[1]\n to \narr1\n. In the second operation, append \nnums[2]\n to \narr2\n. Afterwards, in the \ni\nth\n operation:\n\n\n\n\nIf the last element of \narr1\n is\n greater\n than the last element of \narr2\n, append \nnums[i]\n to \narr1\n. Otherwise, append \nnums[i]\n to \narr2\n.\n\n\n\n\nThe array \nresult\n is formed by concatenating the arrays \narr1\n and \narr2\n. For example, if \narr1 == [1,2,3]\n and \narr2 == [4,5,6]\n, then \nresult = [1,2,3,4,5,6]\n.\n\n\nReturn \nthe array\n \nresult\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,1,3]\n\nOutput:\n [2,3,1]\n\nExplanation:\n After the first 2 operations, arr1 = [2] and arr2 = [1].\nIn the 3\nrd\n operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.\nAfter 3 operations, arr1 = [2,3] and arr2 = [1].\nHence, the array result formed by concatenation is [2,3,1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,4,3,8]\n\nOutput:\n [5,3,4,8]\n\nExplanation:\n After the first 2 operations, arr1 = [5] and arr2 = [4].\nIn the 3\nrd\n operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].\nIn the 4\nth\n operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].\nAfter 4 operations, arr1 = [5,3] and arr2 = [4,8].\nHence, the array result formed by concatenation is [5,3,4,8].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 50\n\n\n1 <= nums[i] <= 100\n\n\nAll elements in \nnums\n are distinct.",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3074,
        "slug": "apple-redistribution-into-boxes",
        "url": "https://leetcode.com/problems/apple-redistribution-into-boxes/",
        "titulo": "Apple Redistribution into Boxes",
        "enunciado": "You are given an array \napple\n of size \nn\n and an array \ncapacity\n of size \nm\n.\n\n\nThere are \nn\n packs where the \ni\nth\n pack contains \napple[i]\n apples. There are \nm\n boxes as well, and the \ni\nth\n box has a capacity of \ncapacity[i]\n apples.\n\n\nReturn \nthe \nminimum\n number of boxes you need to select to redistribute these \nn\n packs of apples into boxes\n.\n\n\nNote\n that, apples from the same pack can be distributed into different boxes.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n apple = [1,3,2], capacity = [4,3,1,5,2]\n\nOutput:\n 2\n\nExplanation:\n We will use boxes with capacities 4 and 5.\nIt is possible to distribute the apples as the total capacity is greater than or equal to the total number of apples.\n\n\n\nExample 2:\n\n\n\n\nInput:\n apple = [5,5,5], capacity = [2,4,2,7]\n\nOutput:\n 4\n\nExplanation:\n We will need to use all the boxes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == apple.length <= 50\n\n\n1 <= m == capacity.length <= 50\n\n\n1 <= apple[i], capacity[i] <= 50\n\n\nThe input is generated such that it's possible to redistribute packs of apples into boxes.",
        "temas": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3065,
        "slug": "minimum-operations-to-exceed-threshold-value-i",
        "url": "https://leetcode.com/problems/minimum-operations-to-exceed-threshold-value-i/",
        "titulo": "Minimum Operations to Exceed Threshold Value I",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n, and an integer \nk\n.\n\n\nIn one operation, you can remove one occurrence of the smallest element of \nnums\n.\n\n\nReturn \nthe \nminimum\n number of operations needed so that all elements of the array are greater than or equal to\n \nk\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,11,10,1,3], k = 10\n\nOutput:\n 3\n\nExplanation:\n After one operation, nums becomes equal to [2, 11, 10, 3].\nAfter two operations, nums becomes equal to [11, 10, 3].\nAfter three operations, nums becomes equal to [11, 10].\nAt this stage, all the elements of nums are greater than or equal to 10 so we can stop.\nIt can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,2,4,9], k = 1\n\nOutput:\n 0\n\nExplanation:\n All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,2,4,9], k = 9\n\nOutput:\n 4\n\nExplanation:\n only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 10\n9\n\n\n1 <= k <= 10\n9\n\n\nThe input is generated such that there is at least one index \ni\n such that \nnums[i] >= k\n.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3033,
        "slug": "modify-the-matrix",
        "url": "https://leetcode.com/problems/modify-the-matrix/",
        "titulo": "Modify the Matrix",
        "enunciado": "Given a \n0-indexed\n \nm x n\n integer matrix \nmatrix\n, create a new \n0-indexed\n matrix called \nanswer\n. Make \nanswer\n equal to \nmatrix\n, then replace each element with the value \n-1\n with the \nmaximum\n element in its respective column.\n\n\nReturn \nthe matrix\n \nanswer\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n\nOutput:\n [[1,2,9],[4,8,6],[7,8,9]]\n\nExplanation:\n The diagram above shows the elements that are changed (in blue).\n- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.\n- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[3,-1],[5,2]]\n\nOutput:\n [[3,2],[5,2]]\n\nExplanation:\n The diagram above shows the elements that are changed (in blue).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n2 <= m, n <= 50\n\n\n-1 <= matrix[i][j] <= 100\n\n\nThe input is generated such that each column contains at least one non-negative integer.",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3046,
        "slug": "split-the-array",
        "url": "https://leetcode.com/problems/split-the-array/",
        "titulo": "Split the Array",
        "enunciado": "You are given an integer array \nnums\n of \neven\n length. You have to split the array into two parts \nnums1\n and \nnums2\n such that:\n\n\n\n\nnums1.length == nums2.length == nums.length / 2\n.\n\n\nnums1\n should contain \ndistinct \nelements.\n\n\nnums2\n should also contain \ndistinct\n elements.\n\n\n\n\nReturn \ntrue\n if it is possible to split the array, and \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,2,2,3,4]\n\nOutput:\n true\n\nExplanation:\n One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1,1]\n\nOutput:\n false\n\nExplanation:\n The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\nnums.length % 2 == 0 \n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3024,
        "slug": "type-of-triangle",
        "url": "https://leetcode.com/problems/type-of-triangle/",
        "titulo": "Type of Triangle",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n of size \n3\n which can form the sides of a triangle.\n\n\n\n\nA triangle is called \nequilateral\n if it has all sides of equal length.\n\n\nA triangle is called \nisosceles\n if it has exactly two sides of equal length.\n\n\nA triangle is called \nscalene\n if all its sides are of different lengths.\n\n\n\n\nReturn \na string representing\n \nthe type of triangle that can be formed \nor \n\"none\"\n if it \ncannot\n form a triangle.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,3,3]\n\nOutput:\n \"equilateral\"\n\nExplanation:\n Since all the sides are of equal length, therefore, it will form an equilateral triangle.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,4,5]\n\nOutput:\n \"scalene\"\n\nExplanation:\n \nnums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.\nnums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.\nnums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3. \nSince the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.\nAs all the sides are of different lengths, it will form a scalene triangle.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums.length == 3\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Math",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3038,
        "slug": "maximum-number-of-operations-with-the-same-score-i",
        "url": "https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-i/",
        "titulo": "Maximum Number of Operations With the Same Score I",
        "enunciado": "You are given an array of integers \nnums\n. Consider the following operation:\n\n\n\n\nDelete the first two elements \nnums\n and define the \nscore\n of the operation as the sum of these two elements.\n\n\n\n\nYou can perform this operation until \nnums\n contains fewer than two elements. Additionally, the \nsame\n \nscore\n must be achieved in \nall\n operations.\n\n\nReturn the \nmaximum\n number of operations you can perform.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [3,2,1,4,5]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nWe can perform the first operation with the score \n3 + 2 = 5\n. After this operation, \nnums = [1,4,5]\n.\n\n\nWe can perform the second operation as its score is \n4 + 1 = 5\n, the same as the previous operation. After this operation, \nnums = [5]\n.\n\n\nAs there are fewer than two elements, we can't perform more operations.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,5,3,3,4,1,3,2,2,3]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nWe can perform the first operation with the score \n1 + 5 = 6\n. After this operation, \nnums = [3,3,4,1,3,2,2,3]\n.\n\n\nWe can perform the second operation as its score is \n3 + 3 = 6\n, the same as the previous operation. After this operation, \nnums = [4,1,3,2,2,3]\n.\n\n\nWe cannot perform the next operation as its score is \n4 + 1 = 5\n, which is different from the previous scores.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [5,3]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3019,
        "slug": "number-of-changing-keys",
        "url": "https://leetcode.com/problems/number-of-changing-keys/",
        "titulo": "Number of Changing Keys",
        "enunciado": "You are given a \n0-indexed \nstring \ns\n typed by a user. Changing a key is defined as using a key different from the last used key. For example, \ns = \"ab\"\n has a change of a key while \ns = \"bBBb\"\n does not have any.\n\n\nReturn \nthe number of times the user had to change the key. \n\n\nNote: \nModifiers like \nshift\n or \ncaps lock\n won't be counted in changing the key that is if a user typed the letter \n'a'\n and then the letter \n'A'\n then it will not be considered as a changing of key.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aAbBcC\"\n\nOutput:\n 2\n\nExplanation:\n \nFrom s[0] = 'a' to s[1] = 'A', there is no change of key as caps lock or shift is not counted.\nFrom s[1] = 'A' to s[2] = 'b', there is a change of key.\nFrom s[2] = 'b' to s[3] = 'B', there is no change of key as caps lock or shift is not counted.\nFrom s[3] = 'B' to s[4] = 'c', there is a change of key.\nFrom s[4] = 'c' to s[5] = 'C', there is no change of key as caps lock or shift is not counted.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"AaAaAaaA\"\n\nOutput:\n 0\n\nExplanation:\n There is no change of key since only the letters 'a' and 'A' are\n pressed which does not require change of key.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of only upper case and lower case English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 3028,
        "slug": "ant-on-the-boundary",
        "url": "https://leetcode.com/problems/ant-on-the-boundary/",
        "titulo": "Ant on the Boundary",
        "enunciado": "An ant is on a boundary. It sometimes goes \nleft\n and sometimes \nright\n.\n\n\nYou are given an array of \nnon-zero\n integers \nnums\n. The ant starts reading \nnums\n from the first element of it to its end. At each step, it moves according to the value of the current element:\n\n\n\n\nIf \nnums[i] < 0\n, it moves \nleft\n by\n \n-nums[i]\n units.\n\n\nIf \nnums[i] > 0\n, it moves \nright\n by \nnums[i]\n units.\n\n\n\n\nReturn \nthe number of times the ant \nreturns\n to the boundary.\n\n\nNotes:\n\n\n\n\nThere is an infinite space on both sides of the boundary.\n\n\nWe check whether the ant is on the boundary only after it has moved \n|nums[i]|\n units. In other words, if the ant crosses the boundary during its movement, it does not count.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,-5]\n\nOutput:\n 1\n\nExplanation:\n After the first step, the ant is 2 steps to the right of the boundary\n.\nAfter the second step, the ant is 5 steps to the right of the boundary\n.\nAfter the third step, the ant is on the boundary.\nSo the answer is 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,-3,-4]\n\nOutput:\n 0\n\nExplanation:\n After the first step, the ant is 3 steps to the right of the boundary\n.\nAfter the second step, the ant is 5 steps to the right of the boundary\n.\nAfter the third step, the ant is 2 steps to the right of the boundary\n.\nAfter the fourth step, the ant is 2 steps to the left of the boundary\n.\nThe ant never returned to the boundary, so the answer is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-10 <= nums[i] <= 10\n\n\nnums[i] != 0",
        "temas": [
            "Array",
            "Simulation",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3042,
        "slug": "count-prefix-and-suffix-pairs-i",
        "url": "https://leetcode.com/problems/count-prefix-and-suffix-pairs-i/",
        "titulo": "Count Prefix and Suffix Pairs I",
        "enunciado": "You are given a \n0-indexed\n string array \nwords\n.\n\n\nLet's define a \nboolean\n function \nisPrefixAndSuffix\n that takes two strings, \nstr1\n and \nstr2\n:\n\n\n\n\nisPrefixAndSuffix(str1, str2)\n returns \ntrue\n if \nstr1\n is \nboth\n a \nprefix\n and a \nsuffix\n of \nstr2\n, and \nfalse\n otherwise.\n\n\n\n\nFor example, \nisPrefixAndSuffix(\"aba\", \"ababa\")\n is \ntrue\n because \n\"aba\"\n is a prefix of \n\"ababa\"\n and also a suffix, but \nisPrefixAndSuffix(\"abc\", \"abcd\")\n is \nfalse\n.\n\n\nReturn \nan integer denoting the \nnumber\n of index pairs \n(i, j)\n such that \ni < j\n, and \nisPrefixAndSuffix(words[i], words[j])\n is \ntrue\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n\nOutput:\n 4\n\nExplanation:\n In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"a\", \"aba\") is true.\ni = 0 and j = 2 because isPrefixAndSuffix(\"a\", \"ababa\") is true.\ni = 0 and j = 3 because isPrefixAndSuffix(\"a\", \"aa\") is true.\ni = 1 and j = 2 because isPrefixAndSuffix(\"aba\", \"ababa\") is true.\nTherefore, the answer is 4.\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n\nOutput:\n 2\n\nExplanation:\n In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"pa\", \"papa\") is true.\ni = 2 and j = 3 because isPrefixAndSuffix(\"ma\", \"mama\") is true.\nTherefore, the answer is 2.  \n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"abab\",\"ab\"]\n\nOutput:\n 0\n\nExplanation: \nIn this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(\"abab\", \"ab\") is false.\nTherefore, the answer is 0.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 50\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists only of lowercase English letters.",
        "temas": [
            "Array",
            "String",
            "Trie",
            "Rolling Hash",
            "String Matching",
            "Hash Function"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3014,
        "slug": "minimum-number-of-pushes-to-type-word-i",
        "url": "https://leetcode.com/problems/minimum-number-of-pushes-to-type-word-i/",
        "titulo": "Minimum Number of Pushes to Type Word I",
        "enunciado": "You are given a string \nword\n containing \ndistinct\n lowercase English letters.\n\n\nTelephone keypads have keys mapped with \ndistinct\n collections of lowercase English letters, which can be used to form words by pushing them. For example, the key \n2\n is mapped with \n[\"a\",\"b\",\"c\"]\n, we need to push the key one time to type \n\"a\"\n, two times to type \n\"b\"\n, and three times to type \n\"c\"\n \n.\n\n\nIt is allowed to remap the keys numbered \n2\n to \n9\n to \ndistinct\n collections of letters. The keys can be remapped to \nany\n amount of letters, but each letter \nmust\n be mapped to \nexactly\n one key. You need to find the \nminimum\n number of times the keys will be pushed to type the string \nword\n.\n\n\nReturn \nthe \nminimum\n number of pushes needed to type \nword\n \nafter remapping the keys\n.\n\n\nAn example mapping of letters to keys on a telephone keypad is given below. Note that \n1\n, \n*\n, \n#\n, and \n0\n do \nnot\n map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n word = \"abcde\"\n\nOutput:\n 5\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\nTotal cost is 1 + 1 + 1 + 1 + 1 = 5.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n word = \"xycdefghij\"\n\nOutput:\n 12\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"x\" -> one push on key 2\n\"y\" -> two pushes on key 2\n\"c\" -> one push on key 3\n\"d\" -> two pushes on key 3\n\"e\" -> one push on key 4\n\"f\" -> one push on key 5\n\"g\" -> one push on key 6\n\"h\" -> one push on key 7\n\"i\" -> one push on key 8\n\"j\" -> one push on key 9\nTotal cost is 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 26\n\n\nword\n consists of lowercase English letters.\n\n\nAll letters in \nword\n are distinct.",
        "temas": [
            "Math",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 3010,
        "slug": "divide-an-array-into-subarrays-with-minimum-cost-i",
        "url": "https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/",
        "titulo": "Divide an Array Into Subarrays With Minimum Cost I",
        "enunciado": "You are given an array of integers \nnums\n of length \nn\n.\n\n\nThe \ncost\n of an array is the value of its \nfirst\n element. For example, the cost of \n[1,2,3]\n is \n1\n while the cost of \n[3,4,1]\n is \n3\n.\n\n\nYou need to divide \nnums\n into \n3\n \ndisjoint contiguous \nsubarrays\n.\n\n\nReturn \nthe \nminimum\n possible \nsum\n of the cost of these subarrays\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,12]\n\nOutput:\n 6\n\nExplanation:\n The best possible way to form 3 subarrays is: [1], [2], and [3,12] at a total cost of 1 + 2 + 3 = 6.\nThe other possible ways to form 3 subarrays are:\n- [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.\n- [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,4,3]\n\nOutput:\n 12\n\nExplanation:\n The best possible way to form 3 subarrays is: [5], [4], and [3] at a total cost of 5 + 4 + 3 = 12.\nIt can be shown that 12 is the minimum cost achievable.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [10,3,1,1]\n\nOutput:\n 12\n\nExplanation:\n The best possible way to form 3 subarrays is: [10,3], [1], and [1] at a total cost of 10 + 1 + 1 = 12.\nIt can be shown that 12 is the minimum cost achievable.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Sorting",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2970,
        "slug": "count-the-number-of-incremovable-subarrays-i",
        "url": "https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/",
        "titulo": "Count the Number of Incremovable Subarrays I",
        "enunciado": "You are given a \n0-indexed\n array of \npositive\n integers \nnums\n.\n\n\nA subarray of \nnums\n is called \nincremovable\n if \nnums\n becomes \nstrictly increasing\n on removing the subarray. For example, the subarray \n[3, 4]\n is an incremovable subarray of \n[5, 3, 4, 6, 7]\n because removing this subarray changes the array \n[5, 3, 4, 6, 7]\n to \n[5, 6, 7]\n which is strictly increasing.\n\n\nReturn \nthe total number of \nincremovable\n subarrays of\n \nnums\n.\n\n\nNote\n that an empty array is considered strictly increasing.\n\n\nA \nsubarray\n is a contiguous non-empty sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n 10\n\nExplanation:\n The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [6,5,7,8]\n\nOutput:\n 7\n\nExplanation:\n The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].\nIt can be shown that there are only 7 incremovable subarrays in nums.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [8,7,6,6]\n\nOutput:\n 3\n\nExplanation:\n The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3000,
        "slug": "maximum-area-of-longest-diagonal-rectangle",
        "url": "https://leetcode.com/problems/maximum-area-of-longest-diagonal-rectangle/",
        "titulo": "Maximum Area of Longest Diagonal Rectangle",
        "enunciado": "You are given a 2D \n0-indexed \ninteger array \ndimensions\n.\n\n\nFor all indices \ni\n, \n0 <= i < dimensions.length\n, \ndimensions[i][0]\n represents the length and \ndimensions[i][1]\n represents the width of the rectangle\n \ni\n.\n\n\nReturn \nthe \narea\n of the rectangle having the \nlongest\n diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the \nmaximum\n area.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n dimensions = [[9,3],[8,6]]\n\nOutput:\n 48\n\nExplanation:\n \nFor index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈\n 9.487.\nFor index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.\nSo, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.\n\n\n\nExample 2:\n\n\n\n\nInput:\n dimensions = [[3,4],[4,3]]\n\nOutput:\n 12\n\nExplanation:\n Length of diagonal is the same for both which is 5, so maximum area = 12.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= dimensions.length <= 100\n\n\ndimensions[i].length == 2\n\n\n1 <= dimensions[i][0], dimensions[i][1] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2980,
        "slug": "check-if-bitwise-or-has-trailing-zeros",
        "url": "https://leetcode.com/problems/check-if-bitwise-or-has-trailing-zeros/",
        "titulo": "Check if Bitwise OR Has Trailing Zeros",
        "enunciado": "You are given an array of \npositive\n integers \nnums\n.\n\n\nYou have to check if it is possible to select \ntwo or more\n elements in the array such that the bitwise \nOR\n of the selected elements has \nat least \none trailing zero in its binary representation.\n\n\nFor example, the binary representation of \n5\n, which is \n\"101\"\n, does not have any trailing zeros, whereas the binary representation of \n4\n, which is \n\"100\"\n, has two trailing zeros.\n\n\nReturn \ntrue\n \nif it is possible to select two or more elements whose bitwise\n \nOR\n \nhas trailing zeros, return\n \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n true\n\nExplanation:\n If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation \"110\" with one trailing zero.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,4,8,16]\n\nOutput:\n true\n\nExplanation: \nIf we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation \"110\" with one trailing zero.\nOther possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,7,9]\n\nOutput:\n false\n\nExplanation:\n There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 3005,
        "slug": "count-elements-with-maximum-frequency",
        "url": "https://leetcode.com/problems/count-elements-with-maximum-frequency/",
        "titulo": "Count Elements With Maximum Frequency",
        "enunciado": "You are given an array \nnums\n consisting of \npositive\n integers.\n\n\nReturn \nthe \ntotal frequencies\n of elements in\n \nnums\n \nsuch that those elements all have the \nmaximum\n frequency\n.\n\n\nThe \nfrequency\n of an element is the number of occurrences of that element in the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,2,3,1,4]\n\nOutput:\n 4\n\nExplanation:\n The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.\nSo the number of elements in the array with maximum frequency is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n 5\n\nExplanation:\n All elements of the array have a frequency of 1 which is the maximum.\nSo the number of elements in the array with maximum frequency is 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2996,
        "slug": "smallest-missing-integer-greater-than-sequential-prefix-sum",
        "url": "https://leetcode.com/problems/smallest-missing-integer-greater-than-sequential-prefix-sum/",
        "titulo": "Smallest Missing Integer Greater Than Sequential Prefix Sum",
        "enunciado": "You are given a \n0-indexed\n array of integers \nnums\n.\n\n\nA prefix \nnums[0..i]\n is \nsequential\n if, for all \n1 <= j <= i\n, \nnums[j] = nums[j - 1] + 1\n. In particular, the prefix consisting only of \nnums[0]\n is \nsequential\n.\n\n\nReturn \nthe \nsmallest\n integer\n \nx\n \nmissing from\n \nnums\n \nsuch that\n \nx\n \nis greater than or equal to the sum of the \nlongest\n sequential prefix.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,2,5]\n\nOutput:\n 6\n\nExplanation:\n The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,4,5,1,12,14,13]\n\nOutput:\n 15\n\nExplanation:\n The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2965,
        "slug": "find-missing-and-repeated-values",
        "url": "https://leetcode.com/problems/find-missing-and-repeated-values/",
        "titulo": "Find Missing and Repeated Values",
        "enunciado": "You are given a \n0-indexed\n 2D integer matrix \ngrid\n of size \nn * n\n with values in the range \n[1, n\n2\n]\n. Each integer appears \nexactly once\n except \na\n which appears \ntwice\n and \nb\n which is \nmissing\n. The task is to find the repeating and missing numbers \na\n and \nb\n.\n\n\nReturn \na \n0-indexed \ninteger array \nans\n of size \n2\n where \nans[0]\n equals to \na\n and \nans[1]\n equals to \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[1,3],[2,2]]\n\nOutput:\n [2,4]\n\nExplanation:\n Number 2 is repeated and number 4 is missing so the answer is [2,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[9,1,7],[8,9,2],[3,4,6]]\n\nOutput:\n [9,5]\n\nExplanation:\n Number 9 is repeated and number 5 is missing so the answer is [9,5].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == grid.length == grid[i].length <= 50\n\n\n1 <= grid[i][j] <= n * n\n\n\nFor all \nx\n that \n1 <= x <= n * n\n there is exactly one \nx\n that is not equal to any of the grid members.\n\n\nFor all \nx\n that \n1 <= x <= n * n\n there is exactly one \nx\n that is equal to exactly two of the grid members.\n\n\nFor all \nx\n that \n1 <= x <= n * n\n except two of them there is exactly one pair of \ni, j\n that \n0 <= i, j <= n - 1\n and \ngrid[i][j] == x\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Math",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2974,
        "slug": "minimum-number-game",
        "url": "https://leetcode.com/problems/minimum-number-game/",
        "titulo": "Minimum Number Game",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n of \neven\n length and there is also an empty array \narr\n. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:\n\n\n\n\nEvery round, first Alice will remove the \nminimum\n element from \nnums\n, and then Bob does the same.\n\n\nNow, first Bob will append the removed element in the array \narr\n, and then Alice does the same.\n\n\nThe game continues until \nnums\n becomes empty.\n\n\n\n\nReturn \nthe resulting array \narr\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [5,4,2,3]\n\nOutput:\n [3,2,5,4]\n\nExplanation:\n In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].\nAt the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,5]\n\nOutput:\n [5,2]\n\nExplanation:\n In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100\n\n\nnums.length % 2 == 0",
        "temas": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2951,
        "slug": "find-the-peaks",
        "url": "https://leetcode.com/problems/find-the-peaks/",
        "titulo": "Find the Peaks",
        "enunciado": "You are given a \n0-indexed\n array \nmountain\n. Your task is to find all the \npeaks\n in the \nmountain\n array.\n\n\nReturn \nan array that consists of \nindices\n of \npeaks\n in the given array in \nany order\n.\n\n\nNotes:\n\n\n\n\nA \npeak\n is defined as an element that is \nstrictly greater\n than its neighboring elements.\n\n\nThe first and last elements of the array are \nnot\n a peak.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n mountain = [2,4,4]\n\nOutput:\n []\n\nExplanation:\n mountain[0] and mountain[2] can not be a peak because they are first and last elements of the array.\nmountain[1] also can not be a peak because it is not strictly greater than mountain[2].\nSo the answer is [].\n\n\n\nExample 2:\n\n\n\n\nInput:\n mountain = [1,4,3,8,5]\n\nOutput:\n [1,3]\n\nExplanation:\n mountain[0] and mountain[4] can not be a peak because they are first and last elements of the array.\nmountain[2] also can not be a peak because it is not strictly greater than mountain[3] and mountain[1].\nBut mountain [1] and mountain[3] are strictly greater than their neighboring elements.\nSo the answer is [1,3].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= mountain.length <= 100\n\n\n1 <= mountain[i] <= 100",
        "temas": [
            "Array",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2960,
        "slug": "count-tested-devices-after-test-operations",
        "url": "https://leetcode.com/problems/count-tested-devices-after-test-operations/",
        "titulo": "Count Tested Devices After Test Operations",
        "enunciado": "You are given a \n0-indexed\n integer array \nbatteryPercentages\n having length \nn\n, denoting the battery percentages of \nn\n \n0-indexed\n devices.\n\n\nYour task is to test each device \ni\n \nin order\n from \n0\n to \nn - 1\n, by performing the following test operations:\n\n\n\n\nIf \nbatteryPercentages[i]\n is \ngreater\n than \n0\n:\n\n\t\n\n\nIncrement\n the count of tested devices.\n\n\nDecrease\n the battery percentage of all devices with indices \nj\n in the range \n[i + 1, n - 1]\n by \n1\n, ensuring their battery percentage \nnever goes below\n \n0\n, i.e, \nbatteryPercentages[j] = max(0, batteryPercentages[j] - 1)\n.\n\n\nMove to the next device.\n\n\n\n\n\n\nOtherwise, move to the next device without performing any test.\n\n\n\n\nReturn \nan integer denoting the number of devices that will be tested after performing the test operations in order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n batteryPercentages = [1,1,2,1,3]\n\nOutput:\n 3\n\nExplanation: \nPerforming the test operations in order starting from device 0:\nAt device 0, batteryPercentages[0] > 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].\nAt device 1, batteryPercentages[1] == 0, so we move to the next device without testing.\nAt device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].\nAt device 3, batteryPercentages[3] == 0, so we move to the next device without testing.\nAt device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, and batteryPercentages stays the same.\nSo, the answer is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n batteryPercentages = [0,1,2]\n\nOutput:\n 2\n\nExplanation:\n Performing the test operations in order starting from device 0:\nAt device 0, batteryPercentages[0] == 0, so we move to the next device without testing.\nAt device 1, batteryPercentages[1] > 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].\nAt device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages stays the same.\nSo, the answer is 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == batteryPercentages.length <= 100 \n\n\n0 <= batteryPercentages[i] <= 100",
        "temas": [
            "Array",
            "Simulation",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2946,
        "slug": "matrix-similarity-after-cyclic-shifts",
        "url": "https://leetcode.com/problems/matrix-similarity-after-cyclic-shifts/",
        "titulo": "Matrix Similarity After Cyclic Shifts",
        "enunciado": "You are given an \nm x n\n integer matrix \nmat\n and an integer \nk\n. The matrix rows are 0-indexed.\n\n\nThe following proccess happens \nk\n times:\n\n\n\n\nEven-indexed\n rows (0, 2, 4, ...) are cyclically shifted to the left.\n\n\n\n\n\n\n\n\nOdd-indexed\n rows (1, 3, 5, ...) are cyclically shifted to the right.\n\n\n\n\n\n\nReturn \ntrue\n if the final modified matrix after \nk\n steps is identical to the original matrix, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nmat = [[1,2,3],[4,5,6],[7,8,9]], k = 4\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nIn each step left shift is applied to rows 0 and 2 (even indices), and right shift to row 1 (odd index).\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nmat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nmat = [[2,2],[2,2]], k = 3\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nAs all the values are equal in the matrix, even after performing cyclic shifts the matrix will remain the same.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= mat.length <= 25\n\n\n1 <= mat[i].length <= 25\n\n\n1 <= mat[i][j] <= 25\n\n\n1 <= k <= 50",
        "temas": [
            "Array",
            "Math",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2937,
        "slug": "make-three-strings-equal",
        "url": "https://leetcode.com/problems/make-three-strings-equal/",
        "titulo": "Make Three Strings Equal",
        "enunciado": "You are given three strings: \ns1\n, \ns2\n, and \ns3\n. In one operation you can choose one of these strings and delete its \nrightmost\n character. Note that you \ncannot\n completely empty a string.\n\n\nReturn the \nminimum number of operations\n required to make the strings equal\n. \nIf it is impossible to make them equal, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput: \ns1 = \"abc\", s2 = \"abb\", s3 = \"ab\"\n\n\nOutput: \n2\n\n\nExplanation: \nDeleting the rightmost character from both \ns1\n and \ns2\n will result in three equal strings.\n\n\n\n\nExample 2:\n\n\n\n\nInput: \ns1 = \"dac\", s2 = \"bac\", s3 = \"cac\"\n\n\nOutput: \n-1\n\n\nExplanation:\n Since the first letters of \ns1\n and \ns2\n differ, they cannot be made equal.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s1.length, s2.length, s3.length <= 100\n\n\ns1\n,\n \ns2\n and\n \ns3\n consist only of lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2956,
        "slug": "find-common-elements-between-two-arrays",
        "url": "https://leetcode.com/problems/find-common-elements-between-two-arrays/",
        "titulo": "Find Common Elements Between Two Arrays",
        "enunciado": "You are given two integer arrays \nnums1\n and \nnums2\n of sizes \nn\n and \nm\n, respectively. Calculate the following values:\n\n\n\n\nanswer1\n : the number of indices \ni\n such that \nnums1[i]\n exists in \nnums2\n.\n\n\nanswer2\n : the number of indices \ni\n such that \nnums2[i]\n exists in \nnums1\n.\n\n\n\n\nReturn \n[answer1,answer2]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums1 = [2,3,2], nums2 = [1,2]\n\n\nOutput:\n \n[2,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]\n\n\nOutput:\n \n[3,4]\n\n\nExplanation:\n\n\nThe elements at indices 1, 2, and 3 in \nnums1\n exist in \nnums2\n as well. So \nanswer1\n is 3.\n\n\nThe elements at indices 0, 1, 3, and 4 in \nnums2\n exist in \nnums1\n. So \nanswer2\n is 4.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums1 = [3,4,2,3], nums2 = [1,5]\n\n\nOutput:\n \n[0,0]\n\n\nExplanation:\n\n\nNo numbers are common between \nnums1\n and \nnums2\n, so answer is [0,0].\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums1.length\n\n\nm == nums2.length\n\n\n1 <= n, m <= 100\n\n\n1 <= nums1[i], nums2[i] <= 100",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2928,
        "slug": "distribute-candies-among-children-i",
        "url": "https://leetcode.com/problems/distribute-candies-among-children-i/",
        "titulo": "Distribute Candies Among Children I",
        "enunciado": "You are given two positive integers \nn\n and \nlimit\n.\n\n\nReturn \nthe \ntotal number\n of ways to distribute \nn\n \ncandies among \n3\n children such that no child gets more than \nlimit\n candies.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5, limit = 2\n\nOutput:\n 3\n\nExplanation:\n There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, limit = 3\n\nOutput:\n 10\n\nExplanation:\n There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 50\n\n\n1 <= limit <= 50",
        "temas": [
            "Math",
            "Combinatorics",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2942,
        "slug": "find-words-containing-character",
        "url": "https://leetcode.com/problems/find-words-containing-character/",
        "titulo": "Find Words Containing Character",
        "enunciado": "You are given a \n0-indexed\n array of strings \nwords\n and a character \nx\n.\n\n\nReturn \nan \narray of indices\n representing the words that contain the character \nx\n.\n\n\nNote\n that the returned array may be in \nany\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"leet\",\"code\"], x = \"e\"\n\nOutput:\n [0,1]\n\nExplanation:\n \"e\" occurs in both words: \"l\nee\nt\", and \"cod\ne\n\". Hence, we return indices 0 and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\"\n\nOutput:\n [0,2]\n\nExplanation:\n \"a\" occurs in \"\na\nbc\", and \"\naaaa\n\". Hence, we return indices 0 and 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\"\n\nOutput:\n []\n\nExplanation:\n \"z\" does not occur in any of the words. Hence, we return an empty array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 50\n\n\n1 <= words[i].length <= 50\n\n\nx\n is a lowercase English letter.\n\n\nwords[i]\n consists only of lowercase English letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2932,
        "slug": "maximum-strong-pair-xor-i",
        "url": "https://leetcode.com/problems/maximum-strong-pair-xor-i/",
        "titulo": "Maximum Strong Pair XOR I",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n. A pair of integers \nx\n and \ny\n is called a \nstrong\n pair if it satisfies the condition:\n\n\n\n\n|x - y| <= min(x, y)\n\n\n\n\nYou need to select two integers from \nnums\n such that they form a strong pair and their bitwise \nXOR\n is the \nmaximum\n among all strong pairs in the array.\n\n\nReturn \nthe \nmaximum\n \nXOR\n value out of all possible strong pairs in the array\n \nnums\n.\n\n\nNote\n that you can pick the same integer twice to form a pair.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n 7\n\nExplanation:\n There are 11 strong pairs in the array \nnums\n: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [10,100]\n\nOutput:\n 0\n\nExplanation:\n There are 2 strong pairs in the array \nnums\n: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,6,25,30]\n\nOutput:\n 7\n\nExplanation:\n There are 6 strong pairs in the array \nnums\n: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).\nThe maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Trie",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2923,
        "slug": "find-champion-i",
        "url": "https://leetcode.com/problems/find-champion-i/",
        "titulo": "Find Champion I",
        "enunciado": "There are \nn\n teams numbered from \n0\n to \nn - 1\n in a tournament.\n\n\nGiven a \n0-indexed\n 2D boolean matrix \ngrid\n of size \nn * n\n. For all \ni, j\n that \n0 <= i, j <= n - 1\n and \ni != j\n team \ni\n is \nstronger\n than team \nj\n if \ngrid[i][j] == 1\n, otherwise, team \nj\n is \nstronger\n than team \ni\n.\n\n\nTeam \na\n will be the \nchampion\n of the tournament if there is no team \nb\n that is stronger than team \na\n.\n\n\nReturn \nthe team that will be the champion of the tournament.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[0,1],[0,0]]\n\nOutput:\n 0\n\nExplanation:\n There are two teams in this tournament.\ngrid[0][1] == 1 means that team 0 is stronger than team 1. So team 0 will be the champion.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0,0,1],[1,0,1],[0,0,0]]\n\nOutput:\n 1\n\nExplanation:\n There are three teams in this tournament.\ngrid[1][0] == 1 means that team 1 is stronger than team 0.\ngrid[1][2] == 1 means that team 1 is stronger than team 2.\nSo team 1 will be the champion.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n2 <= n <= 100\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.\n\n\nFor all \ni grid[i][i]\n is \n0.\n\n\nFor all \ni, j\n that \ni != j\n, \ngrid[i][j] != grid[j][i]\n.\n\n\nThe input is generated such that if team \na\n is stronger than team \nb\n and team \nb\n is stronger than team \nc\n, then team \na\n is stronger than team \nc\n.",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2917,
        "slug": "find-the-k-or-of-an-array",
        "url": "https://leetcode.com/problems/find-the-k-or-of-an-array/",
        "titulo": "Find the K-or of an Array",
        "enunciado": "You are given an integer array \nnums\n, and an integer \nk\n. Let's introduce \nK-or\n operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to \n1\n if at least \nk\n numbers in \nnums\n have a \n1\n in that position.\n\n\nReturn \nthe K-or of\n \nnums\n.\n\n\n \n\n\nExample 1: \n\n\n\n\nInput:\n nums = [7,12,9,8,9,15], k = 4 \n\n\nOutput:\n 9 \n\n\nExplanation: \n\n\nRepresent numbers in binary:\n\n\n\n\n\n\n\n\nNumber\n\n\nBit 3\n\n\nBit 2\n\n\nBit 1\n\n\nBit 0\n\n\n\n\n\n\n7\n\n\n0\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\n12\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n\n\n9\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n\n8\n\n\n1\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n9\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n\n15\n\n\n1\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\nResult = 9\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n\n\n\nBit 0 is set in 7, 9, 9, and 15. Bit 3 is set in 12, 9, 8, 9, and 15.\n\nOnly bits 0 and 3 qualify. The result is \n(1001)\n2\n = 9\n.\n\n\n\n\nExample 2: \n\n\n\n\nInput:\n nums = [2,12,1,11,4,5], k = 6 \n\n\nOutput:\n 0 \n\n\nExplanation: \nNo bit appears as 1 in all six array numbers, as required for K-or with \nk = 6\n. Thus, the result is 0.\n\n\n\n\nExample 3: \n\n\n\n\nInput:\n nums = [10,8,5,9,11,6,8], k = 1 \n\n\nOutput:\n 15 \n\n\nExplanation: \n Since \nk == 1\n, the 1-or of the array is equal to the bitwise OR of all its elements. Hence, the answer is \n10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n0 <= nums[i] < 2\n31\n\n\n1 <= k <= nums.length",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2908,
        "slug": "minimum-sum-of-mountain-triplets-i",
        "url": "https://leetcode.com/problems/minimum-sum-of-mountain-triplets-i/",
        "titulo": "Minimum Sum of Mountain Triplets I",
        "enunciado": "You are given a \n0-indexed\n array \nnums\n of integers.\n\n\nA triplet of indices \n(i, j, k)\n is a \nmountain\n if:\n\n\n\n\ni < j < k\n\n\nnums[i] < nums[j]\n and \nnums[k] < nums[j]\n\n\n\n\nReturn \nthe \nminimum possible sum\n of a mountain triplet of\n \nnums\n. \nIf no such triplet exists, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [8,6,1,5,3]\n\nOutput:\n 9\n\nExplanation:\n Triplet (2, 3, 4) is a mountain triplet of sum 9 since: \n- 2 < 3 < 4\n- nums[2] < nums[3] and nums[4] < nums[3]\nAnd the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,4,8,7,10,2]\n\nOutput:\n 13\n\nExplanation:\n Triplet (1, 3, 5) is a mountain triplet of sum 13 since: \n- 1 < 3 < 5\n- nums[1] < nums[3] and nums[5] < nums[3]\nAnd the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [6,5,4,3,4,5]\n\nOutput:\n -1\n\nExplanation:\n It can be shown that there are no mountain triplets in nums.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2894,
        "slug": "divisible-and-non-divisible-sums-difference",
        "url": "https://leetcode.com/problems/divisible-and-non-divisible-sums-difference/",
        "titulo": "Divisible and Non-divisible Sums Difference",
        "enunciado": "You are given positive integers \nn\n and \nm\n.\n\n\nDefine two integers as follows:\n\n\n\n\nnum1\n: The sum of all integers in the range \n[1, n]\n (both \ninclusive\n) that are \nnot divisible\n by \nm\n.\n\n\nnum2\n: The sum of all integers in the range \n[1, n]\n (both \ninclusive\n) that are \ndivisible\n by \nm\n.\n\n\n\n\nReturn \nthe integer\n \nnum1 - num2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 10, m = 3\n\nOutput:\n 19\n\nExplanation:\n In the given example:\n- Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.\n- Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.\nWe return 37 - 18 = 19 as the answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5, m = 6\n\nOutput:\n 15\n\nExplanation:\n In the given example:\n- Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.\n- Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.\nWe return 15 - 0 = 15 as the answer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 5, m = 1\n\nOutput:\n -15\n\nExplanation:\n In the given example:\n- Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.\n- Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.\nWe return 0 - 15 = -15 as the answer.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 1000",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2903,
        "slug": "find-indices-with-index-and-value-difference-i",
        "url": "https://leetcode.com/problems/find-indices-with-index-and-value-difference-i/",
        "titulo": "Find Indices With Index and Value Difference I",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n having length \nn\n, an integer \nindexDifference\n, and an integer \nvalueDifference\n.\n\n\nYour task is to find \ntwo\n indices \ni\n and \nj\n, both in the range \n[0, n - 1]\n, that satisfy the following conditions:\n\n\n\n\nabs(i - j) >= indexDifference\n, and\n\n\nabs(nums[i] - nums[j]) >= valueDifference\n\n\n\n\nReturn \nan integer array\n \nanswer\n, \nwhere\n \nanswer = [i, j]\n \nif there are two such indices\n, \nand\n \nanswer = [-1, -1]\n \notherwise\n. If there are multiple choices for the two indices, return \nany of them\n.\n\n\nNote:\n \ni\n and \nj\n may be \nequal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\n\nOutput:\n [0,3]\n\nExplanation:\n In this example, i = 0 and j = 3 can be selected.\nabs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.\nHence, a valid answer is [0,3].\n[3,0] is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,1], indexDifference = 0, valueDifference = 0\n\nOutput:\n [0,0]\n\nExplanation:\n In this example, i = 0 and j = 0 can be selected.\nabs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.\nHence, a valid answer is [0,0].\nOther valid answers are [0,1], [1,0], and [1,1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3], indexDifference = 2, valueDifference = 4\n\nOutput:\n [-1,-1]\n\nExplanation:\n In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.\nHence, [-1,-1] is returned.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 100\n\n\n0 <= nums[i] <= 50\n\n\n0 <= indexDifference <= 100\n\n\n0 <= valueDifference <= 50",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2899,
        "slug": "last-visited-integers",
        "url": "https://leetcode.com/problems/last-visited-integers/",
        "titulo": "Last Visited Integers",
        "enunciado": "Given an integer array \nnums\n where \nnums[i]\n is either a positive integer or \n-1\n. We need to find for each \n-1\n the respective positive integer, which we call the last visited integer.\n\n\nTo achieve this goal, let's define two empty arrays: \nseen\n and \nans\n.\n\n\nStart iterating from the beginning of the array \nnums\n.\n\n\n\n\nIf a positive integer is encountered, prepend it to the \nfront\n of \nseen\n.\n\n\nIf \n-1\n is encountered, let \nk\n be the number of \nconsecutive\n \n-1\ns seen so far (including the current \n-1\n),\n\t\n\n\nIf \nk\n is less than or equal to the length of \nseen\n, append the \nk\n-th element of \nseen\n to \nans\n.\n\n\nIf \nk\n is strictly greater than the length of \nseen\n, append \n-1\n to \nans\n.\n\n\n\n\n\n\n\n\nReturn the array\n \nans\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,-1,-1,-1]\n\n\nOutput:\n \n[2,1,-1]\n\n\nExplanation:\n\n\nStart with \nseen = []\n and \nans = []\n.\n\n\n\n\nProcess \nnums[0]\n: The first element in nums is \n1\n. We prepend it to the front of \nseen\n. Now, \nseen == [1]\n.\n\n\nProcess \nnums[1]\n: The next element is \n2\n. We prepend it to the front of \nseen\n. Now, \nseen == [2, 1]\n.\n\n\nProcess \nnums[2]\n: The next element is \n-1\n. This is the first occurrence of \n-1\n, so \nk == 1\n. We look for the first element in seen. We append \n2\n to \nans\n. Now, \nans == [2]\n.\n\n\nProcess \nnums[3]\n: Another \n-1\n. This is the second consecutive \n-1\n, so \nk == 2\n. The second element in \nseen\n is \n1\n, so we append \n1\n to \nans\n. Now, \nans == [2, 1]\n.\n\n\nProcess \nnums[4]\n: Another \n-1\n, the third in a row, making \nk = 3\n. However, \nseen\n only has two elements (\n[2, 1]\n). Since \nk\n is greater than the number of elements in \nseen\n, we append \n-1\n to \nans\n. Finally, \nans == [2, 1, -1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,-1,2,-1,-1]\n\n\nOutput:\n [1,2,1]\n\n\nExplanation:\n\n\nStart with \nseen = []\n and \nans = []\n.\n\n\n\n\nProcess \nnums[0]\n: The first element in nums is \n1\n. We prepend it to the front of \nseen\n. Now, \nseen == [1]\n.\n\n\nProcess \nnums[1]\n: The next element is \n-1\n. This is the first occurrence of \n-1\n, so \nk == 1\n. We look for the first element in \nseen\n, which is \n1\n. Append \n1\n to \nans\n. Now, \nans == [1]\n.\n\n\nProcess \nnums[2]\n: The next element is \n2\n. Prepend this to the front of \nseen\n. Now, \nseen == [2, 1]\n.\n\n\nProcess \nnums[3]\n: The next element is \n-1\n. This \n-1\n is not consecutive to the first \n-1\n since \n2\n was in between. Thus, \nk\n resets to \n1\n. The first element in \nseen\n is \n2\n, so append \n2\n to \nans\n. Now, \nans == [1, 2]\n.\n\n\nProcess \nnums[4]\n: Another \n-1\n. This is consecutive to the previous \n-1\n, so \nk == 2\n. The second element in \nseen\n is \n1\n, append \n1\n to \nans\n. Finally, \nans == [1, 2, 1]\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\nnums[i] == -1\n or \n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2913,
        "slug": "subarrays-distinct-element-sum-of-squares-i",
        "url": "https://leetcode.com/problems/subarrays-distinct-element-sum-of-squares-i/",
        "titulo": "Subarrays Distinct Element Sum of Squares I",
        "enunciado": "You are given a \n0-indexed \ninteger array \nnums\n.\n\n\nThe \ndistinct count\n of a subarray of \nnums\n is defined as:\n\n\n\n\nLet \nnums[i..j]\n be a subarray of \nnums\n consisting of all the indices from \ni\n to \nj\n such that \n0 <= i <= j < nums.length\n. Then the number of distinct values in \nnums[i..j]\n is called the distinct count of \nnums[i..j]\n.\n\n\n\n\nReturn \nthe sum of the \nsquares\n of \ndistinct counts\n of all subarrays of \nnums\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,1]\n\nOutput:\n 15\n\nExplanation:\n Six possible subarrays are:\n[1]: 1 distinct value\n[2]: 1 distinct value\n[1]: 1 distinct value\n[1,2]: 2 distinct values\n[2,1]: 2 distinct values\n[1,2,1]: 2 distinct values\nThe sum of the squares of the distinct counts in all subarrays is equal to 1\n2\n + 1\n2\n + 1\n2\n + 2\n2\n + 2\n2\n + 2\n2\n = 15.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1]\n\nOutput:\n 3\n\nExplanation:\n Three possible subarrays are:\n[1]: 1 distinct value\n[1]: 1 distinct value\n[1,1]: 1 distinct value\nThe sum of the squares of the distinct counts in all subarrays is equal to 1\n2\n + 1\n2\n + 1\n2\n = 3.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2873,
        "slug": "maximum-value-of-an-ordered-triplet-i",
        "url": "https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-i/",
        "titulo": "Maximum Value of an Ordered Triplet I",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n.\n\n\nReturn \nthe maximum value over all triplets of indices\n \n(i, j, k)\n \nsuch that\n \ni < j < k\n. If all such triplets have a negative value, return \n0\n.\n\n\nThe \nvalue of a triplet of indices\n \n(i, j, k)\n is equal to \n(nums[i] - nums[j]) * nums[k]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [12,6,1,2,7]\n\nOutput:\n 77\n\nExplanation:\n The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77. \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,10,3,4,19]\n\nOutput:\n 133\n\nExplanation:\n The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n 0\n\nExplanation:\n The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 100\n\n\n1 <= nums[i] <= 10\n6",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2900,
        "slug": "longest-unequal-adjacent-groups-subsequence-i",
        "url": "https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/",
        "titulo": "Longest Unequal Adjacent Groups Subsequence I",
        "enunciado": "You are given a string array \nwords\n and a \nbinary\n array \ngroups\n both of length \nn\n.\n\n\nA \nsubsequence\n of \nwords\n is \nalternating\n if for any two \nconsecutive\n strings in the sequence, their corresponding elements at the \nsame\n indices in \ngroups\n are \ndifferent\n (that is, there \ncannot\n be consecutive 0 or 1).\n\n\nYour task is to select the \nlongest alternating\n subsequence from \nwords\n.\n\n\nReturn \nthe selected subsequence. If there are multiple answers, return \nany\n of them.\n\n\nNote:\n The elements in \nwords\n are distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nwords = [\"e\",\"a\",\"b\"], groups = [0,0,1]\n\n\nOutput:\n \n[\"e\",\"b\"]\n\n\nExplanation:\n A subsequence that can be selected is \n[\"e\",\"b\"]\n because \ngroups[0] != groups[2]\n. Another subsequence that can be selected is \n[\"a\",\"b\"]\n because \ngroups[1] != groups[2]\n. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is \n2\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nwords = [\"a\",\"b\",\"c\",\"d\"], groups = [1,0,1,1]\n\n\nOutput:\n \n[\"a\",\"b\",\"c\"]\n\n\nExplanation:\n A subsequence that can be selected is \n[\"a\",\"b\",\"c\"]\n because \ngroups[0] != groups[1]\n and \ngroups[1] != groups[2]\n. Another subsequence that can be selected is \n[\"a\",\"b\",\"d\"]\n because \ngroups[0] != groups[1]\n and \ngroups[1] != groups[3]\n. It can be shown that the length of the longest subsequence of indices that satisfies the condition is \n3\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == words.length == groups.length <= 100\n\n\n1 <= words[i].length <= 10\n\n\ngroups[i]\n is either \n0\n or \n1.\n\n\nwords\n consists of \ndistinct\n strings.\n\n\nwords[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "String",
            "Dynamic Programming",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2859,
        "slug": "sum-of-values-at-indices-with-k-set-bits",
        "url": "https://leetcode.com/problems/sum-of-values-at-indices-with-k-set-bits/",
        "titulo": "Sum of Values at Indices With K Set Bits",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n and an integer \nk\n.\n\n\nReturn \nan integer that denotes the \nsum\n of elements in \nnums\n whose corresponding \nindices\n have \nexactly\n \nk\n set bits in their binary representation.\n\n\nThe \nset bits\n in an integer are the \n1\n's present when it is written in binary.\n\n\n\n\nFor example, the binary representation of \n21\n is \n10101\n, which has \n3\n set bits.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [5,10,1,5,2], k = 1\n\nOutput:\n 13\n\nExplanation:\n The binary representation of the indices are: \n0 = 000\n2\n\n1 = 001\n2\n\n2 = 010\n2\n\n3 = 011\n2\n\n4 = 100\n2 \n\nIndices 1, 2, and 4 have k = 1 set bits in their binary representation.\nHence, the answer is nums[1] + nums[2] + nums[4] = 13.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,3,2,1], k = 2\n\nOutput:\n 1\n\nExplanation:\n The binary representation of the indices are:\n0 = 00\n2\n\n1 = 01\n2\n\n2 = 10\n2\n\n3 = 11\n2\n\nOnly index 3 has k = 2 set bits in its binary representation.\nHence, the answer is nums[3] = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 10\n5\n\n\n0 <= k <= 10",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2864,
        "slug": "maximum-odd-binary-number",
        "url": "https://leetcode.com/problems/maximum-odd-binary-number/",
        "titulo": "Maximum Odd Binary Number",
        "enunciado": "You are given a \nbinary\n string \ns\n that contains at least one \n'1'\n.\n\n\nYou have to \nrearrange\n the bits in such a way that the resulting binary number is the \nmaximum odd binary number\n that can be created from this combination.\n\n\nReturn \na string representing the maximum odd binary number that can be created from the given combination.\n\n\nNote \nthat the resulting string \ncan\n have leading zeros.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"010\"\n\nOutput:\n \"001\"\n\nExplanation:\n Because there is just one '1', it must be in the last position. So the answer is \"001\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"0101\"\n\nOutput:\n \"1001\"\n\nExplanation: \nOne of the '1's must be in the last position. The maximum number that can be made with the remaining digits is \"100\". So the answer is \"1001\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists only of \n'0'\n and \n'1'\n.\n\n\ns\n contains at least one \n'1'\n.",
        "temas": [
            "Math",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2855,
        "slug": "minimum-right-shifts-to-sort-the-array",
        "url": "https://leetcode.com/problems/minimum-right-shifts-to-sort-the-array/",
        "titulo": "Minimum Right Shifts to Sort the Array",
        "enunciado": "You are given a \n0-indexed\n array \nnums\n of length \nn\n containing \ndistinct\n positive integers. Return \nthe \nminimum\n number of \nright shifts\n required to sort \nnums\n and \n-1\n if this is not possible.\n\n\nA \nright shift\n is defined as shifting the element at index \ni\n to index \n(i + 1) % n\n, for all indices.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 2\n\nExplanation:\n \nAfter the first right shift, nums = [2,3,4,5,1].\nAfter the second right shift, nums = [1,2,3,4,5].\nNow nums is sorted; therefore the answer is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5]\n\nOutput:\n 0\n\nExplanation:\n nums is already sorted therefore, the answer is 0.\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,1,4]\n\nOutput:\n -1\n\nExplanation:\n It's impossible to sort the array using right shifts.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100\n\n\nnums\n contains distinct integers.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2869,
        "slug": "minimum-operations-to-collect-elements",
        "url": "https://leetcode.com/problems/minimum-operations-to-collect-elements/",
        "titulo": "Minimum Operations to Collect Elements",
        "enunciado": "You are given an array \nnums\n of positive integers and an integer \nk\n.\n\n\nIn one operation, you can remove the last element of the array and add it to your collection.\n\n\nReturn \nthe \nminimum number of operations\n needed to collect elements\n \n1, 2, ..., k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,1,5,4,2], k = 2\n\nOutput:\n 4\n\nExplanation:\n After 4 operations, we collect elements 2, 4, 5, and 1, in this order. Our collection contains elements 1 and 2. Hence, the answer is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,1,5,4,2], k = 5\n\nOutput:\n 5\n\nExplanation:\n After 5 operations, we collect elements 2, 4, 5, 1, and 3, in this order. Our collection contains elements 1 through 5. Hence, the answer is 5.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,2,5,3,1], k = 3\n\nOutput:\n 4\n\nExplanation:\n After 4 operations, we collect elements 1, 3, 5, and 2, in this order. Our collection contains elements 1 through 3. Hence, the answer is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 50\n\n\n1 <= nums[i] <= nums.length\n\n\n1 <= k <= nums.length\n\n\nThe input is generated such that you can collect elements \n1, 2, ..., k\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2848,
        "slug": "points-that-intersect-with-cars",
        "url": "https://leetcode.com/problems/points-that-intersect-with-cars/",
        "titulo": "Points That Intersect With Cars",
        "enunciado": "You are given a \n0-indexed\n 2D integer array \nnums\n representing the coordinates of the cars parking on a number line. For any index \ni\n, \nnums[i] = [start\ni\n, end\ni\n]\n where \nstart\ni\n is the starting point of the \ni\nth\n car and \nend\ni\n is the ending point of the \ni\nth\n car.\n\n\nReturn \nthe number of integer points on the line that are covered with \nany part\n of a car.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [[3,6],[1,5],[4,7]]\n\nOutput:\n 7\n\nExplanation:\n All the points from 1 to 7 intersect at least one car, therefore the answer would be 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [[1,3],[5,8]]\n\nOutput:\n 7\n\nExplanation:\n Points intersecting at least one car are 1, 2, 3, 5, 6, 7, 8. There are a total of 7 points, therefore the answer would be 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\nnums[i].length == 2\n\n\n1 <= start\ni\n <= end\ni\n <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2833,
        "slug": "furthest-point-from-origin",
        "url": "https://leetcode.com/problems/furthest-point-from-origin/",
        "titulo": "Furthest Point From Origin",
        "enunciado": "You are given a string \nmoves\n of length \nn\n consisting only of characters \n'L'\n, \n'R'\n, and \n'_'\n. The string represents your movement on a number line starting from the origin \n0\n.\n\n\nIn the \ni\nth\n move, you can choose one of the following directions:\n\n\n\n\nmove to the left if \nmoves[i] = 'L'\n or \nmoves[i] = '_'\n\n\nmove to the right if \nmoves[i] = 'R'\n or \nmoves[i] = '_'\n\n\n\n\nReturn \nthe \ndistance from the origin\n of the \nfurthest\n point you can get to after \nn\n moves\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n moves = \"L_RL__R\"\n\nOutput:\n 3\n\nExplanation:\n The furthest point we can reach from the origin 0 is point -3 through the following sequence of moves \"LLRLLLR\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n moves = \"_R__LL_\"\n\nOutput:\n 5\n\nExplanation:\n The furthest point we can reach from the origin 0 is point -5 through the following sequence of moves \"LRLLLLL\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n moves = \"_______\"\n\nOutput:\n 7\n\nExplanation:\n The furthest point we can reach from the origin 0 is point 7 through the following sequence of moves \"RRRRRRR\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= moves.length == n <= 50\n\n\nmoves\n consists only of characters \n'L'\n, \n'R'\n and \n'_'\n.",
        "temas": [
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2839,
        "slug": "check-if-strings-can-be-made-equal-with-operations-i",
        "url": "https://leetcode.com/problems/check-if-strings-can-be-made-equal-with-operations-i/",
        "titulo": "Check if Strings Can be Made Equal With Operations I",
        "enunciado": "You are given two strings \ns1\n and \ns2\n, both of length \n4\n, consisting of \nlowercase\n English letters.\n\n\nYou can apply the following operation on any of the two strings \nany\n number of times:\n\n\n\n\nChoose any two indices \ni\n and \nj\n such that \nj - i = 2\n, then \nswap\n the two characters at those indices in the string.\n\n\n\n\nReturn \ntrue\n if you can make the strings \ns1\n and \ns2\n equal, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s1 = \"abcd\", s2 = \"cdab\"\n\nOutput:\n true\n\nExplanation:\n We can do the following operations on s1:\n- Choose the indices i = 0, j = 2. The resulting string is s1 = \"cbad\".\n- Choose the indices i = 1, j = 3. The resulting string is s1 = \"cdab\" = s2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s1 = \"abcd\", s2 = \"dacb\"\n\nOutput:\n false\n\nExplanation:\n It is not possible to make the two strings equal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ns1.length == s2.length == 4\n\n\ns1\n and \ns2\n consist only of lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2843,
        "slug": "count-symmetric-integers",
        "url": "https://leetcode.com/problems/count-symmetric-integers/",
        "titulo": "  Count Symmetric Integers",
        "enunciado": "You are given two positive integers \nlow\n and \nhigh\n.\n\n\nAn integer \nx\n consisting of \n2 * n\n digits is \nsymmetric\n if the sum of the first \nn\n digits of \nx\n is equal to the sum of the last \nn\n digits of \nx\n. Numbers with an odd number of digits are never symmetric.\n\n\nReturn \nthe \nnumber of symmetric\n integers in the range\n \n[low, high]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n low = 1, high = 100\n\nOutput:\n 9\n\nExplanation:\n There are 9 symmetric integers between 1 and 100: 11, 22, 33, 44, 55, 66, 77, 88, and 99.\n\n\n\nExample 2:\n\n\n\n\nInput:\n low = 1200, high = 1230\n\nOutput:\n 4\n\nExplanation:\n There are 4 symmetric integers between 1200 and 1230: 1203, 1212, 1221, and 1230.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= low <= high <= 10\n4",
        "temas": [
            "Math",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2828,
        "slug": "check-if-a-string-is-an-acronym-of-words",
        "url": "https://leetcode.com/problems/check-if-a-string-is-an-acronym-of-words/",
        "titulo": "Check if a String Is an Acronym of Words",
        "enunciado": "Given an array of strings \nwords\n and a string \ns\n, determine if \ns\n is an \nacronym\n of words.\n\n\nThe string \ns\n is considered an acronym of \nwords\n if it can be formed by concatenating the \nfirst\n character of each string in \nwords\n \nin order\n. For example, \n\"ab\"\n can be formed from \n[\"apple\", \"banana\"]\n, but it can't be formed from \n[\"bear\", \"aardvark\"]\n.\n\n\nReturn \ntrue\n if \ns\n is an acronym of \nwords\n, and \nfalse\n otherwise. \n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"alice\",\"bob\",\"charlie\"], s = \"abc\"\n\nOutput:\n true\n\nExplanation:\n The first character in the words \"alice\", \"bob\", and \"charlie\" are 'a', 'b', and 'c', respectively. Hence, s = \"abc\" is the acronym. \n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"an\",\"apple\"], s = \"a\"\n\nOutput:\n false\n\nExplanation:\n The first character in the words \"an\" and \"apple\" are 'a' and 'a', respectively. \nThe acronym formed by concatenating these characters is \"aa\". \nHence, s = \"a\" is not the acronym.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"never\",\"gonna\",\"give\",\"up\",\"on\",\"you\"], s = \"ngguoy\"\n\nOutput:\n true\n\nExplanation: \nBy concatenating the first character of the words in the array, we get the string \"ngguoy\". \nHence, s = \"ngguoy\" is the acronym.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 10\n\n\n1 <= s.length <= 100\n\n\nwords[i]\n and \ns\n consist of lowercase English letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2806,
        "slug": "account-balance-after-rounded-purchase",
        "url": "https://leetcode.com/problems/account-balance-after-rounded-purchase/",
        "titulo": "Account Balance After Rounded Purchase",
        "enunciado": "Initially, you have a bank account balance of \n100\n dollars.\n\n\nYou are given an integer \npurchaseAmount\n representing the amount you will spend on a purchase in dollars, in other words, its price.\n\n\nWhen making the purchase, first the \npurchaseAmount\n \nis rounded to the nearest multiple of 10\n. Let us call this value \nroundedAmount\n. Then, \nroundedAmount\n dollars are removed from your bank account.\n\n\nReturn an integer denoting your final bank account balance after this purchase.\n\n\nNotes:\n\n\n\n\n0 is considered to be a multiple of 10 in this problem.\n\n\nWhen rounding, 5 is rounded upward (5 is rounded to 10, 15 is rounded to 20, 25 to 30, and so on).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \npurchaseAmount = 9\n\n\nOutput:\n \n90\n\n\nExplanation:\n\n\nThe nearest multiple of 10 to 9 is 10. So your account balance becomes 100 - 10 = 90.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \npurchaseAmount = 15\n\n\nOutput:\n \n80\n\n\nExplanation:\n\n\nThe nearest multiple of 10 to 15 is 20. So your account balance becomes 100 - 20 = 80.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npurchaseAmount = 10\n\n\nOutput:\n \n90\n\n\nExplanation:\n\n\n10 is a multiple of 10 itself. So your account balance becomes 100 - 10 = 90.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= purchaseAmount <= 100",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2824,
        "slug": "count-pairs-whose-sum-is-less-than-target",
        "url": "https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/",
        "titulo": "Count Pairs Whose Sum is Less than Target",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n of length \nn\n and an integer \ntarget\n, return \nthe number of pairs\n \n(i, j)\n \nwhere\n \n0 <= i < j < n\n \nand\n \nnums[i] + nums[j] < target\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,1,2,3,1], target = 2\n\nOutput:\n 3\n\nExplanation:\n There are 3 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target\n- (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target \n- (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target\nNote that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-6,2,5,-2,-7,-1,3], target = -2\n\nOutput:\n 10\n\nExplanation:\n There are 10 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target\n- (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target\n- (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target\n- (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target\n- (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target\n- (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target\n- (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target\n- (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target\n- (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target\n- (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length == n <= 50\n\n\n-50 <= nums[i], target <= 50",
        "temas": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2815,
        "slug": "max-pair-sum-in-an-array",
        "url": "https://leetcode.com/problems/max-pair-sum-in-an-array/",
        "titulo": "Max Pair Sum in an Array",
        "enunciado": "You are given an integer array \nnums\n. You have to find the \nmaximum\n sum of a pair of numbers from \nnums\n such that the \nlargest digit \nin both numbers is equal.\n\n\nFor example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them.\n\n\nReturn the \nmaximum\n sum or -1 if no such pair exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [112,131,411]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nEach numbers largest digit in order is [2,3,4].\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2536,1613,3366,162]\n\n\nOutput:\n \n5902\n\n\nExplanation:\n\n\nAll the numbers have 6 as their largest digit, so the answer is \n2536 + 3366 = 5902.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [51,71,17,24,42]\n\n\nOutput:\n \n88\n\n\nExplanation:\n\n\nEach number's largest digit in order is [5,7,7,4,4].\n\n\nSo we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2784,
        "slug": "check-if-array-is-good",
        "url": "https://leetcode.com/problems/check-if-array-is-good/",
        "titulo": "Check if Array is Good",
        "enunciado": "You are given an integer array \nnums\n. We consider an array \ngood \nif it is a permutation of an array \nbase[n]\n.\n\n\nbase[n] = [1, 2, ..., n - 1, n, n] \n(in other words, it is an array of length \nn + 1\n which contains \n1\n to \nn - 1 \nexactly once, plus two occurrences of \nn\n). For example, \nbase[1] = [1, 1]\n and\n base[3] = [1, 2, 3, 3]\n.\n\n\nReturn \ntrue\n \nif the given array is good, otherwise return\n \nfalse\n.\n\n\nNote: \nA permutation of integers represents an arrangement of these numbers.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2, 1, 3]\n\nOutput:\n false\n\nExplanation:\n Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. However, base[3] has four elements but array nums has three. Therefore, it can not be a permutation of base[3] = [1, 2, 3, 3]. So the answer is false.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1, 3, 3, 2]\n\nOutput:\n true\n\nExplanation:\n Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. It can be seen that nums is a permutation of base[3] = [1, 2, 3, 3] (by swapping the second and fourth elements in nums, we reach base[3]). Therefore, the answer is true.\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1, 1]\n\nOutput:\n true\n\nExplanation:\n Since the maximum element of the array is 1, the only candidate n for which this array could be a permutation of base[n], is n = 1. It can be seen that nums is a permutation of base[1] = [1, 1]. Therefore, the answer is true.\n\n\nExample 4:\n\n\n\n\nInput:\n nums = [3, 4, 4, 1, 2, 1]\n\nOutput:\n false\n\nExplanation:\n Since the maximum element of the array is 4, the only candidate n for which this array could be a permutation of base[n], is n = 4. However, base[4] has five elements but array nums has six. Therefore, it can not be a permutation of base[4] = [1, 2, 3, 4, 4]. So the answer is false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= num[i] <= 200",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2810,
        "slug": "faulty-keyboard",
        "url": "https://leetcode.com/problems/faulty-keyboard/",
        "titulo": "Faulty Keyboard",
        "enunciado": "Your laptop keyboard is faulty, and whenever you type a character \n'i'\n on it, it reverses the string that you have written. Typing other characters works as expected.\n\n\nYou are given a \n0-indexed\n string \ns\n, and you type each character of \ns\n using your faulty keyboard.\n\n\nReturn \nthe final string that will be present on your laptop screen.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"string\"\n\nOutput:\n \"rtsng\"\n\nExplanation:\n \nAfter typing first character, the text on the screen is \"s\".\nAfter the second character, the text is \"st\". \nAfter the third character, the text is \"str\".\nSince the fourth character is an 'i', the text gets reversed and becomes \"rts\".\nAfter the fifth character, the text is \"rtsn\". \nAfter the sixth character, the text is \"rtsng\". \nTherefore, we return \"rtsng\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"poiinter\"\n\nOutput:\n \"ponter\"\n\nExplanation:\n \nAfter the first character, the text on the screen is \"p\".\nAfter the second character, the text is \"po\". \nSince the third character you type is an 'i', the text gets reversed and becomes \"op\". \nSince the fourth character you type is an 'i', the text gets reversed and becomes \"po\".\nAfter the fifth character, the text is \"pon\".\nAfter the sixth character, the text is \"pont\". \nAfter the seventh character, the text is \"ponte\". \nAfter the eighth character, the text is \"ponter\". \nTherefore, we return \"ponter\".\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of lowercase English letters.\n\n\ns[0] != 'i'",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2788,
        "slug": "split-strings-by-separator",
        "url": "https://leetcode.com/problems/split-strings-by-separator/",
        "titulo": "Split Strings by Separator",
        "enunciado": "Given an array of strings \nwords\n and a character \nseparator\n, \nsplit\n each string in \nwords\n by \nseparator\n.\n\n\nReturn \nan array of strings containing the new strings formed after the splits, \nexcluding empty strings\n.\n\n\nNotes\n\n\n\n\nseparator\n is used to determine where the split should occur, but it is not included as part of the resulting strings.\n\n\nA split may result in more than two strings.\n\n\nThe resulting strings must maintain the same order as they were initially given.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"one.two.three\",\"four.five\",\"six\"], separator = \".\"\n\nOutput:\n [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]\n\nExplanation: \nIn this example we split as follows:\n\n\"one.two.three\" splits into \"one\", \"two\", \"three\"\n\"four.five\" splits into \"four\", \"five\"\n\"six\" splits into \"six\" \n\nHence, the resulting array is [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"].\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"$easy$\",\"$problem$\"], separator = \"$\"\n\nOutput:\n [\"easy\",\"problem\"]\n\nExplanation:\n In this example we split as follows: \n\n\"$easy$\" splits into \"easy\" (excluding empty strings)\n\"$problem$\" splits into \"problem\" (excluding empty strings)\n\nHence, the resulting array is [\"easy\",\"problem\"].\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"|||\"], separator = \"|\"\n\nOutput:\n []\n\nExplanation:\n In this example the resulting split of \"|||\" will contain only empty strings, so we return an empty array []. \n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 20\n\n\ncharacters in \nwords[i]\n are either lowercase English letters or characters from the string \n\".,|$#@\"\n (excluding the quotes)\n\n\nseparator\n is a character from the string \n\".,|$#@\"\n (excluding the quotes)",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2798,
        "slug": "number-of-employees-who-met-the-target",
        "url": "https://leetcode.com/problems/number-of-employees-who-met-the-target/",
        "titulo": "Number of Employees Who Met the Target",
        "enunciado": "There are \nn\n employees in a company, numbered from \n0\n to \nn - 1\n. Each employee \ni\n has worked for \nhours[i]\n hours in the company.\n\n\nThe company requires each employee to work for \nat least\n \ntarget\n hours.\n\n\nYou are given a \n0-indexed\n array of non-negative integers \nhours\n of length \nn\n and a non-negative integer \ntarget\n.\n\n\nReturn \nthe integer denoting the number of employees who worked at least\n \ntarget\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n hours = [0,1,2,3,4], target = 2\n\nOutput:\n 3\n\nExplanation:\n The company wants each employee to work for at least 2 hours.\n- Employee 0 worked for 0 hours and didn't meet the target.\n- Employee 1 worked for 1 hours and didn't meet the target.\n- Employee 2 worked for 2 hours and met the target.\n- Employee 3 worked for 3 hours and met the target.\n- Employee 4 worked for 4 hours and met the target.\nThere are 3 employees who met the target.\n\n\n\nExample 2:\n\n\n\n\nInput:\n hours = [5,1,4,2,2], target = 6\n\nOutput:\n 0\n\nExplanation:\n The company wants each employee to work for at least 6 hours.\nThere are 0 employees who met the target.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == hours.length <= 50\n\n\n0 <= hours[i], target <= 10\n5",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2765,
        "slug": "longest-alternating-subarray",
        "url": "https://leetcode.com/problems/longest-alternating-subarray/",
        "titulo": "Longest Alternating Subarray",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n. A subarray \ns\n of length \nm\n is called \nalternating\n if:\n\n\n\n\nm\n is greater than \n1\n.\n\n\ns\n1\n = s\n0\n + 1\n.\n\n\nThe \n0-indexed\n subarray \ns\n looks like \n[s\n0\n, s\n1\n, s\n0\n, s\n1\n,...,s\n(m-1) % 2\n]\n. In other words, \ns\n1\n - s\n0\n = 1\n, \ns\n2\n - s\n1\n = -1\n, \ns\n3\n - s\n2\n = 1\n, \ns\n4\n - s\n3\n = -1\n, and so on up to \ns[m - 1] - s[m - 2] = (-1)\nm\n.\n\n\n\n\nReturn \nthe maximum length of all \nalternating\n subarrays present in \nnums\n \nor \n-1\n if no such subarray exists\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,3,4,3,4]\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nThe alternating subarrays are \n[2, 3]\n, \n[3,4]\n, \n[3,4,3]\n, and \n[3,4,3,4]\n. The longest of these is \n[3,4,3,4]\n, which is of length 4.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,5,6]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n[4,5]\n and \n[5,6]\n are the only two alternating subarrays. They are both of length 2.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2760,
        "slug": "longest-even-odd-subarray-with-threshold",
        "url": "https://leetcode.com/problems/longest-even-odd-subarray-with-threshold/",
        "titulo": "Longest Even Odd Subarray With Threshold",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n and an integer \nthreshold\n.\n\n\nFind the length of the \nlongest subarray\n of \nnums\n starting at index \nl\n and ending at index \nr\n \n(0 <= l <= r < nums.length)\n that satisfies the following conditions:\n\n\n\n\nnums[l] % 2 == 0\n\n\nFor all indices \ni\n in the range \n[l, r - 1]\n, \nnums[i] % 2 != nums[i + 1] % 2\n\n\nFor all indices \ni\n in the range \n[l, r]\n, \nnums[i] <= threshold\n\n\n\n\nReturn \nan integer denoting the length of the longest such subarray.\n\n\nNote:\n A \nsubarray\n is a contiguous non-empty sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,2,5,4], threshold = 5\n\nOutput:\n 3\n\nExplanation:\n In this example, we can select the subarray that starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2], threshold = 2\n\nOutput:\n 1\n\nExplanation:\n In this example, we can select the subarray that starts at l = 1 and ends at r = 1 => [2]. \nIt satisfies all the conditions and we can show that 1 is the maximum possible achievable length.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,3,4,5], threshold = 4\n\nOutput:\n 3\n\nExplanation:\n In this example, we can select the subarray that starts at l = 0 and ends at r = 2 => [2,3,4]. \nIt satisfies all the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100 \n\n\n1 <= nums[i] <= 100 \n\n\n1 <= threshold <= 100",
        "temas": [
            "Array",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2739,
        "slug": "total-distance-traveled",
        "url": "https://leetcode.com/problems/total-distance-traveled/",
        "titulo": "Total Distance Traveled",
        "enunciado": "A truck has two fuel tanks. You are given two integers, \nmainTank\n representing the fuel present in the main tank in liters and \nadditionalTank\n representing the fuel present in the additional tank in liters.\n\n\nThe truck has a mileage of \n10\n km per liter. Whenever \n5\n liters of fuel get used up in the main tank, if the additional tank has at least \n1\n liters of fuel, \n1\n liters of fuel will be transferred from the additional tank to the main tank.\n\n\nReturn \nthe maximum distance which can be traveled.\n\n\nNote: \nInjection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n mainTank = 5, additionalTank = 10\n\nOutput:\n 60\n\nExplanation:\n \nAfter spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km.\nAfter spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.\nTotal distance traveled is 60km.\n\n\n\nExample 2:\n\n\n\n\nInput:\n mainTank = 1, additionalTank = 2\n\nOutput:\n 10\n\nExplanation:\n \nAfter spending 1 litre of fuel, the main tank becomes empty.\nTotal distance traveled is 10km.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= mainTank, additionalTank <= 100",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2744,
        "slug": "find-maximum-number-of-string-pairs",
        "url": "https://leetcode.com/problems/find-maximum-number-of-string-pairs/",
        "titulo": "Find Maximum Number of String Pairs",
        "enunciado": "You are given a \n0-indexed\n array \nwords\n consisting of \ndistinct\n strings.\n\n\nThe string \nwords[i]\n can be paired with the string \nwords[j]\n if:\n\n\n\n\nThe string \nwords[i]\n is equal to the reversed string of \nwords[j]\n.\n\n\n0 <= i < j < words.length\n.\n\n\n\n\nReturn \nthe \nmaximum\n number of pairs that can be formed from the array \nwords\n.\n\n\nNote that each string can belong in \nat most one\n pair.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\n\nOutput:\n 2\n\nExplanation:\n In this example, we can form 2 pair of strings in the following way:\n- We pair the 0\nth\n string with the 2\nnd\n string, as the reversed string of word[0] is \"dc\" and is equal to words[2].\n- We pair the 1\nst\n string with the 3\nrd\n string, as the reversed string of word[1] is \"ca\" and is equal to words[3].\nIt can be proven that 2 is the maximum number of pairs that can be formed.\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"ab\",\"ba\",\"cc\"]\n\nOutput:\n 1\n\nExplanation:\n In this example, we can form 1 pair of strings in the following way:\n- We pair the 0\nth\n string with the 1\nst\n string, as the reversed string of words[1] is \"ab\" and is equal to words[0].\nIt can be proven that 1 is the maximum number of pairs that can be formed.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"aa\",\"ab\"]\n\nOutput:\n 0\n\nExplanation:\n In this example, we are unable to form any pair of strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 50\n\n\nwords[i].length == 2\n\n\nwords\n consists of distinct strings.\n\n\nwords[i]\n contains only lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2778,
        "slug": "sum-of-squares-of-special-elements",
        "url": "https://leetcode.com/problems/sum-of-squares-of-special-elements/",
        "titulo": "Sum of Squares of Special Elements ",
        "enunciado": "You are given a \n1-indexed\n integer array \nnums\n of length \nn\n.\n\n\nAn element \nnums[i]\n of \nnums\n is called \nspecial\n if \ni\n divides \nn\n, i.e. \nn % i == 0\n.\n\n\nReturn \nthe \nsum of the squares\n of all \nspecial\n elements of \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n 21\n\nExplanation:\n There are exactly 3 special elements in nums: nums[1] since 1 divides 4, nums[2] since 2 divides 4, and nums[4] since 4 divides 4. \nHence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] = 1 * 1 + 2 * 2 + 4 * 4 = 21.  \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,7,1,19,18,3]\n\nOutput:\n 63\n\nExplanation:\n There are exactly 4 special elements in nums: nums[1] since 1 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides 6, and nums[6] since 6 divides 6. \nHence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] + nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length == n <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2733,
        "slug": "neither-minimum-nor-maximum",
        "url": "https://leetcode.com/problems/neither-minimum-nor-maximum/",
        "titulo": "Neither Minimum nor Maximum",
        "enunciado": "Given an integer array \nnums\n containing \ndistinct\n \npositive\n integers, find and return \nany\n number from the array that is neither the \nminimum\n nor the \nmaximum\n value in the array, or \n-1\n if there is no such number.\n\n\nReturn \nthe selected integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,2,1,4]\n\nOutput:\n 2\n\nExplanation:\n In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2]\n\nOutput:\n -1\n\nExplanation:\n Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,1,3]\n\nOutput:\n 2\n\nExplanation:\n Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100\n\n\nAll values in \nnums\n are distinct",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2748,
        "slug": "number-of-beautiful-pairs",
        "url": "https://leetcode.com/problems/number-of-beautiful-pairs/",
        "titulo": "Number of Beautiful Pairs",
        "enunciado": "You are given a \n0-indexed \ninteger array \nnums\n. A pair of indices \ni\n, \nj\n where \n0 <= i < j < nums.length\n is called beautiful if the \nfirst digit\n of \nnums[i]\n and the \nlast digit\n of \nnums[j]\n are \ncoprime\n.\n\n\nReturn \nthe total number of beautiful pairs in \nnums\n.\n\n\nTwo integers \nx\n and \ny\n are \ncoprime\n if there is no integer greater than 1 that divides both of them. In other words, \nx\n and \ny\n are coprime if \ngcd(x, y) == 1\n, where \ngcd(x, y)\n is the \ngreatest common divisor\n of \nx\n and \ny\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,5,1,4]\n\nOutput:\n 5\n\nExplanation:\n There are 5 beautiful pairs in nums:\nWhen i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.\nWhen i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.\nWhen i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.\nWhen i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.\nThus, we return 5.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [11,21,12]\n\nOutput:\n 2\n\nExplanation:\n There are 2 beautiful pairs:\nWhen i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.\nThus, we return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\n1 <= nums[i] <= 9999\n\n\nnums[i] % 10 != 0",
        "temas": [
            "Array",
            "Hash Table",
            "Math",
            "Counting",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2716,
        "slug": "minimize-string-length",
        "url": "https://leetcode.com/problems/minimize-string-length/",
        "titulo": "Minimize String Length",
        "enunciado": "Given a string \ns\n, you have two types of operation:\n\n\n\n\nChoose an index \ni\n in the string, and let \nc\n be the character in position \ni\n. \nDelete\n the \nclosest occurrence\n of \nc\n to the \nleft\n of \ni\n (if exists).\n\n\nChoose an index \ni\n in the string, and let \nc\n be the character in position \ni\n. \nDelete\n the \nclosest occurrence\n of \nc\n to the \nright\n of \ni\n (if exists).\n\n\n\n\nYour task is to \nminimize\n the length of \ns\n by performing the above operations zero or more times.\n\n\nReturn an integer denoting the length of the \nminimized\n string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"aaabc\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nOperation 2: we choose \ni = 1\n so \nc\n is 'a', then we remove \ns[2]\n as it is closest 'a' character to the right of \ns[1]\n.\n\n\ns\n becomes \"aabc\" after this.\n\n\nOperation 1: we choose \ni = 1\n so \nc\n is 'a', then we remove \ns[0]\n as it is closest 'a' character to the left of \ns[1]\n.\n\n\ns\n becomes \"abc\" after this.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"cbbd\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nOperation 1: we choose \ni = 2\n so \nc\n is 'b', then we remove \ns[1]\n as it is closest 'b' character to the left of \ns[1]\n.\n\n\ns\n becomes \"cbd\" after this.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"baadccab\"\n\n\nOutput:\n 4\n\n\nExplanation:\n\n\n\n\nOperation 1: we choose \ni = 6\n so \nc\n is 'a', then we remove \ns[2]\n as it is closest 'a' character to the left of \ns[6]\n.\n\n\ns\n becomes \"badccab\" after this.\n\n\nOperation 2: we choose \ni = 0\n so \nc\n is 'b', then we remove \ns[6]\n as it is closest 'b' character to the right of \ns[0]\n.\n\n\ns\n becomes \"badcca\" fter this.\n\n\nOperation 2: we choose \ni = 3\n so \nc\n is 'c', then we remove \ns[4]\n as it is closest 'c' character to the right of \ns[3]\n.\n\n\ns\n becomes \"badca\" after this.\n\n\nOperation 1: we choose \ni = 4\n so \nc\n is 'a', then we remove \ns[1]\n as it is closest 'a' character to the left of \ns[4]\n.\n\n\ns\n becomes \"bdca\" after this.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n contains only lowercase English letters",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2729,
        "slug": "check-if-the-number-is-fascinating",
        "url": "https://leetcode.com/problems/check-if-the-number-is-fascinating/",
        "titulo": "Check if The Number is Fascinating",
        "enunciado": "You are given an integer \nn\n that consists of exactly \n3\n digits.\n\n\nWe call the number \nn\n \nfascinating\n if, after the following modification, the resulting number contains all the digits from \n1\n to \n9\n \nexactly\n once and does not contain any \n0\n's:\n\n\n\n\nConcatenate\n \nn\n with the numbers \n2 * n\n and \n3 * n\n.\n\n\n\n\nReturn \ntrue\n if \nn\n is fascinating, or \nfalse\n otherwise\n.\n\n\nConcatenating\n two numbers means joining them together. For example, the concatenation of \n121\n and \n371\n is \n121371\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 192\n\nOutput:\n true\n\nExplanation:\n We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 100\n\nOutput:\n false\n\nExplanation:\n We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n100 <= n <= 999",
        "temas": [
            "Hash Table",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2710,
        "slug": "remove-trailing-zeros-from-a-string",
        "url": "https://leetcode.com/problems/remove-trailing-zeros-from-a-string/",
        "titulo": "Remove Trailing Zeros From a String",
        "enunciado": "Given a \npositive\n integer \nnum\n represented as a string, return \nthe integer \nnum\n without trailing zeros as a string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = \"51230100\"\n\nOutput:\n \"512301\"\n\nExplanation:\n Integer \"51230100\" has 2 trailing zeros, we remove them and return integer \"512301\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = \"123\"\n\nOutput:\n \"123\"\n\nExplanation:\n Integer \"123\" has no trailing zeros, we return integer \"123\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num.length <= 1000\n\n\nnum\n consists of only digits.\n\n\nnum\n doesn't have any leading zeros.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2697,
        "slug": "lexicographically-smallest-palindrome",
        "url": "https://leetcode.com/problems/lexicographically-smallest-palindrome/",
        "titulo": "Lexicographically Smallest Palindrome",
        "enunciado": "You are given a string \ns\n consisting of \nlowercase English letters\n, and you are allowed to perform operations on it. In one operation, you can \nreplace\n a character in \ns\n with another lowercase English letter.\n\n\nYour task is to make \ns\n a \npalindrome\n with the \nminimum\n \nnumber\n \nof operations\n possible. If there are \nmultiple palindromes\n that can be \nmade using the \nminimum\n number of operations, \nmake the \nlexicographically smallest\n one.\n\n\nA string \na\n is lexicographically smaller than a string \nb\n (of the same length) if in the first position where \na\n and \nb\n differ, string \na\n has a letter that appears earlier in the alphabet than the corresponding letter in \nb\n.\n\n\nReturn \nthe resulting palindrome string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"egcfe\"\n\nOutput:\n \"efcfe\"\n\nExplanation:\n The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abcd\"\n\nOutput:\n \"abba\"\n\nExplanation:\n The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"seven\"\n\nOutput:\n \"neven\"\n\nExplanation:\n The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of only lowercase English letters\n.",
        "temas": [
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 2769,
        "slug": "find-the-maximum-achievable-number",
        "url": "https://leetcode.com/problems/find-the-maximum-achievable-number/",
        "titulo": "Find the Maximum Achievable Number",
        "enunciado": "Given two integers, \nnum\n and \nt\n. A \nnumber \nx\n \nis\n achievable\n if it can become equal to \nnum\n after applying the following operation \nat most\n \nt\n times:\n\n\n\n\nIncrease or decrease \nx\n by \n1\n, and \nsimultaneously\n increase or decrease \nnum\n by \n1\n.\n\n\n\n\nReturn the \nmaximum \npossible value of \nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnum = 4, t = 1\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\nApply the following operation once to make the maximum achievable number equal to \nnum\n:\n\n\n\n\nDecrease the maximum achievable number by 1, and increase \nnum\n by 1.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnum = 3, t = 2\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\nApply the following operation twice to make the maximum achievable number equal to \nnum\n:\n\n\n\n\nDecrease the maximum achievable number by 1, and increase \nnum\n by 1.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num, t <= 50",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2696,
        "slug": "minimum-string-length-after-removing-substrings",
        "url": "https://leetcode.com/problems/minimum-string-length-after-removing-substrings/",
        "titulo": "Minimum String Length After Removing Substrings",
        "enunciado": "You are given a string \ns\n consisting only of \nuppercase\n English letters.\n\n\nYou can apply some operations to this string where, in one operation, you can remove \nany\n occurrence of one of the substrings \n\"AB\"\n or \n\"CD\"\n from \ns\n.\n\n\nReturn \nthe \nminimum\n possible length of the resulting string that you can obtain\n.\n\n\nNote\n that the string concatenates after removing the substring and could produce new \n\"AB\"\n or \n\"CD\"\n substrings.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ABFCACDB\"\n\nOutput:\n 2\n\nExplanation:\n We can do the following operations:\n- Remove the substring \"\nAB\nFCACDB\", so s = \"FCACDB\".\n- Remove the substring \"FCA\nCD\nB\", so s = \"FCAB\".\n- Remove the substring \"FC\nAB\n\", so s = \"FC\".\nSo the resulting length of the string is 2.\nIt can be shown that it is the minimum length that we can obtain.\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"ACBBD\"\n\nOutput:\n 5\n\nExplanation:\n We cannot do any operations on the string so the length remains the same.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists only of uppercase English letters.",
        "temas": [
            "String",
            "Stack",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2682,
        "slug": "find-the-losers-of-the-circular-game",
        "url": "https://leetcode.com/problems/find-the-losers-of-the-circular-game/",
        "titulo": "Find the Losers of the Circular Game",
        "enunciado": "There are \nn\n friends that are playing a game. The friends are sitting in a circle and are numbered from \n1\n to \nn\n in \nclockwise order\n. More formally, moving clockwise from the \ni\nth\n friend brings you to the \n(i+1)\nth\n friend for \n1 <= i < n\n, and moving clockwise from the \nn\nth\n friend brings you to the \n1\nst\n friend.\n\n\nThe rules of the game are as follows:\n\n\n1\nst\n friend receives the ball.\n\n\n\n\nAfter that, \n1\nst\n friend passes it to the friend who is \nk\n steps away from them in the \nclockwise\n direction.\n\n\nAfter that, the friend who receives the ball should pass it to the friend who is \n2 * k\n steps away from them in the \nclockwise\n direction.\n\n\nAfter that, the friend who receives the ball should pass it to the friend who is \n3 * k\n steps away from them in the \nclockwise\n direction, and so on and so forth.\n\n\n\n\nIn other words, on the \ni\nth\n turn, the friend holding the ball should pass it to the friend who is \ni * k\n steps away from them in the \nclockwise\n direction.\n\n\nThe game is finished when some friend receives the ball for the second time.\n\n\nThe \nlosers\n of the game are friends who did not receive the ball in the entire game.\n\n\nGiven the number of friends, \nn\n, and an integer \nk\n, return \nthe array answer, which contains the losers of the game in the \nascending\n order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5, k = 2\n\nOutput:\n [4,5]\n\nExplanation:\n The game goes as follows:\n1) Start at 1\nst\n friend and pass the ball to the friend who is 2 steps away from them - 3\nrd\n friend.\n2) 3\nrd\n friend passes the ball to the friend who is 4 steps away from them - 2\nnd\n friend.\n3) 2\nnd\n friend passes the ball to the friend who is 6 steps away from them  - 3\nrd\n friend.\n4) The game ends as 3\nrd\n friend receives the ball for the second time.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 4, k = 4\n\nOutput:\n [2,3,4]\n\nExplanation:\n The game goes as follows:\n1) Start at the 1\nst\n friend and pass the ball to the friend who is 4 steps away from them - 1\nst\n friend.\n2) The game ends as 1\nst\n friend receives the ball for the second time.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 50",
        "temas": [
            "Array",
            "Hash Table",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2717,
        "slug": "semi-ordered-permutation",
        "url": "https://leetcode.com/problems/semi-ordered-permutation/",
        "titulo": "Semi-Ordered Permutation",
        "enunciado": "You are given a \n0-indexed\n permutation of \nn\n integers \nnums\n.\n\n\nA permutation is called \nsemi-ordered\n if the first number equals \n1\n and the last number equals \nn\n. You can perform the below operation as many times as you want until you make \nnums\n a \nsemi-ordered\n permutation:\n\n\n\n\nPick two adjacent elements in \nnums\n, then swap them.\n\n\n\n\nReturn \nthe minimum number of operations to make \nnums\n a \nsemi-ordered permutation\n.\n\n\nA \npermutation\n is a sequence of integers from \n1\n to \nn\n of length \nn\n containing each number exactly once.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,1,4,3]\n\nOutput:\n 2\n\nExplanation:\n We can make the permutation semi-ordered using these sequence of operations: \n1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,4,1,3]\n\nOutput:\n 3\n\nExplanation:\n We can make the permutation semi-ordered using these sequence of operations:\n1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].\n2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,4,2,5]\n\nOutput:\n 0\n\nExplanation:\n The permutation is already a semi-ordered permutation.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length == n <= 50\n\n\n1 <= nums[i] <= 50\n\n\nnums is a permutation.",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2670,
        "slug": "find-the-distinct-difference-array",
        "url": "https://leetcode.com/problems/find-the-distinct-difference-array/",
        "titulo": "Find the Distinct Difference Array",
        "enunciado": "You are given a \n0-indexed\n array \nnums\n of length \nn\n.\n\n\nThe \ndistinct difference\n array of \nnums\n is an array \ndiff\n of length \nn\n such that \ndiff[i]\n is equal to the number of distinct elements in the suffix \nnums[i + 1, ..., n - 1]\n \nsubtracted from\n the number of distinct elements in the prefix \nnums[0, ..., i]\n.\n\n\nReturn \nthe \ndistinct difference\n array of \nnums\n.\n\n\nNote that \nnums[i, ..., j]\n denotes the subarray of \nnums\n starting at index \ni\n and ending at index \nj\n inclusive. Particularly, if \ni > j\n then \nnums[i, ..., j]\n denotes an empty subarray.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n [-3,-1,1,3,5]\n\nExplanation:\n For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,3,4,2]\n\nOutput:\n [-2,-1,0,2,3]\n\nExplanation:\n For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 50\n\n\n1 <= nums[i] <= 50",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2656,
        "slug": "maximum-sum-with-exactly-k-elements",
        "url": "https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/",
        "titulo": "Maximum Sum With Exactly K Elements ",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n and an integer \nk\n. Your task is to perform the following operation \nexactly\n \nk\n times in order to maximize your score:\n\n\n\n\nSelect an element \nm\n from \nnums\n.\n\n\nRemove the selected element \nm\n from the array.\n\n\nAdd a new element with a value of \nm + 1\n to the array.\n\n\nIncrease your score by \nm\n.\n\n\n\n\nReturn \nthe maximum score you can achieve after performing the operation exactly\n \nk\n \ntimes.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5], k = 3\n\nOutput:\n 18\n\nExplanation:\n We need to choose exactly 3 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]\nFor the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]\nSo, we will return 18.\nIt can be proven, that 18 is the maximum answer that we can achieve.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,5,5], k = 2\n\nOutput:\n 11\n\nExplanation:\n We need to choose exactly 2 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]\nSo, we will return 11.\nIt can be proven, that 11 is the maximum answer that we can achieve.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100\n\n\n1 <= k <= 100",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2706,
        "slug": "buy-two-chocolates",
        "url": "https://leetcode.com/problems/buy-two-chocolates/",
        "titulo": "Buy Two Chocolates",
        "enunciado": "You are given an integer array \nprices\n representing the prices of various chocolates in a store. You are also given a single integer \nmoney\n, which represents your initial amount of money.\n\n\nYou must buy \nexactly\n two chocolates in such a way that you still have some \nnon-negative\n leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.\n\n\nReturn \nthe amount of money you will have leftover after buying the two chocolates\n. If there is no way for you to buy two chocolates without ending up in debt, return \nmoney\n. Note that the leftover must be non-negative.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [1,2,2], money = 3\n\nOutput:\n 0\n\nExplanation:\n Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [3,2,3], money = 3\n\nOutput:\n 3\n\nExplanation:\n You cannot buy 2 chocolates without going in debt, so we return 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= prices.length <= 50\n\n\n1 <= prices[i] <= 100\n\n\n1 <= money <= 100",
        "temas": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2652,
        "slug": "sum-multiples",
        "url": "https://leetcode.com/problems/sum-multiples/",
        "titulo": "Sum Multiples",
        "enunciado": "Given a positive integer \nn\n, find the sum of all integers in the range \n[1, n]\n \ninclusive\n that are divisible by \n3\n, \n5\n, or \n7\n.\n\n\nReturn \nan integer denoting the sum of all numbers in the given range satisfying the constraint.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 7\n\nOutput:\n 21\n\nExplanation:\n Numbers in the range \n[1, 7]\n that are divisible by \n3\n, \n5,\n or \n7 \nare \n3, 5, 6, 7\n. The sum of these numbers is \n21\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 10\n\nOutput:\n 40\n\nExplanation:\n Numbers in the range \n[1, 10] that are\n divisible by \n3\n, \n5,\n or \n7\n are \n3, 5, 6, 7, 9, 10\n. The sum of these numbers is 40.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 9\n\nOutput:\n 30\n\nExplanation:\n Numbers in the range \n[1, 9]\n that are divisible by \n3\n, \n5\n, or \n7\n are \n3, 5, 6, 7, 9\n. The sum of these numbers is \n30\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n3",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2651,
        "slug": "calculate-delayed-arrival-time",
        "url": "https://leetcode.com/problems/calculate-delayed-arrival-time/",
        "titulo": "Calculate Delayed Arrival Time",
        "enunciado": "You are given a positive integer \narrivalTime\n denoting the arrival time of a train in hours, and another positive integer \ndelayedTime\n denoting the amount of delay in hours.\n\n\nReturn \nthe time when the train will arrive at the station.\n\n\nNote that the time in this problem is in 24-hours format.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arrivalTime = 15, delayedTime = 5 \n\nOutput:\n 20 \n\nExplanation:\n Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours).\n\n\n\nExample 2:\n\n\n\n\nInput:\n arrivalTime = 13, delayedTime = 11\n\nOutput:\n 0\n\nExplanation:\n Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arrivaltime < 24\n\n\n1 <= delayedTime <= 24",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2643,
        "slug": "row-with-maximum-ones",
        "url": "https://leetcode.com/problems/row-with-maximum-ones/",
        "titulo": "Row With Maximum Ones",
        "enunciado": "Given a \nm x n\n binary matrix \nmat\n, find the \n0-indexed\n position of the row that contains the \nmaximum\n count of \nones,\n and the number of ones in that row.\n\n\nIn case there are multiple rows that have the maximum count of ones, the row with the \nsmallest row number\n should be selected.\n\n\nReturn\n an array containing the index of the row, and the number of ones in it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n mat = [[0,1],[1,0]]\n\nOutput:\n [0,1]\n\nExplanation:\n Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1\n)\n. So, the answer is [0,1]. \n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,1]]\n\nOutput:\n [1,2]\n\nExplanation:\n The row indexed 1 has the maximum count of ones \n(2)\n. So we return its index, \n1\n, and the count. So, the answer is [1,2].\n\n\n\nExample 3:\n\n\n\n\nInput:\n mat = [[0,0],[1,1],[0,0]]\n\nOutput:\n [1,2]\n\nExplanation:\n The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n \n\n\nn == mat[i].length\n \n\n\n1 <= m, n <= 100\n \n\n\nmat[i][j]\n is either \n0\n or \n1\n.",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2678,
        "slug": "number-of-senior-citizens",
        "url": "https://leetcode.com/problems/number-of-senior-citizens/",
        "titulo": "Number of Senior Citizens",
        "enunciado": "You are given a \n0-indexed\n array of strings \ndetails\n. Each element of \ndetails\n provides information about a given passenger compressed into a string of length \n15\n. The system is such that:\n\n\n\n\nThe first ten characters consist of the phone number of passengers.\n\n\nThe next character denotes the gender of the person.\n\n\nThe following two characters are used to indicate the age of the person.\n\n\nThe last two characters determine the seat allotted to that person.\n\n\n\n\nReturn \nthe number of passengers who are \nstrictly \nmore than 60 years old\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\n\nOutput:\n 2\n\nExplanation:\n The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.\n\n\n\nExample 2:\n\n\n\n\nInput:\n details = [\"1313579440F2036\",\"2921522980M5644\"]\n\nOutput:\n 0\n\nExplanation:\n None of the passengers are older than 60.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= details.length <= 100\n\n\ndetails[i].length == 15\n\n\ndetails[i] consists of digits from '0' to '9'.\n\n\ndetails[i][10] is either 'M' or 'F' or 'O'.\n\n\nThe phone numbers and seat numbers of the passengers are distinct.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2609,
        "slug": "find-the-longest-balanced-substring-of-a-binary-string",
        "url": "https://leetcode.com/problems/find-the-longest-balanced-substring-of-a-binary-string/",
        "titulo": "Find the Longest Balanced Substring of a Binary String",
        "enunciado": "You are given a binary string \ns\n consisting only of zeroes and ones.\n\n\nA substring of \ns\n is considered balanced if\n all zeroes are before ones\n and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.\n\n\nReturn \nthe length of the longest balanced substring of \ns\n.\n\n\nA \nsubstring\n is a contiguous sequence of characters within a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"01000111\"\n\nOutput:\n 6\n\nExplanation:\n The longest balanced substring is \"000111\", which has length 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"00111\"\n\nOutput:\n 4\n\nExplanation:\n The longest balanced substring is \"0011\", which has length 4. \n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"111\"\n\nOutput:\n 0\n\nExplanation:\n There is no balanced substring except the empty substring, so the answer is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 50\n\n\n'0' <= s[i] <= '1'",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2614,
        "slug": "prime-in-diagonal",
        "url": "https://leetcode.com/problems/prime-in-diagonal/",
        "titulo": "Prime In Diagonal",
        "enunciado": "You are given a 0-indexed two-dimensional integer array \nnums\n.\n\n\nReturn \nthe largest \nprime\n number that lies on at least one of the \ndiagonals\n of \nnums\n. In case, no prime is present on any of the diagonals, return\n 0.\n\n\nNote that:\n\n\n\n\nAn integer is \nprime\n if it is greater than \n1\n and has no positive integer divisors other than \n1\n and itself.\n\n\nAn integer \nval\n is on one of the \ndiagonals\n of \nnums\n if there exists an integer \ni\n for which \nnums[i][i] = val\n or an \ni\n for which \nnums[i][nums.length - i - 1] = val\n.\n\n\n\n\n\n\nIn the above diagram, one diagonal is \n[1,5,9]\n and another diagonal is\n [3,5,7]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [[1,2,3],[5,6,7],[9,10,11]]\n\nOutput:\n 11\n\nExplanation:\n The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [[1,2,3],[5,17,7],[9,11,10]]\n\nOutput:\n 17\n\nExplanation:\n The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 300\n\n\nnums.length == nums\ni\n.length\n\n\n1 <= nums\n[i][j]\n <= 4*10\n6",
        "temas": [
            "Array",
            "Math",
            "Matrix",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2600,
        "slug": "k-items-with-the-maximum-sum",
        "url": "https://leetcode.com/problems/k-items-with-the-maximum-sum/",
        "titulo": "K Items With the Maximum Sum",
        "enunciado": "There is a bag that consists of items, each item has a number \n1\n, \n0\n, or \n-1\n written on it.\n\n\nYou are given four \nnon-negative \nintegers \nnumOnes\n, \nnumZeros\n, \nnumNegOnes\n, and \nk\n.\n\n\nThe bag initially contains:\n\n\n\n\nnumOnes\n items with \n1\ns written on them.\n\n\nnumZeroes\n items with \n0\ns written on them.\n\n\nnumNegOnes\n items with \n-1\ns written on them.\n\n\n\n\nWe want to pick exactly \nk\n items among the available items. Return \nthe \nmaximum\n possible sum of numbers written on the items\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n\nOutput:\n 2\n\nExplanation:\n We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.\nIt can be proven that 2 is the maximum possible sum.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n\nOutput:\n 3\n\nExplanation:\n We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.\nIt can be proven that 3 is the maximum possible sum.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= numOnes, numZeros, numNegOnes <= 50\n\n\n0 <= k <= numOnes + numZeros + numNegOnes",
        "temas": [
            "Math",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2574,
        "slug": "left-and-right-sum-differences",
        "url": "https://leetcode.com/problems/left-and-right-sum-differences/",
        "titulo": "Left and Right Sum Differences",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n of size \nn\n.\n\n\nDefine two arrays \nleftSum\n and \nrightSum\n where:\n\n\n\n\nleftSum[i]\n is the sum of elements to the left of the index \ni\n in the array \nnums\n. If there is no such element, \nleftSum[i] = 0\n.\n\n\nrightSum[i]\n is the sum of elements to the right of the index \ni\n in the array \nnums\n. If there is no such element, \nrightSum[i] = 0\n.\n\n\n\n\nReturn an integer array \nanswer\n of size \nn\n where \nanswer[i] = |leftSum[i] - rightSum[i]|\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [10,4,8,3]\n\nOutput:\n [15,1,11,22]\n\nExplanation:\n The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].\nThe array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n [0]\n\nExplanation:\n The array leftSum is [0] and the array rightSum is [0].\nThe array answer is [|0 - 0|] = [0].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 10\n5",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2570,
        "slug": "merge-two-2d-arrays-by-summing-values",
        "url": "https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/",
        "titulo": "Merge Two 2D Arrays by Summing Values",
        "enunciado": "You are given two \n2D\n integer arrays \nnums1\n and \nnums2.\n\n\n\n\nnums1[i] = [id\ni\n, val\ni\n]\n indicate that the number with the id \nid\ni\n has a value equal to \nval\ni\n.\n\n\nnums2[i] = [id\ni\n, val\ni\n]\n indicate that the number with the id \nid\ni\n has a value equal to \nval\ni\n.\n\n\n\n\nEach array contains \nunique\n ids and is sorted in \nascending\n order by id.\n\n\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\n\n\n\nOnly ids that appear in at least one of the two arrays should be included in the resulting array.\n\n\nEach id should be included \nonly once\n and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays, then assume its value in that array to be \n0\n.\n\n\n\n\nReturn \nthe resulting array\n. The returned array must be sorted in ascending order by id.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\n\nOutput:\n [[1,6],[2,3],[3,2],[4,6]]\n\nExplanation:\n The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\n\nOutput:\n [[1,3],[2,4],[3,6],[4,3],[5,5]]\n\nExplanation:\n There are no common ids, so we just include each id with its value in the resulting list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 200\n\n\nnums1[i].length == nums2[j].length == 2\n\n\n1 <= id\ni\n, val\ni\n <= 1000\n\n\nBoth arrays contain unique ids.\n\n\nBoth arrays are in strictly ascending order by id.",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2566,
        "slug": "maximum-difference-by-remapping-a-digit",
        "url": "https://leetcode.com/problems/maximum-difference-by-remapping-a-digit/",
        "titulo": "Maximum Difference by Remapping a Digit",
        "enunciado": "You are given an integer \nnum\n. You know that Bob will sneakily \nremap\n one of the \n10\n possible digits (\n0\n to \n9\n) to another digit.\n\n\nReturn \nthe difference between the maximum and minimum values Bob can make by remapping \nexactly\n \none\n digit in \nnum\n.\n\n\nNotes:\n\n\n\n\nWhen Bob remaps a digit \nd1\n to another digit \nd2\n, Bob replaces all occurrences of \nd1\n in \nnum\n with \nd2\n.\n\n\nBob can remap a digit to itself, in which case \nnum\n does not change.\n\n\nBob can remap different digits for obtaining minimum and maximum values respectively.\n\n\nThe resulting number after remapping can contain leading zeroes.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 11891\n\nOutput:\n 99009\n\nExplanation:\n \nTo achieve the maximum value, Bob can remap the digit 1 to the digit 9 to yield 99899.\nTo achieve the minimum value, Bob can remap the digit 1 to the digit 0, yielding 890.\nThe difference between these two numbers is 99009.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 90\n\nOutput:\n 99\n\nExplanation:\n\nThe maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).\nThus, we return 99.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 10\n8",
        "temas": [
            "Math",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2562,
        "slug": "find-the-array-concatenation-value",
        "url": "https://leetcode.com/problems/find-the-array-concatenation-value/",
        "titulo": "Find the Array Concatenation Value",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n.\n\n\nThe \nconcatenation\n of two numbers is the number formed by concatenating their numerals.\n\n\n\n\nFor example, the concatenation of \n15\n, \n49\n is \n1549\n.\n\n\n\n\nThe \nconcatenation value\n of \nnums\n is initially equal to \n0\n. Perform this operation until \nnums\n becomes empty:\n\n\n\n\nIf \nnums\n has a size greater than one, add the value of the concatenation of the first and the last element to the \nconcatenation value\n of \nnums\n, and remove those two elements from \nnums\n. For example, if the \nnums\n was \n[1, 2, 4, 5, 6]\n, add 16 to the \nconcatenation value\n.\n\n\nIf only one element exists in \nnums\n, add its value to the \nconcatenation value\n of \nnums\n, then remove it.\n\n\n\n\nReturn\n the concatenation value of \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [7,52,2,4]\n\nOutput:\n 596\n\nExplanation:\n Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,14,13,8,12]\n\nOutput:\n 673\n\nExplanation:\n Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Two Pointers",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2644,
        "slug": "find-the-maximum-divisibility-score",
        "url": "https://leetcode.com/problems/find-the-maximum-divisibility-score/",
        "titulo": "Find the Maximum Divisibility Score",
        "enunciado": "You are given two integer arrays \nnums\n and \ndivisors\n.\n\n\nThe \ndivisibility score\n of \ndivisors[i]\n is the number of indices \nj\n such that \nnums[j]\n is divisible by \ndivisors[i]\n.\n\n\nReturn the integer \ndivisors[i]\n with the \nmaximum\n divisibility score. If multiple integers have the maximum score, return the smallest one.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,9,15,50], divisors = [5,3,7,2]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe divisibility score of \ndivisors[0]\n is 2 since \nnums[2]\n and \nnums[3]\n are divisible by 5.\n\n\nThe divisibility score of \ndivisors[1]\n is 2 since \nnums[1]\n and \nnums[2]\n are divisible by 3.\n\n\nThe divisibility score of \ndivisors[2]\n is 0 since none of the numbers in \nnums\n is divisible by 7.\n\n\nThe divisibility score of \ndivisors[3]\n is 2 since \nnums[0]\n and \nnums[3]\n are divisible by 2.\n\n\nAs \ndivisors[0]\n, \ndivisors[1]\n, and \ndivisors[3]\n have the same divisibility score, we return the smaller one which is \ndivisors[3]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,7,9,3,9], divisors = [5,2,3]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe divisibility score of \ndivisors[0]\n is 0 since none of numbers in \nnums\n is divisible by 5.\n\n\nThe divisibility score of \ndivisors[1]\n is 1 since only \nnums[0]\n is divisible by 2.\n\n\nThe divisibility score of \ndivisors[2]\n is 3 since \nnums[2]\n, \nnums[3]\n and \nnums[4]\n are divisible by 3.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [20,14,21,10], divisors = [10,16,20]\n\n\nOutput:\n \n10\n\n\nExplanation:\n\n\nThe divisibility score of \ndivisors[0]\n is 2 since \nnums[0]\n and \nnums[3]\n are divisible by 10.\n\n\nThe divisibility score of \ndivisors[1]\n is 0 since none of the numbers in \nnums\n is divisible by 16.\n\n\nThe divisibility score of \ndivisors[2]\n is 1 since \nnums[0]\n is divisible by 20.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length, divisors.length <= 1000\n\n\n1 <= nums[i], divisors[i] <= 10\n9",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2558,
        "slug": "take-gifts-from-the-richest-pile",
        "url": "https://leetcode.com/problems/take-gifts-from-the-richest-pile/",
        "titulo": "Take Gifts From the Richest Pile",
        "enunciado": "You are given an integer array \ngifts\n denoting the number of gifts in various piles. Every second, you do the following:\n\n\n\n\nChoose the pile with the maximum number of gifts.\n\n\nIf there is more than one pile with the maximum number of gifts, choose any.\n\n\nReduce the number of gifts in the pile to the floor of the square root of the original number of gifts in the pile.\n\n\n\n\nReturn \nthe number of gifts remaining after \nk\n seconds.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n gifts = [25,64,9,4,100], k = 4\n\nOutput:\n 29\n\nExplanation:\n \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.\n\n\n\nExample 2:\n\n\n\n\nInput:\n gifts = [1,1,1,1], k = 4\n\nOutput:\n 4\n\nExplanation:\n \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= gifts.length <= 10\n3\n\n\n1 <= gifts[i] <= 10\n9\n\n\n1 <= k <= 10\n3",
        "temas": [
            "Array",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2660,
        "slug": "determine-the-winner-of-a-bowling-game",
        "url": "https://leetcode.com/problems/determine-the-winner-of-a-bowling-game/",
        "titulo": "Determine the Winner of a Bowling Game",
        "enunciado": "You are given two \n0-indexed\n integer arrays \nplayer1\n and \nplayer2\n, representing the number of pins that player 1 and player 2 hit in a bowling game, respectively.\n\n\nThe bowling game consists of \nn\n turns, and the number of pins in each turn is exactly 10.\n\n\nAssume a player hits \nx\ni\n pins in the i\nth\n turn. The value of the i\nth\n turn for the player is:\n\n\n\n\n2x\ni\n if the player hits 10 pins \nin either (i - 1)\nth\n or (i - 2)\nth\n turn\n.\n\n\nOtherwise, it is \nx\ni\n.\n\n\n\n\nThe \nscore\n of the player is the sum of the values of their \nn\n turns.\n\n\nReturn\n\n\n\n\n1 if the score of player 1 is more than the score of player 2,\n\n\n2 if the score of player 2 is more than the score of player 1, and\n\n\n0 in case of a draw.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nplayer1 = [5,10,3,2], player2 = [6,5,7,3]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe score of player 1 is 5 + 10 + 2*3 + 2*2 = 25.\n\n\nThe score of player 2 is 6 + 5 + 7 + 3 = 21.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nplayer1 = [3,5,7,6], player2 = [8,10,10,2]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe score of player 1 is 3 + 5 + 7 + 6 = 21.\n\n\nThe score of player 2 is 8 + 10 + 2*10 + 2*2 = 42.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nplayer1 = [2,3], player2 = [4,1]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe score of player1 is 2 + 3 = 5.\n\n\nThe score of player2 is 4 + 1 = 5.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nplayer1 = [1,1,1,10,10,10,10], player2 = [10,10,10,10,1,1,1]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe score of player1 is 1 + 1 + 1 + 10 + 2*10 + 2*10 + 2*10 = 73.\n\n\nThe score of player2 is 10 + 2*10 + 2*10 + 2*10 + 2*1 + 2*1 + 1 = 75.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == player1.length == player2.length\n\n\n1 <= n <= 1000\n\n\n0 <= player1[i], player2[i] <= 10",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2549,
        "slug": "count-distinct-numbers-on-board",
        "url": "https://leetcode.com/problems/count-distinct-numbers-on-board/",
        "titulo": "Count Distinct Numbers on Board",
        "enunciado": "You are given a positive integer \nn\n, that is initially placed on a board. Every day, for \n10\n9\n days, you perform the following procedure:\n\n\n\n\nFor each number \nx\n present on the board, find all numbers \n1 <= i <= n\n such that \nx % i == 1\n.\n\n\nThen, place those numbers on the board.\n\n\n\n\nReturn\n the number of \ndistinct\n integers present on the board after\n \n10\n9\n \ndays have elapsed\n.\n\n\nNote:\n\n\n\n\nOnce a number is placed on the board, it will remain on it until the end.\n\n\n%\n stands for the modulo operation. For example, \n14 % 3\n is \n2\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 4\n\nExplanation:\n Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2639,
        "slug": "find-the-width-of-columns-of-a-grid",
        "url": "https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/",
        "titulo": "Find the Width of Columns of a Grid",
        "enunciado": "You are given a \n0-indexed\n \nm x n\n integer matrix \ngrid\n. The width of a column is the maximum \nlength \nof its integers.\n\n\n\n\nFor example, if \ngrid = [[-10], [3], [12]]\n, the width of the only column is \n3\n since \n-10\n is of length \n3\n.\n\n\n\n\nReturn \nan integer array\n \nans\n \nof size\n \nn\n \nwhere\n \nans[i]\n \nis the width of the\n \ni\nth\n \ncolumn\n.\n\n\nThe \nlength\n of an integer \nx\n with \nlen\n digits is equal to \nlen\n if \nx\n is non-negative, and \nlen + 1\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[1],[22],[333]]\n\nOutput:\n [3]\n\nExplanation:\n In the 0\nth\n column, 333 is of length 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[-15,1,3],[15,7,12],[5,6,-2]]\n\nOutput:\n [3,1,2]\n\nExplanation:\n \nIn the 0\nth\n column, only -15 is of length 3.\nIn the 1\nst\n column, all integers are of length 1. \nIn the 2\nnd\n column, both 12 and -2 are of length 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 100 \n\n\n-10\n9\n <= grid[r][c] <= 10\n9",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2605,
        "slug": "form-smallest-number-from-two-digit-arrays",
        "url": "https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/",
        "titulo": "Form Smallest Number From Two Digit Arrays",
        "enunciado": "Given two arrays of \nunique\n digits \nnums1\n and \nnums2\n, return \nthe \nsmallest\n number that contains \nat least\n one digit from each array\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,3], nums2 = [5,7]\n\nOutput:\n 15\n\nExplanation:\n The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [3,5,2,6], nums2 = [3,1,7]\n\nOutput:\n 3\n\nExplanation:\n The number 3 contains the digit 3 which exists in both arrays.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 9\n\n\n1 <= nums1[i], nums2[i] <= 9\n\n\nAll digits in each array are \nunique\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2591,
        "slug": "distribute-money-to-maximum-children",
        "url": "https://leetcode.com/problems/distribute-money-to-maximum-children/",
        "titulo": "Distribute Money to Maximum Children",
        "enunciado": "You are given an integer \nmoney\n denoting the amount of money (in dollars) that you have and another integer \nchildren\n denoting the number of children that you must distribute the money to.\n\n\nYou have to distribute the money according to the following rules:\n\n\n\n\nAll money must be distributed.\n\n\nEveryone must receive at least \n1\n dollar.\n\n\nNobody receives \n4\n dollars.\n\n\n\n\nReturn \nthe \nmaximum\n number of children who may receive \nexactly\n \n8\n \ndollars if you distribute the money according to the aforementioned rules\n. If there is no way to distribute the money, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n money = 20, children = 3\n\nOutput:\n 1\n\nExplanation:\n \nThe maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:\n- 8 dollars to the first child.\n- 9 dollars to the second child. \n- 3 dollars to the third child.\nIt can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n money = 16, children = 2\n\nOutput:\n 2\n\nExplanation:\n Each child can be given 8 dollars.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= money <= 200\n\n\n2 <= children <= 30",
        "temas": [
            "Math",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2595,
        "slug": "number-of-even-and-odd-bits",
        "url": "https://leetcode.com/problems/number-of-even-and-odd-bits/",
        "titulo": "Number of Even and Odd Bits",
        "enunciado": "You are given a \npositive\n integer \nn\n.\n\n\nLet \neven\n denote the number of even indices in the binary representation of \nn\n with value 1.\n\n\nLet \nodd\n denote the number of odd indices in the binary representation of \nn\n with value 1.\n\n\nNote that bits are indexed from \nright to left\n in the binary representation of a number.\n\n\nReturn the array \n[even, odd]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 50\n\n\nOutput:\n \n[1,2]\n\n\nExplanation:\n\n\nThe binary representation of 50 is \n110010\n.\n\n\nIt contains 1 on indices 1, 4, and 5.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 2\n\n\nOutput:\n \n[0,1]\n\n\nExplanation:\n\n\nThe binary representation of 2 is \n10\n.\n\n\nIt contains 1 only on index 1.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 2586,
        "slug": "count-the-number-of-vowel-strings-in-range",
        "url": "https://leetcode.com/problems/count-the-number-of-vowel-strings-in-range/",
        "titulo": "Count the Number of Vowel Strings in Range",
        "enunciado": "You are given a \n0-indexed\n array of string \nwords\n and two integers \nleft\n and \nright\n.\n\n\nA string is called a \nvowel string\n if it starts with a vowel character and ends with a vowel character where vowel characters are \n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, and \n'u'\n.\n\n\nReturn \nthe number of vowel strings \nwords[i]\n where \ni\n belongs to the inclusive range \n[left, right]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"are\",\"amy\",\"u\"], left = 0, right = 2\n\nOutput:\n 2\n\nExplanation:\n \n- \"are\" is a vowel string because it starts with 'a' and ends with 'e'.\n- \"amy\" is not a vowel string because it does not end with a vowel.\n- \"u\" is a vowel string because it starts with 'u' and ends with 'u'.\nThe number of vowel strings in the mentioned range is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4\n\nOutput:\n 3\n\nExplanation:\n \n- \"aeo\" is a vowel string because it starts with 'a' and ends with 'o'.\n- \"mu\" is not a vowel string because it does not start with a vowel.\n- \"ooo\" is a vowel string because it starts with 'o' and ends with 'o'.\n- \"artro\" is a vowel string because it starts with 'a' and ends with 'o'.\nThe number of vowel strings in the mentioned range is 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 1000\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of only lowercase English letters.\n\n\n0 <= left <= right < words.length",
        "temas": [
            "Array",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2578,
        "slug": "split-with-minimum-sum",
        "url": "https://leetcode.com/problems/split-with-minimum-sum/",
        "titulo": "Split With Minimum Sum",
        "enunciado": "Given a positive integer \nnum\n, split it into two non-negative integers \nnum1\n and \nnum2\n such that:\n\n\n\n\nThe concatenation of \nnum1\n and \nnum2\n is a permutation of \nnum\n.\n\n\t\n\n\nIn other words, the sum of the number of occurrences of each digit in \nnum1\n and \nnum2\n is equal to the number of occurrences of that digit in \nnum\n.\n\n\n\n\n\n\nnum1\n and \nnum2\n can contain leading zeros.\n\n\n\n\nReturn \nthe \nminimum\n possible sum of\n \nnum1\n \nand\n \nnum2\n.\n\n\nNotes:\n\n\n\n\nIt is guaranteed that \nnum\n does not contain any leading zeros.\n\n\nThe order of occurrence of the digits in \nnum1\n and \nnum2\n may differ from the order of occurrence of \nnum\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 4325\n\nOutput:\n 59\n\nExplanation:\n We can split 4325 so that \nnum1\n is 24 and \nnum2\n is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 687\n\nOutput:\n 75\n\nExplanation:\n We can split 687 so that \nnum1\n is 68 and \nnum2\n is 7, which would give an optimal sum of 75.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n10 <= num <= 10\n9",
        "temas": [
            "Math",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2582,
        "slug": "pass-the-pillow",
        "url": "https://leetcode.com/problems/pass-the-pillow/",
        "titulo": "Pass the Pillow",
        "enunciado": "There are \nn\n people standing in a line labeled from \n1\n to \nn\n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\n\n\n\nFor example, once the pillow reaches the \nn\nth\n person they pass it to the \nn - 1\nth\n person, then to the \nn - 2\nth\n person and so on.\n\n\n\n\nGiven the two positive integers \nn\n and \ntime\n, return \nthe index of the person holding the pillow after \ntime\n seconds\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4, time = 5\n\nOutput:\n 2\n\nExplanation:\n People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfter five seconds, the 2\nnd\n person is holding the pillow.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, time = 2\n\nOutput:\n 3\n\nExplanation:\n People pass the pillow in the following way: 1 -> 2 -> 3.\nAfter two seconds, the 3\nr\nd\n person is holding the pillow.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 1000\n\n\n1 <= time <= 1000\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 3178: Find the Child Who Has the Ball After K Seconds.",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2553,
        "slug": "separate-the-digits-in-an-array",
        "url": "https://leetcode.com/problems/separate-the-digits-in-an-array/",
        "titulo": "Separate the Digits in an Array",
        "enunciado": "Given an array of positive integers \nnums\n, return \nan array \nanswer\n that consists of the digits of each integer in \nnums\n after separating them in \nthe same order\n they appear in \nnums\n.\n\n\nTo separate the digits of an integer is to get all the digits it has in the same order.\n\n\n\n\nFor example, for the integer \n10921\n, the separation of its digits is \n[1,0,9,2,1]\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [13,25,83,77]\n\nOutput:\n [1,3,2,5,8,3,7,7]\n\nExplanation:\n \n- The separation of 13 is [1,3].\n- The separation of 25 is [2,5].\n- The separation of 83 is [8,3].\n- The separation of 77 is [7,7].\nanswer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [7,1,3,9]\n\nOutput:\n [7,1,3,9]\n\nExplanation:\n The separation of each integer in nums is itself.\nanswer = [7,1,3,9].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 10\n5",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2540,
        "slug": "minimum-common-value",
        "url": "https://leetcode.com/problems/minimum-common-value/",
        "titulo": "Minimum Common Value",
        "enunciado": "Given two integer arrays \nnums1\n and \nnums2\n, sorted in non-decreasing order, return \nthe \nminimum integer common\n to both arrays\n. If there is no common integer amongst \nnums1\n and \nnums2\n, return \n-1\n.\n\n\nNote that an integer is said to be \ncommon\n to \nnums1\n and \nnums2\n if both arrays have \nat least one\n occurrence of that integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3], nums2 = [2,4]\n\nOutput:\n 2\n\nExplanation:\n The smallest element common to both arrays is 2, so we return 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2,3,6], nums2 = [2,3,4,5]\n\nOutput:\n 2\n\nExplanation:\n There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 10\n5\n\n\n1 <= nums1[i], nums2[j] <= 10\n9\n\n\nBoth \nnums1\n and \nnums2\n are sorted in \nnon-decreasing\n order.",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2544,
        "slug": "alternating-digit-sum",
        "url": "https://leetcode.com/problems/alternating-digit-sum/",
        "titulo": "Alternating Digit Sum",
        "enunciado": "You are given a positive integer \nn\n. Each digit of \nn\n has a sign according to the following rules:\n\n\n\n\nThe \nmost significant digit\n is assigned a \npositive\n sign.\n\n\nEach other digit has an opposite sign to its adjacent digits.\n\n\n\n\nReturn \nthe sum of all digits with their corresponding sign\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 521\n\nOutput:\n 4\n\nExplanation:\n (+5) + (-2) + (+1) = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 111\n\nOutput:\n 1\n\nExplanation:\n (+1) + (-1) + (+1) = 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 886996\n\nOutput:\n 0\n\nExplanation:\n (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n9",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2535,
        "slug": "difference-between-element-sum-and-digit-sum-of-an-array",
        "url": "https://leetcode.com/problems/difference-between-element-sum-and-digit-sum-of-an-array/",
        "titulo": "Difference Between Element Sum and Digit Sum of an Array",
        "enunciado": "You are given a positive integer array \nnums\n.\n\n\n\n\nThe \nelement sum\n is the sum of all the elements in \nnums\n.\n\n\nThe \ndigit sum\n is the sum of all the digits (not necessarily distinct) that appear in \nnums\n.\n\n\n\n\nReturn \nthe \nabsolute\n difference between the \nelement sum\n and \ndigit sum\n of \nnums\n.\n\n\nNote\n that the absolute difference between two integers \nx\n and \ny\n is defined as \n|x - y|\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,15,6,3]\n\nOutput:\n 9\n\nExplanation:\n \nThe element sum of nums is 1 + 15 + 6 + 3 = 25.\nThe digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\nThe absolute difference between the element sum and digit sum is |25 - 16| = 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n 0\n\nExplanation:\n\nThe element sum of nums is 1 + 2 + 3 + 4 = 10.\nThe digit sum of nums is 1 + 2 + 3 + 4 = 10.\nThe absolute difference between the element sum and digit sum is |10 - 10| = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2000\n\n\n1 <= nums[i] <= 2000",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2525,
        "slug": "categorize-box-according-to-criteria",
        "url": "https://leetcode.com/problems/categorize-box-according-to-criteria/",
        "titulo": "Categorize Box According to Criteria",
        "enunciado": "Given four integers \nlength\n, \nwidth\n, \nheight\n, and \nmass\n, representing the dimensions and mass of a box, respectively, return \na string representing the \ncategory\n of the box\n.\n\n\n\n\nThe box is \n\"Bulky\"\n if:\n\n\t\n\n\nAny\n of the dimensions of the box is greater or equal to \n10\n4\n.\n\n\nOr, the \nvolume\n of the box is greater or equal to \n10\n9\n.\n\n\n\n\n\n\nIf the mass of the box is greater or equal to \n100\n, it is \n\"Heavy\".\n\n\nIf the box is both \n\"Bulky\"\n and \n\"Heavy\"\n, then its category is \n\"Both\"\n.\n\n\nIf the box is neither \n\"Bulky\"\n nor \n\"Heavy\"\n, then its category is \n\"Neither\"\n.\n\n\nIf the box is \n\"Bulky\"\n but not \n\"Heavy\"\n, then its category is \n\"Bulky\"\n.\n\n\nIf the box is \n\"Heavy\"\n but not \n\"Bulky\"\n, then its category is \n\"Heavy\"\n.\n\n\n\n\nNote\n that the volume of the box is the product of its length, width and height.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n length = 1000, width = 35, height = 700, mass = 300\n\nOutput:\n \"Heavy\"\n\nExplanation:\n \nNone of the dimensions of the box is greater or equal to 10\n4\n. \nIts volume = 24500000 <= 10\n9\n. So it cannot be categorized as \"Bulky\".\nHowever mass >= 100, so the box is \"Heavy\".\nSince the box is not \"Bulky\" but \"Heavy\", we return \"Heavy\".\n\n\nExample 2:\n\n\n\n\nInput:\n length = 200, width = 50, height = 800, mass = 50\n\nOutput:\n \"Neither\"\n\nExplanation:\n \nNone of the dimensions of the box is greater or equal to 10\n4\n.\nIts volume = 8 * 10\n6\n <= 10\n9\n. So it cannot be categorized as \"Bulky\".\nIts mass is also less than 100, so it cannot be categorized as \"Heavy\" either. \nSince its neither of the two above categories, we return \"Neither\".\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= length, width, height <= 10\n5\n\n\n1 <= mass <= 10\n3",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2529,
        "slug": "maximum-count-of-positive-integer-and-negative-integer",
        "url": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/",
        "titulo": "Maximum Count of Positive Integer and Negative Integer",
        "enunciado": "Given an array \nnums\n sorted in \nnon-decreasing\n order, return \nthe maximum between the number of positive integers and the number of negative integers.\n\n\n\n\nIn other words, if the number of positive integers in \nnums\n is \npos\n and the number of negative integers is \nneg\n, then return the maximum of \npos\n and \nneg\n.\n\n\n\n\nNote\n that \n0\n is neither positive nor negative.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,-1,-1,1,2,3]\n\nOutput:\n 3\n\nExplanation:\n There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-3,-2,-1,0,0,1,2]\n\nOutput:\n 3\n\nExplanation:\n There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,20,66,1314]\n\nOutput:\n 4\n\nExplanation:\n There are 4 positive integers and 0 negative integers. The maximum count among them is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2000\n\n\n-2000 <= nums[i] <= 2000\n\n\nnums\n is sorted in a \nnon-decreasing order\n.\n\n\n\n\n \n\n\nFollow up:\n Can you solve the problem in \nO(log(n))\n time complexity?",
        "temas": [
            "Array",
            "Binary Search",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2520,
        "slug": "count-the-digits-that-divide-a-number",
        "url": "https://leetcode.com/problems/count-the-digits-that-divide-a-number/",
        "titulo": "Count the Digits That Divide a Number",
        "enunciado": "Given an integer \nnum\n, return \nthe number of digits in \nnum\n that divide \nnum\n.\n\n\nAn integer \nval\n divides \nnums\n if \nnums % val == 0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 7\n\nOutput:\n 1\n\nExplanation:\n 7 divides itself, hence the answer is 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 121\n\nOutput:\n 2\n\nExplanation:\n 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = 1248\n\nOutput:\n 4\n\nExplanation:\n 1248 is divisible by all of its digits, hence the answer is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 10\n9\n\n\nnum\n does not contain \n0\n as one of its digits.",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2511,
        "slug": "maximum-enemy-forts-that-can-be-captured",
        "url": "https://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/",
        "titulo": "Maximum Enemy Forts That Can Be Captured",
        "enunciado": "You are given a \n0-indexed\n integer array \nforts\n of length \nn\n representing the positions of several forts. \nforts[i]\n can be \n-1\n, \n0\n, or \n1\n where:\n\n\n\n\n-1\n represents there is \nno fort\n at the \ni\nth\n position.\n\n\n0\n indicates there is an \nenemy\n fort at the \ni\nth\n position.\n\n\n1\n indicates the fort at the \ni\nth\n the position is under your command.\n\n\n\n\nNow you have decided to move your army from one of your forts at position \ni\n to an empty position \nj\n such that:\n\n\n\n\n0 <= i, j <= n - 1\n\n\nThe army travels over enemy forts \nonly\n. Formally, for all \nk\n where \nmin(i,j) < k < max(i,j)\n, \nforts[k] == 0.\n\n\n\n\nWhile moving the army, all the enemy forts that come in the way are \ncaptured\n.\n\n\nReturn\n the \nmaximum\n number of enemy forts that can be captured\n. In case it is \nimpossible\n to move your army, or you do not have any fort under your command, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n forts = [1,0,0,-1,0,0,0,0,1]\n\nOutput:\n 4\n\nExplanation:\n\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n forts = [0,0,1,-1]\n\nOutput:\n 0\n\nExplanation:\n Since no enemy fort can be captured, 0 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= forts.length <= 1000\n\n\n-1 <= forts[i] <= 1",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2515,
        "slug": "shortest-distance-to-target-string-in-a-circular-array",
        "url": "https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/",
        "titulo": "Shortest Distance to Target String in a Circular Array",
        "enunciado": "You are given a \n0-indexed\n \ncircular\n string array \nwords\n and a string \ntarget\n. A \ncircular array\n means that the array's end connects to the array's beginning.\n\n\n\n\nFormally, the next element of \nwords[i]\n is \nwords[(i + 1) % n]\n and the previous element of \nwords[i]\n is \nwords[(i - 1 + n) % n]\n, where \nn\n is the length of \nwords\n.\n\n\n\n\nStarting from \nstartIndex\n, you can move to either the next word or the previous word with \n1\n step at a time.\n\n\nReturn \nthe \nshortest\n distance needed to reach the string\n \ntarget\n. If the string \ntarget\n does not exist in \nwords\n, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\n\nOutput:\n 1\n\nExplanation:\n We start from index 1 and can reach \"hello\" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach \"hello\" is 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\n\nOutput:\n 1\n\nExplanation:\n We start from index 0 and can reach \"leetcode\" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach \"leetcode\" is 1.\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\n\nOutput:\n -1\n\nExplanation:\n Since \"ate\" does not exist in \nwords\n, we return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n and \ntarget\n consist of only lowercase English letters.\n\n\n0 <= startIndex < words.length",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2506,
        "slug": "count-pairs-of-similar-strings",
        "url": "https://leetcode.com/problems/count-pairs-of-similar-strings/",
        "titulo": "Count Pairs Of Similar Strings",
        "enunciado": "You are given a \n0-indexed\n string array \nwords\n.\n\n\nTwo strings are \nsimilar\n if they consist of the same characters.\n\n\n\n\nFor example, \n\"abca\"\n and \n\"cba\"\n are similar since both consist of characters \n'a'\n, \n'b'\n, and \n'c'\n.\n\n\nHowever, \n\"abacba\"\n and \n\"bcfd\"\n are not similar since they do not consist of the same characters.\n\n\n\n\nReturn \nthe number of pairs \n(i, j)\n such that \n0 <= i < j <= word.length - 1\n and the two strings \nwords[i]\n and \nwords[j]\n are similar\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\n\nOutput:\n 2\n\nExplanation:\n There are 2 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'. \n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"aabb\",\"ab\",\"ba\"]\n\nOutput:\n 3\n\nExplanation:\n There are 3 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'.\n- i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"nba\",\"cba\",\"dba\"]\n\nOutput:\n 0\n\nExplanation:\n Since there does not exist any pair that satisfies the conditions, we return 0.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n consist of only lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2496,
        "slug": "maximum-value-of-a-string-in-an-array",
        "url": "https://leetcode.com/problems/maximum-value-of-a-string-in-an-array/",
        "titulo": "Maximum Value of a String in an Array",
        "enunciado": "The \nvalue\n of an alphanumeric string can be defined as:\n\n\n\n\nThe \nnumeric\n representation of the string in base \n10\n, if it comprises of digits \nonly\n.\n\n\nThe \nlength\n of the string, otherwise.\n\n\n\n\nGiven an array \nstrs\n of alphanumeric strings, return \nthe \nmaximum value\n of any string in \nstrs\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\n\nOutput:\n 5\n\nExplanation:\n \n- \"alic3\" consists of both letters and digits, so its value is its length, i.e. 5.\n- \"bob\" consists only of letters, so its value is also its length, i.e. 3.\n- \"3\" consists only of digits, so its value is its numeric equivalent, i.e. 3.\n- \"4\" also consists only of digits, so its value is 4.\n- \"00000\" consists only of digits, so its value is 0.\nHence, the maximum value is 5, of \"alic3\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"1\",\"01\",\"001\",\"0001\"]\n\nOutput:\n 1\n\nExplanation:\n \nEach string in the array has value 1. Hence, we return 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 100\n\n\n1 <= strs[i].length <= 9\n\n\nstrs[i]\n consists of only lowercase English letters and digits.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2500,
        "slug": "delete-greatest-value-in-each-row",
        "url": "https://leetcode.com/problems/delete-greatest-value-in-each-row/",
        "titulo": "Delete Greatest Value in Each Row",
        "enunciado": "You are given an \nm x n\n matrix \ngrid\n consisting of positive integers.\n\n\nPerform the following operation until \ngrid\n becomes empty:\n\n\n\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\n\n\nAdd the maximum of deleted elements to the answer.\n\n\n\n\nNote\n that the number of columns decreases by one after each operation.\n\n\nReturn \nthe answer after performing the operations described above\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2,4],[3,3,1]]\n\nOutput:\n 8\n\nExplanation:\n The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[10]]\n\nOutput:\n 10\n\nExplanation:\n The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n1 <= grid[i][j] <= 100",
        "temas": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2490,
        "slug": "circular-sentence",
        "url": "https://leetcode.com/problems/circular-sentence/",
        "titulo": "Circular Sentence",
        "enunciado": "A \nsentence\n is a list of words that are separated by a\n single\n space with no leading or trailing spaces.\n\n\n\n\nFor example, \n\"Hello World\"\n, \n\"HELLO\"\n, \n\"hello world hello world\"\n are all sentences.\n\n\n\n\nWords consist of \nonly\n uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\n\n\nA sentence is \ncircular \nif:\n\n\n\n\nThe last character of each word in the sentence is equal to the first character of its next word.\n\n\nThe last character of the last word is equal to the first character of the first word.\n\n\n\n\nFor example, \n\"leetcode exercises sound delightful\"\n, \n\"eetcode\"\n, \n\"leetcode eats soul\" \nare all circular sentences. However, \n\"Leetcode is cool\"\n, \n\"happy Leetcode\"\n, \n\"Leetcode\"\n and \n\"I like Leetcode\"\n are \nnot\n circular sentences.\n\n\nGiven a string \nsentence\n, return \ntrue\n if it is circular\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n sentence = \"leetcode exercises sound delightful\"\n\nOutput:\n true\n\nExplanation:\n The words in sentence are [\"leetcode\", \"exercises\", \"sound\", \"delightful\"].\n- leetcod\ne\n's last character is equal to \ne\nxercises's first character.\n- exercise\ns\n's last character is equal to \ns\nound's first character.\n- soun\nd\n's last character is equal to \nd\nelightful's first character.\n- delightfu\nl\n's last character is equal to \nl\neetcode's first character.\nThe sentence is circular.\n\n\nExample 2:\n\n\n\n\nInput:\n sentence = \"eetcode\"\n\nOutput:\n true\n\nExplanation:\n The words in sentence are [\"eetcode\"].\n- eetcod\ne\n's last character is equal to \ne\netcode's first character.\nThe sentence is circular.\n\n\nExample 3:\n\n\n\n\nInput:\n sentence = \"Leetcode is cool\"\n\nOutput:\n false\n\nExplanation:\n The words in sentence are [\"Leetcode\", \"is\", \"cool\"].\n- Leetcod\ne\n's last character is \nnot\n equal to \ni\ns's first character.\nThe sentence is \nnot\n circular.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 500\n\n\nsentence\n consist of only lowercase and uppercase English letters and spaces.\n\n\nThe words in \nsentence\n are separated by a single space.\n\n\nThere are no leading or trailing spaces.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2481,
        "slug": "minimum-cuts-to-divide-a-circle",
        "url": "https://leetcode.com/problems/minimum-cuts-to-divide-a-circle/",
        "titulo": "Minimum Cuts to Divide a Circle",
        "enunciado": "A \nvalid cut\n in a circle can be:\n\n\n\n\nA cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\n\n\nA cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n\n\n\n\nSome valid and invalid cuts are shown in the figures below.\n\n\n\n\nGiven the integer \nn\n, return \nthe \nminimum\n number of cuts needed to divide a circle into \nn\n equal slices\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 2\n\nExplanation:\n \nThe above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n\nAt least 3 cuts are needed to divide the circle into 3 equal slices. \nIt can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\nAlso note that the first cut will not divide the circle into distinct parts.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100",
        "temas": [
            "Math",
            "Geometry"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2485,
        "slug": "find-the-pivot-integer",
        "url": "https://leetcode.com/problems/find-the-pivot-integer/",
        "titulo": "Find the Pivot Integer",
        "enunciado": "Given a positive integer \nn\n, find the \npivot integer\n \nx\n such that:\n\n\n\n\nThe sum of all elements between \n1\n and \nx\n inclusively equals the sum of all elements between \nx\n and \nn\n inclusively.\n\n\n\n\nReturn \nthe pivot integer \nx\n. If no such integer exists, return \n-1\n. It is guaranteed that there will be at most one pivot index for the given input.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 8\n\nOutput:\n 6\n\nExplanation:\n 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 1\n\nExplanation:\n 1 is the pivot integer since: 1 = 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n -1\n\nExplanation:\n It can be proved that no such integer exist.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
        "temas": [
            "Math",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2475,
        "slug": "number-of-unequal-triplets-in-array",
        "url": "https://leetcode.com/problems/number-of-unequal-triplets-in-array/",
        "titulo": "Number of Unequal Triplets in Array",
        "enunciado": "You are given a \n0-indexed\n array of positive integers \nnums\n. Find the number of triplets \n(i, j, k)\n that meet the following conditions:\n\n\n\n\n0 <= i < j < k < nums.length\n\n\nnums[i]\n, \nnums[j]\n, and \nnums[k]\n are \npairwise distinct\n.\n\t\n\n\nIn other words, \nnums[i] != nums[j]\n, \nnums[i] != nums[k]\n, and \nnums[j] != nums[k]\n.\n\n\n\n\n\n\n\n\nReturn \nthe number of triplets that meet the conditions.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,4,2,4,3]\n\nOutput:\n 3\n\nExplanation:\n The following triplets meet the conditions:\n- (0, 2, 4) because 4 != 2 != 3\n- (1, 2, 4) because 4 != 2 != 3\n- (2, 3, 4) because 2 != 4 != 3\nSince there are 3 triplets, we return 3.\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1,1,1]\n\nOutput:\n 0\n\nExplanation:\n No triplets meet the conditions so we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 100\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2465,
        "slug": "number-of-distinct-averages",
        "url": "https://leetcode.com/problems/number-of-distinct-averages/",
        "titulo": "Number of Distinct Averages",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n of \neven\n length.\n\n\nAs long as \nnums\n is \nnot\n empty, you must repetitively:\n\n\n\n\nFind the minimum number in \nnums\n and remove it.\n\n\nFind the maximum number in \nnums\n and remove it.\n\n\nCalculate the average of the two removed numbers.\n\n\n\n\nThe \naverage\n of two numbers \na\n and \nb\n is \n(a + b) / 2\n.\n\n\n\n\nFor example, the average of \n2\n and \n3\n is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nReturn\n the number of \ndistinct\n averages calculated using the above process\n.\n\n\nNote\n that when there is a tie for a minimum or maximum number, any can be removed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,1,4,0,3,5]\n\nOutput:\n 2\n\nExplanation:\n\n1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].\n2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].\n3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.\nSince there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,100]\n\nOutput:\n 1\n\nExplanation:\n\nThere is only one average to be calculated after removing 1 and 100, so we return 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\nnums.length\n is even.\n\n\n0 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2469,
        "slug": "convert-the-temperature",
        "url": "https://leetcode.com/problems/convert-the-temperature/",
        "titulo": "Convert the Temperature",
        "enunciado": "You are given a non-negative floating point number rounded to two decimal places \ncelsius\n, that denotes the \ntemperature in Celsius\n.\n\n\nYou should convert Celsius into \nKelvin\n and \nFahrenheit\n and return it as an array \nans = [kelvin, fahrenheit]\n.\n\n\nReturn \nthe array \nans\n. \nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\nNote that:\n\n\n\n\nKelvin = Celsius + 273.15\n\n\nFahrenheit = Celsius * 1.80 + 32.00\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n celsius = 36.50\n\nOutput:\n [309.65000,97.70000]\n\nExplanation:\n Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.\n\n\n\nExample 2:\n\n\n\n\nInput:\n celsius = 122.11\n\nOutput:\n [395.26000,251.79800]\n\nExplanation:\n Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= celsius <= 1000",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2460,
        "slug": "apply-operations-to-an-array",
        "url": "https://leetcode.com/problems/apply-operations-to-an-array/",
        "titulo": "Apply Operations to an Array",
        "enunciado": "You are given a \n0-indexed\n array \nnums\n of size \nn\n consisting of \nnon-negative\n integers.\n\n\nYou need to apply \nn - 1\n operations to this array where, in the \ni\nth\n operation (\n0-indexed\n), you will apply the following on the \ni\nth\n element of \nnums\n:\n\n\n\n\nIf \nnums[i] == nums[i + 1]\n, then multiply \nnums[i]\n by \n2\n and set \nnums[i + 1]\n to \n0\n. Otherwise, you skip this operation.\n\n\n\n\nAfter performing \nall\n the operations, \nshift\n all the \n0\n's to the \nend\n of the array.\n\n\n\n\nFor example, the array \n[1,0,2,0,0,1]\n after shifting all its \n0\n's to the end, is \n[1,2,1,0,0,0]\n.\n\n\n\n\nReturn \nthe resulting array\n.\n\n\nNote\n that the operations are applied \nsequentially\n, not all at once.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,2,1,1,0]\n\nOutput:\n [1,4,2,0,0,0]\n\nExplanation:\n We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,\n4\n,\n0\n,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,\n2\n,\n0\n,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,\n0\n,\n0\n].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1]\n\nOutput:\n [1,0]\n\nExplanation:\n No operation can be applied, we just shift the 0 to the end.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 2000\n\n\n0 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Two Pointers",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2451,
        "slug": "odd-string-difference",
        "url": "https://leetcode.com/problems/odd-string-difference/",
        "titulo": "Odd String Difference",
        "enunciado": "You are given an array of equal-length strings \nwords\n. Assume that the length of each string is \nn\n.\n\n\nEach string \nwords[i]\n can be converted into a \ndifference integer array\n \ndifference[i]\n of length \nn - 1\n where \ndifference[i][j] = words[i][j+1] - words[i][j]\n where \n0 <= j <= n - 2\n. Note that the difference between two letters is the difference between their \npositions\n in the alphabet i.e. the position of \n'a'\n is \n0\n, \n'b'\n is \n1\n, and \n'z'\n is \n25\n.\n\n\n\n\nFor example, for the string \n\"acb\"\n, the difference integer array is \n[2 - 0, 1 - 2] = [2, -1]\n.\n\n\n\n\nAll the strings in words have the same difference integer array, \nexcept one\n. You should find that string.\n\n\nReturn\n the string in \nwords\n that has different \ndifference integer array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"adc\",\"wzy\",\"abc\"]\n\nOutput:\n \"abc\"\n\nExplanation:\n \n- The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1].\n- The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1].\n- The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. \nThe odd array out is [1, 1], so we return the corresponding string, \"abc\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"]\n\nOutput:\n \"bob\"\n\nExplanation:\n All the integer arrays are [0, 0] except for \"bob\", which corresponds to [13, -13].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= words.length <= 100\n\n\nn == words[i].length\n\n\n2 <= n <= 20\n\n\nwords[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2455,
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "url": "https://leetcode.com/problems/average-value-of-even-numbers-that-are-divisible-by-three/",
        "titulo": "Average Value of Even Numbers That Are Divisible by Three",
        "enunciado": "Given an integer array \nnums\n of \npositive\n integers, return \nthe average value of all even integers that are divisible by\n \n3\n.\n\n\nNote that the \naverage\n of \nn\n elements is the \nsum\n of the \nn\n elements divided by \nn\n and \nrounded down\n to the nearest integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,6,10,12,15]\n\nOutput:\n 9\n\nExplanation:\n 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,4,7,10]\n\nOutput:\n 0\n\nExplanation:\n There is no single number that satisfies the requirement, so return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2446,
        "slug": "determine-if-two-events-have-conflict",
        "url": "https://leetcode.com/problems/determine-if-two-events-have-conflict/",
        "titulo": "Determine if Two Events Have Conflict",
        "enunciado": "You are given two arrays of strings that represent two inclusive events that happened \non the same day\n, \nevent1\n and \nevent2\n, where:\n\n\n\n\nevent1 = [startTime\n1\n, endTime\n1\n]\n and\n\n\nevent2 = [startTime\n2\n, endTime\n2\n]\n.\n\n\n\n\nEvent times are valid 24 hours format in the form of \nHH:MM\n.\n\n\nA \nconflict\n happens when two events have some non-empty intersection (i.e., some moment is common to both events).\n\n\nReturn \ntrue\n if there is a conflict between two events. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\n\nOutput:\n true\n\nExplanation:\n The two events intersect at time 2:00.\n\n\n\nExample 2:\n\n\n\n\nInput:\n event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\n\nOutput:\n true\n\nExplanation:\n The two events intersect starting from 01:20 to 02:00.\n\n\n\nExample 3:\n\n\n\n\nInput:\n event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\n\nOutput:\n false\n\nExplanation:\n The two events do not intersect.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nevent1.length == event2.length == 2\n\n\nevent1[i].length == event2[i].length == 5\n\n\nstartTime\n1\n <= endTime\n1\n\n\nstartTime\n2\n <= endTime\n2\n\n\nAll the event times follow the \nHH:MM\n format.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2423,
        "slug": "remove-letter-to-equalize-frequency",
        "url": "https://leetcode.com/problems/remove-letter-to-equalize-frequency/",
        "titulo": "Remove Letter To Equalize Frequency",
        "enunciado": "You are given a \n0-indexed\n string \nword\n, consisting of lowercase English letters. You need to select \none\n index and \nremove\n the letter at that index from \nword\n so that the \nfrequency\n of every letter present in \nword\n is equal.\n\n\nReturn\n \ntrue\n if it is possible to remove one letter so that the frequency of all letters in \nword\n are equal, and \nfalse\n otherwise\n.\n\n\nNote:\n\n\n\n\nThe \nfrequency\n of a letter \nx\n is the number of times it occurs in the string.\n\n\nYou \nmust\n remove exactly one letter and cannot choose to do nothing.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"abcc\"\n\nOutput:\n true\n\nExplanation:\n Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"aazz\"\n\nOutput:\n false\n\nExplanation:\n We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= word.length <= 100\n\n\nword\n consists of lowercase English letters only.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2437,
        "slug": "number-of-valid-clock-times",
        "url": "https://leetcode.com/problems/number-of-valid-clock-times/",
        "titulo": "Number of Valid Clock Times",
        "enunciado": "You are given a string of length \n5\n called \ntime\n, representing the current time on a digital clock in the format \n\"hh:mm\"\n. The \nearliest\n possible time is \n\"00:00\"\n and the \nlatest\n possible time is \n\"23:59\"\n.\n\n\nIn the string \ntime\n, the digits represented by the \n?\n symbol are \nunknown\n, and must be \nreplaced\n with a digit from \n0\n to \n9\n.\n\n\nReturn\n an integer \nanswer\n, the number of valid clock times that can be created by replacing every \n?\n with a digit from \n0\n to \n9\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n time = \"?5:00\"\n\nOutput:\n 2\n\nExplanation:\n We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices.\n\n\n\nExample 2:\n\n\n\n\nInput:\n time = \"0?:0?\"\n\nOutput:\n 100\n\nExplanation:\n Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\n\n\nExample 3:\n\n\n\n\nInput:\n time = \"??:??\"\n\nOutput:\n 1440\n\nExplanation:\n There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ntime\n is a valid string of length \n5\n in the format \n\"hh:mm\"\n.\n\n\n\"00\" <= hh <= \"23\"\n\n\n\"00\" <= mm <= \"59\"\n\n\nSome of the digits might be replaced with \n'?'\n and need to be replaced with digits from \n0\n to \n9\n.",
        "temas": [
            "String",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2441,
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "url": "https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/",
        "titulo": "Largest Positive Integer That Exists With Its Negative",
        "enunciado": "Given an integer array \nnums\n that \ndoes not contain\n any zeros, find \nthe largest positive\n integer \nk\n such that \n-k\n also exists in the array.\n\n\nReturn \nthe positive integer \nk\n. If there is no such integer, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,2,-3,3]\n\nOutput:\n 3\n\nExplanation:\n 3 is the only valid k we can find in the array.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,10,6,7,-7,1]\n\nOutput:\n 7\n\nExplanation:\n Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [-10,8,6,7,-2,-3]\n\nOutput:\n -1\n\nExplanation:\n There is no a single valid k, we return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-1000 <= nums[i] <= 1000\n\n\nnums[i] != 0",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2432,
        "slug": "the-employee-that-worked-on-the-longest-task",
        "url": "https://leetcode.com/problems/the-employee-that-worked-on-the-longest-task/",
        "titulo": "The Employee That Worked on the Longest Task",
        "enunciado": "There are \nn\n employees, each with a unique id from \n0\n to \nn - 1\n.\n\n\nYou are given a 2D integer array \nlogs\n where \nlogs[i] = [id\ni\n, leaveTime\ni\n]\n where:\n\n\n\n\nid\ni\n is the id of the employee that worked on the \ni\nth\n task, and\n\n\nleaveTime\ni\n is the time at which the employee finished the \ni\nth\n task. All the values \nleaveTime\ni\n are \nunique\n.\n\n\n\n\nNote that the \ni\nth\n task starts the moment right after the \n(i - 1)\nth\n task ends, and the \n0\nth\n task starts at time \n0\n.\n\n\nReturn \nthe id of the employee that worked the task with the longest time.\n If there is a tie between two or more employees, return\n the \nsmallest\n id among them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]\n\nOutput:\n 1\n\nExplanation:\n \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]\n\nOutput:\n 3\n\nExplanation:\n \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employee that worked on it is 3, so we return 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2, logs = [[0,10],[1,20]]\n\nOutput:\n 0\n\nExplanation:\n \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 500\n\n\n1 <= logs.length <= 500\n\n\nlogs[i].length == 2\n\n\n0 <= id\ni\n <= n - 1\n\n\n1 <= leaveTime\ni\n <= 500\n\n\nid\ni\n != id\ni+1\n\n\nleaveTime\ni\n are sorted in a strictly increasing order.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2427,
        "slug": "number-of-common-factors",
        "url": "https://leetcode.com/problems/number-of-common-factors/",
        "titulo": "Number of Common Factors",
        "enunciado": "Given two positive integers \na\n and \nb\n, return \nthe number of \ncommon\n factors of \na\n and \nb\n.\n\n\nAn integer \nx\n is a \ncommon factor\n of \na\n and \nb\n if \nx\n divides both \na\n and \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n a = 12, b = 6\n\nOutput:\n 4\n\nExplanation:\n The common factors of 12 and 6 are 1, 2, 3, 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n a = 25, b = 30\n\nOutput:\n 2\n\nExplanation:\n The common factors of 25 and 30 are 1, 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a, b <= 1000",
        "temas": [
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2418,
        "slug": "sort-the-people",
        "url": "https://leetcode.com/problems/sort-the-people/",
        "titulo": "Sort the People",
        "enunciado": "You are given an array of strings \nnames\n, and an array \nheights\n that consists of \ndistinct\n positive integers. Both arrays are of length \nn\n.\n\n\nFor each index \ni\n, \nnames[i]\n and \nheights[i]\n denote the name and height of the \ni\nth\n person.\n\n\nReturn \nnames\n sorted in \ndescending\n order by the people's heights\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170]\n\nOutput:\n [\"Mary\",\"Emma\",\"John\"]\n\nExplanation:\n Mary is the tallest, followed by Emma and John.\n\n\n\nExample 2:\n\n\n\n\nInput:\n names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150]\n\nOutput:\n [\"Bob\",\"Alice\",\"Bob\"]\n\nExplanation:\n The first Bob is the tallest, followed by Alice and the second Bob.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == names.length == heights.length\n\n\n1 <= n <= 10\n3\n\n\n1 <= names[i].length <= 20\n\n\n1 <= heights[i] <= 10\n5\n\n\nnames[i]\n consists of lower and upper case English letters.\n\n\nAll the values of \nheights\n are distinct.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2409,
        "slug": "count-days-spent-together",
        "url": "https://leetcode.com/problems/count-days-spent-together/",
        "titulo": "Count Days Spent Together",
        "enunciado": "Alice and Bob are traveling to Rome for separate business meetings.\n\n\nYou are given 4 strings \narriveAlice\n, \nleaveAlice\n, \narriveBob\n, and \nleaveBob\n. Alice will be in the city from the dates \narriveAlice\n to \nleaveAlice\n (\ninclusive\n), while Bob will be in the city from the dates \narriveBob\n to \nleaveBob\n (\ninclusive\n). Each will be a 5-character string in the format \n\"MM-DD\"\n, corresponding to the month and day of the date.\n\n\nReturn\n the total number of days that Alice and Bob are in Rome together.\n\n\nYou can assume that all dates occur in the \nsame\n calendar year, which is \nnot\n a leap year. Note that the number of days per month can be represented as: \n[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\n\nOutput:\n 3\n\nExplanation:\n Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\n\nOutput:\n 0\n\nExplanation:\n There is no day when Alice and Bob are in Rome together, so we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nAll dates are provided in the format \n\"MM-DD\"\n.\n\n\nAlice and Bob's arrival dates are \nearlier than or equal to\n their leaving dates.\n\n\nThe given dates are valid dates of a \nnon-leap\n year.",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2413,
        "slug": "smallest-even-multiple",
        "url": "https://leetcode.com/problems/smallest-even-multiple/",
        "titulo": "Smallest Even Multiple",
        "enunciado": "Given a \npositive\n integer \nn\n, return \nthe smallest positive integer that is a multiple of \nboth\n \n2\n and \nn\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 10\n\nExplanation:\n The smallest multiple of both 5 and 2 is 10.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 6\n\nOutput:\n 6\n\nExplanation:\n The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 150",
        "temas": [
            "Math",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2404,
        "slug": "most-frequent-even-element",
        "url": "https://leetcode.com/problems/most-frequent-even-element/",
        "titulo": "Most Frequent Even Element",
        "enunciado": "Given an integer array \nnums\n, return \nthe most frequent even element\n.\n\n\nIf there is a tie, return the \nsmallest\n one. If there is no such element, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1,2,2,4,4,1]\n\nOutput:\n 2\n\nExplanation:\n\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,4,4,9,2,4]\n\nOutput:\n 4\n\nExplanation:\n 4 is the even element appears the most.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [29,47,21,41,13,37,25,7]\n\nOutput:\n -1\n\nExplanation:\n There is no even element.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2000\n\n\n0 <= nums[i] <= 10\n5",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2395,
        "slug": "find-subarrays-with-equal-sum",
        "url": "https://leetcode.com/problems/find-subarrays-with-equal-sum/",
        "titulo": "Find Subarrays With Equal Sum",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n, determine whether there exist \ntwo\n subarrays of length \n2\n with \nequal\n sum. Note that the two subarrays must begin at \ndifferent\n indices.\n\n\nReturn \ntrue\n if these subarrays exist, and \nfalse\n otherwise.\n\n\nA \nsubarray\n is a contiguous non-empty sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,2,4]\n\nOutput:\n true\n\nExplanation:\n The subarrays with elements [4,2] and [2,4] have the same sum of 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n false\n\nExplanation:\n No two subarrays of size 2 have the same sum.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n true\n\nExplanation:\n The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. \nNote that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 1000\n\n\n-10\n9\n <= nums[i] <= 10\n9",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2399,
        "slug": "check-distances-between-same-letters",
        "url": "https://leetcode.com/problems/check-distances-between-same-letters/",
        "titulo": "Check Distances Between Same Letters",
        "enunciado": "You are given a \n0-indexed\n string \ns\n consisting of only lowercase English letters, where each letter in \ns\n appears \nexactly\n \ntwice\n. You are also given a \n0-indexed\n integer array \ndistance\n of length \n26\n.\n\n\nEach letter in the alphabet is numbered from \n0\n to \n25\n (i.e. \n'a' -> 0\n, \n'b' -> 1\n, \n'c' -> 2\n, ... , \n'z' -> 25\n).\n\n\nIn a \nwell-spaced\n string, the number of letters between the two occurrences of the \ni\nth\n letter is \ndistance[i]\n. If the \ni\nth\n letter does not appear in \ns\n, then \ndistance[i]\n can be \nignored\n.\n\n\nReturn \ntrue\n if \ns\n is a \nwell-spaced\n string, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\nOutput:\n true\n\nExplanation:\n\n- 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.\n- 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.\n- 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.\nNote that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.\nReturn true because s is a well-spaced string.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\nOutput:\n false\n\nExplanation:\n\n- 'a' appears at indices 0 and 1 so there are zero letters between them.\nBecause distance[0] = 1, s is not a well-spaced string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 52\n\n\ns\n consists only of lowercase English letters.\n\n\nEach letter appears in \ns\n exactly twice.\n\n\ndistance.length == 26\n\n\n0 <= distance[i] <= 50",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2389,
        "slug": "longest-subsequence-with-limited-sum",
        "url": "https://leetcode.com/problems/longest-subsequence-with-limited-sum/",
        "titulo": "Longest Subsequence With Limited Sum",
        "enunciado": "You are given an integer array \nnums\n of length \nn\n, and an integer array \nqueries\n of length \nm\n.\n\n\nReturn \nan array \nanswer\n of length \nm\n where \nanswer[i]\n is the \nmaximum\n size of a \nsubsequence\n that you can take from \nnums\n such that the \nsum\n of its elements is less than or equal to \nqueries[i]\n.\n\n\nA \nsubsequence\n is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,5,2,1], queries = [3,10,21]\n\nOutput:\n [2,3,4]\n\nExplanation:\n We answer the queries as follows:\n- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.\n- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.\n- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,4,5], queries = [1]\n\nOutput:\n [0]\n\nExplanation:\n The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\nm == queries.length\n\n\n1 <= n, m <= 1000\n\n\n1 <= nums[i], queries[i] <= 10\n6",
        "temas": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2379,
        "slug": "minimum-recolors-to-get-k-consecutive-black-blocks",
        "url": "https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/",
        "titulo": "Minimum Recolors to Get K Consecutive Black Blocks",
        "enunciado": "You are given a \n0-indexed\n string \nblocks\n of length \nn\n, where \nblocks[i]\n is either \n'W'\n or \n'B'\n, representing the color of the \ni\nth\n block. The characters \n'W'\n and \n'B'\n denote the colors white and black, respectively.\n\n\nYou are also given an integer \nk\n, which is the desired number of \nconsecutive\n black blocks.\n\n\nIn one operation, you can \nrecolor\n a white block such that it becomes a black block.\n\n\nReturn\n the \nminimum\n number of operations needed such that there is at least \none\n occurrence of \nk\n consecutive black blocks.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n blocks = \"WBBWWBBWBW\", k = 7\n\nOutput:\n 3\n\nExplanation:\n\nOne way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\nso that blocks = \"BBBBBBBWBW\". \nIt can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\nTherefore, we return 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n blocks = \"WBWBBBW\", k = 2\n\nOutput:\n 0\n\nExplanation:\n\nNo changes need to be made, since 2 consecutive black blocks already exist.\nTherefore, we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == blocks.length\n\n\n1 <= n <= 100\n\n\nblocks[i]\n is either \n'W'\n or \n'B'\n.\n\n\n1 <= k <= n",
        "temas": [
            "String",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2383,
        "slug": "minimum-hours-of-training-to-win-a-competition",
        "url": "https://leetcode.com/problems/minimum-hours-of-training-to-win-a-competition/",
        "titulo": "Minimum Hours of Training to Win a Competition",
        "enunciado": "You are entering a competition, and are given two \npositive\n integers \ninitialEnergy\n and \ninitialExperience\n denoting your initial energy and initial experience respectively.\n\n\nYou are also given two \n0-indexed\n integer arrays \nenergy\n and \nexperience\n, both of length \nn\n.\n\n\nYou will face \nn\n opponents \nin order\n. The energy and experience of the \ni\nth\n opponent is denoted by \nenergy[i]\n and \nexperience[i]\n respectively. When you face an opponent, you need to have both \nstrictly\n greater experience and energy to defeat them and move to the next opponent if available.\n\n\nDefeating the \ni\nth\n opponent \nincreases\n your experience by \nexperience[i]\n, but \ndecreases\n your energy by \nenergy[i]\n.\n\n\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can \neither\n choose to increase your initial experience by one, or increase your initial energy by one.\n\n\nReturn \nthe \nminimum\n number of training hours required to defeat all \nn\n opponents\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n\nOutput:\n 8\n\nExplanation:\n You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0\nth\n opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1\nst\n opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2\nnd\n opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3\nrd\n opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n\n\n\nExample 2:\n\n\n\n\nInput:\n initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n\nOutput:\n 0\n\nExplanation:\n You do not need any additional energy or experience to win the competition, so we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == energy.length == experience.length\n\n\n1 <= n <= 100\n\n\n1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2373,
        "slug": "largest-local-values-in-a-matrix",
        "url": "https://leetcode.com/problems/largest-local-values-in-a-matrix/",
        "titulo": "Largest Local Values in a Matrix",
        "enunciado": "You are given an \nn x n\n integer matrix \ngrid\n.\n\n\nGenerate an integer matrix \nmaxLocal\n of size \n(n - 2) x (n - 2)\n such that:\n\n\n\n\nmaxLocal[i][j]\n is equal to the \nlargest\n value of the \n3 x 3\n matrix in \ngrid\n centered around row \ni + 1\n and column \nj + 1\n.\n\n\n\n\nIn other words, we want to find the largest value in every contiguous \n3 x 3\n matrix in \ngrid\n.\n\n\nReturn \nthe generated matrix\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n\nOutput:\n [[9,9],[8,6]]\n\nExplanation:\n The diagram above shows the original matrix and the generated matrix.\nNotice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n\nOutput:\n [[2,2,2],[2,2,2],[2,2,2]]\n\nExplanation:\n Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n3 <= n <= 100\n\n\n1 <= grid[i][j] <= 100",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2363,
        "slug": "merge-similar-items",
        "url": "https://leetcode.com/problems/merge-similar-items/",
        "titulo": "Merge Similar Items",
        "enunciado": "You are given two 2D integer arrays, \nitems1\n and \nitems2\n, representing two sets of items. Each array \nitems\n has the following properties:\n\n\n\n\nitems[i] = [value\ni\n, weight\ni\n]\n where \nvalue\ni\n represents the \nvalue\n and \nweight\ni\n represents the \nweight \nof the \ni\nth\n item.\n\n\nThe value of each item in \nitems\n is \nunique\n.\n\n\n\n\nReturn \na 2D integer array\n \nret\n \nwhere\n \nret[i] = [value\ni\n, weight\ni\n]\n,\n \nwith\n \nweight\ni\n \nbeing the \nsum of weights\n of all items with value\n \nvalue\ni\n.\n\n\nNote:\n \nret\n should be returned in \nascending\n order by value.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\n\nOutput:\n [[1,6],[3,9],[4,5]]\n\nExplanation:\n \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\nThe item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\nThe item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \nTherefore, we return [[1,6],[3,9],[4,5]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\n\nOutput:\n [[1,4],[2,4],[3,4]]\n\nExplanation:\n \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\nThe item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\nThe item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\nTherefore, we return [[1,4],[2,4],[3,4]].\n\n\nExample 3:\n\n\n\n\nInput:\n items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\n\nOutput:\n [[1,7],[2,4],[7,1]]\n\nExplanation:\n\nThe item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \nThe item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \nThe item with value = 7 occurs in items2 with weight = 1, total weight = 1.\nTherefore, we return [[1,7],[2,4],[7,1]].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= items1.length, items2.length <= 1000\n\n\nitems1[i].length == items2[i].length == 2\n\n\n1 <= value\ni\n, weight\ni\n <= 1000\n\n\nEach \nvalue\ni\n in \nitems1\n is \nunique\n.\n\n\nEach \nvalue\ni\n in \nitems2\n is \nunique\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Ordered Set"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2367,
        "slug": "number-of-arithmetic-triplets",
        "url": "https://leetcode.com/problems/number-of-arithmetic-triplets/",
        "titulo": "Number of Arithmetic Triplets",
        "enunciado": "You are given a \n0-indexed\n, \nstrictly increasing\n integer array \nnums\n and a positive integer \ndiff\n. A triplet \n(i, j, k)\n is an \narithmetic triplet\n if the following conditions are met:\n\n\n\n\ni < j < k\n,\n\n\nnums[j] - nums[i] == diff\n, and\n\n\nnums[k] - nums[j] == diff\n.\n\n\n\n\nReturn \nthe number of unique \narithmetic triplets\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1,4,6,7,10], diff = 3\n\nOutput:\n 2\n\nExplanation:\n\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,5,6,7,8,9], diff = 2\n\nOutput:\n 2\n\nExplanation:\n\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 200\n\n\n0 <= nums[i] <= 200\n\n\n1 <= diff <= 50\n\n\nnums\n is \nstrictly\n increasing.",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2357,
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "url": "https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/",
        "titulo": "Make Array Zero by Subtracting Equal Amounts",
        "enunciado": "You are given a non-negative integer array \nnums\n. In one operation, you must:\n\n\n\n\nChoose a positive integer \nx\n such that \nx\n is less than or equal to the \nsmallest non-zero\n element in \nnums\n.\n\n\nSubtract \nx\n from every \npositive\n element in \nnums\n.\n\n\n\n\nReturn \nthe \nminimum\n number of operations to make every element in \nnums\n equal to \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,5,0,3,5]\n\nOutput:\n 3\n\nExplanation:\n\nIn the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n 0\n\nExplanation:\n Each element in nums is already 0 so no operations are needed.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2347,
        "slug": "best-poker-hand",
        "url": "https://leetcode.com/problems/best-poker-hand/",
        "titulo": "Best Poker Hand",
        "enunciado": "You are given an integer array \nranks\n and a character array \nsuits\n. You have \n5\n cards where the \ni\nth\n card has a rank of \nranks[i]\n and a suit of \nsuits[i]\n.\n\n\nThe following are the types of \npoker hands\n you can make from best to worst:\n\n\n\n\n\"Flush\"\n: Five cards of the same suit.\n\n\n\"Three of a Kind\"\n: Three cards of the same rank.\n\n\n\"Pair\"\n: Two cards of the same rank.\n\n\n\"High Card\"\n: Any single card.\n\n\n\n\nReturn \na string representing the \nbest\n type of \npoker hand\n you can make with the given cards.\n\n\nNote\n that the return values are \ncase-sensitive\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"]\n\nOutput:\n \"Flush\"\n\nExplanation:\n The hand with all the cards consists of 5 cards with the same suit, so we have a \"Flush\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"]\n\nOutput:\n \"Three of a Kind\"\n\nExplanation:\n The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a \"Three of a Kind\".\nNote that we could also make a \"Pair\" hand but \"Three of a Kind\" is a better hand.\nAlso note that other cards could be used to make the \"Three of a Kind\" hand.\n\n\nExample 3:\n\n\n\n\nInput:\n ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"]\n\nOutput:\n \"Pair\"\n\nExplanation:\n The hand with the first and second card consists of 2 cards with the same rank, so we have a \"Pair\".\nNote that we cannot make a \"Flush\" or a \"Three of a Kind\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\nranks.length == suits.length == 5\n\n\n1 <= ranks[i] <= 13\n\n\n'a' <= suits[i] <= 'd'\n\n\nNo two cards have the same rank and suit.",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2351,
        "slug": "first-letter-to-appear-twice",
        "url": "https://leetcode.com/problems/first-letter-to-appear-twice/",
        "titulo": "First Letter to Appear Twice",
        "enunciado": "Given a string \ns\n consisting of lowercase English letters, return \nthe first letter to appear \ntwice\n.\n\n\nNote\n:\n\n\n\n\nA letter \na\n appears twice before another letter \nb\n if the \nsecond\n occurrence of \na\n is before the \nsecond\n occurrence of \nb\n.\n\n\ns\n will contain at least one letter that appears twice.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abccbaacz\"\n\nOutput:\n \"c\"\n\nExplanation:\n\nThe letter 'a' appears on the indexes 0, 5 and 6.\nThe letter 'b' appears on the indexes 1 and 4.\nThe letter 'c' appears on the indexes 2, 3 and 7.\nThe letter 'z' appears on the index 8.\nThe letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abcdd\"\n\nOutput:\n \"d\"\n\nExplanation:\n\nThe only letter that appears twice is 'd' so we return 'd'.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 100\n\n\ns\n consists of lowercase English letters.\n\n\ns\n has at least one repeated letter.",
        "temas": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2341,
        "slug": "maximum-number-of-pairs-in-array",
        "url": "https://leetcode.com/problems/maximum-number-of-pairs-in-array/",
        "titulo": "Maximum Number of Pairs in Array",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n. In one operation, you may do the following:\n\n\n\n\nChoose \ntwo\n integers in \nnums\n that are \nequal\n.\n\n\nRemove both integers from \nnums\n, forming a \npair\n.\n\n\n\n\nThe operation is done on \nnums\n as many times as possible.\n\n\nReturn \na \n0-indexed\n integer array \nanswer\n of size \n2\n where \nanswer[0]\n is the number of pairs that are formed and \nanswer[1]\n is the number of leftover integers in \nnums\n after doing the operation as many times as possible\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,2,1,3,2,2]\n\nOutput:\n [3,1]\n\nExplanation:\n\nForm a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].\nForm a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].\nForm a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].\nNo more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1]\n\nOutput:\n [1,0]\n\nExplanation:\n Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].\nNo more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [0,1]\n\nExplanation:\n No pairs can be formed, and there is 1 number leftover in nums.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2331,
        "slug": "evaluate-boolean-binary-tree",
        "url": "https://leetcode.com/problems/evaluate-boolean-binary-tree/",
        "titulo": "Evaluate Boolean Binary Tree",
        "enunciado": "You are given the \nroot\n of a \nfull binary tree\n with the following properties:\n\n\n\n\nLeaf nodes\n have either the value \n0\n or \n1\n, where \n0\n represents \nFalse\n and \n1\n represents \nTrue\n.\n\n\nNon-leaf nodes\n have either the value \n2\n or \n3\n, where \n2\n represents the boolean \nOR\n and \n3\n represents the boolean \nAND\n.\n\n\n\n\nThe \nevaluation\n of a node is as follows:\n\n\n\n\nIf the node is a leaf node, the evaluation is the \nvalue\n of the node, i.e. \nTrue\n or \nFalse\n.\n\n\nOtherwise, \nevaluate\n the node's two children and \napply\n the boolean operation of its value with the children's evaluations.\n\n\n\n\nReturn\n the boolean result of \nevaluating\n the \nroot\n node.\n\n\nA \nfull binary tree\n is a binary tree where each node has either \n0\n or \n2\n children.\n\n\nA \nleaf node\n is a node that has zero children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3,null,null,0,1]\n\nOutput:\n true\n\nExplanation:\n The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n false\n\nExplanation:\n The root node is a leaf node and it evaluates to false, so we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 3\n\n\nEvery node has either \n0\n or \n2\n children.\n\n\nLeaf nodes have a value of \n0\n or \n1\n.\n\n\nNon-leaf nodes have a value of \n2\n or \n3\n.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 2335,
        "slug": "minimum-amount-of-time-to-fill-cups",
        "url": "https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/",
        "titulo": "Minimum Amount of Time to Fill Cups",
        "enunciado": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up \n2\n cups with \ndifferent\n types of water, or \n1\n cup of any type of water.\n\n\nYou are given a \n0-indexed\n integer array \namount\n of length \n3\n where \namount[0]\n, \namount[1]\n, and \namount[2]\n denote the number of cold, warm, and hot water cups you need to fill respectively. Return \nthe \nminimum\n number of seconds needed to fill up all the cups\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n amount = [1,4,2]\n\nOutput:\n 4\n\nExplanation:\n One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n amount = [5,4,4]\n\nOutput:\n 7\n\nExplanation:\n One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n\n\n\nExample 3:\n\n\n\n\nInput:\n amount = [5,0,0]\n\nOutput:\n 5\n\nExplanation:\n Every second, we fill up a cold cup.\n\n\n\n \n\n\nConstraints:\n\n\n\n\namount.length == 3\n\n\n0 <= amount[i] <= 100",
        "temas": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2325,
        "slug": "decode-the-message",
        "url": "https://leetcode.com/problems/decode-the-message/",
        "titulo": "Decode the Message",
        "enunciado": "You are given the strings \nkey\n and \nmessage\n, which represent a cipher key and a secret message, respectively. The steps to decode \nmessage\n are as follows:\n\n\n\n\nUse the \nfirst\n appearance of all 26 lowercase English letters in \nkey\n as the \norder\n of the substitution table.\n\n\nAlign the substitution table with the regular English alphabet.\n\n\nEach letter in \nmessage\n is then \nsubstituted\n using the table.\n\n\nSpaces \n' '\n are transformed to themselves.\n\n\n\n\n\n\nFor example, given \nkey = \"\nhap\np\ny\n \nbo\ny\"\n (actual key would have \nat least one\n instance of each letter in the alphabet), we have the partial substitution table of (\n'h' -> 'a'\n, \n'a' -> 'b'\n, \n'p' -> 'c'\n, \n'y' -> 'd'\n, \n'b' -> 'e'\n, \n'o' -> 'f'\n).\n\n\n\n\nReturn \nthe decoded message\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"\n\nOutput:\n \"this is a secret\"\n\nExplanation:\n The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"\nthe\n \nquick\n \nbrown\n \nf\no\nx\n \nj\nu\nmps\n o\nv\ner the \nlazy\n \nd\no\ng\n\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\n\nOutput:\n \"the five boxing wizards jump quickly\"\n\nExplanation:\n The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"\neljuxhpwnyrdgtqkviszcfmabo\n\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n26 <= key.length <= 2000\n\n\nkey\n consists of lowercase English letters and \n' '\n.\n\n\nkey\n contains every letter in the English alphabet (\n'a'\n to \n'z'\n) \nat least once\n.\n\n\n1 <= message.length <= 2000\n\n\nmessage\n consists of lowercase English letters and \n' '\n.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2315,
        "slug": "count-asterisks",
        "url": "https://leetcode.com/problems/count-asterisks/",
        "titulo": "Count Asterisks",
        "enunciado": "You are given a string \ns\n, where every \ntwo\n consecutive vertical bars \n'|'\n are grouped into a \npair\n. In other words, the 1\nst\n and 2\nnd\n \n'|'\n make a pair, the 3\nrd\n and 4\nth\n \n'|'\n make a pair, and so forth.\n\n\nReturn \nthe number of \n'*'\n in \ns\n, \nexcluding\n the \n'*'\n between each pair of \n'|'\n.\n\n\nNote\n that each \n'|'\n will belong to \nexactly\n one pair.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"l|*e*et|c**o|*de|\"\n\nOutput:\n 2\n\nExplanation:\n The considered characters are underlined: \"\nl\n|*e*et|\nc**o\n|*de|\".\nThe characters between the first and second '|' are excluded from the answer.\nAlso, the characters between the third and fourth '|' are excluded from the answer.\nThere are 2 asterisks considered. Therefore, we return 2.\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"iamprogrammer\"\n\nOutput:\n 0\n\nExplanation:\n In this example, there are no asterisks in s. Therefore, we return 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"yo|uar|e**|b|e***au|tifu|l\"\n\nOutput:\n 5\n\nExplanation:\n The considered characters are underlined: \"\nyo\n|uar|\ne**\n|b|\ne***au\n|tifu|\nl\n\". There are 5 asterisks considered. Therefore, we return 5.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of lowercase English letters, vertical bars \n'|'\n, and asterisks \n'*'\n.\n\n\ns\n contains an \neven\n number of vertical bars \n'|'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2319,
        "slug": "check-if-matrix-is-x-matrix",
        "url": "https://leetcode.com/problems/check-if-matrix-is-x-matrix/",
        "titulo": "Check if Matrix Is X-Matrix",
        "enunciado": "A square matrix is said to be an \nX-Matrix\n if \nboth\n of the following conditions hold:\n\n\n\n\nAll the elements in the diagonals of the matrix are \nnon-zero\n.\n\n\nAll other elements are 0.\n\n\n\n\nGiven a 2D integer array \ngrid\n of size \nn x n\n representing a square matrix, return \ntrue\n if \ngrid\n is an X-Matrix\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n\nOutput:\n true\n\nExplanation:\n Refer to the diagram above. \nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is an X-Matrix.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[5,7,0],[0,3,1],[0,5,0]]\n\nOutput:\n false\n\nExplanation:\n Refer to the diagram above.\nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is not an X-Matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n3 <= n <= 100\n\n\n0 <= grid[i][j] <= 10\n5",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2299,
        "slug": "strong-password-checker-ii",
        "url": "https://leetcode.com/problems/strong-password-checker-ii/",
        "titulo": "Strong Password Checker II",
        "enunciado": "A password is said to be \nstrong\n if it satisfies all the following criteria:\n\n\n\n\nIt has at least \n8\n characters.\n\n\nIt contains at least \none lowercase\n letter.\n\n\nIt contains at least \none uppercase\n letter.\n\n\nIt contains at least \none digit\n.\n\n\nIt contains at least \none special character\n. The special characters are the characters in the following string: \n\"!@#$%^&*()-+\"\n.\n\n\nIt does \nnot\n contain \n2\n of the same character in adjacent positions (i.e., \n\"aab\"\n violates this condition, but \n\"aba\"\n does not).\n\n\n\n\nGiven a string \npassword\n, return \ntrue\n if it is a \nstrong\n password\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n password = \"IloveLe3tcode!\"\n\nOutput:\n true\n\nExplanation:\n The password meets all the requirements. Therefore, we return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n password = \"Me+You--IsMyDream\"\n\nOutput:\n false\n\nExplanation:\n The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false.\n\n\n\nExample 3:\n\n\n\n\nInput:\n password = \"1aB!\"\n\nOutput:\n false\n\nExplanation:\n The password does not meet the length requirement. Therefore, we return false.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= password.length <= 100\n\n\npassword\n consists of letters, digits, and special characters: \n\"!@#$%^&*()-+\"\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2293,
        "slug": "min-max-game",
        "url": "https://leetcode.com/problems/min-max-game/",
        "titulo": "Min Max Game",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n whose length is a power of \n2\n.\n\n\nApply the following algorithm on \nnums\n:\n\n\n\n\nLet \nn\n be the length of \nnums\n. If \nn == 1\n, \nend\n the process. Otherwise, \ncreate\n a new \n0-indexed\n integer array \nnewNums\n of length \nn / 2\n.\n\n\nFor every \neven\n index \ni\n where \n0 <= i < n / 2\n, \nassign\n the value of \nnewNums[i]\n as \nmin(nums[2 * i], nums[2 * i + 1])\n.\n\n\nFor every \nodd\n index \ni\n where \n0 <= i < n / 2\n, \nassign\n the value of \nnewNums[i]\n as \nmax(nums[2 * i], nums[2 * i + 1])\n.\n\n\nReplace\n the array \nnums\n with \nnewNums\n.\n\n\nRepeat\n the entire process starting from step 1.\n\n\n\n\nReturn \nthe last number that remains in \nnums\n after applying the algorithm.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,3,5,2,4,8,2,2]\n\nOutput:\n 1\n\nExplanation:\n The following arrays are the results of applying the algorithm repeatedly.\nFirst: nums = [1,5,4,2]\nSecond: nums = [1,4]\nThird: nums = [1]\n1 is the last remaining number, so we return 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3]\n\nOutput:\n 3\n\nExplanation:\n 3 is already the last remaining number, so we return 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1024\n\n\n1 <= nums[i] <= 10\n9\n\n\nnums.length\n is a power of \n2\n.",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2236,
        "slug": "root-equals-sum-of-children",
        "url": "https://leetcode.com/problems/root-equals-sum-of-children/",
        "titulo": "Root Equals Sum of Children",
        "enunciado": "You are given the \nroot\n of a \nbinary tree\n that consists of exactly \n3\n nodes: the root, its left child, and its right child.\n\n\nReturn \ntrue\n \nif the value of the root is equal to the \nsum\n of the values of its two children, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,4,6]\n\nOutput:\n true\n\nExplanation:\n The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,1]\n\nOutput:\n false\n\nExplanation:\n The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe tree consists only of the root, its left child, and its right child.\n\n\n-100 <= Node.val <= 100",
        "temas": [
            "Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 2235,
        "slug": "add-two-integers",
        "url": "https://leetcode.com/problems/add-two-integers/",
        "titulo": "Add Two Integers",
        "enunciado": "Given two integers \nnum1\n and \nnum2\n, return \nthe \nsum\n of the two integers\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = 12, num2 = 5\n\nOutput:\n 17\n\nExplanation:\n num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = -10, num2 = 4\n\nOutput:\n -6\n\nExplanation:\n num1 + num2 = -6, so -6 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100 <= num1, num2 <= 100",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2283,
        "slug": "check-if-number-has-equal-digit-count-and-digit-value",
        "url": "https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/",
        "titulo": "Check if Number Has Equal Digit Count and Digit Value",
        "enunciado": "You are given a \n0-indexed\n string \nnum\n of length \nn\n consisting of digits.\n\n\nReturn \ntrue\n \nif for \nevery\n index \ni\n in the range \n0 <= i < n\n, the digit \ni\n occurs \nnum[i]\n times in \nnum\n, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = \"1210\"\n\nOutput:\n true\n\nExplanation:\n\nnum[0] = '1'. The digit 0 occurs once in num.\nnum[1] = '2'. The digit 1 occurs twice in num.\nnum[2] = '1'. The digit 2 occurs once in num.\nnum[3] = '0'. The digit 3 occurs zero times in num.\nThe condition holds true for every index in \"1210\", so return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = \"030\"\n\nOutput:\n false\n\nExplanation:\n\nnum[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.\nnum[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.\nnum[2] = '0'. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == num.length\n\n\n1 <= n <= 10\n\n\nnum\n consists of digits.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2287,
        "slug": "rearrange-characters-to-make-target-string",
        "url": "https://leetcode.com/problems/rearrange-characters-to-make-target-string/",
        "titulo": "Rearrange Characters to Make Target String",
        "enunciado": "You are given two \n0-indexed\n strings \ns\n and \ntarget\n. You can take some letters from \ns\n and rearrange them to form new strings.\n\n\nReturn\n the \nmaximum\n number of copies of \ntarget\n that can be formed by taking letters from \ns\n and rearranging them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ilovecodingonleetcode\", target = \"code\"\n\nOutput:\n 2\n\nExplanation:\n\nFor the first copy of \"code\", take the letters at indices 4, 5, 6, and 7.\nFor the second copy of \"code\", take the letters at indices 17, 18, 19, and 20.\nThe strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\".\nWe can make at most two copies of \"code\", so we return 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abcba\", target = \"abc\"\n\nOutput:\n 1\n\nExplanation:\n\nWe can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2.\nWe can make at most one copy of \"abc\", so we return 1.\nNote that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"abbaccaddaeea\", target = \"aaaaa\"\n\nOutput:\n 1\n\nExplanation:\n\nWe can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12.\nWe can make at most one copy of \"aaaaa\", so we return 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\n1 <= target.length <= 10\n\n\ns\n and \ntarget\n consist of lowercase English letters.\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 1189: Maximum Number of Balloons.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2278,
        "slug": "percentage-of-letter-in-string",
        "url": "https://leetcode.com/problems/percentage-of-letter-in-string/",
        "titulo": "Percentage of Letter in String",
        "enunciado": "Given a string \ns\n and a character \nletter\n, return\n the \npercentage\n of characters in \ns\n that equal \nletter\n \nrounded down\n to the nearest whole percent.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"foobar\", letter = \"o\"\n\nOutput:\n 33\n\nExplanation:\n\nThe percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"jjjj\", letter = \"k\"\n\nOutput:\n 0\n\nExplanation:\n\nThe percentage of characters in s that equal the letter 'k' is 0%, so we return 0.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of lowercase English letters.\n\n\nletter\n is a lowercase English letter.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2243,
        "slug": "calculate-digit-sum-of-a-string",
        "url": "https://leetcode.com/problems/calculate-digit-sum-of-a-string/",
        "titulo": "Calculate Digit Sum of a String",
        "enunciado": "You are given a string \ns\n consisting of digits and an integer \nk\n.\n\n\nA \nround\n can be completed if the length of \ns\n is greater than \nk\n. In one round, do the following:\n\n\n\n\nDivide\n \ns\n into \nconsecutive groups\n of size \nk\n such that the first \nk\n characters are in the first group, the next \nk\n characters are in the second group, and so on. \nNote\n that the size of the last group can be smaller than \nk\n.\n\n\nReplace\n each group of \ns\n with a string representing the sum of all its digits. For example, \n\"346\"\n is replaced with \n\"13\"\n because \n3 + 4 + 6 = 13\n.\n\n\nMerge\n consecutive groups together to form a new string. If the length of the string is greater than \nk\n, repeat from step \n1\n.\n\n\n\n\nReturn \ns\n \nafter all rounds have been completed\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"11111222223\", k = 3\n\nOutput:\n \"135\"\n\nExplanation:\n \n- For the first round, we divide s into groups of size 3: \"111\", \"112\", \"222\", and \"23\".\n  ​​​​​Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. \n  So, s becomes \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" after the first round.\n- For the second round, we divide s into \"346\" and \"5\".\n  Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. \n  So, s becomes \"13\" + \"5\" = \"135\" after second round. \nNow, s.length <= k, so we return \"135\" as the answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"00000000\", k = 3\n\nOutput:\n \"000\"\n\nExplanation:\n \nWe divide s into \"000\", \"000\", and \"00\".\nThen we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. \ns becomes \"0\" + \"0\" + \"0\" = \"000\", whose length is equal to k, so we return \"000\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\n2 <= k <= 100\n\n\ns\n consists of digits only.",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2239,
        "slug": "find-closest-number-to-zero",
        "url": "https://leetcode.com/problems/find-closest-number-to-zero/",
        "titulo": "Find Closest Number to Zero",
        "enunciado": "Given an integer array \nnums\n of size \nn\n, return \nthe number with the value \nclosest\n to \n0\n in \nnums\n. If there are multiple answers, return \nthe number with the \nlargest\n value\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-4,-2,1,4,8]\n\nOutput:\n 1\n\nExplanation:\n\nThe distance from -4 to 0 is |-4| = 4.\nThe distance from -2 to 0 is |-2| = 2.\nThe distance from 1 to 0 is |1| = 1.\nThe distance from 4 to 0 is |4| = 4.\nThe distance from 8 to 0 is |8| = 8.\nThus, the closest number to 0 in the array is 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,-1,1]\n\nOutput:\n 1\n\nExplanation:\n 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2264,
        "slug": "largest-3-same-digit-number-in-string",
        "url": "https://leetcode.com/problems/largest-3-same-digit-number-in-string/",
        "titulo": "Largest 3-Same-Digit Number in String",
        "enunciado": "You are given a string \nnum\n representing a large integer. An integer is \ngood\n if it meets the following conditions:\n\n\n\n\nIt is a \nsubstring\n of \nnum\n with length \n3\n.\n\n\nIt consists of only one unique digit.\n\n\n\n\nReturn \nthe \nmaximum good \ninteger as a \nstring\n or an empty string \n\"\"\n if no such integer exists\n.\n\n\nNote:\n\n\n\n\nA \nsubstring\n is a contiguous sequence of characters within a string.\n\n\nThere may be \nleading zeroes\n in \nnum\n or a good integer.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = \"6\n777\n133339\"\n\nOutput:\n \"777\"\n\nExplanation:\n There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = \"23\n000\n19\"\n\nOutput:\n \"000\"\n\nExplanation:\n \"000\" is the only good integer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = \"42352338\"\n\nOutput:\n \"\"\n\nExplanation:\n No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= num.length <= 1000\n\n\nnum\n only consists of digits.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2224,
        "slug": "minimum-number-of-operations-to-convert-time",
        "url": "https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/",
        "titulo": "Minimum Number of Operations to Convert Time",
        "enunciado": "You are given two strings \ncurrent\n and \ncorrect\n representing two \n24-hour times\n.\n\n\n24-hour times are formatted as \n\"HH:MM\"\n, where \nHH\n is between \n00\n and \n23\n, and \nMM\n is between \n00\n and \n59\n. The earliest 24-hour time is \n00:00\n, and the latest is \n23:59\n.\n\n\nIn one operation you can increase the time \ncurrent\n by \n1\n, \n5\n, \n15\n, or \n60\n minutes. You can perform this operation \nany\n number of times.\n\n\nReturn \nthe \nminimum number of operations\n needed to convert \ncurrent\n to \ncorrect\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n current = \"02:30\", correct = \"04:35\"\n\nOutput:\n 3\n\nExplanation:\n\nWe can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes \"03:30\".\n- Add 60 minutes to current. current becomes \"04:30\".\n- Add 5 minutes to current. current becomes \"04:35\".\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations.\n\n\nExample 2:\n\n\n\n\nInput:\n current = \"11:00\", correct = \"11:01\"\n\nOutput:\n 1\n\nExplanation:\n We only have to add one minute to current, so the minimum number of operations needed is 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ncurrent\n and \ncorrect\n are in the format \n\"HH:MM\"\n\n\ncurrent <= correct",
        "temas": [
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2255,
        "slug": "count-prefixes-of-a-given-string",
        "url": "https://leetcode.com/problems/count-prefixes-of-a-given-string/",
        "titulo": "Count Prefixes of a Given String",
        "enunciado": "You are given a string array \nwords\n and a string \ns\n, where \nwords[i]\n and \ns\n comprise only of \nlowercase English letters\n.\n\n\nReturn \nthe \nnumber of strings\n in\n \nwords\n \nthat are a \nprefix\n of\n \ns\n.\n\n\nA \nprefix\n of a string is a substring that occurs at the beginning of the string. A \nsubstring\n is a contiguous sequence of characters within a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\n\nOutput:\n 3\n\nExplanation:\n\nThe strings in words which are a prefix of s = \"abc\" are:\n\"a\", \"ab\", and \"abc\".\nThus the number of strings in words which are a prefix of s is 3.\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"a\",\"a\"], s = \"aa\"\n\nOutput:\n 2\n\nExplanation:\n\nBoth of the strings are a prefix of s. \nNote that the same string can occur multiple times in words, and it should be counted each time.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 1000\n\n\n1 <= words[i].length, s.length <= 10\n\n\nwords[i]\n and \ns\n consist of lowercase English letters \nonly\n.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2259,
        "slug": "remove-digit-from-number-to-maximize-result",
        "url": "https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/",
        "titulo": "Remove Digit From Number to Maximize Result",
        "enunciado": "You are given a string \nnumber\n representing a \npositive integer\n and a character \ndigit\n.\n\n\nReturn \nthe resulting string after removing \nexactly one occurrence\n of \ndigit\n from \nnumber\n such that the value of the resulting string in \ndecimal\n form is \nmaximized\n. The test cases are generated such that \ndigit\n occurs at least once in \nnumber\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n number = \"123\", digit = \"3\"\n\nOutput:\n \"12\"\n\nExplanation:\n There is only one '3' in \"123\". After removing '3', the result is \"12\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n number = \"1231\", digit = \"1\"\n\nOutput:\n \"231\"\n\nExplanation:\n We can remove the first '1' to get \"231\" or remove the second '1' to get \"123\".\nSince 231 > 123, we return \"231\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n number = \"551\", digit = \"5\"\n\nOutput:\n \"51\"\n\nExplanation:\n We can remove either the first or second '5' from \"551\".\nBoth result in the string \"51\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= number.length <= 100\n\n\nnumber\n consists of digits from \n'1'\n to \n'9'\n.\n\n\ndigit\n is a digit from \n'1'\n to \n'9'\n.\n\n\ndigit\n occurs at least once in \nnumber\n.",
        "temas": [
            "String",
            "Greedy",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2248,
        "slug": "intersection-of-multiple-arrays",
        "url": "https://leetcode.com/problems/intersection-of-multiple-arrays/",
        "titulo": "Intersection of Multiple Arrays",
        "enunciado": "Given a 2D integer array \nnums\n where \nnums[i]\n is a non-empty array of \ndistinct\n positive integers, return \nthe list of integers that are present in \neach array\n of\n \nnums\n sorted in \nascending order\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [[\n3\n,1,2,\n4\n,5],[1,2,\n3\n,\n4\n],[\n3\n,\n4\n,5,6]]\n\nOutput:\n [3,4]\n\nExplanation:\n \nThe only integers present in each of nums[0] = [\n3\n,1,2,\n4\n,5], nums[1] = [1,2,\n3\n,\n4\n], and nums[2] = [\n3\n,\n4\n,5,6] are 3 and 4, so we return [3,4].\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [[1,2,3],[4,5,6]]\n\nOutput:\n []\n\nExplanation:\n \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= sum(nums[i].length) <= 1000\n\n\n1 <= nums[i][j] <= 1000\n\n\nAll the values of \nnums[i]\n are \nunique\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2231,
        "slug": "largest-number-after-digit-swaps-by-parity",
        "url": "https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/",
        "titulo": "Largest Number After Digit Swaps by Parity",
        "enunciado": "You are given a positive integer \nnum\n. You may swap any two digits of \nnum\n that have the same \nparity\n (i.e. both odd digits or both even digits).\n\n\nReturn\n the \nlargest\n possible value of \nnum\n after \nany\n number of swaps.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 1234\n\nOutput:\n 3412\n\nExplanation:\n Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 65875\n\nOutput:\n 87655\n\nExplanation:\n Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 10\n9",
        "temas": [
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Sorting"
    },
    {
        "id": 2220,
        "slug": "minimum-bit-flips-to-convert-number",
        "url": "https://leetcode.com/problems/minimum-bit-flips-to-convert-number/",
        "titulo": "Minimum Bit Flips to Convert Number",
        "enunciado": "A \nbit flip\n of a number \nx\n is choosing a bit in the binary representation of \nx\n and \nflipping\n it from either \n0\n to \n1\n or \n1\n to \n0\n.\n\n\n\n\nFor example, for \nx = 7\n, the binary representation is \n111\n and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get \n110\n, flip the second bit from the right to get \n101\n, flip the fifth bit from the right (a leading zero) to get \n10111\n, etc.\n\n\n\n\nGiven two integers \nstart\n and \ngoal\n, return\n the \nminimum\n number of \nbit flips\n to convert \nstart\n to \ngoal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n start = 10, goal = 7\n\nOutput:\n 3\n\nExplanation:\n The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 101\n0\n -> 101\n1\n.\n- Flip the third bit from the right: 1\n0\n11 -> 1\n1\n11.\n- Flip the fourth bit from the right: \n1\n111 -> \n0\n111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.\n\n\nExample 2:\n\n\n\n\nInput:\n start = 3, goal = 4\n\nOutput:\n 3\n\nExplanation:\n The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 01\n1\n -> 01\n0\n.\n- Flip the second bit from the right: 0\n1\n0 -> 0\n0\n0.\n- Flip the third bit from the right: \n0\n00 -> \n1\n00.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= start, goal <= 10\n9\n\n\n\n\n \n\n\nNote:\n This question is the same as \n461: Hamming Distance.",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 2200,
        "slug": "find-all-k-distant-indices-in-an-array",
        "url": "https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/",
        "titulo": "Find All K-Distant Indices in an Array",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n and two integers \nkey\n and \nk\n. A \nk-distant index\n is an index \ni\n of \nnums\n for which there exists at least one index \nj\n such that \n|i - j| <= k\n and \nnums[j] == key\n.\n\n\nReturn \na list of all k-distant indices sorted in \nincreasing order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,9,1,3,9,5], key = 9, k = 1\n\nOutput:\n [1,2,3,4,5,6]\n\nExplanation:\n Here, \nnums[2] == key\n and \nnums[5] == key.\n- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j\n where \n|0 - j| <= k\n and \nnums[j] == key. Thus, 0 is not a k-distant index.\n- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.\n- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.\n- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.\n- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.\n- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.\n- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.\n\nThus, we return [1,2,3,4,5,6] which is sorted in increasing order. \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2], key = 2, k = 2\n\nOutput:\n [0,1,2,3,4]\n\nExplanation:\n For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. \nHence, we return [0,1,2,3,4].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 1000\n\n\nkey\n is an integer from the array \nnums\n.\n\n\n1 <= k <= nums.length",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2210,
        "slug": "count-hills-and-valleys-in-an-array",
        "url": "https://leetcode.com/problems/count-hills-and-valleys-in-an-array/",
        "titulo": "Count Hills and Valleys in an Array",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n. An index \ni\n is part of a \nhill\n in \nnums\n if the closest non-equal neighbors of \ni\n are smaller than \nnums[i]\n. Similarly, an index \ni\n is part of a \nvalley\n in \nnums\n if the closest non-equal neighbors of \ni\n are larger than \nnums[i]\n. Adjacent indices \ni\n and \nj\n are part of the \nsame\n hill or valley if \nnums[i] == nums[j]\n.\n\n\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on \nboth\n the left and right of the index.\n\n\nReturn \nthe number of hills and valleys in \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,4,1,1,6,5]\n\nOutput:\n 3\n\nExplanation:\n\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [6,6,5,5,4,1]\n\nOutput:\n 0\n\nExplanation:\n\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2190,
        "slug": "most-frequent-number-following-key-in-an-array",
        "url": "https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/",
        "titulo": "Most Frequent Number Following Key In an Array",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n.\n \nYou are also given an integer \nkey\n, which is present in \nnums\n.\n\n\nFor every unique integer \ntarget\n in \nnums\n, \ncount\n the number of times \ntarget\n immediately follows an occurrence of \nkey\n in \nnums\n. In other words, count the number of indices \ni\n such that:\n\n\n\n\n0 <= i <= nums.length - 2\n,\n\n\nnums[i] == key\n and,\n\n\nnums[i + 1] == target\n.\n\n\n\n\nReturn \nthe \ntarget\n with the \nmaximum\n count\n. The test cases will be generated such that the \ntarget\n with maximum count is unique.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,100,200,1,100], key = 1\n\nOutput:\n 100\n\nExplanation:\n For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.\nNo other integers follow an occurrence of key, so we return 100.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,3], key = 2\n\nOutput:\n 2\n\nExplanation:\n For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.\nFor target = 3, there is only one occurrence at index 4 which follows an occurrence of key.\ntarget = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 1000\n\n\nThe test cases will be generated such that the answer is unique.",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2206,
        "slug": "divide-array-into-equal-pairs",
        "url": "https://leetcode.com/problems/divide-array-into-equal-pairs/",
        "titulo": "Divide Array Into Equal Pairs",
        "enunciado": "You are given an integer array \nnums\n consisting of \n2 * n\n integers.\n\n\nYou need to divide \nnums\n into \nn\n pairs such that:\n\n\n\n\nEach element belongs to \nexactly one\n pair.\n\n\nThe elements present in a pair are \nequal\n.\n\n\n\n\nReturn \ntrue\n \nif nums can be divided into\n \nn\n \npairs, otherwise return\n \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,2,3,2,2,2]\n\nOutput:\n true\n\nExplanation:\n \nThere are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\nIf nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n false\n\nExplanation:\n \nThere is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums.length == 2 * n\n\n\n1 <= n <= 500\n\n\n1 <= nums[i] <= 500",
        "temas": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2194,
        "slug": "cells-in-a-range-on-an-excel-sheet",
        "url": "https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/",
        "titulo": "Cells in a Range on an Excel Sheet",
        "enunciado": "A cell \n(r, c)\n of an excel sheet is represented as a string \n\"<col><row>\"\n where:\n\n\n\n\n<col>\n denotes the column number \nc\n of the cell. It is represented by \nalphabetical letters\n.\n\n\t\n\n\nFor example, the \n1\nst\n column is denoted by \n'A'\n, the \n2\nnd\n by \n'B'\n, the \n3\nrd\n by \n'C'\n, and so on.\n\n\n\n\n\n\n<row>\n is the row number \nr\n of the cell. The \nr\nth\n row is represented by the \ninteger\n \nr\n.\n\n\n\n\nYou are given a string \ns\n in the format \n\"<col1><row1>:<col2><row2>\"\n, where \n<col1>\n represents the column \nc1\n, \n<row1>\n represents the row \nr1\n, \n<col2>\n represents the column \nc2\n, and \n<row2>\n represents the row \nr2\n, such that \nr1 <= r2\n and \nc1 <= c2\n.\n\n\nReturn \nthe \nlist of cells\n \n(x, y)\n \nsuch that\n \nr1 <= x <= r2\n \nand\n \nc1 <= y <= c2\n. The cells should be represented as \nstrings\n in the format mentioned above and be sorted in \nnon-decreasing\n order first by columns and then by rows.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"K1:L2\"\n\nOutput:\n [\"K1\",\"K2\",\"L1\",\"L2\"]\n\nExplanation:\n\nThe above diagram shows the cells which should be present in the list.\nThe red arrows denote the order in which the cells should be presented.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n s = \"A1:F1\"\n\nOutput:\n [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n\nExplanation:\n\nThe above diagram shows the cells which should be present in the list.\nThe red arrow denotes the order in which the cells should be presented.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ns.length == 5\n\n\n'A' <= s[0] <= s[3] <= 'Z'\n\n\n'1' <= s[1] <= s[4] <= '9'\n\n\ns\n consists of uppercase English letters, digits and \n':'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2180,
        "slug": "count-integers-with-even-digit-sum",
        "url": "https://leetcode.com/problems/count-integers-with-even-digit-sum/",
        "titulo": "Count Integers With Even Digit Sum",
        "enunciado": "Given a positive integer \nnum\n, return \nthe number of positive integers \nless than or equal to\n \nnum\n \nwhose digit sums are \neven\n.\n\n\nThe \ndigit sum\n of a positive integer is the sum of all its digits.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 4\n\nOutput:\n 2\n\nExplanation:\n\nThe only integers less than or equal to 4 whose digit sums are even are 2 and 4.    \n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 30\n\nOutput:\n 14\n\nExplanation:\n\nThe 14 integers less than or equal to 30 whose digit sums are even are\n2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 1000",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2185,
        "slug": "counting-words-with-a-given-prefix",
        "url": "https://leetcode.com/problems/counting-words-with-a-given-prefix/",
        "titulo": "Counting Words With a Given Prefix",
        "enunciado": "You are given an array of strings \nwords\n and a string \npref\n.\n\n\nReturn \nthe number of strings in \nwords\n that contain \npref\n as a \nprefix\n.\n\n\nA \nprefix\n of a string \ns\n is any leading contiguous substring of \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"pay\",\"\nat\ntention\",\"practice\",\"\nat\ntend\"], \npref \n= \"at\"\n\nOutput:\n 2\n\nExplanation:\n The 2 strings that contain \"at\" as a prefix are: \"\nat\ntention\" and \"\nat\ntend\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"leetcode\",\"win\",\"loops\",\"success\"], \npref \n= \"code\"\n\nOutput:\n 0\n\nExplanation:\n There are no strings that contain \"code\" as a prefix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length, pref.length <= 100\n\n\nwords[i]\n and \npref\n consist of lowercase English letters.",
        "temas": [
            "Array",
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2169,
        "slug": "count-operations-to-obtain-zero",
        "url": "https://leetcode.com/problems/count-operations-to-obtain-zero/",
        "titulo": "Count Operations to Obtain Zero",
        "enunciado": "You are given two \nnon-negative\n integers \nnum1\n and \nnum2\n.\n\n\nIn one \noperation\n, if \nnum1 >= num2\n, you must subtract \nnum2\n from \nnum1\n, otherwise subtract \nnum1\n from \nnum2\n.\n\n\n\n\nFor example, if \nnum1 = 5\n and \nnum2 = 4\n, subtract \nnum2\n from \nnum1\n, thus obtaining \nnum1 = 1\n and \nnum2 = 4\n. However, if \nnum1 = 4\n and \nnum2 = 5\n, after one operation, \nnum1 = 4\n and \nnum2 = 1\n.\n\n\n\n\nReturn \nthe \nnumber of operations\n required to make either\n \nnum1 = 0\n \nor\n \nnum2 = 0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = 2, num2 = 3\n\nOutput:\n 3\n\nExplanation:\n \n- Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.\n- Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.\n- Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.\nNow num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.\nSo the total number of operations required is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = 10, num2 = 10\n\nOutput:\n 1\n\nExplanation:\n \n- Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.\nNow num1 = 0 and num2 = 10. Since num1 == 0, we are done.\nSo the total number of operations required is 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num1, num2 <= 10\n5",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2164,
        "slug": "sort-even-and-odd-indices-independently",
        "url": "https://leetcode.com/problems/sort-even-and-odd-indices-independently/",
        "titulo": "Sort Even and Odd Indices Independently",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n. Rearrange the values of \nnums\n according to the following rules:\n\n\n\n\nSort the values at \nodd indices\n of \nnums\n in \nnon-increasing\n order.\n\n\t\n\n\nFor example, if \nnums = [4,\n1\n,2,\n3\n]\n before this step, it becomes \n[4,\n3\n,2,\n1\n]\n after. The values at odd indices \n1\n and \n3\n are sorted in non-increasing order.\n\n\n\n\n\n\nSort the values at \neven indices\n of \nnums\n in \nnon-decreasing\n order.\n\t\n\n\nFor example, if \nnums = [\n4\n,1,\n2\n,3]\n before this step, it becomes \n[\n2\n,1,\n4\n,3]\n after. The values at even indices \n0\n and \n2\n are sorted in non-decreasing order.\n\n\n\n\n\n\n\n\nReturn \nthe array formed after rearranging the values of\n \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,1,2,3]\n\nOutput:\n [2,3,4,1]\n\nExplanation:\n \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4,\n1\n,2,\n3\n] to [4,\n3\n,2,\n1\n].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [\n4\n,1,\n2\n,3] to [\n2\n,3,\n4\n,1].\nThus, the array formed after rearranging the values is [2,3,4,1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,1]\n\nOutput:\n [2,1]\n\nExplanation:\n \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2176,
        "slug": "count-equal-and-divisible-pairs-in-an-array",
        "url": "https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/",
        "titulo": "Count Equal and Divisible Pairs in an Array",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n of length \nn\n and an integer \nk\n, return \nthe \nnumber of pairs\n \n(i, j)\n \nwhere\n \n0 <= i < j < n\n, \nsuch that\n \nnums[i] == nums[j]\n \nand\n \n(i * j)\n \nis divisible by\n \nk\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,1,2,2,2,1,3], k = 2\n\nOutput:\n 4\n\nExplanation:\n\nThere are 4 pairs that meet all the requirements:\n- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4], k = 1\n\nOutput:\n 0\n\nExplanation:\n Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i], k <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2154,
        "slug": "keep-multiplying-found-values-by-two",
        "url": "https://leetcode.com/problems/keep-multiplying-found-values-by-two/",
        "titulo": "Keep Multiplying Found Values by Two",
        "enunciado": "You are given an array of integers \nnums\n. You are also given an integer \noriginal\n which is the first number that needs to be searched for in \nnums\n.\n\n\nYou then do the following steps:\n\n\n\n\nIf \noriginal\n is found in \nnums\n, \nmultiply\n it by two (i.e., set \noriginal = 2 * original\n).\n\n\nOtherwise, \nstop\n the process.\n\n\nRepeat\n this process with the new number as long as you keep finding the number.\n\n\n\n\nReturn \nthe \nfinal\n value of \noriginal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [5,3,6,1,12], original = 3\n\nOutput:\n 24\n\nExplanation:\n \n- 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n- 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n- 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n- 24 is not found in nums. Thus, 24 is returned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,7,9], original = 4\n\nOutput:\n 4\n\nExplanation:\n\n- 4 is not found in nums. Thus, 4 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i], original <= 1000",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2148,
        "slug": "count-elements-with-strictly-smaller-and-greater-elements",
        "url": "https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/",
        "titulo": "Count Elements With Strictly Smaller and Greater Elements ",
        "enunciado": "Given an integer array \nnums\n, return \nthe number of elements that have \nboth\n a strictly smaller and a strictly greater element appear in \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [11,7,2,15]\n\nOutput:\n 2\n\nExplanation:\n The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in \nnums\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-3,3,3,90]\n\nOutput:\n 2\n\nExplanation:\n The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in \nnums\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-10\n5\n <= nums[i] <= 10\n5",
        "temas": [
            "Array",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2160,
        "slug": "minimum-sum-of-four-digit-number-after-splitting-digits",
        "url": "https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/",
        "titulo": "Minimum Sum of Four Digit Number After Splitting Digits",
        "enunciado": "You are given a \npositive\n integer \nnum\n consisting of exactly four digits. Split \nnum\n into two new integers \nnew1\n and \nnew2\n by using the \ndigits\n found in \nnum\n. \nLeading zeros\n are allowed in \nnew1\n and \nnew2\n, and \nall\n the digits found in \nnum\n must be used.\n\n\n\n\nFor example, given \nnum = 2932\n, you have the following digits: two \n2\n's, one \n9\n and one \n3\n. Some of the possible pairs \n[new1, new2]\n are \n[22, 93]\n, \n[23, 92]\n, \n[223, 9]\n and \n[2, 329]\n.\n\n\n\n\nReturn \nthe \nminimum\n possible sum of \nnew1\n and \nnew2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 2932\n\nOutput:\n 52\n\nExplanation:\n Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.\nThe minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 4009\n\nOutput:\n 13\n\nExplanation:\n Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. \nThe minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1000 <= num <= 9999",
        "temas": [
            "Math",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2138,
        "slug": "divide-a-string-into-groups-of-size-k",
        "url": "https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/",
        "titulo": "Divide a String Into Groups of Size k",
        "enunciado": "A string \ns\n can be partitioned into groups of size \nk\n using the following procedure:\n\n\n\n\nThe first group consists of the first \nk\n characters of the string, the second group consists of the next \nk\n characters of the string, and so on. Each element can be a part of \nexactly one\n group.\n\n\nFor the last group, if the string \ndoes not\n have \nk\n characters remaining, a character \nfill\n is used to complete the group.\n\n\n\n\nNote that the partition is done so that after removing the \nfill\n character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be \ns\n.\n\n\nGiven the string \ns\n, the size of each group \nk\n and the character \nfill\n, return \na string array denoting the \ncomposition of every group\n \ns\n has been divided into, using the above procedure\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcdefghi\", k = 3, fill = \"x\"\n\nOutput:\n [\"abc\",\"def\",\"ghi\"]\n\nExplanation:\n\nThe first 3 characters \"abc\" form the first group.\nThe next 3 characters \"def\" form the second group.\nThe last 3 characters \"ghi\" form the third group.\nSince all groups can be completely filled by characters from the string, we do not need to use fill.\nThus, the groups formed are \"abc\", \"def\", and \"ghi\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abcdefghij\", k = 3, fill = \"x\"\n\nOutput:\n [\"abc\",\"def\",\"ghi\",\"jxx\"]\n\nExplanation:\n\nSimilar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\".\nFor the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.\nThus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of lowercase English letters only.\n\n\n1 <= k <= 100\n\n\nfill\n is a lowercase English letter.",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2133,
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "url": "https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/",
        "titulo": "Check if Every Row and Column Contains All Numbers",
        "enunciado": "An \nn x n\n matrix is \nvalid\n if every row and every column contains \nall\n the integers from \n1\n to \nn\n (\ninclusive\n).\n\n\nGiven an \nn x n\n integer matrix \nmatrix\n, return \ntrue\n \nif the matrix is \nvalid\n.\n Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[3,1,2],[2,3,1]]\n\nOutput:\n true\n\nExplanation:\n In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,1,1],[1,2,3],[1,2,3]]\n\nOutput:\n false\n\nExplanation:\n In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 100\n\n\n1 <= matrix[i][j] <= n",
        "temas": [
            "Array",
            "Hash Table",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2144,
        "slug": "minimum-cost-of-buying-candies-with-discount",
        "url": "https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/",
        "titulo": "Minimum Cost of Buying Candies With Discount",
        "enunciado": "A shop is selling candies at a discount. For \nevery two\n candies sold, the shop gives a \nthird\n candy for \nfree\n.\n\n\nThe customer can choose \nany\n candy to take away for free as long as the cost of the chosen candy is less than or equal to the \nminimum\n cost of the two candies bought.\n\n\n\n\nFor example, if there are \n4\n candies with costs \n1\n, \n2\n, \n3\n, and \n4\n, and the customer buys candies with costs \n2\n and \n3\n, they can take the candy with cost \n1\n for free, but not the candy with cost \n4\n.\n\n\n\n\nGiven a \n0-indexed\n integer array \ncost\n, where \ncost[i]\n denotes the cost of the \ni\nth\n candy, return \nthe \nminimum cost\n of buying \nall\n the candies\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n cost = [1,2,3]\n\nOutput:\n 5\n\nExplanation:\n We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the \nonly\n way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cost = [6,5,7,9,2,2]\n\nOutput:\n 23\n\nExplanation:\n The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n\n\n\nExample 3:\n\n\n\n\nInput:\n cost = [5,5]\n\nOutput:\n 10\n\nExplanation:\n Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= cost.length <= 100\n\n\n1 <= cost[i] <= 100",
        "temas": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2124,
        "slug": "check-if-all-as-appears-before-all-bs",
        "url": "https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/",
        "titulo": "Check if All A's Appears Before All B's",
        "enunciado": "Given a string \ns\n consisting of \nonly\n the characters \n'a'\n and \n'b'\n, return \ntrue\n \nif \nevery\n \n'a'\n \nappears before \nevery\n \n'b'\n in the string\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aaabbb\"\n\nOutput:\n true\n\nExplanation:\n\nThe 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5.\nHence, every 'a' appears before every 'b' and we return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abab\"\n\nOutput:\n false\n\nExplanation:\n\nThere is an 'a' at index 2 and a 'b' at index 1.\nHence, not every 'a' appears before every 'b' and we return false.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"bbb\"\n\nOutput:\n true\n\nExplanation:\n\nThere are no 'a's, hence, every 'a' appears before every 'b' and we return true.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns[i]\n is either \n'a'\n or \n'b'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2119,
        "slug": "a-number-after-a-double-reversal",
        "url": "https://leetcode.com/problems/a-number-after-a-double-reversal/",
        "titulo": "A Number After a Double Reversal",
        "enunciado": "Reversing\n an integer means to reverse all its digits.\n\n\n\n\nFor example, reversing \n2021\n gives \n1202\n. Reversing \n12300\n gives \n321\n as the \nleading zeros are not retained\n.\n\n\n\n\nGiven an integer \nnum\n, \nreverse\n \nnum\n to get \nreversed1\n, \nthen reverse\n \nreversed1\n to get \nreversed2\n. Return \ntrue\n \nif\n \nreversed2\n \nequals\n \nnum\n. Otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 526\n\nOutput:\n true\n\nExplanation:\n Reverse num to get 625, then reverse 625 to get 526, which equals num.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 1800\n\nOutput:\n false\n\nExplanation:\n Reverse num to get 81, then reverse 81 to get 18, which does not equal num.\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = 0\n\nOutput:\n true\n\nExplanation:\n Reverse num to get 0, then reverse 0 to get 0, which equals num.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 10\n6",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 2129,
        "slug": "capitalize-the-title",
        "url": "https://leetcode.com/problems/capitalize-the-title/",
        "titulo": "Capitalize the Title",
        "enunciado": "You are given a string \ntitle\n consisting of one or more words separated by a single space, where each word consists of English letters. \nCapitalize\n the string by changing the capitalization of each word such that:\n\n\n\n\nIf the length of the word is \n1\n or \n2\n letters, change all letters to lowercase.\n\n\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\n\n\n\nReturn \nthe \ncapitalized\n \ntitle\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n title = \"capiTalIze tHe titLe\"\n\nOutput:\n \"Capitalize The Title\"\n\nExplanation:\n\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.\n\n\n\nExample 2:\n\n\n\n\nInput:\n title = \"First leTTeR of EACH Word\"\n\nOutput:\n \"First Letter of Each Word\"\n\nExplanation:\n\nThe word \"of\" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n\n\n\nExample 3:\n\n\n\n\nInput:\n title = \"i lOve leetcode\"\n\nOutput:\n \"i Love Leetcode\"\n\nExplanation:\n\nThe word \"i\" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= title.length <= 100\n\n\ntitle\n consists of words separated by a single space without any leading or trailing spaces.\n\n\nEach word consists of uppercase and lowercase English letters and is \nnon-empty\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2108,
        "slug": "find-first-palindromic-string-in-the-array",
        "url": "https://leetcode.com/problems/find-first-palindromic-string-in-the-array/",
        "titulo": "Find First Palindromic String in the Array",
        "enunciado": "Given an array of strings \nwords\n, return \nthe first \npalindromic\n string in the array\n. If there is no such string, return \nan \nempty string\n \n\"\"\n.\n\n\nA string is \npalindromic\n if it reads the same forward and backward.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\n\nOutput:\n \"ada\"\n\nExplanation:\n The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"notapalindrome\",\"racecar\"]\n\nOutput:\n \"racecar\"\n\nExplanation:\n The first and only string that is palindromic is \"racecar\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"def\",\"ghi\"]\n\nOutput:\n \"\"\n\nExplanation:\n There are no palindromic strings, so the empty string is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n consists only of lowercase English letters.",
        "temas": [
            "Array",
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2103,
        "slug": "rings-and-rods",
        "url": "https://leetcode.com/problems/rings-and-rods/",
        "titulo": "Rings and Rods",
        "enunciado": "There are \nn\n rings and each ring is either red, green, or blue. The rings are distributed \nacross ten rods\n labeled from \n0\n to \n9\n.\n\n\nYou are given a string \nrings\n of length \n2n\n that describes the \nn\n rings that are placed onto the rods. Every two characters in \nrings\n forms a \ncolor-position pair\n that is used to describe each ring where:\n\n\n\n\nThe \nfirst\n character of the \ni\nth\n pair denotes the \ni\nth\n ring's \ncolor\n (\n'R'\n, \n'G'\n, \n'B'\n).\n\n\nThe \nsecond\n character of the \ni\nth\n pair denotes the \nrod\n that the \ni\nth\n ring is placed on (\n'0'\n to \n'9'\n).\n\n\n\n\nFor example, \n\"R3G2B1\"\n describes \nn == 3\n rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\n\nReturn \nthe number of rods that have \nall three colors\n of rings on them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n rings = \"B0B6G0R6R0R6G9\"\n\nOutput:\n 1\n\nExplanation:\n \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n rings = \"B0R0G0R9R0B0G0\"\n\nOutput:\n 1\n\nExplanation:\n \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n rings = \"G4\"\n\nOutput:\n 0\n\nExplanation:\n \nOnly one ring is given. Thus, no rods have all three colors.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrings.length == 2 * n\n\n\n1 <= n <= 100\n\n\nrings[i]\n where \ni\n is \neven\n is either \n'R'\n, \n'G'\n, or \n'B'\n (\n0-indexed\n).\n\n\nrings[i]\n where \ni\n is \nodd\n is a digit from \n'0'\n to \n'9'\n (\n0-indexed\n).",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2114,
        "slug": "maximum-number-of-words-found-in-sentences",
        "url": "https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/",
        "titulo": "Maximum Number of Words Found in Sentences",
        "enunciado": "A \nsentence\n is a list of \nwords\n that are separated by a single space with no leading or trailing spaces.\n\n\nYou are given an array of strings \nsentences\n, where each \nsentences[i]\n represents a single \nsentence\n.\n\n\nReturn \nthe \nmaximum number of words\n that appear in a single sentence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n sentences = [\"alice and bob love leetcode\", \"i think so too\", \n\"this is great thanks very much\"\n]\n\nOutput:\n 6\n\nExplanation:\n \n- The first sentence, \"alice and bob love leetcode\", has 5 words in total.\n- The second sentence, \"i think so too\", has 4 words in total.\n- The third sentence, \"this is great thanks very much\", has 6 words in total.\nThus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.\n\n\n\nExample 2:\n\n\n\n\nInput:\n sentences = [\"please wait\", \n\"continue to fight\"\n, \n\"continue to win\"\n]\n\nOutput:\n 3\n\nExplanation:\n It is possible that multiple sentences contain the same number of words. \nIn this example, the second and third sentences (underlined) have the same number of words.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentences.length <= 100\n\n\n1 <= sentences[i].length <= 100\n\n\nsentences[i]\n consists only of lowercase English letters and \n' '\n only.\n\n\nsentences[i]\n does not have leading or trailing spaces.\n\n\nAll the words in \nsentences[i]\n are separated by a single space.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2094,
        "slug": "finding-3-digit-even-numbers",
        "url": "https://leetcode.com/problems/finding-3-digit-even-numbers/",
        "titulo": "Finding 3-Digit Even Numbers",
        "enunciado": "You are given an integer array \ndigits\n, where each element is a digit. The array may contain duplicates.\n\n\nYou need to find \nall\n the \nunique\n integers that follow the given requirements:\n\n\n\n\nThe integer consists of the \nconcatenation\n of \nthree\n elements from \ndigits\n in \nany\n arbitrary order.\n\n\nThe integer does not have \nleading zeros\n.\n\n\nThe integer is \neven\n.\n\n\n\n\nFor example, if the given \ndigits\n were \n[1, 2, 3]\n, integers \n132\n and \n312\n follow the requirements.\n\n\nReturn \na \nsorted\n array of the unique integers.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = [2,1,3,0]\n\nOutput:\n [102,120,130,132,210,230,302,310,312,320]\n\nExplanation:\n All the possible integers that follow the requirements are in the output array. \nNotice that there are no \nodd\n integers or integers with \nleading zeros\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = [2,2,8,8,2]\n\nOutput:\n [222,228,282,288,822,828,882]\n\nExplanation:\n The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882. \n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = [3,7,5]\n\nOutput:\n []\n\nExplanation:\n No \neven\n integers can be formed using the given digits.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= digits.length <= 100\n\n\n0 <= digits[i] <= 9",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2089,
        "slug": "find-target-indices-after-sorting-array",
        "url": "https://leetcode.com/problems/find-target-indices-after-sorting-array/",
        "titulo": "Find Target Indices After Sorting Array",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n and a target element \ntarget\n.\n\n\nA \ntarget index\n is an index \ni\n such that \nnums[i] == target\n.\n\n\nReturn \na list of the target indices of\n \nnums\n after\n sorting \nnums\n in \nnon-decreasing\n order\n. If there are no target indices, return \nan \nempty\n list\n. The returned list must be sorted in \nincreasing\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,5,2,3], target = 2\n\nOutput:\n [1,2]\n\nExplanation:\n After sorting, nums is [1,\n2\n,\n2\n,3,5].\nThe indices where nums[i] == 2 are 1 and 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,5,2,3], target = 3\n\nOutput:\n [3]\n\nExplanation:\n After sorting, nums is [1,2,2,\n3\n,5].\nThe index where nums[i] == 3 is 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,5,2,3], target = 5\n\nOutput:\n [4]\n\nExplanation:\n After sorting, nums is [1,2,2,3,\n5\n].\nThe index where nums[i] == 5 is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i], target <= 100",
        "temas": [
            "Array",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2099,
        "slug": "find-subsequence-of-length-k-with-the-largest-sum",
        "url": "https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/",
        "titulo": "Find Subsequence of Length K With the Largest Sum",
        "enunciado": "You are given an integer array \nnums\n and an integer \nk\n. You want to find a \nsubsequence \nof \nnums\n of length \nk\n that has the \nlargest\n sum.\n\n\nReturn\n \nany\n such subsequence as an integer array of length \nk\n.\n\n\nA \nsubsequence\n is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,1,3,3], k = 2\n\nOutput:\n [3,3]\n\nExplanation:\n\nThe subsequence has the largest sum of 3 + 3 = 6.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,-2,3,4], k = 3\n\nOutput:\n [-1,3,4]\n\nExplanation:\n \nThe subsequence has the largest sum of -1 + 3 + 4 = 6.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,4,3,3], k = 2\n\nOutput:\n [3,4]\n\nExplanation:\n\nThe subsequence has the largest sum of 3 + 4 = 7. \nAnother possible subsequence is [4, 3].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-10\n5\n <= nums[i] <= 10\n5\n\n\n1 <= k <= nums.length",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2078,
        "slug": "two-furthest-houses-with-different-colors",
        "url": "https://leetcode.com/problems/two-furthest-houses-with-different-colors/",
        "titulo": "Two Furthest Houses With Different Colors",
        "enunciado": "There are \nn\n houses evenly lined up on the street, and each house is beautifully painted. You are given a \n0-indexed\n integer array \ncolors\n of length \nn\n, where \ncolors[i]\n represents the color of the \ni\nth\n house.\n\n\nReturn \nthe \nmaximum\n distance between \ntwo\n houses with \ndifferent\n colors\n.\n\n\nThe distance between the \ni\nth\n and \nj\nth\n houses is \nabs(i - j)\n, where \nabs(x)\n is the \nabsolute value\n of \nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n colors = [\n1\n,1,1,\n6\n,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n colors = [\n1\n,8,3,8,\n3\n]\n\nOutput:\n 4\n\nExplanation:\n In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n colors = [\n0\n,\n1\n]\n\nOutput:\n 1\n\nExplanation:\n The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == colors.length\n\n\n2 <= n <= 100\n\n\n0 <= colors[i] <= 100\n\n\nTest data are generated such that \nat least\n two houses have different colors.",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2073,
        "slug": "time-needed-to-buy-tickets",
        "url": "https://leetcode.com/problems/time-needed-to-buy-tickets/",
        "titulo": "Time Needed to Buy Tickets",
        "enunciado": "There are \nn\n people in a line queuing to buy tickets, where the \n0\nth\n person is at the \nfront\n of the line and the \n(n - 1)\nth\n person is at the \nback\n of the line.\n\n\nYou are given a \n0-indexed\n integer array \ntickets\n of length \nn\n where the number of tickets that the \ni\nth\n person would like to buy is \ntickets[i]\n.\n\n\nEach person takes \nexactly 1 second\n to buy a ticket. A person can only buy \n1 ticket at a time\n and has to go back to \nthe end\n of the line (which happens \ninstantaneously\n) in order to buy more tickets. If a person does not have any tickets left to buy, the person will \nleave \nthe line.\n\n\nReturn the \ntime taken\n for the person \ninitially\n at position \nk\n \n(0-indexed) to finish buying tickets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ntickets = [2,3,2], k = 2\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\n\nThe queue starts as [2,3,\n2\n], where the kth person is underlined.\n\n\nAfter the person at the front has bought a ticket, the queue becomes [3,\n2\n,1] at 1 second.\n\n\nContinuing this process, the queue becomes [\n2\n,1,2] at 2 seconds.\n\n\nContinuing this process, the queue becomes [1,2,\n1\n] at 3 seconds.\n\n\nContinuing this process, the queue becomes [2,\n1\n] at 4 seconds. Note: the person at the front left the queue.\n\n\nContinuing this process, the queue becomes [\n1\n,1] at 5 seconds.\n\n\nContinuing this process, the queue becomes [1] at 6 seconds. The kth person has bought all their tickets, so return 6.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ntickets = [5,1,1,1], k = 0\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\nThe queue starts as [\n5\n,1,1,1], where the kth person is underlined.\n\n\nAfter the person at the front has bought a ticket, the queue becomes [1,1,1,\n4\n] at 1 second.\n\n\nContinuing this process for 3 seconds, the queue becomes [\n4]\n at 4 seconds.\n\n\nContinuing this process for 4 seconds, the queue becomes [] at 8 seconds. The kth person has bought all their tickets, so return 8.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == tickets.length\n\n\n1 <= n <= 100\n\n\n1 <= tickets[i] <= 100\n\n\n0 <= k < n",
        "temas": [
            "Array",
            "Queue",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2085,
        "slug": "count-common-words-with-one-occurrence",
        "url": "https://leetcode.com/problems/count-common-words-with-one-occurrence/",
        "titulo": "Count Common Words With One Occurrence",
        "enunciado": "Given two string arrays \nwords1\n and \nwords2\n, return \nthe number of strings that appear \nexactly once\n in \neach\n of the two arrays.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n\nOutput:\n 2\n\nExplanation:\n\n- \"leetcode\" appears exactly once in each of the two arrays. We count this string.\n- \"amazing\" appears exactly once in each of the two arrays. We count this string.\n- \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n- \"as\" appears once in words1, but does not appear in words2. We do not count this string.\nThus, there are 2 strings that appear exactly once in each of the two arrays.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n\nOutput:\n 0\n\nExplanation:\n There are no strings that appear in each of the two arrays.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n\nOutput:\n 1\n\nExplanation:\n The only string that appears exactly once in each of the two arrays is \"ab\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words1.length, words2.length <= 1000\n\n\n1 <= words1[i].length, words2[j].length <= 30\n\n\nwords1[i]\n and \nwords2[j]\n consists only of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2062,
        "slug": "count-vowel-substrings-of-a-string",
        "url": "https://leetcode.com/problems/count-vowel-substrings-of-a-string/",
        "titulo": "Count Vowel Substrings of a String",
        "enunciado": "A \nsubstring\n is a contiguous (non-empty) sequence of characters within a string.\n\n\nA \nvowel substring\n is a substring that \nonly\n consists of vowels (\n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, and \n'u'\n) and has \nall five\n vowels present in it.\n\n\nGiven a string \nword\n, return \nthe number of \nvowel substrings\n in\n \nword\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"aeiouu\"\n\nOutput:\n 2\n\nExplanation:\n The vowel substrings of word are as follows (underlined):\n- \"\naeiou\nu\"\n- \"\naeiouu\n\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"unicornarihan\"\n\nOutput:\n 0\n\nExplanation:\n Not all 5 vowels are present, so there are no vowel substrings.\n\n\n\nExample 3:\n\n\n\n\nInput:\n word = \"cuaieuouac\"\n\nOutput:\n 7\n\nExplanation:\n The vowel substrings of word are as follows (underlined):\n- \"c\nuaieuo\nuac\"\n- \"c\nuaieuou\nac\"\n- \"c\nuaieuoua\nc\"\n- \"cu\naieuo\nuac\"\n- \"cu\naieuou\nac\"\n- \"cu\naieuoua\nc\"\n- \"cua\nieuoua\nc\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 100\n\n\nword\n consists of lowercase English letters only.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2057,
        "slug": "smallest-index-with-equal-value",
        "url": "https://leetcode.com/problems/smallest-index-with-equal-value/",
        "titulo": "Smallest Index With Equal Value",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n, return \nthe \nsmallest\n index \ni\n of \nnums\n such that \ni mod 10 == nums[i]\n, or \n-1\n if such index does not exist\n.\n\n\nx mod y\n denotes the \nremainder\n when \nx\n is divided by \ny\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1,2]\n\nOutput:\n 0\n\nExplanation:\n \ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\nAll indices have i mod 10 == nums[i], so we return the smallest index 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,3,2,1]\n\nOutput:\n 2\n\nExplanation:\n \ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 is the only index which has i mod 10 == nums[i].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,4,5,6,7,8,9,0]\n\nOutput:\n -1\n\nExplanation:\n No index satisfies i mod 10 == nums[i].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 9",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2068,
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "url": "https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/",
        "titulo": "Check Whether Two Strings are Almost Equivalent",
        "enunciado": "Two strings \nword1\n and \nword2\n are considered \nalmost equivalent\n if the differences between the frequencies of each letter from \n'a'\n to \n'z'\n between \nword1\n and \nword2\n is \nat most\n \n3\n.\n\n\nGiven two strings \nword1\n and \nword2\n, each of length \nn\n, return \ntrue\n \nif \nword1\n \nand\n \nword2\n \nare \nalmost equivalent\n, or\n \nfalse\n \notherwise\n.\n\n\nThe \nfrequency\n of a letter \nx\n is the number of times it occurs in the string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word1 = \"aaaa\", word2 = \"bccb\"\n\nOutput:\n false\n\nExplanation:\n There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n word1 = \"abcdeef\", word2 = \"abaaacc\"\n\nOutput:\n true\n\nExplanation:\n The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n word1 = \"cccddabba\", word2 = \"babababab\"\n\nOutput:\n true\n\nExplanation:\n The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == word1.length == word2.length\n\n\n1 <= n <= 100\n\n\nword1\n and \nword2\n consist only of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2047,
        "slug": "number-of-valid-words-in-a-sentence",
        "url": "https://leetcode.com/problems/number-of-valid-words-in-a-sentence/",
        "titulo": "Number of Valid Words in a Sentence",
        "enunciado": "A sentence consists of lowercase letters (\n'a'\n to \n'z'\n), digits (\n'0'\n to \n'9'\n), hyphens (\n'-'\n), punctuation marks (\n'!'\n, \n'.'\n, and \n','\n), and spaces (\n' '\n) only. Each sentence can be broken down into \none or more tokens\n separated by one or more spaces \n' '\n.\n\n\nA token is a valid word if \nall three\n of the following are true:\n\n\n\n\nIt only contains lowercase letters, hyphens, and/or punctuation (\nno\n digits).\n\n\nThere is \nat most one\n hyphen \n'-'\n. If present, it \nmust\n be surrounded by lowercase characters (\n\"a-b\"\n is valid, but \n\"-ab\"\n and \n\"ab-\"\n are not valid).\n\n\nThere is \nat most one\n punctuation mark. If present, it \nmust\n be at the \nend\n of the token (\n\"ab,\"\n, \n\"cd!\"\n, and \n\".\"\n are valid, but \n\"a!b\"\n and \n\"c.,\"\n are not valid).\n\n\n\n\nExamples of valid words include \n\"a-b.\"\n, \n\"afad\"\n, \n\"ba-c\"\n, \n\"a!\"\n, and \n\"!\"\n.\n\n\nGiven a string \nsentence\n, return \nthe \nnumber\n of valid words in \nsentence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n sentence = \"\ncat\n \nand\n  \ndog\n\"\n\nOutput:\n 3\n\nExplanation:\n The valid words in the sentence are \"cat\", \"and\", and \"dog\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n sentence = \"!this  1-s b8d!\"\n\nOutput:\n 0\n\nExplanation:\n There are no valid words in the sentence.\n\"!this\" is invalid because it starts with a punctuation mark.\n\"1-s\" and \"b8d\" are invalid because they contain digits.\n\n\n\nExample 3:\n\n\n\n\nInput:\n sentence = \"\nalice\n \nand\n  \nbob\n \nare\n \nplaying\n stone-game10\"\n\nOutput:\n 5\n\nExplanation:\n The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\".\n\"stone-game10\" is invalid because it contains digits.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 1000\n\n\nsentence\n only contains lowercase English letters, digits, \n' '\n, \n'-'\n, \n'!'\n, \n'.'\n, and \n','\n.\n\n\nThere will be at least \n1\n token.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2042,
        "slug": "check-if-numbers-are-ascending-in-a-sentence",
        "url": "https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/",
        "titulo": "Check if Numbers Are Ascending in a Sentence",
        "enunciado": "A sentence is a list of \ntokens\n separated by a \nsingle\n space with no leading or trailing spaces. Every token is either a \npositive number\n consisting of digits \n0-9\n with no leading zeros, or a \nword\n consisting of lowercase English letters.\n\n\n\n\nFor example, \n\"a puppy has 2 eyes 4 legs\"\n is a sentence with seven tokens: \n\"2\"\n and \n\"4\"\n are numbers and the other tokens such as \n\"puppy\"\n are words.\n\n\n\n\nGiven a string \ns\n representing a sentence, you need to check if \nall\n the numbers in \ns\n are \nstrictly increasing\n from left to right (i.e., other than the last number, \neach\n number is \nstrictly smaller\n than the number on its \nright\n in \ns\n).\n\n\nReturn \ntrue\n if so, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n\nOutput:\n true\n\nExplanation:\n The numbers in s are: 1, 3, 4, 6, 12.\nThey are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"hello world 5 x 5\"\n\nOutput:\n false\n\nExplanation:\n The numbers in s are: \n5\n, \n5\n. They are not strictly increasing.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n\nOutput:\n false\n\nExplanation:\n The numbers in s are: 7, \n51\n, \n50\n, 60. They are not strictly increasing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 200\n\n\ns\n consists of lowercase English letters, spaces, and digits from \n0\n to \n9\n, inclusive.\n\n\nThe number of tokens in \ns\n is between \n2\n and \n100\n, inclusive.\n\n\nThe tokens in \ns\n are separated by a single space.\n\n\nThere are at least \ntwo\n numbers in \ns\n.\n\n\nEach number in \ns\n is a \npositive\n number \nless\n than \n100\n, with no leading zeros.\n\n\ns\n contains no leading or trailing spaces.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2053,
        "slug": "kth-distinct-string-in-an-array",
        "url": "https://leetcode.com/problems/kth-distinct-string-in-an-array/",
        "titulo": "Kth Distinct String in an Array",
        "enunciado": "A \ndistinct string\n is a string that is present only \nonce\n in an array.\n\n\nGiven an array of strings \narr\n, and an integer \nk\n, return \nthe \nk\nth\n \ndistinct string\n present in \narr\n. If there are \nfewer\n than \nk\n distinct strings, return \nan \nempty string \n\"\"\n.\n\n\nNote that the strings are considered in the \norder in which they appear\n in the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2\n\nOutput:\n \"a\"\n\nExplanation:\n\nThe only distinct strings in arr are \"d\" and \"a\".\n\"d\" appears 1\nst\n, so it is the 1\nst\n distinct string.\n\"a\" appears 2\nnd\n, so it is the 2\nnd\n distinct string.\nSince k == 2, \"a\" is returned. \n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [\"aaa\",\"aa\",\"a\"], k = 1\n\nOutput:\n \"aaa\"\n\nExplanation:\n\nAll strings in arr are distinct, so the 1\nst\n string \"aaa\" is returned.\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [\"a\",\"b\",\"a\"], k = 3\n\nOutput:\n \"\"\n\nExplanation:\n\nThe only distinct string is \"b\". Since there are fewer than 3 distinct strings, we return an empty string \"\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= arr.length <= 1000\n\n\n1 <= arr[i].length <= 5\n\n\narr[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2032,
        "slug": "two-out-of-three",
        "url": "https://leetcode.com/problems/two-out-of-three/",
        "titulo": "Two Out of Three",
        "enunciado": "Given three integer arrays \nnums1\n, \nnums2\n, and \nnums3\n, return \na \ndistinct\n array containing all the values that are present in \nat least two\n out of the three arrays. You may return the values in \nany\n order\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\n\nOutput:\n [3,2]\n\nExplanation:\n The values that are present in at least two arrays are:\n- 3, in all three arrays.\n- 2, in nums1 and nums2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\n\nOutput:\n [2,3,1]\n\nExplanation:\n The values that are present in at least two arrays are:\n- 2, in nums2 and nums3.\n- 3, in nums1 and nums2.\n- 1, in nums1 and nums3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\n\nOutput:\n []\n\nExplanation:\n No value is present in at least two arrays.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length, nums3.length <= 100\n\n\n1 <= nums1[i], nums2[j], nums3[k] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2027,
        "slug": "minimum-moves-to-convert-string",
        "url": "https://leetcode.com/problems/minimum-moves-to-convert-string/",
        "titulo": "Minimum Moves to Convert String",
        "enunciado": "You are given a string \ns\n consisting of \nn\n characters which are either \n'X'\n or \n'O'\n.\n\n\nA \nmove\n is defined as selecting \nthree\n \nconsecutive characters\n of \ns\n and converting them to \n'O'\n. Note that if a move is applied to the character \n'O'\n, it will stay the \nsame\n.\n\n\nReturn \nthe \nminimum\n number of moves required so that all the characters of \ns\n are converted to \n'O'\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"XXX\"\n\nOutput:\n 1\n\nExplanation:\n \nXXX\n -> OOO\nWe select all the 3 characters and convert them in one move.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"XXOX\"\n\nOutput:\n 2\n\nExplanation:\n \nXXO\nX -> O\nOOX\n -> OOOO\nWe select the first 3 characters in the first move, and convert them to \n'O'\n.\nThen we select the last 3 characters and convert them so that the final string contains all \n'O'\ns.\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"OOOO\"\n\nOutput:\n 0\n\nExplanation:\n There are no \n'X's\n in \ns\n to convert.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 1000\n\n\ns[i]\n is either \n'X'\n or \n'O'\n.",
        "temas": [
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2037,
        "slug": "minimum-number-of-moves-to-seat-everyone",
        "url": "https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/",
        "titulo": "Minimum Number of Moves to Seat Everyone",
        "enunciado": "There are \nn\n \navailabe \nseats and \nn\n students \nstanding\n in a room. You are given an array \nseats\n of length \nn\n, where \nseats[i]\n is the position of the \ni\nth\n seat. You are also given the array \nstudents\n of length \nn\n, where \nstudents[j]\n is the position of the \nj\nth\n student.\n\n\nYou may perform the following move any number of times:\n\n\n\n\nIncrease or decrease the position of the \ni\nth\n student by \n1\n (i.e., moving the \ni\nth\n student from position \nx\n to \nx + 1\n or \nx - 1\n)\n\n\n\n\nReturn \nthe \nminimum number of moves\n required to move each student to a seat\n such that no two students are in the same seat.\n\n\nNote that there may be \nmultiple\n seats or students in the \nsame \nposition at the beginning.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n seats = [3,1,5], students = [2,7,4]\n\nOutput:\n 4\n\nExplanation:\n The students are moved as follows:\n- The first student is moved from position 2 to position 1 using 1 move.\n- The second student is moved from position 7 to position 5 using 2 moves.\n- The third student is moved from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\n\n\nExample 2:\n\n\n\n\nInput:\n seats = [4,1,5,9], students = [1,3,2,6]\n\nOutput:\n 7\n\nExplanation:\n The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from position 3 to position 4 using 1 move.\n- The third student is moved from position 2 to position 5 using 3 moves.\n- The fourth student is moved from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\n\n\nExample 3:\n\n\n\n\nInput:\n seats = [2,2,6,6], students = [1,3,2,6]\n\nOutput:\n 4\n\nExplanation:\n Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from position 1 to position 2 using 1 move.\n- The second student is moved from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == seats.length == students.length\n\n\n1 <= n <= 100\n\n\n1 <= seats[i], students[j] <= 100",
        "temas": [
            "Array",
            "Greedy",
            "Sorting",
            "Counting Sort"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2016,
        "slug": "maximum-difference-between-increasing-elements",
        "url": "https://leetcode.com/problems/maximum-difference-between-increasing-elements/",
        "titulo": "Maximum Difference Between Increasing Elements",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n of size \nn\n, find the \nmaximum difference\n between \nnums[i]\n and \nnums[j]\n (i.e., \nnums[j] - nums[i]\n), such that \n0 <= i < j < n\n and \nnums[i] < nums[j]\n.\n\n\nReturn \nthe \nmaximum difference\n. \nIf no such \ni\n and \nj\n exists, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [7,\n1\n,\n5\n,4]\n\nOutput:\n 4\n\nExplanation:\n\nThe maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [9,4,3,2]\n\nOutput:\n -1\n\nExplanation:\n\nThere is no i and j such that i < j and nums[i] < nums[j].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [\n1\n,5,2,\n10\n]\n\nOutput:\n 9\n\nExplanation:\n\nThe maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n2 <= n <= 1000\n\n\n1 <= nums[i] <= 10\n9",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2011,
        "slug": "final-value-of-variable-after-performing-operations",
        "url": "https://leetcode.com/problems/final-value-of-variable-after-performing-operations/",
        "titulo": "Final Value of Variable After Performing Operations",
        "enunciado": "There is a programming language with only \nfour\n operations and \none\n variable \nX\n:\n\n\n\n\n++X\n and \nX++\n \nincrements\n the value of the variable \nX\n by \n1\n.\n\n\n--X\n and \nX--\n \ndecrements\n the value of the variable \nX\n by \n1\n.\n\n\n\n\nInitially, the value of \nX\n is \n0\n.\n\n\nGiven an array of strings \noperations\n containing a list of operations, return \nthe \nfinal \nvalue of \nX\n \nafter performing all the operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n operations = [\"--X\",\"X++\",\"X++\"]\n\nOutput:\n 1\n\nExplanation:\n The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n operations = [\"++X\",\"++X\",\"X++\"]\n\nOutput:\n 3\n\nExplanation: \nThe operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n\nOutput:\n 0\n\nExplanation:\n The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= operations.length <= 100\n\n\noperations[i]\n will be either \n\"++X\"\n, \n\"X++\"\n, \n\"--X\"\n, or \n\"X--\"\n.",
        "temas": [
            "Array",
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2022,
        "slug": "convert-1d-array-into-2d-array",
        "url": "https://leetcode.com/problems/convert-1d-array-into-2d-array/",
        "titulo": "Convert 1D Array Into 2D Array",
        "enunciado": "You are given a \n0-indexed\n 1-dimensional (1D) integer array \noriginal\n, and two integers, \nm\n and \nn\n. You are tasked with creating a 2-dimensional (2D) array with \n m\n rows and \nn\n columns using \nall\n the elements from \noriginal\n.\n\n\nThe elements from indices \n0\n to \nn - 1\n (\ninclusive\n) of \noriginal\n should form the first row of the constructed 2D array, the elements from indices \nn\n to \n2 * n - 1\n (\ninclusive\n) should form the second row of the constructed 2D array, and so on.\n\n\nReturn \nan \nm x n\n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n original = [1,2,3,4], m = 2, n = 2\n\nOutput:\n [[1,2],[3,4]]\n\nExplanation:\n The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\n\n\nExample 2:\n\n\n\n\nInput:\n original = [1,2,3], m = 1, n = 3\n\nOutput:\n [[1,2,3]]\n\nExplanation:\n The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\n\n\nExample 3:\n\n\n\n\nInput:\n original = [1,2], m = 1, n = 1\n\nOutput:\n []\n\nExplanation:\n There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= original.length <= 5 * 10\n4\n\n\n1 <= original[i] <= 10\n5\n\n\n1 <= m, n <= 4 * 10\n4",
        "temas": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2000,
        "slug": "reverse-prefix-of-word",
        "url": "https://leetcode.com/problems/reverse-prefix-of-word/",
        "titulo": "Reverse Prefix of Word",
        "enunciado": "Given a \n0-indexed\n string \nword\n and a character \nch\n, \nreverse\n the segment of \nword\n that starts at index \n0\n and ends at the index of the \nfirst occurrence\n of \nch\n (\ninclusive\n). If the character \nch\n does not exist in \nword\n, do nothing.\n\n\n\n\nFor example, if \nword = \"abcdefd\"\n and \nch = \"d\"\n, then you should \nreverse\n the segment that starts at \n0\n and ends at \n3\n (\ninclusive\n). The resulting string will be \n\"\ndcba\nefd\"\n.\n\n\n\n\nReturn \nthe resulting string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"\nabcd\nefd\", ch = \"d\"\n\nOutput:\n \"\ndcba\nefd\"\n\nExplanation:\n The first occurrence of \"d\" is at index 3. \nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"\nxyxz\nxe\", ch = \"z\"\n\nOutput:\n \"\nzxyx\nxe\"\n\nExplanation:\n The first and only occurrence of \"z\" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n word = \"abcd\", ch = \"z\"\n\nOutput:\n \"abcd\"\n\nExplanation:\n \"z\" does not exist in word.\nYou should not do any reverse operation, the resulting string is \"abcd\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 250\n\n\nword\n consists of lowercase English letters.\n\n\nch\n is a lowercase English letter.",
        "temas": [
            "Two Pointers",
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 1995,
        "slug": "count-special-quadruplets",
        "url": "https://leetcode.com/problems/count-special-quadruplets/",
        "titulo": "Count Special Quadruplets",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n, return \nthe number of \ndistinct\n quadruplets\n \n(a, b, c, d)\n \nsuch that:\n\n\n\n\nnums[a] + nums[b] + nums[c] == nums[d]\n, and\n\n\na < b < c < d\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,6]\n\nOutput:\n 1\n\nExplanation:\n The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,3,6,4,5]\n\nOutput:\n 0\n\nExplanation:\n There are no such quadruplets in [3,3,6,4,5].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,1,3,5]\n\nOutput:\n 4\n\nExplanation:\n The 4 quadruplets that satisfy the requirement are:\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n4 <= nums.length <= 50\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1971,
        "slug": "find-if-path-exists-in-graph",
        "url": "https://leetcode.com/problems/find-if-path-exists-in-graph/",
        "titulo": "Find if Path Exists in Graph",
        "enunciado": "There is a \nbi-directional\n graph with \nn\n vertices, where each vertex is labeled from \n0\n to \nn - 1\n (\ninclusive\n). The edges in the graph are represented as a 2D integer array \nedges\n, where each \nedges[i] = [u\ni\n, v\ni\n]\n denotes a bi-directional edge between vertex \nu\ni\n and vertex \nv\ni\n. Every vertex pair is connected by \nat most one\n edge, and no vertex has an edge to itself.\n\n\nYou want to determine if there is a \nvalid path\n that exists from vertex \nsource\n to vertex \ndestination\n.\n\n\nGiven \nedges\n and the integers \nn\n, \nsource\n, and \ndestination\n, return \ntrue\n if there is a \nvalid path\n from \nsource\n to \ndestination\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\n\nOutput:\n true\n\nExplanation:\n There are two paths from vertex 0 to vertex 2:\n- 0 → 1 → 2\n- 0 → 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\n\nOutput:\n false\n\nExplanation:\n There is no path from vertex 0 to vertex 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n5\n\n\n0 <= edges.length <= 2 * 10\n5\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\nu\ni\n != v\ni\n\n\n0 <= source, destination <= n - 1\n\n\nThere are no duplicate edges.\n\n\nThere are no self edges.",
        "temas": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Depth-First Search"
    },
    {
        "id": 2006,
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "url": "https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/",
        "titulo": "Count Number of Pairs With Absolute Difference K",
        "enunciado": "Given an integer array \nnums\n and an integer \nk\n, return \nthe number of pairs\n \n(i, j)\n \nwhere\n \ni < j\n \nsuch that\n \n|nums[i] - nums[j]| == k\n.\n\n\nThe value of \n|x|\n is defined as:\n\n\n\n\nx\n if \nx >= 0\n.\n\n\n-x\n if \nx < 0\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,2,1], k = 1\n\nOutput:\n 4\n\nExplanation:\n The pairs with an absolute difference of 1 are:\n- [\n1\n,\n2\n,2,1]\n- [\n1\n,2,\n2\n,1]\n- [1,\n2\n,2,\n1\n]\n- [1,2,\n2\n,\n1\n]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3], k = 3\n\nOutput:\n 0\n\nExplanation:\n There are no pairs with an absolute difference of 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,2,1,5,4], k = 2\n\nOutput:\n 3\n\nExplanation:\n The pairs with an absolute difference of 2 are:\n- [\n3\n,2,\n1\n,5,4]\n- [\n3\n,2,1,\n5\n,4]\n- [3,\n2\n,1,5,\n4\n]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 200\n\n\n1 <= nums[i] <= 100\n\n\n1 <= k <= 99",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1984,
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "url": "https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/",
        "titulo": "Minimum Difference Between Highest and Lowest of K Scores",
        "enunciado": "You are given a \n0-indexed\n integer array \nnums\n, where \nnums[i]\n represents the score of the \ni\nth\n student. You are also given an integer \nk\n.\n\n\nPick the scores of any \nk\n students from the array so that the \ndifference\n between the \nhighest\n and the \nlowest\n of the \nk\n scores is \nminimized\n.\n\n\nReturn \nthe \nminimum\n possible difference\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [90], k = 1\n\nOutput:\n 0\n\nExplanation:\n There is one way to pick score(s) of one student:\n- [\n90\n]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [9,4,1,7], k = 2\n\nOutput:\n 2\n\nExplanation:\n There are six ways to pick score(s) of two students:\n- [\n9\n,\n4\n,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [\n9\n,4,\n1\n,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [\n9\n,4,1,\n7\n]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,\n4\n,\n1\n,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,\n4\n,1,\n7\n]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,\n1\n,\n7\n]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 1000\n\n\n0 <= nums[i] <= 10\n5",
        "temas": [
            "Array",
            "Sliding Window",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1979,
        "slug": "find-greatest-common-divisor-of-array",
        "url": "https://leetcode.com/problems/find-greatest-common-divisor-of-array/",
        "titulo": "Find Greatest Common Divisor of Array",
        "enunciado": "Given an integer array \nnums\n, return\n \nthe \ngreatest common divisor\n of the smallest number and largest number in \nnums\n.\n\n\nThe \ngreatest common divisor\n of two numbers is the largest positive integer that evenly divides both numbers.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,5,6,9,10]\n\nOutput:\n 2\n\nExplanation:\n\nThe smallest number in nums is 2.\nThe largest number in nums is 10.\nThe greatest common divisor of 2 and 10 is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [7,5,6,8,3]\n\nOutput:\n 1\n\nExplanation:\n\nThe smallest number in nums is 3.\nThe largest number in nums is 8.\nThe greatest common divisor of 3 and 8 is 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3]\n\nOutput:\n 3\n\nExplanation:\n\nThe smallest number in nums is 3.\nThe largest number in nums is 3.\nThe greatest common divisor of 3 and 3 is 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Math",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1991,
        "slug": "find-the-middle-index-in-array",
        "url": "https://leetcode.com/problems/find-the-middle-index-in-array/",
        "titulo": "Find the Middle Index in Array",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n, find the \nleftmost\n \nmiddleIndex\n (i.e., the smallest amongst all the possible ones).\n\n\nA \nmiddleIndex\n is an index where \nnums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]\n.\n\n\nIf \nmiddleIndex == 0\n, the left side sum is considered to be \n0\n. Similarly, if \nmiddleIndex == nums.length - 1\n, the right side sum is considered to be \n0\n.\n\n\nReturn \nthe \nleftmost\n \nmiddleIndex\n that satisfies the condition, or \n-1\n if there is no such index\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,-1,\n8\n,4]\n\nOutput:\n 3\n\nExplanation:\n The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,-1,\n4\n]\n\nOutput:\n 2\n\nExplanation:\n The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,5]\n\nOutput:\n -1\n\nExplanation:\n There is no valid middleIndex.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-1000 <= nums[i] <= 1000\n\n\n\n\n \n\n\nNote:\n This question is the same as 724: \nhttps://leetcode.com/problems/find-pivot-index/",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1967,
        "slug": "number-of-strings-that-appear-as-substrings-in-word",
        "url": "https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/",
        "titulo": "Number of Strings That Appear as Substrings in Word",
        "enunciado": "Given an array of strings \npatterns\n and a string \nword\n, return \nthe \nnumber\n of strings in \npatterns\n that exist as a \nsubstring\n in \nword\n.\n\n\nA \nsubstring\n is a contiguous sequence of characters within a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"\n\nOutput:\n 3\n\nExplanation:\n\n- \"a\" appears as a substring in \"\na\nbc\".\n- \"abc\" appears as a substring in \"\nabc\n\".\n- \"bc\" appears as a substring in \"a\nbc\n\".\n- \"d\" does not appear as a substring in \"abc\".\n3 of the strings in patterns appear as a substring in word.\n\n\n\nExample 2:\n\n\n\n\nInput:\n patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"\n\nOutput:\n 2\n\nExplanation:\n\n- \"a\" appears as a substring in \"a\na\naaabbbbb\".\n- \"b\" appears as a substring in \"aaaaabbbb\nb\n\".\n- \"c\" does not appear as a substring in \"aaaaabbbbb\".\n2 of the strings in patterns appear as a substring in word.\n\n\n\nExample 3:\n\n\n\n\nInput:\n patterns = [\"a\",\"a\",\"a\"], word = \"ab\"\n\nOutput:\n 3\n\nExplanation:\n Each of the patterns appears as a substring in word \"\na\nb\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= patterns.length <= 100\n\n\n1 <= patterns[i].length <= 100\n\n\n1 <= word.length <= 100\n\n\npatterns[i]\n and \nword\n consist of lowercase English letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1961,
        "slug": "check-if-string-is-a-prefix-of-array",
        "url": "https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/",
        "titulo": "Check If String Is a Prefix of Array",
        "enunciado": "Given a string \ns\n and an array of strings \nwords\n, determine whether \ns\n is a \nprefix string\n of \nwords\n.\n\n\nA string \ns\n is a \nprefix string\n of \nwords\n if \ns\n can be made by concatenating the first \nk\n strings in \nwords\n for some \npositive\n \nk\n no larger than \nwords.length\n.\n\n\nReturn \ntrue\n if \ns\n is a \nprefix string\n of \nwords\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]\n\nOutput:\n true\n\nExplanation:\n\ns can be made by concatenating \"i\", \"love\", and \"leetcode\" together.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]\n\nOutput:\n false\n\nExplanation:\n\nIt is impossible to make s using a prefix of arr.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 20\n\n\n1 <= s.length <= 1000\n\n\nwords[i]\n and \ns\n consist of only lowercase English letters.",
        "temas": [
            "Array",
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1974,
        "slug": "minimum-time-to-type-word-using-special-typewriter",
        "url": "https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/",
        "titulo": "Minimum Time to Type Word Using Special Typewriter",
        "enunciado": "There is a special typewriter with lowercase English letters \n'a'\n to \n'z'\n arranged in a \ncircle\n with a \npointer\n. A character can \nonly\n be typed if the pointer is pointing to that character. The pointer is \ninitially\n pointing to the character \n'a'\n.\n\n\n\n\nEach second, you may perform one of the following operations:\n\n\n\n\nMove the pointer one character \ncounterclockwise\n or \nclockwise\n.\n\n\nType the character the pointer is \ncurrently\n on.\n\n\n\n\nGiven a string \nword\n, return the\n minimum\n number of seconds to type out the characters in \nword\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"abc\"\n\nOutput:\n 5\n\nExplanation: \n\nThe characters are printed as follows:\n- Type the character 'a' in 1 second since the pointer is initially on 'a'.\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer clockwise to 'c' in 1 second.\n- Type the character 'c' in 1 second.\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"bza\"\n\nOutput:\n 7\n\nExplanation:\n\nThe characters are printed as follows:\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer counterclockwise to 'z' in 2 seconds.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'a' in 1 second.\n- Type the character 'a' in 1 second.\n\n\n\nExample 3:\n\n\n\n\nInput:\n word = \"zjpc\"\n\nOutput:\n 34\n\nExplanation:\n\nThe characters are printed as follows:\n- Move the pointer counterclockwise to 'z' in 1 second.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'j' in 10 seconds.\n- Type the character 'j' in 1 second.\n- Move the pointer clockwise to 'p' in 6 seconds.\n- Type the character 'p' in 1 second.\n- Move the pointer counterclockwise to 'c' in 13 seconds.\n- Type the character 'c' in 1 second.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 100\n\n\nword\n consists of lowercase English letters.",
        "temas": [
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1952,
        "slug": "three-divisors",
        "url": "https://leetcode.com/problems/three-divisors/",
        "titulo": "Three Divisors",
        "enunciado": "Given an integer \nn\n, return \ntrue\n if \nn\n has \nexactly three positive divisors\n. Otherwise, return \nfalse\n.\n\n\nAn integer \nm\n is a \ndivisor\n of \nn\n if there exists an integer \nk\n such that \nn = k * m\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\nExplantion:\n 2 has only two divisors: 1 and 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n true\n\nExplantion:\n 4 has three divisors: 1, 2, and 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
        "temas": [
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1945,
        "slug": "sum-of-digits-of-string-after-convert",
        "url": "https://leetcode.com/problems/sum-of-digits-of-string-after-convert/",
        "titulo": "Sum of Digits of String After Convert",
        "enunciado": "You are given a string \ns\n consisting of lowercase English letters, and an integer \nk\n. Your task is to \nconvert\n the string into an integer by a special process, and then \ntransform\n it by summing its digits repeatedly \nk\n times. More specifically, perform the following steps:\n\n\n\n\nConvert\n \ns\n into an integer by replacing each letter with its position in the alphabet (i.e. replace \n'a'\n with \n1\n, \n'b'\n with \n2\n, ..., \n'z'\n with \n26\n).\n\n\nT\nransform\n the integer by replacing it with the \nsum of its digits\n.\n\n\nRepeat the \ntransform\n operation (step 2) \nk\n times\n in total.\n\n\n\n\nFor example, if \ns = \"zbax\"\n and \nk = 2\n, then the resulting integer would be \n8\n by the following operations:\n\n\n\n\nConvert\n: \n\"zbax\" ➝ \"(26)(2)(1)(24)\" ➝ \"262124\" ➝ 262124\n\n\nTransform #1\n: \n262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17\n\n\nTransform #2\n: \n17 ➝ 1 + 7 ➝ 8\n\n\n\n\nReturn the \nresulting\n \ninteger\n after performing the \noperations\n described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"iiii\", k = 1\n\n\nOutput:\n \n36\n\n\nExplanation:\n\n\nThe operations are as follows:\n\n- Convert: \"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999\n\n- Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36\n\nThus the resulting integer is 36.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"leetcode\", k = 2\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\nThe operations are as follows:\n\n- Convert: \"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545\n\n- Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33\n\n- Transform #2: 33 ➝ 3 + 3 ➝ 6\n\nThus the resulting integer is 6.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"zbax\", k = 2\n\n\nOutput:\n \n8\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\n1 <= k <= 10\n\n\ns\n consists of lowercase English letters.",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1929,
        "slug": "concatenation-of-array",
        "url": "https://leetcode.com/problems/concatenation-of-array/",
        "titulo": "Concatenation of Array",
        "enunciado": "Given an integer array \nnums\n of length \nn\n, you want to create an array \nans\n of length \n2n\n where \nans[i] == nums[i]\n and \nans[i + n] == nums[i]\n for \n0 <= i < n\n (\n0-indexed\n).\n\n\nSpecifically, \nans\n is the \nconcatenation\n of two \nnums\n arrays.\n\n\nReturn \nthe array \nans\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,1]\n\nOutput:\n [1,2,1,1,2,1]\n\nExplanation:\n The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,2,1]\n\nOutput:\n [1,3,2,1,1,3,2,1]\n\nExplanation:\n The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 1000\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1941,
        "slug": "check-if-all-characters-have-equal-number-of-occurrences",
        "url": "https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/",
        "titulo": "Check if All Characters Have Equal Number of Occurrences",
        "enunciado": "Given a string \ns\n, return \ntrue\n if \ns\n is a \ngood\n string, or \nfalse\n otherwise\n.\n\n\nA string \ns\n is \ngood\n if \nall\n the characters that appear in \ns\n have the \nsame\n number of occurrences (i.e., the same frequency).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abacbc\"\n\nOutput:\n true\n\nExplanation:\n The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aaabb\"\n\nOutput:\n false\n\nExplanation:\n The characters that appear in s are 'a' and 'b'.\n'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1920,
        "slug": "build-array-from-permutation",
        "url": "https://leetcode.com/problems/build-array-from-permutation/",
        "titulo": "Build Array from Permutation",
        "enunciado": "Given a \nzero-based permutation\n \nnums\n (\n0-indexed\n), build an array \nans\n of the \nsame length\n where \nans[i] = nums[nums[i]]\n for each \n0 <= i < nums.length\n and return it.\n\n\nA \nzero-based permutation\n \nnums\n is an array of \ndistinct\n integers from \n0\n to \nnums.length - 1\n (\ninclusive\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,2,1,5,3,4]\n\nOutput:\n [0,1,2,4,5,3]\n\nExplanation:\n The array ans is built as follows: \nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,0,1,2,3,4]\n\nOutput:\n [4,5,0,1,2,3]\n\nExplanation:\n The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n0 <= nums[i] < nums.length\n\n\nThe elements in \nnums\n are \ndistinct\n.\n\n\n\n\n \n\n\nFollow-up:\n Can you solve it without using an extra space (i.e., \nO(1)\n memory)?",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1913,
        "slug": "maximum-product-difference-between-two-pairs",
        "url": "https://leetcode.com/problems/maximum-product-difference-between-two-pairs/",
        "titulo": "Maximum Product Difference Between Two Pairs",
        "enunciado": "The \nproduct difference\n between two pairs \n(a, b)\n and \n(c, d)\n is defined as \n(a * b) - (c * d)\n.\n\n\n\n\nFor example, the product difference between \n(5, 6)\n and \n(2, 7)\n is \n(5 * 6) - (2 * 7) = 16\n.\n\n\n\n\nGiven an integer array \nnums\n, choose four \ndistinct\n indices \nw\n, \nx\n, \ny\n, and \nz\n such that the \nproduct difference\n between pairs \n(nums[w], nums[x])\n and \n(nums[y], nums[z])\n is \nmaximized\n.\n\n\nReturn \nthe \nmaximum\n such product difference\n.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n nums = [5,6,2,7,4]\r\n\nOutput:\n 34\r\n\nExplanation:\n We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\nThe product difference is (6 * 7) - (2 * 4) = 34.\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n nums = [4,2,5,9,7,4,8]\r\n\nOutput:\n 64\r\n\nExplanation:\n We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\nThe product difference is (9 * 8) - (2 * 4) = 64.\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n4 <= nums.length <= 10\n4\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1925,
        "slug": "count-square-sum-triples",
        "url": "https://leetcode.com/problems/count-square-sum-triples/",
        "titulo": "Count Square Sum Triples",
        "enunciado": "A \nsquare triple\n \n(a,b,c)\n is a triple where \na\n, \nb\n, and \nc\n are \nintegers\n and \na\n2\n + b\n2\n = c\n2\n.\n\n\nGiven an integer \nn\n, return \nthe number of \nsquare triples\n such that \n1 <= a, b, c <= n\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 2\n\nExplanation\n: The square triples are (3,4,5) and (4,3,5).\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 10\n\nOutput:\n 4\n\nExplanation\n: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 250",
        "temas": [
            "Math",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1903,
        "slug": "largest-odd-number-in-string",
        "url": "https://leetcode.com/problems/largest-odd-number-in-string/",
        "titulo": "Largest Odd Number in String",
        "enunciado": "You are given a string \nnum\n, representing a large integer. Return \nthe \nlargest-valued odd\n integer (as a string) that is a \nnon-empty substring\n of \nnum\n, or an empty string \n\"\"\n if no odd integer exists\n.\n\n\nA \nsubstring\n is a contiguous sequence of characters within a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = \"52\"\n\nOutput:\n \"5\"\n\nExplanation:\n The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = \"4206\"\n\nOutput:\n \"\"\n\nExplanation:\n There are no odd numbers in \"4206\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = \"35427\"\n\nOutput:\n \"35427\"\n\nExplanation:\n \"35427\" is already an odd number.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num.length <= 10\n5\n\n\nnum\n only consists of digits and does not contain any leading zeros.",
        "temas": [
            "Math",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1897,
        "slug": "redistribute-characters-to-make-all-strings-equal",
        "url": "https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/",
        "titulo": "Redistribute Characters to Make All Strings Equal",
        "enunciado": "You are given an array of strings \nwords\n (\n0-indexed\n).\n\n\nIn one operation, pick two \ndistinct\n indices \ni\n and \nj\n, where \nwords[i]\n is a non-empty string, and move \nany\n character from \nwords[i]\n to \nany\n position in \nwords[j]\n.\n\n\nReturn \ntrue\n \nif you can make\n every\n string in \nwords\n \nequal \nusing \nany\n number of operations\n,\n and \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"abc\",\"aabc\",\"bc\"]\n\nOutput:\n true\n\nExplanation:\n Move the first 'a' in \nwords[1] to the front of words[2],\nto make \nwords[1]\n = \"abc\" and words[2] = \"abc\".\nAll the strings are now equal to \"abc\", so return \ntrue\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"ab\",\"a\"]\n\nOutput:\n false\n\nExplanation:\n It is impossible to make all the strings equal using the operation.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n consists of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1909,
        "slug": "remove-one-element-to-make-the-array-strictly-increasing",
        "url": "https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/",
        "titulo": "Remove One Element to Make the Array Strictly Increasing",
        "enunciado": "Given a \n0-indexed\n integer array \nnums\n, return \ntrue\n \nif it can be made \nstrictly increasing\n after removing \nexactly one\n element, or \nfalse\n otherwise. If the array is already strictly increasing, return \ntrue\n.\n\n\nThe array \nnums\n is \nstrictly increasing\n if \nnums[i - 1] < nums[i]\n for each index \n(1 <= i < nums.length).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,\n10\n,5,7]\n\nOutput:\n true\n\nExplanation:\n By removing 10 at index 2 from nums, it becomes [1,2,5,7].\n[1,2,5,7] is strictly increasing, so return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,1,2]\n\nOutput:\n false\n\nExplanation:\n\n[3,1,2] is the result of removing the element at index 0.\n[2,1,2] is the result of removing the element at index 1.\n[2,3,2] is the result of removing the element at index 2.\n[2,3,1] is the result of removing the element at index 3.\nNo resulting array is strictly increasing, so return false.\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,1]\n\nOutput:\n false\n\nExplanation:\n The result of removing any element is [1,1].\n[1,1] is not strictly increasing, so return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 1000",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1886,
        "slug": "determine-whether-matrix-can-be-obtained-by-rotation",
        "url": "https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
        "titulo": "Determine Whether Matrix Can Be Obtained By Rotation",
        "enunciado": "Given two \nn x n\n binary matrices \nmat\n and \ntarget\n, return \ntrue\n if it is possible to make \nmat\n equal to \ntarget\n by \nrotating\n \nmat\n in \n90-degree increments\n, or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n\nOutput:\n true\n\nExplanation: \nWe can rotate mat 90 degrees clockwise to make mat equal target.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n It is impossible to make mat equal to target by rotating mat.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n\nOutput:\n true\n\nExplanation: \nWe can rotate mat 90 degrees clockwise two times to make mat equal target.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == mat.length == target.length\n\n\nn == mat[i].length == target[i].length\n\n\n1 <= n <= 10\n\n\nmat[i][j]\n and \ntarget[i][j]\n are either \n0\n or \n1\n.",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1880,
        "slug": "check-if-word-equals-summation-of-two-words",
        "url": "https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/",
        "titulo": "Check if Word Equals Summation of Two Words",
        "enunciado": "The \nletter value\n of a letter is its position in the alphabet \nstarting from 0\n (i.e. \n'a' -> 0\n, \n'b' -> 1\n, \n'c' -> 2\n, etc.).\n\n\nThe \nnumerical value\n of some string of lowercase English letters \ns\n is the \nconcatenation\n of the \nletter values\n of each letter in \ns\n, which is then \nconverted\n into an integer.\n\n\n\n\nFor example, if \ns = \"acb\"\n, we concatenate each letter's letter value, resulting in \n\"021\"\n. After converting it, we get \n21\n.\n\n\n\n\nYou are given three strings \nfirstWord\n, \nsecondWord\n, and \ntargetWord\n, each consisting of lowercase English letters \n'a'\n through \n'j'\n \ninclusive\n.\n\n\nReturn \ntrue\n \nif the \nsummation\n of the \nnumerical values\n of \nfirstWord\n and \nsecondWord\n equals the \nnumerical value\n of \ntargetWord\n, or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n\nOutput:\n true\n\nExplanation:\n\nThe numerical value of firstWord is \"acb\" -> \"021\" -> 21.\nThe numerical value of secondWord is \"cba\" -> \"210\" -> 210.\nThe numerical value of targetWord is \"cdb\" -> \"231\" -> 231.\nWe return true because 21 + 210 == 231.\n\n\n\nExample 2:\n\n\n\n\nInput:\n firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n\nOutput:\n false\n\nExplanation:\n \nThe numerical value of firstWord is \"aaa\" -> \"000\" -> 0.\nThe numerical value of secondWord is \"a\" -> \"0\" -> 0.\nThe numerical value of targetWord is \"aab\" -> \"001\" -> 1.\nWe return false because 0 + 0 != 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n\nOutput:\n true\n\nExplanation:\n \nThe numerical value of firstWord is \"aaa\" -> \"000\" -> 0.\nThe numerical value of secondWord is \"a\" -> \"0\" -> 0.\nThe numerical value of targetWord is \"aaaa\" -> \"0000\" -> 0.\nWe return true because 0 + 0 == 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= firstWord.length, \nsecondWord.length, \ntargetWord.length <= 8\n\n\nfirstWord\n, \nsecondWord\n, and \ntargetWord\n consist of lowercase English letters from \n'a'\n to \n'j'\n \ninclusive\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1893,
        "slug": "check-if-all-the-integers-in-a-range-are-covered",
        "url": "https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/",
        "titulo": "Check if All the Integers in a Range Are Covered",
        "enunciado": "You are given a 2D integer array \nranges\n and two integers \nleft\n and \nright\n. Each \nranges[i] = [start\ni\n, end\ni\n]\n represents an \ninclusive\n interval between \nstart\ni\n and \nend\ni\n.\n\n\nReturn \ntrue\n \nif each integer in the inclusive range\n \n[left, right]\n \nis covered by \nat least one\n interval in\n \nranges\n. Return \nfalse\n \notherwise\n.\n\n\nAn integer \nx\n is covered by an interval \nranges[i] = [start\ni\n, end\ni\n]\n if \nstart\ni\n <= x <= end\ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n\nOutput:\n true\n\nExplanation:\n Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.\n\n\n\nExample 2:\n\n\n\n\nInput:\n ranges = [[1,10],[10,20]], left = 21, right = 21\n\nOutput:\n false\n\nExplanation:\n 21 is not covered by any range.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= ranges.length <= 50\n\n\n1 <= start\ni\n <= end\ni\n <= 50\n\n\n1 <= left <= right <= 50",
        "temas": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1869,
        "slug": "longer-contiguous-segments-of-ones-than-zeros",
        "url": "https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/",
        "titulo": "Longer Contiguous Segments of Ones than Zeros",
        "enunciado": "Given a binary string \ns\n, return \ntrue\n if the \nlongest\n contiguous segment of \n1\n'\ns is \nstrictly longer\n than the \nlongest\n contiguous segment of \n0\n'\ns in \ns\n, or return \nfalse\n otherwise\n.\n\n\n\n\nFor example, in \ns = \"\n11\n01\n000\n10\"\n the longest continuous segment of \n1\ns has length \n2\n, and the longest continuous segment of \n0\ns has length \n3\n.\n\n\n\n\nNote that if there are no \n0\n's, then the longest continuous segment of \n0\n's is considered to have a length \n0\n. The same applies if there is no \n1\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"1101\"\n\nOutput:\n true\n\nExplanation:\n\nThe longest contiguous segment of 1s has length 2: \"\n11\n01\"\nThe longest contiguous segment of 0s has length 1: \"11\n0\n1\"\nThe segment of 1s is longer, so return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"111000\"\n\nOutput:\n false\n\nExplanation:\n\nThe longest contiguous segment of 1s has length 3: \"\n111\n000\"\nThe longest contiguous segment of 0s has length 3: \"111\n000\n\"\nThe segment of 1s is not longer, so return false.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"110100010\"\n\nOutput:\n false\n\nExplanation:\n\nThe longest contiguous segment of 1s has length 2: \"\n11\n0100010\"\nThe longest contiguous segment of 0s has length 3: \"1101\n000\n10\"\nThe segment of 1s is not longer, so return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns[i]\n is either \n'0'\n or \n'1'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1863,
        "slug": "sum-of-all-subset-xor-totals",
        "url": "https://leetcode.com/problems/sum-of-all-subset-xor-totals/",
        "titulo": "Sum of All Subset XOR Totals",
        "enunciado": "The \nXOR total\n of an array is defined as the bitwise \nXOR\n of\n all its elements\n, or \n0\n if the array is\n empty\n.\n\n\n\n\nFor example, the \nXOR total\n of the array \n[2,5,6]\n is \n2 XOR 5 XOR 6 = 1\n.\n\n\n\n\nGiven an array \nnums\n, return \nthe \nsum\n of all \nXOR totals\n for every \nsubset\n of \nnums\n. \n\n\nNote:\n Subsets with the \nsame\n elements should be counted \nmultiple\n times.\n\n\nAn array \na\n is a \nsubset\n of an array \nb\n if \na\n can be obtained from \nb\n by deleting some (possibly zero) elements of \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3]\n\nOutput:\n 6\n\nExplanation: \nThe 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,1,6]\n\nOutput:\n 28\n\nExplanation: \nThe 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,4,5,6,7,8]\n\nOutput:\n 480\n\nExplanation:\n The sum of all XOR totals for every subset is 480.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 12\n\n\n1 <= nums[i] <= 20",
        "temas": [
            "Array",
            "Math",
            "Backtracking",
            "Bit Manipulation",
            "Combinatorics",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1876,
        "slug": "substrings-of-size-three-with-distinct-characters",
        "url": "https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/",
        "titulo": "Substrings of Size Three with Distinct Characters",
        "enunciado": "A string is \ngood\n if there are no repeated characters.\n\n\nGiven a string \ns\n​​​​​, return \nthe number of \ngood substrings\n of length \nthree \nin \ns\n​​​​​​.\n\n\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\n\n\nA \nsubstring\n is a contiguous sequence of characters in a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"xyzzaz\"\n\nOutput:\n 1\n\nExplanation:\n There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aababcabc\"\n\nOutput:\n 4\n\nExplanation:\n There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n​​​​​​ consists of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Sliding Window",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1854,
        "slug": "maximum-population-year",
        "url": "https://leetcode.com/problems/maximum-population-year/",
        "titulo": "Maximum Population Year",
        "enunciado": "You are given a 2D integer array \nlogs\n where each \nlogs[i] = [birth\ni\n, death\ni\n]\n indicates the birth and death years of the \ni\nth\n person.\n\n\nThe \npopulation\n of some year \nx\n is the number of people alive during that year. The \ni\nth\n person is counted in year \nx\n's population if \nx\n is in the \ninclusive\n range \n[birth\ni\n, death\ni\n - 1]\n. Note that the person is \nnot\n counted in the year that they die.\n\n\nReturn \nthe \nearliest\n year with the \nmaximum population\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n logs = [[1993,1999],[2000,2010]]\n\nOutput:\n 1993\n\nExplanation:\n The maximum population is 1, and 1993 is the earliest year with this population.\n\n\n\nExample 2:\n\n\n\n\nInput:\n logs = [[1950,1961],[1960,1971],[1970,1981]]\n\nOutput:\n 1960\n\nExplanation:\n \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= logs.length <= 100\n\n\n1950 <= birth\ni\n < death\ni\n <= 2050",
        "temas": [
            "Array",
            "Counting",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1848,
        "slug": "minimum-distance-to-the-target-element",
        "url": "https://leetcode.com/problems/minimum-distance-to-the-target-element/",
        "titulo": "Minimum Distance to the Target Element",
        "enunciado": "Given an integer array \nnums\n \n(0-indexed)\n and two integers \ntarget\n and \nstart\n, find an index \ni\n such that \nnums[i] == target\n and \nabs(i - start)\n is \nminimized\n. Note that \nabs(x)\n is the absolute value of \nx\n.\n\n\nReturn \nabs(i - start)\n.\n\n\nIt is \nguaranteed\n that \ntarget\n exists in \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5], target = 5, start = 3\n\nOutput:\n 1\n\nExplanation:\n nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], target = 1, start = 0\n\nOutput:\n 0\n\nExplanation:\n nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\n\nOutput:\n 0\n\nExplanation:\n Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= 10\n4\n\n\n0 <= start < nums.length\n\n\ntarget\n is in \nnums\n.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1859,
        "slug": "sorting-the-sentence",
        "url": "https://leetcode.com/problems/sorting-the-sentence/",
        "titulo": "Sorting the Sentence",
        "enunciado": "A \nsentence\n is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.\n\n\nA sentence can be \nshuffled\n by appending the \n1-indexed word position\n to each word then rearranging the words in the sentence.\n\n\n\n\nFor example, the sentence \n\"This is a sentence\"\n can be shuffled as \n\"sentence4 a3 is2 This1\"\n or \n\"is2 sentence4 This1 a3\"\n.\n\n\n\n\nGiven a \nshuffled sentence\n \ns\n containing no more than \n9\n words, reconstruct and return \nthe original sentence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"is2 sentence4 This1 a3\"\n\nOutput:\n \"This is a sentence\"\n\nExplanation:\n Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"Myself2 Me1 I4 and3\"\n\nOutput:\n \"Me Myself and I\"\n\nExplanation:\n Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 200\n\n\ns\n consists of lowercase and uppercase English letters, spaces, and digits from \n1\n to \n9\n.\n\n\nThe number of words in \ns\n is between \n1\n and \n9\n.\n\n\nThe words in \ns\n are separated by a single space.\n\n\ns\n contains no leading or trailing spaces.",
        "temas": [
            "String",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1837,
        "slug": "sum-of-digits-in-base-k",
        "url": "https://leetcode.com/problems/sum-of-digits-in-base-k/",
        "titulo": "Sum of Digits in Base K",
        "enunciado": "Given an integer \nn\n (in base \n10\n) and a base \nk\n, return \nthe \nsum\n of the digits of \nn\n \nafter\n converting \nn\n from base \n10\n to base \nk\n.\n\n\nAfter converting, each digit should be interpreted as a base \n10\n number, and the sum should be returned in base \n10\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 34, k = 6\n\nOutput:\n 9\n\nExplanation: \n34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 10, k = 10\n\nOutput:\n 1\n\nExplanation: \nn is already in base 10. 1 + 0 = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n2 <= k <= 10",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1832,
        "slug": "check-if-the-sentence-is-pangram",
        "url": "https://leetcode.com/problems/check-if-the-sentence-is-pangram/",
        "titulo": "Check if the Sentence Is Pangram",
        "enunciado": "A \npangram\n is a sentence where every letter of the English alphabet appears at least once.\n\n\nGiven a string \nsentence\n containing only lowercase English letters, return\n \ntrue\n if \nsentence\n is a \npangram\n, or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n\nOutput:\n true\n\nExplanation:\n sentence contains at least one of every letter of the English alphabet.\n\n\n\nExample 2:\n\n\n\n\nInput:\n sentence = \"leetcode\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 1000\n\n\nsentence\n consists of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1844,
        "slug": "replace-all-digits-with-characters",
        "url": "https://leetcode.com/problems/replace-all-digits-with-characters/",
        "titulo": "Replace All Digits with Characters",
        "enunciado": "You are given a \n0-indexed\n string \ns\n that has lowercase English letters in its \neven\n indices and digits in its \nodd\n indices.\n\n\nYou must perform an operation \nshift(c, x)\n, where \nc\n is a character and \nx\n is a digit, that returns the \nx\nth\n character after \nc\n.\n\n\n\n\nFor example, \nshift('a', 5) = 'f'\n and \nshift('x', 0) = 'x'\n.\n\n\n\n\nFor every \nodd\n index \ni\n, you want to replace the digit \ns[i]\n with the result of the \nshift(s[i-1], s[i])\n operation.\n\n\nReturn \ns\n \nafter replacing all digits. It is \nguaranteed\n that\n \nshift(s[i-1], s[i])\n \nwill never exceed\n \n'z'\n.\n\n\nNote\n that \nshift(c, x)\n is \nnot\n a preloaded function, but an operation \nto be implemented\n as part of the solution.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"a1c1e1\"\n\nOutput:\n \"abcdef\"\n\nExplanation: \nThe digits are replaced as follows:\n- s[1] -> shift('a',1) = 'b'\n- s[3] -> shift('c',1) = 'd'\n- s[5] -> shift('e',1) = 'f'\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a1b2c3d4e\"\n\nOutput:\n \"abbdcfdhe\"\n\nExplanation: \nThe digits are replaced as follows:\n- s[1] -> shift('a',1) = 'b'\n- s[3] -> shift('b',2) = 'd'\n- s[5] -> shift('c',3) = 'f'\n- s[7] -> shift('d',4) = 'h'\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters and digits.\n\n\nshift(s[i-1], s[i]) <= 'z'\n for all \nodd\n indices \ni\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1822,
        "slug": "sign-of-the-product-of-an-array",
        "url": "https://leetcode.com/problems/sign-of-the-product-of-an-array/",
        "titulo": "Sign of the Product of an Array",
        "enunciado": "Implement a function \nsignFunc(x)\n that returns:\n\n\n\n\n1\n if \nx\n is positive.\n\n\n-1\n if \nx\n is negative.\n\n\n0\n if \nx\n is equal to \n0\n.\n\n\n\n\nYou are given an integer array \nnums\n. Let \nproduct\n be the product of all values in the array \nnums\n.\n\n\nReturn \nsignFunc(product)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,-2,-3,-4,3,2,1]\n\nOutput:\n 1\n\nExplanation:\n The product of all values in the array is 144, and signFunc(144) = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,5,0,2,-3]\n\nOutput:\n 0\n\nExplanation:\n The product of all values in the array is 0, and signFunc(0) = 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [-1,1,-1,1,-1]\n\nOutput:\n -1\n\nExplanation:\n The product of all values in the array is -1, and signFunc(-1) = -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1816,
        "slug": "truncate-sentence",
        "url": "https://leetcode.com/problems/truncate-sentence/",
        "titulo": "Truncate Sentence",
        "enunciado": "A \nsentence\n is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of \nonly\n uppercase and lowercase English letters (no punctuation).\n\n\n\n\nFor example, \n\"Hello World\"\n, \n\"HELLO\"\n, and \n\"hello world hello world\"\n are all sentences.\n\n\n\n\nYou are given a sentence \ns\n​​​​​​ and an integer \nk\n​​​​​​. You want to \ntruncate\n \ns\n​​​​​​ such that it contains only the \nfirst\n \nk\n​​​​​​ words. Return \ns\n​​​​\n​​ after \ntruncating\n it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"Hello how are you Contestant\", k = 4\n\nOutput:\n \"Hello how are you\"\n\nExplanation:\n\nThe words in s are [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"].\nThe first 4 words are [\"Hello\", \"how\", \"are\", \"you\"].\nHence, you should return \"Hello how are you\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"What is the solution to this problem\", k = 4\n\nOutput:\n \"What is the solution\"\n\nExplanation:\n\nThe words in s are [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"].\nThe first 4 words are [\"What\", \"is\", \"the\", \"solution\"].\nHence, you should return \"What is the solution\".\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"chopper is not a tanuki\", k = 5\n\nOutput:\n \"chopper is not a tanuki\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\nk\n is in the range \n[1, the number of words in s]\n.\n\n\ns\n consist of only lowercase and uppercase English letters and spaces.\n\n\nThe words in \ns\n are separated by a single space.\n\n\nThere are no leading or trailing spaces.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1827,
        "slug": "minimum-operations-to-make-the-array-increasing",
        "url": "https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/",
        "titulo": "Minimum Operations to Make the Array Increasing",
        "enunciado": "You are given an integer array \nnums\n (\n0-indexed\n). In one operation, you can choose an element of the array and increment it by \n1\n.\n\n\n\n\nFor example, if \nnums = [1,2,3]\n, you can choose to increment \nnums[1]\n to make \nnums = [1,\n3\n,3]\n.\n\n\n\n\nReturn \nthe \nminimum\n number of operations needed to make\n \nnums\n \nstrictly\n \nincreasing\n.\n\n\nAn array \nnums\n is \nstrictly increasing\n if \nnums[i] < nums[i+1]\n for all \n0 <= i < nums.length - 1\n. An array of length \n1\n is trivially strictly increasing.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n nums = [1,1,1]\r\n\nOutput:\n 3\r\n\nExplanation:\n You can do the following operations:\r\n1) Increment nums[2], so nums becomes [1,1,\n2\n].\r\n2) Increment nums[1], so nums becomes [1,\n2\n,2].\r\n3) Increment nums[2], so nums becomes [1,2,\n3\n].\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n nums = [1,5,2,4,1]\r\n\nOutput:\n 14\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n nums = [8]\r\n\nOutput:\n 0\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1805,
        "slug": "number-of-different-integers-in-a-string",
        "url": "https://leetcode.com/problems/number-of-different-integers-in-a-string/",
        "titulo": "Number of Different Integers in a String",
        "enunciado": "You are given a string \nword\n that consists of digits and lowercase English letters.\n\n\nYou will replace every non-digit character with a space. For example, \n\"a123bc34d8ef34\"\n will become \n\" 123  34 8  34\"\n. Notice that you are left with some integers that are separated by at least one space: \n\"123\"\n, \n\"34\"\n, \n\"8\"\n, and \n\"34\"\n.\n\n\nReturn \nthe number of \ndifferent\n integers after performing the replacement operations on \nword\n.\n\n\nTwo integers are considered different if their decimal representations \nwithout any leading zeros\n are different.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"a\n123\nbc\n34\nd\n8\nef\n34\n\"\n\nOutput:\n 3\n\nExplanation: \nThe three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"leet\n1234\ncode\n234\n\"\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n word = \"a\n1\nb\n01\nc\n001\n\"\n\nOutput:\n 1\n\nExplanation: \nThe three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 1000\n\n\nword\n consists of digits and lowercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1800,
        "slug": "maximum-ascending-subarray-sum",
        "url": "https://leetcode.com/problems/maximum-ascending-subarray-sum/",
        "titulo": "Maximum Ascending Subarray Sum",
        "enunciado": "Given an array of positive integers \nnums\n, return the \nmaximum\n possible sum of an \nstrictly increasing subarray\n in\n \nnums\n.\n\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [10,20,30,5,10,50]\n\nOutput:\n 65\n\nExplanation: \n[5,10,50] is the ascending subarray with the maximum sum of 65.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [10,20,30,40,50]\n\nOutput:\n 150\n\nExplanation: \n[10,20,30,40,50] is the ascending subarray with the maximum sum of 150.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [12,17,15,13,10,11,12]\n\nOutput:\n 33\n\nExplanation: \n[10,11,12] is the ascending subarray with the maximum sum of 33.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1812,
        "slug": "determine-color-of-a-chessboard-square",
        "url": "https://leetcode.com/problems/determine-color-of-a-chessboard-square/",
        "titulo": "Determine Color of a Chessboard Square",
        "enunciado": "You are given \ncoordinates\n, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\n\n\n\nReturn \ntrue\n if the square is white, and \nfalse\n if the square is black\n.\n\n\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n coordinates = \"a1\"\n\nOutput:\n false\n\nExplanation:\n From the chessboard above, the square with coordinates \"a1\" is black, so return false.\n\n\n\nExample 2:\n\n\n\n\nInput:\n coordinates = \"h3\"\n\nOutput:\n true\n\nExplanation:\n From the chessboard above, the square with coordinates \"h3\" is white, so return true.\n\n\n\nExample 3:\n\n\n\n\nInput:\n coordinates = \"c7\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\ncoordinates.length == 2\n\n\n'a' <= coordinates[0] <= 'h'\n\n\n'1' <= coordinates[1] <= '8'",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1791,
        "slug": "find-center-of-star-graph",
        "url": "https://leetcode.com/problems/find-center-of-star-graph/",
        "titulo": "Find Center of Star Graph",
        "enunciado": "There is an undirected \nstar\n graph consisting of \nn\n nodes labeled from \n1\n to \nn\n. A star graph is a graph where there is one \ncenter\n node and \nexactly\n \nn - 1\n edges that connect the center node with every other node.\n\n\nYou are given a 2D integer array \nedges\n where each \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between the nodes \nu\ni\n and \nv\ni\n. Return the center of the given star graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[2,3],[4,2]]\n\nOutput:\n 2\n\nExplanation:\n As shown in the figure above, node 2 is connected to every other node, so 2 is the center.\n\n\n\nExample 2:\n\n\n\n\nInput:\n edges = [[1,2],[5,1],[1,3],[1,4]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n1 <= u\ni,\n v\ni\n <= n\n\n\nu\ni\n != v\ni\n\n\nThe given \nedges\n represent a valid star graph.",
        "temas": [
            "Graph"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Graph"
    },
    {
        "id": 1790,
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "url": "https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/",
        "titulo": "Check if One String Swap Can Make Strings Equal",
        "enunciado": "You are given two strings \ns1\n and \ns2\n of equal length. A \nstring swap\n is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\n\n\nReturn \ntrue\n \nif it is possible to make both strings equal by performing \nat most one string swap \non \nexactly one\n of the strings. \nOtherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s1 = \"bank\", s2 = \"kanb\"\n\nOutput:\n true\n\nExplanation:\n For example, swap the first character with the last character of s2 to make \"bank\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s1 = \"attack\", s2 = \"defend\"\n\nOutput:\n false\n\nExplanation:\n It is impossible to make them equal with one string swap.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s1 = \"kelb\", s2 = \"kelb\"\n\nOutput:\n true\n\nExplanation:\n The two strings are already equal, so no string swap operation is required.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s1.length, s2.length <= 100\n\n\ns1.length == s2.length\n\n\ns1\n and \ns2\n consist of only lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1784,
        "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "url": "https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/",
        "titulo": "Check if Binary String Has at Most One Segment of Ones",
        "enunciado": "Given a binary string \ns\n \n​​​​​without leading zeros\n, return \ntrue\n​​​ \nif \ns\n contains \nat most one contiguous segment of ones\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"1001\"\n\nOutput:\n false\n\nExplanation: \nThe ones do not form a contiguous segment.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"110\"\n\nOutput:\n true\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns[i]\n​​​​ is either \n'0'\n or \n'1'\n.\n\n\ns[0]\n is \n'1'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1796,
        "slug": "second-largest-digit-in-a-string",
        "url": "https://leetcode.com/problems/second-largest-digit-in-a-string/",
        "titulo": "Second Largest Digit in a String",
        "enunciado": "Given an alphanumeric string \ns\n, return \nthe \nsecond largest\n numerical digit that appears in \ns\n, or \n-1\n if it does not exist\n.\n\n\nAn \nalphanumeric\n \nstring is a string consisting of lowercase English letters and digits.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"dfa12321afd\"\n\nOutput:\n 2\n\nExplanation:\n The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abc1111\"\n\nOutput:\n -1\n\nExplanation:\n The digits that appear in s are [1]. There is no second largest digit. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of only lowercase English letters and digits.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1773,
        "slug": "count-items-matching-a-rule",
        "url": "https://leetcode.com/problems/count-items-matching-a-rule/",
        "titulo": "Count Items Matching a Rule",
        "enunciado": "You are given an array \nitems\n, where each \nitems[i] = [type\ni\n, color\ni\n, name\ni\n]\n describes the type, color, and name of the \ni\nth\n item. You are also given a rule represented by two strings, \nruleKey\n and \nruleValue\n.\n\n\nThe \ni\nth\n item is said to match the rule if \none\n of the following is true:\n\n\n\n\nruleKey == \"type\"\n and \nruleValue == type\ni\n.\n\n\nruleKey == \"color\"\n and \nruleValue == color\ni\n.\n\n\nruleKey == \"name\"\n and \nruleValue == name\ni\n.\n\n\n\n\nReturn \nthe number of items that match the given rule\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\n\nOutput:\n 1\n\nExplanation:\n There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"].\n\n\n\nExample 2:\n\n\n\n\nInput:\n items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\n\nOutput:\n 2\n\nExplanation:\n There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= items.length <= 10\n4\n\n\n1 <= type\ni\n.length, color\ni\n.length, name\ni\n.length, ruleValue.length <= 10\n\n\nruleKey\n is equal to either \n\"type\"\n, \n\"color\"\n, or \n\"name\"\n.\n\n\nAll strings consist only of lowercase letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1768,
        "slug": "merge-strings-alternately",
        "url": "https://leetcode.com/problems/merge-strings-alternately/",
        "titulo": "Merge Strings Alternately",
        "enunciado": "You are given two strings \nword1\n and \nword2\n. Merge the strings by adding letters in alternating order, starting with \nword1\n. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\n\nReturn \nthe merged string.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n word1 = \"abc\", word2 = \"pqr\"\r\n\nOutput:\n \"apbqcr\"\r\n\nExplanation:\n The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n word1 = \"ab\", word2 = \"pqrs\"\r\n\nOutput:\n \"apbqrs\"\r\n\nExplanation:\n Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n word1 = \"abcd\", word2 = \"pq\"\r\n\nOutput:\n \"apbqcd\"\r\n\nExplanation:\n Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word1.length, word2.length <= 100\n\n\nword1\n and \nword2\n consist of lowercase English letters.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 1779,
        "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "url": "https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/",
        "titulo": "Find Nearest Point That Has the Same X or Y Coordinate",
        "enunciado": "You are given two integers, \nx\n and \ny\n, which represent your current location on a Cartesian grid: \n(x, y)\n. You are also given an array \npoints\n where each \npoints[i] = [a\ni\n, b\ni\n]\n represents that a point exists at \n(a\ni\n, b\ni\n)\n. A point is \nvalid\n if it shares the same x-coordinate or the same y-coordinate as your location.\n\n\nReturn \nthe index \n(0-indexed)\n of the \nvalid\n point with the smallest \nManhattan distance\n from your current location\n. If there are multiple, return \nthe valid point with the \nsmallest\n index\n. If there are no valid points, return \n-1\n.\n\n\nThe \nManhattan distance\n between two points \n(x\n1\n, y\n1\n)\n and \n(x\n2\n, y\n2\n)\n is \nabs(x\n1\n - x\n2\n) + abs(y\n1\n - y\n2\n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\n\nOutput:\n 2\n\nExplanation:\n Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.\n\n\nExample 2:\n\n\n\n\nInput:\n x = 3, y = 4, points = [[3,4]]\n\nOutput:\n 0\n\nExplanation:\n The answer is allowed to be on the same location as your current location.\n\n\nExample 3:\n\n\n\n\nInput:\n x = 3, y = 4, points = [[2,3]]\n\nOutput:\n -1\n\nExplanation:\n There are no valid points.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 10\n4\n\n\npoints[i].length == 2\n\n\n1 <= x, y, a\ni\n, b\ni\n <= 10\n4",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1758,
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "url": "https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/",
        "titulo": "Minimum Changes To Make Alternating Binary String",
        "enunciado": "You are given a string \ns\n consisting only of the characters \n'0'\n and \n'1'\n. In one operation, you can change any \n'0'\n to \n'1'\n or vice versa.\n\n\nThe string is called alternating if no two adjacent characters are equal. For example, the string \n\"010\"\n is alternating, while the string \n\"0100\"\n is not.\n\n\nReturn \nthe \nminimum\n number of operations needed to make\n \ns\n \nalternating\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"0100\"\n\nOutput:\n 1\n\nExplanation:\n If you change the last character to '1', s will be \"0101\", which is alternating.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"10\"\n\nOutput:\n 0\n\nExplanation:\n s is already alternating.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"1111\"\n\nOutput:\n 2\n\nExplanation:\n You need two operations to reach \"0101\" or \"1010\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns[i]\n is either \n'0'\n or \n'1'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1752,
        "slug": "check-if-array-is-sorted-and-rotated",
        "url": "https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/",
        "titulo": "Check if Array Is Sorted and Rotated",
        "enunciado": "Given an array \nnums\n, return \ntrue\n if the array was originally sorted in non-decreasing order, then rotated \nsome\n number of positions (including zero)\n. Otherwise, return \nfalse\n.\n\n\nThere may be \nduplicates\n in the original array.\n\n\nNote:\n An array \nA\n rotated by \nx\n positions results in an array \nB\n of the same length such that \nB[i] == A[(i+x) % A.length]\n for every valid index \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n true\n\nExplanation:\n [1,2,3,4,5] is the original sorted array.\nYou can rotate the array by x = 3 positions to begin on the element of value 3: [3,4,5,1,2].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,1,3,4]\n\nOutput:\n false\n\nExplanation:\n There is no sorted array once rotated that can make nums.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n true\n\nExplanation:\n [1,2,3] is the original sorted array.\nYou can rotate the array by x = 0 positions (i.e. no rotation) to make nums.\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n \n\n\n\n\n \n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1763,
        "slug": "longest-nice-substring",
        "url": "https://leetcode.com/problems/longest-nice-substring/",
        "titulo": "Longest Nice Substring",
        "enunciado": "A string \ns\n is \nnice\n if, for every letter of the alphabet that \ns\n contains, it appears \nboth\n in uppercase and lowercase. For example, \n\"abABB\"\n is nice because \n'A'\n and \n'a'\n appear, and \n'B'\n and \n'b'\n appear. However, \n\"abA\"\n is not because \n'b'\n appears, but \n'B'\n does not.\n\n\nGiven a string \ns\n, return \nthe longest \nsubstring\n of \ns\n that is \nnice\n. If there are multiple, return the substring of the \nearliest\n occurrence. If there are none, return an empty string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"YazaAay\"\n\nOutput:\n \"aAa\"\n\nExplanation: \n\"aAa\" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.\n\"aAa\" is the longest nice substring.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"Bb\"\n\nOutput:\n \"Bb\"\n\nExplanation:\n \"Bb\" is a nice string because both 'B' and 'b' appear. The whole string is a substring.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"c\"\n\nOutput:\n \"\"\n\nExplanation:\n There are no nice substrings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of uppercase and lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Divide and Conquer",
            "Bit Manipulation",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1736,
        "slug": "latest-time-by-replacing-hidden-digits",
        "url": "https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/",
        "titulo": "Latest Time by Replacing Hidden Digits",
        "enunciado": "You are given a string \ntime\n in the form of \n hh:mm\n, where some of the digits in the string are hidden (represented by \n?\n).\n\n\nThe valid times are those inclusively between \n00:00\n and \n23:59\n.\n\n\nReturn \nthe latest valid time you can get from\n \ntime\n by replacing the hidden\n \ndigits\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n time = \"2?:?0\"\n\nOutput:\n \"23:50\"\n\nExplanation:\n The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.\n\n\n\nExample 2:\n\n\n\n\nInput:\n time = \"0?:3?\"\n\nOutput:\n \"09:39\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n time = \"1?:22\"\n\nOutput:\n \"19:22\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\ntime\n is in the format \nhh:mm\n.\n\n\nIt is guaranteed that you can produce a valid time from the given string.",
        "temas": [
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1748,
        "slug": "sum-of-unique-elements",
        "url": "https://leetcode.com/problems/sum-of-unique-elements/",
        "titulo": "Sum of Unique Elements",
        "enunciado": "You are given an integer array \nnums\n. The unique elements of an array are the elements that appear \nexactly once\n in the array.\n\n\nReturn \nthe \nsum\n of all the unique elements of \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,2]\n\nOutput:\n 4\n\nExplanation:\n The unique elements are [1,3], and the sum is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1,1,1]\n\nOutput:\n 0\n\nExplanation:\n There are no unique elements, and the sum is 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n 15\n\nExplanation:\n The unique elements are [1,2,3,4,5], and the sum is 15.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1742,
        "slug": "maximum-number-of-balls-in-a-box",
        "url": "https://leetcode.com/problems/maximum-number-of-balls-in-a-box/",
        "titulo": "Maximum Number of Balls in a Box",
        "enunciado": "You are working in a ball factory where you have \nn\n balls numbered from \nlowLimit\n up to \nhighLimit\n \ninclusive\n (i.e., \nn == highLimit - lowLimit + 1\n), and an infinite number of boxes numbered from \n1\n to \ninfinity\n.\n\n\nYour job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number \n321\n will be put in the box number \n3 + 2 + 1 = 6\n and the ball number \n10\n will be put in the box number \n1 + 0 = 1\n.\n\n\nGiven two integers \nlowLimit\n and \nhighLimit\n, return\n the number of balls in the box with the most balls.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lowLimit = 1, highLimit = 10\n\nOutput:\n 2\n\nExplanation:\n\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  2 1 1 1 1 1 1 1 1 0  0  ...\nBox 1 has the most number of balls with 2 balls.\n\n\nExample 2:\n\n\n\n\nInput:\n lowLimit = 5, highLimit = 15\n\nOutput:\n 2\n\nExplanation:\n\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  1 1 1 1 2 2 1 1 1 0  0  ...\nBoxes 5 and 6 have the most number of balls with 2 balls in each.\n\n\n\nExample 3:\n\n\n\n\nInput:\n lowLimit = 19, highLimit = 28\n\nOutput:\n 2\n\nExplanation:\n\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...\nBall Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...\nBox 10 has the most number of balls with 2 balls.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= lowLimit <= highLimit <= 10\n5",
        "temas": [
            "Hash Table",
            "Math",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1725,
        "slug": "number-of-rectangles-that-can-form-the-largest-square",
        "url": "https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/",
        "titulo": "Number Of Rectangles That Can Form The Largest Square",
        "enunciado": "You are given an array \nrectangles\n where \nrectangles[i] = [l\ni\n, w\ni\n]\n represents the \ni\nth\n rectangle of length \nl\ni\n and width \nw\ni\n.\n\n\nYou can cut the \ni\nth\n rectangle to form a square with a side length of \nk\n if both \nk <= l\ni\n and \nk <= w\ni\n. For example, if you have a rectangle \n[4,6]\n, you can cut it to get a square with a side length of at most \n4\n.\n\n\nLet \nmaxLen\n be the side length of the \nlargest\n square you can obtain from any of the given rectangles.\n\n\nReturn \nthe \nnumber\n of rectangles that can make a square with a side length of \nmaxLen\n.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n rectangles = [[5,8],[3,9],[5,12],[16,5]]\r\n\nOutput:\n 3\r\n\nExplanation:\n The largest squares you can get from each rectangle are of lengths [5,3,5,5].\r\nThe largest possible square is of length 5, and you can get it out of 3 rectangles.\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n rectangles = [[2,3],[3,7],[4,3],[3,7]]\r\n\nOutput:\n 3\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rectangles.length <= 1000\n\n\nrectangles[i].length == 2\n\n\n1 <= l\ni\n, w\ni\n <= 10\n9\n\n\nl\ni\n != w\ni",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1720,
        "slug": "decode-xored-array",
        "url": "https://leetcode.com/problems/decode-xored-array/",
        "titulo": "Decode XORed Array",
        "enunciado": "There is a \nhidden\n integer array \narr\n that consists of \nn\n non-negative integers.\n\n\nIt was encoded into another integer array \nencoded\n of length \nn - 1\n, such that \nencoded[i] = arr[i] XOR arr[i + 1]\n. For example, if \narr = [1,0,2,1]\n, then \nencoded = [1,2,3]\n.\n\n\nYou are given the \nencoded\n array. You are also given an integer \nfirst\n, that is the first element of \narr\n, i.e. \narr[0]\n.\n\n\nReturn \nthe original array\n \narr\n. It can be proved that the answer exists and is unique.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n encoded = [1,2,3], first = 1\n\nOutput:\n [1,0,2,1]\n\nExplanation:\n If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n\n\n\nExample 2:\n\n\n\n\nInput:\n encoded = [6,2,7,3], first = 4\n\nOutput:\n [4,2,0,7,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n4\n\n\nencoded.length == n - 1\n\n\n0 <= encoded[i] <= 10\n5\n\n\n0 <= first <= 10\n5",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1732,
        "slug": "find-the-highest-altitude",
        "url": "https://leetcode.com/problems/find-the-highest-altitude/",
        "titulo": "Find the Highest Altitude",
        "enunciado": "There is a biker going on a road trip. The road trip consists of \nn + 1\n points at different altitudes. The biker starts his trip on point \n0\n with altitude equal \n0\n.\n\n\nYou are given an integer array \ngain\n of length \nn\n where \ngain[i]\n is the \nnet gain in altitude\n between points \ni\n​​​​​​ and \ni + 1\n for all (\n0 <= i < n)\n. Return \nthe \nhighest altitude\n of a point.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n gain = [-5,1,5,0,-7]\n\nOutput:\n 1\n\nExplanation:\n The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n gain = [-4,-3,-2,-1,4,3,2]\n\nOutput:\n 0\n\nExplanation:\n The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == gain.length\n\n\n1 <= n <= 100\n\n\n-100 <= gain[i] <= 100",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1710,
        "slug": "maximum-units-on-a-truck",
        "url": "https://leetcode.com/problems/maximum-units-on-a-truck/",
        "titulo": "Maximum Units on a Truck",
        "enunciado": "You are assigned to put some amount of boxes onto \none truck\n. You are given a 2D array \nboxTypes\n, where \nboxTypes[i] = [numberOfBoxes\ni\n, numberOfUnitsPerBox\ni\n]\n:\n\n\n\n\nnumberOfBoxes\ni\n is the number of boxes of type \ni\n.\n\n\nnumberOfUnitsPerBox\ni\n \nis the number of units in each box of the type \ni\n.\n\n\n\n\nYou are also given an integer \ntruckSize\n, which is the \nmaximum\n number of \nboxes\n that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed \ntruckSize\n.\n\n\nReturn \nthe \nmaximum\n total number of \nunits\n that can be put on the truck.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\n\nOutput:\n 8\n\nExplanation:\n There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.\n\n\n\nExample 2:\n\n\n\n\nInput:\n boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\n\nOutput:\n 91\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= boxTypes.length <= 1000\n\n\n1 <= numberOfBoxes\ni\n, numberOfUnitsPerBox\ni\n <= 1000\n\n\n1 <= truckSize <= 10\n6",
        "temas": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1704,
        "slug": "determine-if-string-halves-are-alike",
        "url": "https://leetcode.com/problems/determine-if-string-halves-are-alike/",
        "titulo": "Determine if String Halves Are Alike",
        "enunciado": "You are given a string \ns\n of even length. Split this string into two halves of equal lengths, and let \na\n be the first half and \nb\n be the second half.\n\n\nTwo strings are \nalike\n if they have the same number of vowels (\n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, \n'u'\n, \n'A'\n, \n'E'\n, \n'I'\n, \n'O'\n, \n'U'\n). Notice that \ns\n contains uppercase and lowercase letters.\n\n\nReturn \ntrue\n if \na\n and \nb\n are \nalike\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"book\"\n\nOutput:\n true\n\nExplanation:\n a = \"b\no\n\" and b = \"\no\nk\". a has 1 vowel and b has 1 vowel. Therefore, they are alike.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"textbook\"\n\nOutput:\n false\n\nExplanation:\n a = \"t\ne\nxt\" and b = \"b\noo\nk\". a has 1 vowel whereas b has 2. Therefore, they are not alike.\nNotice that the vowel o is counted twice.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 1000\n\n\ns.length\n is even.\n\n\ns\n consists of \nuppercase and lowercase\n letters.",
        "temas": [
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1716,
        "slug": "calculate-money-in-leetcode-bank",
        "url": "https://leetcode.com/problems/calculate-money-in-leetcode-bank/",
        "titulo": "Calculate Money in Leetcode Bank",
        "enunciado": "Hercy wants to save money for his first car. He puts money in the Leetcode bank \nevery day\n.\n\n\nHe starts by putting in \n$1\n on Monday, the first day. Every day from Tuesday to Sunday, he will put in \n$1\n more than the day before. On every subsequent Monday, he will put in \n$1\n more than the \nprevious Monday\n.\n \n\n\nGiven \nn\n, return \nthe total amount of money he will have in the Leetcode bank at the end of the \nn\nth\n day.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 10\n\nExplanation:\n After the 4\nth\n day, the total is 1 + 2 + 3 + 4 = 10.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 10\n\nOutput:\n 37\n\nExplanation:\n After the 10\nth\n day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2\nnd\n Monday, Hercy only puts in $2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 20\n\nOutput:\n 96\n\nExplanation:\n After the 20\nth\n day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1694,
        "slug": "reformat-phone-number",
        "url": "https://leetcode.com/problems/reformat-phone-number/",
        "titulo": "Reformat Phone Number",
        "enunciado": "You are given a phone number as a string \nnumber\n. \nnumber\n consists of digits, spaces \n' '\n, and/or dashes \n'-'\n.\n\n\nYou would like to reformat the phone number in a certain manner. Firstly, \nremove\n all spaces and dashes. Then, \ngroup\n the digits from left to right into blocks of length 3 \nuntil\n there are 4 or fewer digits. The final digits are then grouped as follows:\n\n\n\n\n2 digits: A single block of length 2.\n\n\n3 digits: A single block of length 3.\n\n\n4 digits: Two blocks of length 2 each.\n\n\n\n\nThe blocks are then joined by dashes. Notice that the reformatting process should \nnever\n produce any blocks of length 1 and produce \nat most\n two blocks of length 2.\n\n\nReturn \nthe phone number after formatting.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n number = \"1-23-45 6\"\n\nOutput:\n \"123-456\"\n\nExplanation:\n The digits are \"123456\".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\nStep 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\".\nJoining the blocks gives \"123-456\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n number = \"123 4-567\"\n\nOutput:\n \"123-45-67\"\n\nExplanation: \nThe digits are \"1234567\".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\nStep 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\".\nJoining the blocks gives \"123-45-67\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n number = \"123 4-5678\"\n\nOutput:\n \"123-456-78\"\n\nExplanation:\n The digits are \"12345678\".\nStep 1: The 1st block is \"123\".\nStep 2: The 2nd block is \"456\".\nStep 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\".\nJoining the blocks gives \"123-456-78\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= number.length <= 100\n\n\nnumber\n consists of digits and the characters \n'-'\n and \n' '\n.\n\n\nThere are at least \ntwo\n digits in \nnumber\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1688,
        "slug": "count-of-matches-in-tournament",
        "url": "https://leetcode.com/problems/count-of-matches-in-tournament/",
        "titulo": "Count of Matches in Tournament",
        "enunciado": "You are given an integer \nn\n, the number of teams in a tournament that has strange rules:\n\n\n\n\nIf the current number of teams is \neven\n, each team gets paired with another team. A total of \nn / 2\n matches are played, and \nn / 2\n teams advance to the next round.\n\n\nIf the current number of teams is \nodd\n, one team randomly advances in the tournament, and the rest gets paired. A total of \n(n - 1) / 2\n matches are played, and \n(n - 1) / 2 + 1\n teams advance to the next round.\n\n\n\n\nReturn \nthe number of matches played in the tournament until a winner is decided.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 7\n\nOutput:\n 6\n\nExplanation:\n Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 14\n\nOutput:\n 13\n\nExplanation:\n Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1700,
        "slug": "number-of-students-unable-to-eat-lunch",
        "url": "https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/",
        "titulo": "Number of Students Unable to Eat Lunch",
        "enunciado": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers \n0\n and \n1\n respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.\n\n\nThe number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a \nstack\n. At each step:\n\n\n\n\nIf the student at the front of the queue \nprefers\n the sandwich on the top of the stack, they will \ntake it\n and leave the queue.\n\n\nOtherwise, they will \nleave it\n and go to the queue's end.\n\n\n\n\nThis continues until none of the queue students want to take the top sandwich and are thus unable to eat.\n\n\nYou are given two integer arrays \nstudents\n and \nsandwiches\n where \nsandwiches[i]\n is the type of the \ni\n​​​​​​th\n sandwich in the stack (\ni = 0\n is the top of the stack) and \nstudents[j]\n is the preference of the \nj\n​​​​​​th\n student in the initial queue (\nj = 0\n is the front of the queue). Return \nthe number of students that are unable to eat.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n students = [1,1,0,0], sandwiches = [0,1,0,1]\n\nOutput:\n 0\n \nExplanation:\n\n- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].\n- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].\n- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].\n- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].\n- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].\nHence all students are able to eat.\n\n\n\nExample 2:\n\n\n\n\nInput:\n students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= students.length, sandwiches.length <= 100\n\n\nstudents.length == sandwiches.length\n\n\nsandwiches[i]\n is \n0\n or \n1\n.\n\n\nstudents[i]\n is \n0\n or \n1\n.",
        "temas": [
            "Array",
            "Stack",
            "Queue",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1678,
        "slug": "goal-parser-interpretation",
        "url": "https://leetcode.com/problems/goal-parser-interpretation/",
        "titulo": "Goal Parser Interpretation",
        "enunciado": "You own a \nGoal Parser\n that can interpret a string \ncommand\n. The \ncommand\n consists of an alphabet of \n\"G\"\n, \n\"()\"\n and/or \n\"(al)\"\n in some order. The Goal Parser will interpret \n\"G\"\n as the string \n\"G\"\n, \n\"()\"\n as the string \n\"o\"\n, and \n\"(al)\"\n as the string \n\"al\"\n. The interpreted strings are then concatenated in the original order.\n\n\nGiven the string \ncommand\n, return \nthe \nGoal Parser\n's interpretation of \ncommand\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n command = \"G()(al)\"\n\nOutput:\n \"Goal\"\n\nExplanation:\n The Goal Parser interprets the command as follows:\nG -> G\n() -> o\n(al) -> al\nThe final concatenated result is \"Goal\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n command = \"G()()()()(al)\"\n\nOutput:\n \"Gooooal\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n command = \"(al)G(al)()()G\"\n\nOutput:\n \"alGalooG\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= command.length <= 100\n\n\ncommand\n consists of \n\"G\"\n, \n\"()\"\n, and/or \n\"(al)\"\n in some order.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1672,
        "slug": "richest-customer-wealth",
        "url": "https://leetcode.com/problems/richest-customer-wealth/",
        "titulo": "Richest Customer Wealth",
        "enunciado": "You are given an \nm x n\n integer grid \naccounts\n where \naccounts[i][j]\n is the amount of money the \ni​​​​​\n​​​​​​th\n​​​​\n customer has in the \nj​​​​​\n​​​​​​th\n​​​​ bank. Return\n the \nwealth\n that the richest customer has.\n\n\nA customer's \nwealth\n is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum \nwealth\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n accounts = [[1,2,3],[3,2,1]]\n\nOutput:\n 6\n\nExplanation\n:\n\n\n1st customer has wealth = 1 + 2 + 3 = 6\n\n2nd customer has wealth = 3 + 2 + 1 = 6\n\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n accounts = [[1,5],[7,3],[3,5]]\n\nOutput:\n 10\n\nExplanation\n: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\n\n\nExample 3:\n\n\n\n\nInput:\n accounts = [[2,8,7],[7,1,3],[1,9,5]]\n\nOutput:\n 17\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == accounts.length\n\n\nn == accounts[i].length\n\n\n1 <= m, n <= 50\n\n\n1 <= accounts[i][j] <= 100",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1684,
        "slug": "count-the-number-of-consistent-strings",
        "url": "https://leetcode.com/problems/count-the-number-of-consistent-strings/",
        "titulo": "Count the Number of Consistent Strings",
        "enunciado": "You are given a string \nallowed\n consisting of \ndistinct\n characters and an array of strings \nwords\n. A string is \nconsistent \nif all characters in the string appear in the string \nallowed\n.\n\n\nReturn\n the number of \nconsistent\n strings in the array \nwords\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n\nOutput:\n 2\n\nExplanation:\n Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'.\n\n\n\nExample 2:\n\n\n\n\nInput:\n allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\n\nOutput:\n 7\n\nExplanation:\n All strings are consistent.\n\n\n\nExample 3:\n\n\n\n\nInput:\n allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n\nOutput:\n 4\n\nExplanation:\n Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 10\n4\n\n\n1 <= allowed.length <=\n \n26\n\n\n1 <= words[i].length <= 10\n\n\nThe characters in \nallowed\n are \ndistinct\n.\n\n\nwords[i]\n and \nallowed\n contain only lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1662,
        "slug": "check-if-two-string-arrays-are-equivalent",
        "url": "https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/",
        "titulo": "Check If Two String Arrays are Equivalent",
        "enunciado": "Given two string arrays \nword1\n and \nword2\n, return\n \ntrue\n if the two arrays \nrepresent\n the same string, and \nfalse\n otherwise.\n\n\nA string is \nrepresented\n by an array if the array elements concatenated \nin order\n forms the string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\n\nOutput:\n true\n\nExplanation:\n\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.\n\n\nExample 2:\n\n\n\n\nInput:\n word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word1.length, word2.length <= 10\n3\n\n\n1 <= word1[i].length, word2[i].length <= 10\n3\n\n\n1 <= sum(word1[i].length), sum(word2[i].length) <= 10\n3\n\n\nword1[i]\n and \nword2[i]\n consist of lowercase letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1656,
        "slug": "design-an-ordered-stream",
        "url": "https://leetcode.com/problems/design-an-ordered-stream/",
        "titulo": "Design an Ordered Stream",
        "enunciado": "There is a stream of \nn\n \n(idKey, value)\n pairs arriving in an \narbitrary\n order, where \nidKey\n is an integer between \n1\n and \nn\n and \nvalue\n is a string. No two pairs have the same \nid\n.\n\n\nDesign a stream that returns the values in \nincreasing order of their IDs\n by returning a \nchunk\n (list) of values after each insertion. The concatenation of all the \nchunks\n should result in a list of the sorted values.\n\n\nImplement the \nOrderedStream\n class:\n\n\n\n\nOrderedStream(int n)\n Constructs the stream to take \nn\n values.\n\n\nString[] insert(int idKey, String value)\n Inserts the pair \n(idKey, value)\n into the stream, then returns the \nlargest possible chunk\n of currently inserted values that appear next in the order.\n\n\n\n\n \n\n\nExample:\n\n\n\n\n\n\nInput\n\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\n\nOutput\n\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\n\nExplanation\n\n// Note that the values ordered by ID is [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"].\nOrderedStream os = new OrderedStream(5);\nos.insert(3, \"ccccc\"); // Inserts (3, \"ccccc\"), returns [].\nos.insert(1, \"aaaaa\"); // Inserts (1, \"aaaaa\"), returns [\"aaaaa\"].\nos.insert(2, \"bbbbb\"); // Inserts (2, \"bbbbb\"), returns [\"bbbbb\", \"ccccc\"].\nos.insert(5, \"eeeee\"); // Inserts (5, \"eeeee\"), returns [].\nos.insert(4, \"ddddd\"); // Inserts (4, \"ddddd\"), returns [\"ddddd\", \"eeeee\"].\n// Concatentating all the chunks returned:\n// [] + [\"aaaaa\"] + [\"bbbbb\", \"ccccc\"] + [] + [\"ddddd\", \"eeeee\"] = [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"]\n// The resulting order is the same as the order above.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n1 <= id <= n\n\n\nvalue.length == 5\n\n\nvalue\n consists only of lowercase letters.\n\n\nEach call to \ninsert\n will have a unique \nid.\n\n\nExactly \nn\n calls will be made to \ninsert\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Design",
            "Data Stream"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1646,
        "slug": "get-maximum-in-generated-array",
        "url": "https://leetcode.com/problems/get-maximum-in-generated-array/",
        "titulo": "Get Maximum in Generated Array",
        "enunciado": "You are given an integer \nn\n. A \n0-indexed\n integer array \nnums\n of length \nn + 1\n is generated in the following way:\n\n\n\n\nnums[0] = 0\n\n\nnums[1] = 1\n\n\nnums[2 * i] = nums[i]\n when \n2 <= 2 * i <= n\n\n\nnums[2 * i + 1] = nums[i] + nums[i + 1]\n when \n2 <= 2 * i + 1 <= n\n\n\n\n\nReturn\n \nthe \nmaximum\n integer in the array \nnums\n​​​.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 7\n\nOutput:\n 3\n\nExplanation:\n According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 100",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1668,
        "slug": "maximum-repeating-substring",
        "url": "https://leetcode.com/problems/maximum-repeating-substring/",
        "titulo": "Maximum Repeating Substring",
        "enunciado": "For a string \nsequence\n, a string \nword\n is \nk\n-repeating\n if \nword\n concatenated \nk\n times is a substring of \nsequence\n. The \nword\n's \nmaximum \nk\n-repeating value\n is the highest value \nk\n where \nword\n is \nk\n-repeating in \nsequence\n. If \nword\n is not a substring of \nsequence\n, \nword\n's maximum \nk\n-repeating value is \n0\n.\n\n\nGiven strings \nsequence\n and \nword\n, return \nthe \nmaximum \nk\n-repeating value\n of \nword\n in \nsequence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n sequence = \"ababc\", word = \"ab\"\n\nOutput:\n 2\n\nExplanation: \n\"abab\" is a substring in \"\nabab\nc\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n sequence = \"ababc\", word = \"ba\"\n\nOutput:\n 1\n\nExplanation: \n\"ba\" is a substring in \"a\nba\nbc\". \"baba\" is not a substring in \"ababc\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n sequence = \"ababc\", word = \"ac\"\n\nOutput:\n 0\n\nExplanation: \n\"ac\" is not a substring in \"ababc\". \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sequence.length <= 100\n\n\n1 <= word.length <= 100\n\n\nsequence\n and \nword\n contains only lowercase English letters.",
        "temas": [
            "String",
            "Dynamic Programming",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1640,
        "slug": "check-array-formation-through-concatenation",
        "url": "https://leetcode.com/problems/check-array-formation-through-concatenation/",
        "titulo": "Check Array Formation Through Concatenation",
        "enunciado": "You are given an array of \ndistinct\n integers \narr\n and an array of integer arrays \npieces\n, where the integers in \npieces\n are \ndistinct\n. Your goal is to form \narr\n by concatenating the arrays in \npieces\n \nin any order\n. However, you are \nnot\n allowed to reorder the integers in each array \npieces[i]\n.\n\n\nReturn \ntrue\n \nif it is possible \nto form the array \narr\n from \npieces\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [15,88], pieces = [[88],[15]]\n\nOutput:\n true\n\nExplanation:\n Concatenate [15] then [88]\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [49,18,16], pieces = [[16,18,49]]\n\nOutput:\n false\n\nExplanation:\n Even though the numbers match, we cannot reorder pieces[0].\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n\nOutput:\n true\n\nExplanation:\n Concatenate [91] then [4,64] then [78]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= pieces.length <= arr.length <= 100\n\n\nsum(pieces[i].length) == arr.length\n\n\n1 <= pieces[i].length <= arr.length\n\n\n1 <= arr[i], pieces[i][j] <= 100\n\n\nThe integers in \narr\n are \ndistinct\n.\n\n\nThe integers in \npieces\n are \ndistinct\n (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1652,
        "slug": "defuse-the-bomb",
        "url": "https://leetcode.com/problems/defuse-the-bomb/",
        "titulo": "Defuse the Bomb",
        "enunciado": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a \ncircular\n array \ncode\n of length of \nn\n and a key \nk\n.\n\n\nTo decrypt the code, you must replace every number. All the numbers are replaced \nsimultaneously\n.\n\n\n\n\nIf \nk > 0\n, replace the \ni\nth\n number with the sum of the \nnext\n \nk\n numbers.\n\n\nIf \nk < 0\n, replace the \ni\nth\n number with the sum of the \nprevious\n \nk\n numbers.\n\n\nIf \nk == 0\n, replace the \ni\nth\n number with \n0\n.\n\n\n\n\nAs \ncode\n is circular, the next element of \ncode[n-1]\n is \ncode[0]\n, and the previous element of \ncode[0]\n is \ncode[n-1]\n.\n\n\nGiven the \ncircular\n array \ncode\n and an integer key \nk\n, return \nthe decrypted code to defuse the bomb\n!\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n code = [5,7,1,4], k = 3\n\nOutput:\n [12,10,16,13]\n\nExplanation:\n Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\n\n\nExample 2:\n\n\n\n\nInput:\n code = [1,2,3,4], k = 0\n\nOutput:\n [0,0,0,0]\n\nExplanation:\n When k is zero, the numbers are replaced by 0. \n\n\n\nExample 3:\n\n\n\n\nInput:\n code = [2,4,9,3], k = -2\n\nOutput:\n [12,5,6,13]\n\nExplanation:\n The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the \nprevious\n numbers.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == code.length\n\n\n1 <= n <= 100\n\n\n1 <= code[i] <= 100\n\n\n-(n - 1) <= k <= n - 1",
        "temas": [
            "Array",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1629,
        "slug": "slowest-key",
        "url": "https://leetcode.com/problems/slowest-key/",
        "titulo": "Slowest Key",
        "enunciado": "A newly designed keypad was tested, where a tester pressed a sequence of \nn\n keys, one at a time.\n\n\nYou are given a string \nkeysPressed\n of length \nn\n, where \nkeysPressed[i]\n was the \ni\nth\n key pressed in the testing sequence, and a sorted list \nreleaseTimes\n, where \nreleaseTimes[i]\n was the time the \ni\nth\n key was released. Both arrays are \n0-indexed\n. The \n0\nth\n key was pressed at the time \n0\n, and every subsequent key was pressed at the \nexact\n time the previous key was released.\n\n\nThe tester wants to know the key of the keypress that had the \nlongest duration\n. The \ni\nth\n \nkeypress had a \nduration\n of \nreleaseTimes[i] - releaseTimes[i - 1]\n, and the \n0\nth\n keypress had a duration of \nreleaseTimes[0]\n.\n\n\nNote that the same key could have been pressed multiple times during the test, and these multiple presses of the same key \nmay not\n have had the same \nduration\n.\n\n\nReturn the key of the keypress that had the \nlongest duration\n. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n\nOutput:\n \"c\"\n\nExplanation:\n The keypresses were as follows:\nKeypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).\nKeypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\nKeypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\nKeypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\nThe longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.\n'c' is lexicographically larger than 'b', so the answer is 'c'.\n\n\n\nExample 2:\n\n\n\n\nInput:\n releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n\nOutput:\n \"a\"\n\nExplanation:\n The keypresses were as follows:\nKeypress for 's' had a duration of 12.\nKeypress for 'p' had a duration of 23 - 12 = 11.\nKeypress for 'u' had a duration of 36 - 23 = 13.\nKeypress for 'd' had a duration of 46 - 36 = 10.\nKeypress for 'a' had a duration of 62 - 46 = 16.\nThe longest of these was the keypress for 'a' with duration 16.\n\n\n \n\n\nConstraints:\n\n\n\n\nreleaseTimes.length == n\n\n\nkeysPressed.length == n\n\n\n2 <= n <= 1000\n\n\n1 <= releaseTimes[i] <= 10\n9\n\n\nreleaseTimes[i] < releaseTimes[i+1]\n\n\nkeysPressed\n contains only lowercase English letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1624,
        "slug": "largest-substring-between-two-equal-characters",
        "url": "https://leetcode.com/problems/largest-substring-between-two-equal-characters/",
        "titulo": "Largest Substring Between Two Equal Characters",
        "enunciado": "Given a string \ns\n, return \nthe length of the longest substring between two equal characters, excluding the two characters.\n If there is no such substring return \n-1\n.\n\n\nA \nsubstring\n is a contiguous sequence of characters within a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aa\"\n\nOutput:\n 0\n\nExplanation:\n The optimal substring here is an empty substring between the two \n'a's\n.\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abca\"\n\nOutput:\n 2\n\nExplanation:\n The optimal substring here is \"bc\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"cbzxy\"\n\nOutput:\n -1\n\nExplanation:\n There are no characters that appear twice in s.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 300\n\n\ns\n contains only lowercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1637,
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "url": "https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/",
        "titulo": "Widest Vertical Area Between Two Points Containing No Points",
        "enunciado": "Given \nn\n \npoints\n on a 2D plane where \npoints[i] = [x\ni\n, y\ni\n]\n, Return\n the \nwidest vertical area\n between two points such that no points are inside the area.\n\n\nA \nvertical area\n is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The \nwidest vertical area\n is the one with the maximum width.\n\n\nNote that points \non the edge\n of a vertical area \nare not\n considered included in the area.\n\n\n \n\n\nExample 1:\n\n\n​\n\n\n\nInput:\n points = [[8,7],[9,9],[7,4],[9,7]]\n\nOutput:\n 1\n\nExplanation:\n Both the red and the blue area are optimal.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == points.length\n\n\n2 <= n <= 10\n5\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 10\n9",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1636,
        "slug": "sort-array-by-increasing-frequency",
        "url": "https://leetcode.com/problems/sort-array-by-increasing-frequency/",
        "titulo": "Sort Array by Increasing Frequency",
        "enunciado": "Given an array of integers \nnums\n, sort the array in \nincreasing\n order based on the frequency of the values. If multiple values have the same frequency, sort them in \ndecreasing\n order.\n\n\nReturn the \nsorted array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,2,2,2,3]\n\nOutput:\n [3,1,1,2,2,2]\n\nExplanation:\n '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,1,3,2]\n\nOutput:\n [1,3,3,2,2]\n\nExplanation:\n '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [-1,1,-6,4,5,-6,1,4,1]\n\nOutput:\n [5,-1,4,4,-6,-6,1,1,1]\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1614,
        "slug": "maximum-nesting-depth-of-the-parentheses",
        "url": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/",
        "titulo": "Maximum Nesting Depth of the Parentheses",
        "enunciado": "Given a \nvalid parentheses string\n \ns\n, return the \nnesting depth\n of\n \ns\n. The nesting depth is the \nmaximum\n number of nested parentheses.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"(1+(2*3)+((8)/4))+1\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nDigit 8 is inside of 3 nested parentheses in the string.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"(1)+((2))+(((3)))\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nDigit 3 is inside of 3 nested parentheses in the string.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"()(())((()()))\"\n\n\nOutput:\n \n3\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of digits \n0-9\n and characters \n'+'\n, \n'-'\n, \n'*'\n, \n'/'\n, \n'('\n, and \n')'\n.\n\n\nIt is guaranteed that parentheses expression \ns\n is a VPS.",
        "temas": [
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1608,
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "url": "https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/",
        "titulo": "Special Array With X Elements Greater Than or Equal X",
        "enunciado": "You are given an array \nnums\n of non-negative integers. \nnums\n is considered \nspecial\n if there exists a number \nx\n such that there are \nexactly\n \nx\n numbers in \nnums\n that are \ngreater than or equal to\n \nx\n.\n\n\nNotice that \nx\n \ndoes not\n have to be an element in \nnums\n.\n\n\nReturn \nx\n \nif the array is \nspecial\n, otherwise, return \n-1\n. It can be proven that if \nnums\n is special, the value for \nx\n is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,5]\n\nOutput:\n 2\n\nExplanation:\n There are 2 values (3 and 5) that are greater than or equal to 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0]\n\nOutput:\n -1\n\nExplanation:\n No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,4,3,0,4]\n\nOutput:\n 3\n\nExplanation:\n There are 3 values that are greater than or equal to 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1598,
        "slug": "crawler-log-folder",
        "url": "https://leetcode.com/problems/crawler-log-folder/",
        "titulo": "Crawler Log Folder",
        "enunciado": "The Leetcode file system keeps a log each time some user performs a \nchange folder\n operation.\n\n\nThe operations are described below:\n\n\n\n\n\"../\"\n : Move to the parent folder of the current folder. (If you are already in the main folder, \nremain in the same folder\n).\n\n\n\"./\"\n : Remain in the same folder.\n\n\n\"x/\"\n : Move to the child folder named \nx\n (This folder is \nguaranteed to always exist\n).\n\n\n\n\nYou are given a list of strings \nlogs\n where \nlogs[i]\n is the operation performed by the user at the \ni\nth\n step.\n\n\nThe file system starts in the main folder, then the operations in \nlogs\n are performed.\n\n\nReturn \nthe minimum number of operations needed to go back to the main folder after the change folder operations.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n\nOutput:\n 2\n\nExplanation: \nUse this change folder operation \"../\" 2 times and go back to the main folder.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n logs = [\"d1/\",\"../\",\"../\",\"../\"]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= logs.length <= 10\n3\n\n\n2 <= logs[i].length <= 10\n\n\nlogs[i]\n contains lowercase English letters, digits, \n'.'\n, and \n'/'\n.\n\n\nlogs[i]\n follows the format described in the statement.\n\n\nFolder names consist of lowercase English letters and digits.",
        "temas": [
            "Array",
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1592,
        "slug": "rearrange-spaces-between-words",
        "url": "https://leetcode.com/problems/rearrange-spaces-between-words/",
        "titulo": "Rearrange Spaces Between Words",
        "enunciado": "You are given a string \ntext\n of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that \ntext\n \ncontains at least one word\n.\n\n\nRearrange the spaces so that there is an \nequal\n number of spaces between every pair of adjacent words and that number is \nmaximized\n. If you cannot redistribute all the spaces equally, place the \nextra spaces at the end\n, meaning the returned string should be the same length as \ntext\n.\n\n\nReturn \nthe string after rearranging the spaces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n text = \"  this   is  a sentence \"\n\nOutput:\n \"this   is   a   sentence\"\n\nExplanation:\n There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.\n\n\n\nExample 2:\n\n\n\n\nInput:\n text = \" practice   makes   perfect\"\n\nOutput:\n \"practice   makes   perfect \"\n\nExplanation:\n There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text.length <= 100\n\n\ntext\n consists of lowercase English letters and \n' '\n.\n\n\ntext\n contains at least one word.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1603,
        "slug": "design-parking-system",
        "url": "https://leetcode.com/problems/design-parking-system/",
        "titulo": "Design Parking System",
        "enunciado": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\n\n\nImplement the \nParkingSystem\n class:\n\n\n\n\nParkingSystem(int big, int medium, int small)\n Initializes object of the \nParkingSystem\n class. The number of slots for each parking space are given as part of the constructor.\n\n\nbool addCar(int carType)\n Checks whether there is a parking space of \ncarType\n for the car that wants to get into the parking lot. \ncarType\n can be of three kinds: big, medium, or small, which are represented by \n1\n, \n2\n, and \n3\n respectively. \nA car can only park in a parking space of its \ncarType\n. If there is no space available, return \nfalse\n, else park the car in that size space and return \ntrue\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n\nOutput\n\n[null, true, true, false, false]\n\n\nExplanation\n\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= big, medium, small <= 1000\n\n\ncarType\n is \n1\n, \n2\n, or \n3\n\n\nAt most \n1000\n calls will be made to \naddCar",
        "temas": [
            "Design",
            "Simulation",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Design"
    },
    {
        "id": 1582,
        "slug": "special-positions-in-a-binary-matrix",
        "url": "https://leetcode.com/problems/special-positions-in-a-binary-matrix/",
        "titulo": "Special Positions in a Binary Matrix",
        "enunciado": "Given an \nm x n\n binary matrix \nmat\n, return \nthe number of special positions in \nmat\n.\n\n\nA position \n(i, j)\n is called \nspecial\n if \nmat[i][j] == 1\n and all other elements in row \ni\n and column \nj\n are \n0\n (rows and columns are \n0-indexed\n).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,0,0],[0,0,1],[1,0,0]]\n\nOutput:\n 1\n\nExplanation:\n (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\nExplanation:\n (0, 0), (1, 1) and (2, 2) are special positions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 100\n\n\nmat[i][j]\n is either \n0\n or \n1\n.",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1576,
        "slug": "replace-all-s-to-avoid-consecutive-repeating-characters",
        "url": "https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/",
        "titulo": "Replace All ?'s to Avoid Consecutive Repeating Characters",
        "enunciado": "Given a string \ns\n containing only lowercase English letters and the \n'?'\n character, convert \nall \nthe \n'?'\n characters into lowercase letters such that the final string does not contain any \nconsecutive repeating \ncharacters. You \ncannot \nmodify the non \n'?'\n characters.\n\n\nIt is \nguaranteed \nthat there are no consecutive repeating characters in the given string \nexcept \nfor \n'?'\n.\n\n\nReturn \nthe final string after all the conversions (possibly zero) have been made\n. If there is more than one solution, return \nany of them\n. It can be shown that an answer is always possible with the given constraints.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"?zs\"\n\nOutput:\n \"azs\"\n\nExplanation:\n There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"ubv?w\"\n\nOutput:\n \"ubvaw\"\n\nExplanation:\n There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consist of lowercase English letters and \n'?'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1588,
        "slug": "sum-of-all-odd-length-subarrays",
        "url": "https://leetcode.com/problems/sum-of-all-odd-length-subarrays/",
        "titulo": "Sum of All Odd Length Subarrays",
        "enunciado": "Given an array of positive integers \narr\n, return \nthe sum of all possible \nodd-length subarrays\n of \narr\n.\n\n\nA \nsubarray\n is a contiguous subsequence of the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [1,4,2,5,3]\n\nOutput:\n 58\n\nExplanation: \nThe odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2]\n\nOutput:\n 3\n\nExplanation: \nThere are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [10,11,12]\n\nOutput:\n 66\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 100\n\n\n1 <= arr[i] <= 1000\n\n\n\n\n \n\n\nFollow up:\n\n\nCould you solve this problem in O(n) time complexity?",
        "temas": [
            "Array",
            "Math",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1566,
        "slug": "detect-pattern-of-length-m-repeated-k-or-more-times",
        "url": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/",
        "titulo": "Detect Pattern of Length M Repeated K or More Times",
        "enunciado": "Given an array of positive integers \narr\n, find a pattern of length \nm\n that is repeated \nk\n or more times.\n\n\nA \npattern\n is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times \nconsecutively \nwithout overlapping. A pattern is defined by its length and the number of repetitions.\n\n\nReturn \ntrue\n \nif there exists a pattern of length\n \nm\n \nthat is repeated\n \nk\n \nor more times, otherwise return\n \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [1,2,4,4,4,4], m = 1, k = 3\n\nOutput:\n true\n\nExplanation: \nThe pattern \n(4)\n of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\n\nOutput:\n true\n\nExplanation: \nThe pattern \n(1,2)\n of length 2 is repeated 2 consecutive times. Another valid pattern \n(2,1) is\n also repeated 2 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [1,2,1,2,1,3], m = 2, k = 3\n\nOutput:\n false\n\nExplanation: \nThe pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= arr.length <= 100\n\n\n1 <= arr[i] <= 100\n\n\n1 <= m <= 100\n\n\n2 <= k <= 100",
        "temas": [
            "Array",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1560,
        "slug": "most-visited-sector-in-a-circular-track",
        "url": "https://leetcode.com/problems/most-visited-sector-in-a-circular-track/",
        "titulo": "Most Visited Sector in  a Circular Track",
        "enunciado": "Given an integer \nn\n and an integer array \nrounds\n. We have a circular track which consists of \nn\n sectors labeled from \n1\n to \nn\n. A marathon will be held on this track, the marathon consists of \nm\n rounds. The \ni\nth\n round starts at sector \nrounds[i - 1]\n and ends at sector \nrounds[i]\n. For example, round 1 starts at sector \nrounds[0]\n and ends at sector \nrounds[1]\n\n\nReturn \nan array of the most visited sectors\n sorted in \nascending\n order.\n\n\nNotice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, rounds = [1,3,1,2]\n\nOutput:\n [1,2]\n\nExplanation:\n The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, rounds = [2,1,2,1,2,1,2,1,2]\n\nOutput:\n [2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 7, rounds = [1,3,5,7]\n\nOutput:\n [1,2,3,4,5,6,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n1 <= m <= 100\n\n\nrounds.length == m + 1\n\n\n1 <= rounds[i] <= n\n\n\nrounds[i] != rounds[i + 1]\n for \n0 <= i < m",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1572,
        "slug": "matrix-diagonal-sum",
        "url": "https://leetcode.com/problems/matrix-diagonal-sum/",
        "titulo": "Matrix Diagonal Sum",
        "enunciado": "Given a square matrix \nmat\n, return the sum of the matrix diagonals.\n\n\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[\n1\n,2,\n3\n],\n              [4,\n5\n,6],\n              [\n7\n,8,\n9\n]]\n\nOutput:\n 25\n\nExplanation: \nDiagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat[1][1] = 5 is counted only once.\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[\n1\n,1,1,\n1\n],\n              [1,\n1\n,\n1\n,1],\n              [1,\n1\n,\n1\n,1],\n              [\n1\n,1,1,\n1\n]]\n\nOutput:\n 8\n\n\n\nExample 3:\n\n\n\n\nInput:\n mat = [[\n5\n]]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == mat.length == mat[i].length\n\n\n1 <= n <= 100\n\n\n1 <= mat[i][j] <= 100",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1544,
        "slug": "make-the-string-great",
        "url": "https://leetcode.com/problems/make-the-string-great/",
        "titulo": "Make The String Great",
        "enunciado": "Given a string \ns\n of lower and upper case English letters.\n\n\nA good string is a string which doesn't have \ntwo adjacent characters\n \ns[i]\n and \ns[i + 1]\n where:\n\n\n\n\n0 <= i <= s.length - 2\n\n\ns[i]\n is a lower-case letter and \ns[i + 1]\n is the same letter but in upper-case or \nvice-versa\n.\n\n\n\n\nTo make the string good, you can choose \ntwo adjacent\n characters that make the string bad and remove them. You can keep doing this until the string becomes good.\n\n\nReturn \nthe string\n after making it good. The answer is guaranteed to be unique under the given constraints.\n\n\nNotice\n that an empty string is also good.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leEeetcode\"\n\nOutput:\n \"leetcode\"\n\nExplanation:\n In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abBAcC\"\n\nOutput:\n \"\"\n\nExplanation:\n We have many possible scenarios, and all lead to the same answer. For example:\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"s\"\n\nOutput:\n \"s\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n contains only lower and upper case English letters.",
        "temas": [
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1556,
        "slug": "thousand-separator",
        "url": "https://leetcode.com/problems/thousand-separator/",
        "titulo": "Thousand Separator",
        "enunciado": "Given an integer \nn\n, add a dot (\".\") as the thousands separator and return it in string format.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 987\n\nOutput:\n \"987\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1234\n\nOutput:\n \"1.234\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 2\n31\n - 1",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1534,
        "slug": "count-good-triplets",
        "url": "https://leetcode.com/problems/count-good-triplets/",
        "titulo": "Count Good Triplets",
        "enunciado": "Given an array of integers \narr\n, and three integers \na\n, \nb\n and \nc\n. You need to find the number of good triplets.\n\n\nA triplet \n(arr[i], arr[j], arr[k])\n is \ngood\n if the following conditions are true:\n\n\n\n\n0 <= i < j < k < arr.length\n\n\n|arr[i] - arr[j]| <= a\n\n\n|arr[j] - arr[k]| <= b\n\n\n|arr[i] - arr[k]| <= c\n\n\n\n\nWhere \n|x|\n denotes the absolute value of \nx\n.\n\n\nReturn\n the number of good triplets\n.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\r\n\nOutput:\n 4\r\n\nExplanation:\n There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n arr = [1,1,2,2,3], a = 0, b = 0, c = 1\r\n\nOutput:\n 0\r\n\nExplanation: \nNo triplet satisfies all conditions.\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= arr.length <= 100\n\n\n0 <= arr[i] <= 1000\n\n\n0 <= a, b, c <= 1000",
        "temas": [
            "Array",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1528,
        "slug": "shuffle-string",
        "url": "https://leetcode.com/problems/shuffle-string/",
        "titulo": "Shuffle String",
        "enunciado": "You are given a string \ns\n and an integer array \nindices\n of the \nsame length\n. The string \ns\n will be shuffled such that the character at the \ni\nth\n position moves to \nindices[i]\n in the shuffled string.\n\n\nReturn \nthe shuffled string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"codeleet\", \nindices\n = [4,5,6,7,0,2,1,3]\n\nOutput:\n \"leetcode\"\n\nExplanation:\n As shown, \"codeleet\" becomes \"leetcode\" after shuffling.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abc\", \nindices\n = [0,1,2]\n\nOutput:\n \"abc\"\n\nExplanation:\n After shuffling, each character remains in its position.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ns.length == indices.length == n\n\n\n1 <= n <= 100\n\n\ns\n consists of only lowercase English letters.\n\n\n0 <= indices[i] < n\n\n\nAll values of \nindices\n are \nunique\n.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1539,
        "slug": "kth-missing-positive-number",
        "url": "https://leetcode.com/problems/kth-missing-positive-number/",
        "titulo": "Kth Missing Positive Number",
        "enunciado": "Given an array \narr\n of positive integers sorted in a \nstrictly increasing order\n, and an integer \nk\n.\n\n\nReturn \nthe\n \nk\nth\n \npositive\n integer that is \nmissing\n from this array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [2,3,4,7,11], k = 5\n\nOutput:\n 9\n\nExplanation: \nThe missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5\nth\n missing positive integer is 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,3,4], k = 2\n\nOutput:\n 6\n\nExplanation: \nThe missing positive integers are [5,6,7,...]. The 2\nnd\n missing positive integer is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 1000\n\n\n1 <= arr[i] <= 1000\n\n\n1 <= k <= 1000\n\n\narr[i] < arr[j]\n for \n1 <= i < j <= arr.length\n\n\n\n\n \n\n\nFollow up:\n\n\nCould you solve this problem in less than O(n) complexity?",
        "temas": [
            "Array",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1518,
        "slug": "water-bottles",
        "url": "https://leetcode.com/problems/water-bottles/",
        "titulo": "Water Bottles",
        "enunciado": "There are \nnumBottles\n water bottles that are initially full of water. You can exchange \nnumExchange\n empty water bottles from the market with one full water bottle.\n\n\nThe operation of drinking a full water bottle turns it into an empty bottle.\n\n\nGiven the two integers \nnumBottles\n and \nnumExchange\n, return \nthe \nmaximum\n number of water bottles you can drink\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n numBottles = 9, numExchange = 3\n\nOutput:\n 13\n\nExplanation:\n You can exchange 3 empty bottles to get 1 full water bottle.\nNumber of water bottles you can drink: 9 + 3 + 1 = 13.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n numBottles = 15, numExchange = 4\n\nOutput:\n 19\n\nExplanation:\n You can exchange 4 empty bottles to get 1 full water bottle. \nNumber of water bottles you can drink: 15 + 3 + 1 = 19.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numBottles <= 100\n\n\n2 <= numExchange <= 100",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1512,
        "slug": "number-of-good-pairs",
        "url": "https://leetcode.com/problems/number-of-good-pairs/",
        "titulo": "Number of Good Pairs",
        "enunciado": "Given an array of integers \nnums\n, return \nthe number of \ngood pairs\n.\n\n\nA pair \n(i, j)\n is called \ngood\n if \nnums[i] == nums[j]\n and \ni\n < \nj\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1,1,3]\n\nOutput:\n 4\n\nExplanation:\n There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1,1]\n\nOutput:\n 6\n\nExplanation:\n Each pair in the array are \ngood\n.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Math",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1523,
        "slug": "count-odd-numbers-in-an-interval-range",
        "url": "https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/",
        "titulo": "Count Odd Numbers in an Interval Range",
        "enunciado": "Given two non-negative integers \nlow\n and \nhigh\n. Return the \ncount of odd numbers between \nlow\n and \nhigh\n (inclusive)\n.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n low = 3, high = 7\r\n\nOutput:\n 3\r\n\nExplanation: \nThe odd numbers between 3 and 7 are [3,5,7].\n\n\nExample 2:\n\n\n\r\n\nInput:\n low = 8, high = 10\r\n\nOutput:\n 1\r\n\nExplanation: \nThe odd numbers between 8 and 10 are [9].\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= low <= high <= 10^9",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1502,
        "slug": "can-make-arithmetic-progression-from-sequence",
        "url": "https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/",
        "titulo": "Can Make Arithmetic Progression From Sequence",
        "enunciado": "A sequence of numbers is called an \narithmetic progression\n if the difference between any two consecutive elements is the same.\n\n\nGiven an array of numbers \narr\n, return \ntrue\n \nif the array can be rearranged to form an \narithmetic progression\n. Otherwise, return\n \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [3,5,1]\n\nOutput:\n true\n\nExplanation: \nWe can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,4]\n\nOutput:\n false\n\nExplanation: \nThere is no way to reorder the elements to obtain an arithmetic progression.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= arr.length <= 1000\n\n\n-10\n6\n <= arr[i] <= 10\n6",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1496,
        "slug": "path-crossing",
        "url": "https://leetcode.com/problems/path-crossing/",
        "titulo": "Path Crossing",
        "enunciado": "Given a string \npath\n, where \npath[i] = 'N'\n, \n'S'\n, \n'E'\n or \n'W'\n, each representing moving one unit north, south, east, or west, respectively. You start at the origin \n(0, 0)\n on a 2D plane and walk on the path specified by \npath\n.\n\n\nReturn \ntrue\n \nif the path crosses itself at any point, that is, if at any time you are on a location you have previously visited\n. Return \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n path = \"NES\"\n\nOutput:\n false \n\nExplanation:\n Notice that the path doesn't cross any point more than once.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n path = \"NESWW\"\n\nOutput:\n true\n\nExplanation:\n Notice that the path visits the origin twice.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= path.length <= 10\n4\n\n\npath[i]\n is either \n'N'\n, \n'S'\n, \n'E'\n, or \n'W'\n.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1486,
        "slug": "xor-operation-in-an-array",
        "url": "https://leetcode.com/problems/xor-operation-in-an-array/",
        "titulo": "XOR Operation in an Array",
        "enunciado": "You are given an integer \nn\n and an integer \nstart\n.\n\n\nDefine an array \nnums\n where \nnums[i] = start + 2 * i\n (\n0-indexed\n) and \nn == nums.length\n.\n\n\nReturn \nthe bitwise XOR of all elements of\n \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5, start = 0\n\nOutput:\n 8\n\nExplanation:\n Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere \"^\" corresponds to bitwise XOR operator.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 4, start = 3\n\nOutput:\n 8\n\nExplanation:\n Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n0 <= start <= 1000\n\n\nn == nums.length",
        "temas": [
            "Math",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1480,
        "slug": "running-sum-of-1d-array",
        "url": "https://leetcode.com/problems/running-sum-of-1d-array/",
        "titulo": "Running Sum of 1d Array",
        "enunciado": "Given an array \nnums\n. We define a running sum of an array as \nrunningSum[i] = sum(nums[0]…nums[i])\n.\n\n\nReturn the running sum of \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [1,3,6,10]\n\nExplanation:\n Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1,1,1]\n\nOutput:\n [1,2,3,4,5]\n\nExplanation:\n Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,1,2,10,1]\n\nOutput:\n [3,4,6,16,17]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-10^6 <= nums[i] <= 10^6",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1491,
        "slug": "average-salary-excluding-the-minimum-and-maximum-salary",
        "url": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/",
        "titulo": "Average Salary Excluding the Minimum and Maximum Salary",
        "enunciado": "You are given an array of \nunique\n integers \nsalary\n where \nsalary[i]\n is the salary of the \ni\nth\n employee.\n\n\nReturn \nthe average salary of employees excluding the minimum and maximum salary\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n salary = [4000,3000,1000,2000]\n\nOutput:\n 2500.00000\n\nExplanation:\n Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n\n\n\nExample 2:\n\n\n\n\nInput:\n salary = [1000,2000,3000]\n\nOutput:\n 2000.00000\n\nExplanation:\n Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= salary.length <= 100\n\n\n1000 <= salary[i] <= 10\n6\n\n\nAll the integers of \nsalary\n are \nunique\n.",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1470,
        "slug": "shuffle-the-array",
        "url": "https://leetcode.com/problems/shuffle-the-array/",
        "titulo": "Shuffle the Array",
        "enunciado": "Given the array \nnums\n consisting of \n2n\n elements in the form \n[x\n1\n,x\n2\n,...,x\nn\n,y\n1\n,y\n2\n,...,y\nn\n]\n.\n\n\nReturn the array in the form\n \n[x\n1\n,y\n1\n,x\n2\n,y\n2\n,...,x\nn\n,y\nn\n]\n.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n nums = [2,5,1,3,4,7], n = 3\r\n\nOutput:\n [2,3,5,4,1,7] \r\n\nExplanation:\n Since x\n1\n=2, x\n2\n=5, x\n3\n=1, y\n1\n=3, y\n2\n=4, y\n3\n=7 then the answer is [2,3,5,4,1,7].\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n nums = [1,2,3,4,4,3,2,1], n = 4\r\n\nOutput:\n [1,4,2,3,3,2,4,1]\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n nums = [1,1,2,2], n = 2\r\n\nOutput:\n [1,2,1,2]\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 500\n\n\nnums.length == 2n\n\n\n1 <= nums[i] <= 10^3",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1464,
        "slug": "maximum-product-of-two-elements-in-an-array",
        "url": "https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/",
        "titulo": "Maximum Product of Two Elements in an Array",
        "enunciado": "Given the array of integers \nnums\n, you will choose two different indices \ni\n and \nj\n of that array. \nReturn the maximum value of\n \n(nums[i]-1)*(nums[j]-1)\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,2]\n\nOutput:\n 12 \n\nExplanation:\n If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,5,4,5]\n\nOutput:\n 16\n\nExplanation:\n Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,7]\n\nOutput:\n 12\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 500\n\n\n1 <= nums[i] <= 10^3",
        "temas": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1475,
        "slug": "final-prices-with-a-special-discount-in-a-shop",
        "url": "https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/",
        "titulo": "Final Prices With a Special Discount in a Shop",
        "enunciado": "You are given an integer array \nprices\n where \nprices[i]\n is the price of the \ni\nth\n item in a shop.\n\n\nThere is a special discount for items in the shop. If you buy the \ni\nth\n item, then you will receive a discount equivalent to \nprices[j]\n where \nj\n is the minimum index such that \nj > i\n and \nprices[j] <= prices[i]\n. Otherwise, you will not receive any discount at all.\n\n\nReturn an integer array \nanswer\n where \nanswer[i]\n is the final price you will pay for the \ni\nth\n item of the shop, considering the special discount.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [8,4,6,2,3]\n\nOutput:\n [4,2,4,2,3]\n\nExplanation:\n \nFor item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n [1,2,3,4,5]\n\nExplanation:\n In this case, for all items, you will not receive any discount at all.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [10,1,1,6]\n\nOutput:\n [9,0,1,6]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 500\n\n\n1 <= prices[i] <= 1000",
        "temas": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1455,
        "slug": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
        "url": "https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/",
        "titulo": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "enunciado": "Given a \nsentence\n that consists of some words separated by a \nsingle space\n, and a \nsearchWord\n, check if \nsearchWord\n is a prefix of any word in \nsentence\n.\n\n\nReturn \nthe index of the word in \nsentence\n (\n1-indexed\n) where \nsearchWord\n is a prefix of this word\n. If \nsearchWord\n is a prefix of more than one word, return the index of the first word \n(minimum index)\n. If there is no such word return \n-1\n.\n\n\nA \nprefix\n of a string \ns\n is any leading contiguous substring of \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n sentence = \"i love eating burger\", searchWord = \"burg\"\n\nOutput:\n 4\n\nExplanation:\n \"burg\" is prefix of \"burger\" which is the 4th word in the sentence.\n\n\n\nExample 2:\n\n\n\n\nInput:\n sentence = \"this problem is an easy problem\", searchWord = \"pro\"\n\nOutput:\n 2\n\nExplanation:\n \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.\n\n\n\nExample 3:\n\n\n\n\nInput:\n sentence = \"i am tired\", searchWord = \"you\"\n\nOutput:\n -1\n\nExplanation:\n \"you\" is not a prefix of any word in the sentence.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 100\n\n\n1 <= searchWord.length <= 10\n\n\nsentence\n consists of lowercase English letters and spaces.\n\n\nsearchWord\n consists of lowercase English letters.",
        "temas": [
            "Two Pointers",
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 1450,
        "slug": "number-of-students-doing-homework-at-a-given-time",
        "url": "https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/",
        "titulo": "Number of Students Doing Homework at a Given Time",
        "enunciado": "Given two integer arrays \nstartTime\n and \nendTime\n and given an integer \nqueryTime\n.\n\n\nThe \nith\n student started doing their homework at the time \nstartTime[i]\n and finished it at time \nendTime[i]\n.\n\n\nReturn \nthe number of students\n doing their homework at time \nqueryTime\n. More formally, return the number of students where \nqueryTime\n lays in the interval \n[startTime[i], endTime[i]]\n inclusive.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n\nOutput:\n 1\n\nExplanation:\n We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n startTime = [4], endTime = [4], queryTime = 4\n\nOutput:\n 1\n\nExplanation:\n The only student was doing their homework at the queryTime.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nstartTime.length == endTime.length\n\n\n1 <= startTime.length <= 100\n\n\n1 <= startTime[i] <= endTime[i] <= 1000\n\n\n1 <= queryTime <= 1000",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1460,
        "slug": "make-two-arrays-equal-by-reversing-subarrays",
        "url": "https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays/",
        "titulo": "Make Two Arrays Equal by Reversing Subarrays",
        "enunciado": "You are given two integer arrays of equal length \ntarget\n and \narr\n. In one step, you can select any \nnon-empty subarray\n of \narr\n and reverse it. You are allowed to make any number of steps.\n\n\nReturn \ntrue\n \nif you can make \narr\n equal to \ntarget\n or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n target = [1,2,3,4], arr = [2,4,1,3]\n\nOutput:\n true\n\nExplanation:\n You can follow the next steps to convert arr to target:\n1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]\n2- Reverse subarray [4,2], arr becomes [1,2,4,3]\n3- Reverse subarray [4,3], arr becomes [1,2,3,4]\nThere are multiple ways to convert arr to target, this is not the only way to do so.\n\n\n\nExample 2:\n\n\n\n\nInput:\n target = [7], arr = [7]\n\nOutput:\n true\n\nExplanation:\n arr is equal to target without any reverses.\n\n\n\nExample 3:\n\n\n\n\nInput:\n target = [3,7,9], arr = [3,7,11]\n\nOutput:\n false\n\nExplanation:\n arr does not have value 9 and it can never be converted to target.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ntarget.length == arr.length\n\n\n1 <= target.length <= 1000\n\n\n1 <= target[i] <= 1000\n\n\n1 <= arr[i] <= 1000",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1437,
        "slug": "check-if-all-1s-are-at-least-length-k-places-away",
        "url": "https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/",
        "titulo": "Check If All 1's Are at Least Length K Places Away",
        "enunciado": "Given an binary array \nnums\n and an integer \nk\n, return \ntrue\n if all \n1\n's are at least \nk\n places away from each other, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,0,0,0,1,0,0,1], k = 2\n\nOutput:\n true\n\nExplanation:\n Each of the 1s are at least 2 places away from each other.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,0,0,1,0,1], k = 2\n\nOutput:\n false\n\nExplanation:\n The second 1 and third 1 are only one apart from each other.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= k <= nums.length\n\n\nnums[i]\n is \n0\n or \n1",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1436,
        "slug": "destination-city",
        "url": "https://leetcode.com/problems/destination-city/",
        "titulo": "Destination City",
        "enunciado": "You are given the array \npaths\n, where \npaths[i] = [cityA\ni\n, cityB\ni\n]\n means there exists a direct path going from \ncityA\ni\n to \ncityB\ni\n. \nReturn the destination city, that is, the city without any path outgoing to another city.\n\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\n\nOutput:\n \"Sao Paulo\" \n\nExplanation:\n Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\n\nOutput:\n \"A\"\n\nExplanation:\n All possible trips are: \n\"D\" -> \"B\" -> \"C\" -> \"A\". \n\"B\" -> \"C\" -> \"A\". \n\"C\" -> \"A\". \n\"A\". \nClearly the destination city is \"A\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n paths = [[\"A\",\"Z\"]]\n\nOutput:\n \"Z\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= paths.length <= 100\n\n\npaths[i].length == 2\n\n\n1 <= cityA\ni\n.length, cityB\ni\n.length <= 10\n\n\ncityA\ni\n != cityB\ni\n\n\nAll strings consist of lowercase and uppercase English letters and the space character.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1446,
        "slug": "consecutive-characters",
        "url": "https://leetcode.com/problems/consecutive-characters/",
        "titulo": "Consecutive Characters",
        "enunciado": "The \npower\n of the string is the maximum length of a non-empty substring that contains only one unique character.\n\n\nGiven a string \ns\n, return \nthe \npower\n of\n \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leetcode\"\n\nOutput:\n 2\n\nExplanation:\n The substring \"ee\" is of length 2 with the character 'e' only.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abbcccddddeeeeedcba\"\n\nOutput:\n 5\n\nExplanation:\n The substring \"eeeee\" is of length 5 with the character 'e' only.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of only lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1422,
        "slug": "maximum-score-after-splitting-a-string",
        "url": "https://leetcode.com/problems/maximum-score-after-splitting-a-string/",
        "titulo": "Maximum Score After Splitting a String",
        "enunciado": "Given a string \ns\n of zeros and ones, \nreturn the maximum score after splitting the string into two \nnon-empty\n substrings\n (i.e. \nleft\n substring and \nright\n substring).\n\n\nThe score after splitting a string is the number of \nzeros\n in the \nleft\n substring plus the number of \nones\n in the \nright\n substring.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"011101\"\n\nOutput:\n 5 \n\nExplanation:\n \nAll possible ways of splitting s into two non-empty substrings are:\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"00111\"\n\nOutput:\n 5\n\nExplanation:\n When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"1111\"\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 500\n\n\nThe string \ns\n consists of characters \n'0'\n and \n'1'\n only.",
        "temas": [
            "String",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1417,
        "slug": "reformat-the-string",
        "url": "https://leetcode.com/problems/reformat-the-string/",
        "titulo": "Reformat The String",
        "enunciado": "You are given an alphanumeric string \ns\n. (\nAlphanumeric string\n is a string consisting of lowercase English letters and digits).\n\n\nYou have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.\n\n\nReturn \nthe reformatted string\n or return \nan empty string\n if it is impossible to reformat the string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"a0b1c2\"\n\nOutput:\n \"0a1b2c\"\n\nExplanation:\n No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"leetcode\"\n\nOutput:\n \"\"\n\nExplanation:\n \"leetcode\" has only characters so we cannot separate them by digits.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"1229857369\"\n\nOutput:\n \"\"\n\nExplanation:\n \"1229857369\" has only digits so we cannot separate them by characters.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of only lowercase English letters and/or digits.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1431,
        "slug": "kids-with-the-greatest-number-of-candies",
        "url": "https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/",
        "titulo": "Kids With the Greatest Number of Candies",
        "enunciado": "There are \nn\n kids with candies. You are given an integer array \ncandies\n, where each \ncandies[i]\n represents the number of candies the \ni\nth\n kid has, and an integer \nextraCandies\n, denoting the number of extra candies that you have.\n\n\nReturn \na boolean array \nresult\n of length \nn\n, where \nresult[i]\n is \ntrue\n if, after giving the \ni\nth\n kid all the \nextraCandies\n, they will have the \ngreatest\n number of candies among all the kids\n, or \nfalse\n otherwise\n.\n\n\nNote that \nmultiple\n kids can have the \ngreatest\n number of candies.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candies = [2,3,5,1,3], extraCandies = 3\n\nOutput:\n [true,true,true,false,true] \n\nExplanation:\n If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n\n\n\nExample 2:\n\n\n\n\nInput:\n candies = [4,2,1,1,2], extraCandies = 1\n\nOutput:\n [true,false,false,false,false] \n\nExplanation:\n There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n\n\n\nExample 3:\n\n\n\n\nInput:\n candies = [12,1,12], extraCandies = 10\n\nOutput:\n [true,false,true]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == candies.length\n\n\n2 <= n <= 100\n\n\n1 <= candies[i] <= 100\n\n\n1 <= extraCandies <= 50",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1408,
        "slug": "string-matching-in-an-array",
        "url": "https://leetcode.com/problems/string-matching-in-an-array/",
        "titulo": "String Matching in an Array",
        "enunciado": "Given an array of string \nwords\n, return all strings in\n \nwords\n \nthat are a \nsubstring\n of another word. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"mass\",\"as\",\"hero\",\"superhero\"]\n\nOutput:\n [\"as\",\"hero\"]\n\nExplanation:\n \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\".\n[\"hero\",\"as\"] is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"leetcode\",\"et\",\"code\"]\n\nOutput:\n [\"et\",\"code\"]\n\nExplanation:\n \"et\", \"code\" are substring of \"leetcode\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"blue\",\"green\",\"bu\"]\n\nOutput:\n []\n\nExplanation:\n No string of words is substring of another string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 30\n\n\nwords[i]\n contains only lowercase English letters.\n\n\nAll the strings of \nwords\n are \nunique\n.",
        "temas": [
            "Array",
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1403,
        "slug": "minimum-subsequence-in-non-increasing-order",
        "url": "https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/",
        "titulo": "Minimum Subsequence in Non-Increasing Order",
        "enunciado": "Given the array \nnums\n, obtain a subsequence of the array whose sum of elements is \nstrictly greater\n than the sum of the non included elements in such subsequence. \n\n\nIf there are multiple solutions, return the subsequence with \nminimum size\n and if there still exist multiple solutions, return the subsequence with the \nmaximum total sum\n of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. \n\n\nNote that the solution with the given constraints is guaranteed to be \nunique\n. Also return the answer sorted in \nnon-increasing\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,3,10,9,8]\n\nOutput:\n [10,9] \n\nExplanation:\n The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. \n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,4,7,6,7]\n\nOutput:\n [7,7,6] \n\nExplanation:\n The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order.  \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 500\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1413,
        "slug": "minimum-value-to-get-positive-step-by-step-sum",
        "url": "https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/",
        "titulo": "Minimum Value to Get Positive Step by Step Sum",
        "enunciado": "Given an array of integers \nnums\n, you start with an initial \npositive\n value \nstartValue\n.\n\n\nIn each iteration, you calculate the step by step sum of \nstartValue\n plus elements in \nnums\n (from left to right).\n\n\nReturn the minimum \npositive\n value of \nstartValue\n such that the step by step sum is never less than 1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-3,2,-3,4,2]\n\nOutput:\n 5\n\nExplanation: \nIf you choose startValue = 4, in the third iteration your step by step sum is less than 1.\n\nstep by step sum\n\n\nstartValue = 4 | startValue = 5 | nums\n\n  (4 \n-3\n ) = 1  | (5 \n-3\n ) = 2    |  -3\n  (1 \n+2\n ) = 3  | (2 \n+2\n ) = 4    |   2\n  (3 \n-3\n ) = 0  | (4 \n-3\n ) = 1    |  -3\n  (0 \n+4\n ) = 4  | (1 \n+4\n ) = 5    |   4\n  (4 \n+2\n ) = 6  | (5 \n+2\n ) = 7    |   2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2]\n\nOutput:\n 1\n\nExplanation:\n Minimum start value should be positive. \n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,-2,-3]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n-100 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1394,
        "slug": "find-lucky-integer-in-an-array",
        "url": "https://leetcode.com/problems/find-lucky-integer-in-an-array/",
        "titulo": "Find Lucky Integer in an Array",
        "enunciado": "Given an array of integers \narr\n, a \nlucky integer\n is an integer that has a frequency in the array equal to its value.\n\n\nReturn \nthe largest \nlucky integer\n in the array\n. If there is no \nlucky integer\n return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [2,2,3,4]\n\nOutput:\n 2\n\nExplanation:\n The only lucky number in the array is 2 because frequency[2] == 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,2,3,3,3]\n\nOutput:\n 3\n\nExplanation:\n 1, 2 and 3 are all lucky numbers, return the largest of them.\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [2,2,2,3,3]\n\nOutput:\n -1\n\nExplanation:\n There are no lucky numbers in the array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 500\n\n\n1 <= arr[i] <= 500",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1389,
        "slug": "create-target-array-in-the-given-order",
        "url": "https://leetcode.com/problems/create-target-array-in-the-given-order/",
        "titulo": "Create Target Array in the Given Order",
        "enunciado": "Given two arrays of integers \nnums\n and \nindex\n. Your task is to create \ntarget\n array under the following rules:\n\n\n\n\nInitially \ntarget\n array is empty.\n\n\nFrom left to right read nums[i] and index[i], insert at index \nindex[i]\n the value \nnums[i]\n in \ntarget\n array.\n\n\nRepeat the previous step until there are no elements to read in \nnums\n and \nindex.\n\n\n\n\nReturn the \ntarget\n array.\n\n\nIt is guaranteed that the insertion operations will be valid.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1,2,3,4], index = [0,1,2,2,1]\n\nOutput:\n [0,4,1,3,2]\n\nExplanation:\n\nnums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,0], index = [0,1,2,3,0]\n\nOutput:\n [0,1,2,3,4]\n\nExplanation:\n\nnums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1], index = [0]\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length, index.length <= 100\n\n\nnums.length == index.length\n\n\n0 <= nums[i] <= 100\n\n\n0 <= index[i] <= i",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1399,
        "slug": "count-largest-group",
        "url": "https://leetcode.com/problems/count-largest-group/",
        "titulo": "Count Largest Group",
        "enunciado": "You are given an integer \nn\n.\n\n\nWe need to group the numbers from \n1\n to \nn\n according to the sum of its digits. For example, the numbers 14 and 5 belong to the \nsame\n group, whereas 13 and 3 belong to \ndifferent\n groups.\n\n\nReturn the number of groups that have the largest size, i.e. the \nmaximum\n number of elements.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 13\n\nOutput:\n 4\n\nExplanation:\n There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are 2 groups [1], [2] of size 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
        "temas": [
            "Hash Table",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1379,
        "slug": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
        "url": "https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/",
        "titulo": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "enunciado": "Given two binary trees \noriginal\n and \ncloned\n and given a reference to a node \ntarget\n in the original tree.\n\n\nThe \ncloned\n tree is a \ncopy of\n the \noriginal\n tree.\n\n\nReturn \na reference to the same node\n in the \ncloned\n tree.\n\n\nNote\n that you are \nnot allowed\n to change any of the two trees or the \ntarget\n node and the answer \nmust be\n a reference to a node in the \ncloned\n tree.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n tree = [7,4,3,null,null,6,19], target = 3\n\nOutput:\n 3\n\nExplanation:\n In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n tree = [7], target =  7\n\nOutput:\n 7\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the \ntree\n is in the range \n[1, 10\n4\n]\n.\n\n\nThe values of the nodes of the \ntree\n are unique.\n\n\ntarget\n node is a node from the \noriginal\n tree and is not \nnull\n.\n\n\n\n\n \n\n\nFollow up:\n Could you solve the problem if repeated values on the tree are allowed?",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 1380,
        "slug": "lucky-numbers-in-a-matrix",
        "url": "https://leetcode.com/problems/lucky-numbers-in-a-matrix/",
        "titulo": "Lucky Numbers in a Matrix",
        "enunciado": "Given an \nm x n\n matrix of \ndistinct \nnumbers, return \nall \nlucky numbers\n in the matrix in \nany \norder\n.\n\n\nA \nlucky number\n is an element of the matrix such that it is the minimum element in its row and maximum in its column.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix = [[3,7,8],[9,11,13],[15,16,17]]\n\nOutput:\n [15]\n\nExplanation:\n 15 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n\nOutput:\n [12]\n\nExplanation:\n 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[7,8],[1,2]]\n\nOutput:\n [7]\n\nExplanation:\n 7 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= n, m <= 50\n\n\n1 <= matrix[i][j] <= 10\n5\n.\n\n\nAll elements in the matrix are distinct.",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1374,
        "slug": "generate-a-string-with-characters-that-have-odd-counts",
        "url": "https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/",
        "titulo": "Generate a String With Characters That Have Odd Counts",
        "enunciado": "Given an integer \nn\n, \nreturn a string with \nn\n characters such that each character in such string occurs \nan odd number of times\n.\n\n\nThe returned string must contain only lowercase English letters. If there are multiples valid strings, return \nany\n of them.  \n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n \"pppz\"\n\nExplanation:\n \"pppz\" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as \"ohhh\" and \"love\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n \"xy\"\n\nExplanation:\n \"xy\" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as \"ag\" and \"ur\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 7\n\nOutput:\n \"holasss\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 500",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1385,
        "slug": "find-the-distance-value-between-two-arrays",
        "url": "https://leetcode.com/problems/find-the-distance-value-between-two-arrays/",
        "titulo": "Find the Distance Value Between Two Arrays",
        "enunciado": "Given two integer arrays \narr1\n and \narr2\n, and the integer \nd\n, \nreturn the distance value between the two arrays\n.\n\n\nThe distance value is defined as the number of elements \narr1[i]\n such that there is not any element \narr2[j]\n where \n|arr1[i]-arr2[j]| <= d\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\n\nOutput:\n 2\n\nExplanation:\n \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n\n|8-10|=2 <= d=2\n\n\n|8-9|=1 <= d=2\n\n|8-1|=7 > d=2\n\n|8-8|=0 <= d=2\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr1.length, arr2.length <= 500\n\n\n-1000 <= arr1[i], arr2[j] <= 1000\n\n\n0 <= d <= 100",
        "temas": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1365,
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "url": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/",
        "titulo": "How Many Numbers Are Smaller Than the Current Number",
        "enunciado": "Given the array \nnums\n, for each \nnums[i]\n find out how many numbers in the array are smaller than it. That is, for each \nnums[i]\n you have to count the number of valid \nj's\n such that \nj != i\n \nand\n \nnums[j] < nums[i]\n.\n\n\nReturn the answer in an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [8,1,2,2,3]\n\nOutput:\n [4,0,1,1,3]\n\nExplanation:\n \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [6,5,4,8]\n\nOutput:\n [2,1,0,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,7,7,7]\n\nOutput:\n [0,0,0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 500\n\n\n0 <= nums[i] <= 100",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting Sort"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1351,
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "url": "https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/",
        "titulo": "Count Negative Numbers in a Sorted Matrix",
        "enunciado": "Given a \nm x n\n matrix \ngrid\n which is sorted in non-increasing order both row-wise and column-wise, return \nthe number of \nnegative\n numbers in\n \ngrid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n\nOutput:\n 8\n\nExplanation:\n There are 8 negatives number in the matrix.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[3,2],[1,0]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 100\n\n\n-100 <= grid[i][j] <= 100\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(n + m)\n solution?",
        "temas": [
            "Array",
            "Binary Search",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1370,
        "slug": "increasing-decreasing-string",
        "url": "https://leetcode.com/problems/increasing-decreasing-string/",
        "titulo": "Increasing Decreasing String",
        "enunciado": "You are given a string \ns\n. Reorder the string using the following algorithm:\n\n\n\n\nRemove the \nsmallest\n character from \ns\n and \nappend\n it to the result.\n\n\nRemove the \nsmallest\n character from \ns\n that is greater than the last appended character, and \nappend\n it to the result.\n\n\nRepeat step 2 until no more characters can be removed.\n\n\nRemove the \nlargest\n character from \ns\n and \nappend\n it to the result.\n\n\nRemove the \nlargest\n character from \ns\n that is smaller than the last appended character, and \nappend\n it to the result.\n\n\nRepeat step 5 until no more characters can be removed.\n\n\nRepeat steps 1 through 6 until all characters from \ns\n have been removed.\n\n\n\n\nIf the smallest or largest character appears more than once, you may choose any occurrence to append to the result.\n\n\nReturn the resulting string after reordering \ns\n using this algorithm.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aaaabbbbcccc\"\n\nOutput:\n \"abccbaabccba\"\n\nExplanation:\n After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"rat\"\n\nOutput:\n \"art\"\n\nExplanation:\n The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of only lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1346,
        "slug": "check-if-n-and-its-double-exist",
        "url": "https://leetcode.com/problems/check-if-n-and-its-double-exist/",
        "titulo": "Check If N and Its Double Exist",
        "enunciado": "Given an array \narr\n of integers, check if there exist two indices \ni\n and \nj\n such that :\n\n\n\n\ni != j\n\n\n0 <= i, j < arr.length\n\n\narr[i] == 2 * arr[j]\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [10,2,5,3]\n\nOutput:\n true\n\nExplanation:\n For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [3,1,7,11]\n\nOutput:\n false\n\nExplanation:\n There is no i and j that satisfy the conditions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= arr.length <= 500\n\n\n-10\n3\n <= arr[i] <= 10\n3",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1337,
        "slug": "the-k-weakest-rows-in-a-matrix",
        "url": "https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/",
        "titulo": "The K Weakest Rows in a Matrix",
        "enunciado": "You are given an \nm x n\n binary matrix \nmat\n of \n1\n's (representing soldiers) and \n0\n's (representing civilians). The soldiers are positioned \nin front\n of the civilians. That is, all the \n1\n's will appear to the \nleft\n of all the \n0\n's in each row.\n\n\nA row \ni\n is \nweaker\n than a row \nj\n if one of the following is true:\n\n\n\n\nThe number of soldiers in row \ni\n is less than the number of soldiers in row \nj\n.\n\n\nBoth rows have the same number of soldiers and \ni < j\n.\n\n\n\n\nReturn \nthe indices of the \nk\n \nweakest\n rows in the matrix ordered from weakest to strongest\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n mat = \n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]], \nk = 3\n\nOutput:\n [2,0,3]\n\nExplanation:\n \nThe number of soldiers in each row is: \n- Row 0: 2 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 2 \n- Row 4: 5 \nThe rows ordered from weakest to strongest are [2,0,3,1,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = \n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]], \nk = 2\n\nOutput:\n [0,2]\n\nExplanation:\n \nThe number of soldiers in each row is: \n- Row 0: 1 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 1 \nThe rows ordered from weakest to strongest are [0,2,3,1].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n2 <= n, m <= 100\n\n\n1 <= k <= m\n\n\nmatrix[i][j]\n is either 0 or 1.",
        "temas": [
            "Array",
            "Binary Search",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1356,
        "slug": "sort-integers-by-the-number-of-1-bits",
        "url": "https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/",
        "titulo": "Sort Integers by The Number of 1 Bits",
        "enunciado": "You are given an integer array \narr\n. Sort the integers in the array in ascending order by the number of \n1\n's in their binary representation and in case of two or more integers have the same number of \n1\n's you have to sort them in ascending order.\n\n\nReturn \nthe array after sorting it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [0,1,2,3,4,5,6,7,8]\n\nOutput:\n [0,1,2,4,8,3,5,6,7]\n\nExplantion:\n [0] is the only integer with 0 bits.\n[1,2,4,8] all have 1 bit.\n[3,5,6] have 2 bits.\n[7] has 3 bits.\nThe sorted array by bits is [0,1,2,4,8,3,5,6,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1024,512,256,128,64,32,16,8,4,2,1]\n\nOutput:\n [1,2,4,8,16,32,64,128,256,512,1024]\n\nExplantion:\n All integers have 1 bit in the binary representation, you should just sort them in ascending order.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 500\n\n\n0 <= arr[i] <= 10\n4",
        "temas": [
            "Array",
            "Bit Manipulation",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1332,
        "slug": "remove-palindromic-subsequences",
        "url": "https://leetcode.com/problems/remove-palindromic-subsequences/",
        "titulo": "Remove Palindromic Subsequences",
        "enunciado": "You are given a string \ns\n consisting \nonly\n of letters \n'a'\n and \n'b'\n. In a single step you can remove one \npalindromic subsequence\n from \ns\n.\n\n\nReturn \nthe \nminimum\n number of steps to make the given string empty\n.\n\n\nA string is a \nsubsequence\n of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does \nnot\n necessarily need to be contiguous.\n\n\nA string is called \npalindrome\n if is one that reads the same backward as well as forward.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ababa\"\n\nOutput:\n 1\n\nExplanation:\n s is already a palindrome, so its entirety can be removed in a single step.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abb\"\n\nOutput:\n 2\n\nExplanation:\n \"\na\nbb\" -> \"\nbb\n\" -> \"\". \nRemove palindromic subsequence \"a\" then \"bb\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"baabb\"\n\nOutput:\n 2\n\nExplanation:\n \"\nbaa\nb\nb\n\" -> \"\nb\n\" -> \"\". \nRemove palindromic subsequence \"baab\" then \"b\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns[i]\n is either \n'a'\n or \n'b'\n.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 1323,
        "slug": "maximum-69-number",
        "url": "https://leetcode.com/problems/maximum-69-number/",
        "titulo": "Maximum 69 Number",
        "enunciado": "You are given a positive integer \nnum\n consisting only of digits \n6\n and \n9\n.\n\n\nReturn \nthe maximum number you can get by changing \nat most\n one digit (\n6\n becomes \n9\n, and \n9\n becomes \n6\n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 9669\n\nOutput:\n 9969\n\nExplanation:\n \nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666.\nThe maximum number is 9969.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 9996\n\nOutput:\n 9999\n\nExplanation:\n Changing the last digit 6 to 9 results in the maximum number.\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = 9999\n\nOutput:\n 9999\n\nExplanation:\n It is better not to apply any change.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 10\n4\n\n\nnum\n consists of only \n6\n and \n9\n digits.",
        "temas": [
            "Math",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1342,
        "slug": "number-of-steps-to-reduce-a-number-to-zero",
        "url": "https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/",
        "titulo": "Number of Steps to Reduce a Number to Zero",
        "enunciado": "Given an integer \nnum\n, return \nthe number of steps to reduce it to zero\n.\n\n\nIn one step, if the current number is even, you have to divide it by \n2\n, otherwise, you have to subtract \n1\n from it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 14\n\nOutput:\n 6\n\nExplanation:\n \nStep 1) 14 is even; divide by 2 and obtain 7. \nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3. \nStep 4) 3 is odd; subtract 1 and obtain 2. \nStep 5) 2 is even; divide by 2 and obtain 1. \nStep 6) 1 is odd; subtract 1 and obtain 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 8\n\nOutput:\n 4\n\nExplanation:\n \nStep 1) 8 is even; divide by 2 and obtain 4. \nStep 2) 4 is even; divide by 2 and obtain 2. \nStep 3) 2 is even; divide by 2 and obtain 1. \nStep 4) 1 is odd; subtract 1 and obtain 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = 123\n\nOutput:\n 12\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 10\n6",
        "temas": [
            "Math",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1317,
        "slug": "convert-integer-to-the-sum-of-two-no-zero-integers",
        "url": "https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/",
        "titulo": "Convert Integer to the Sum of Two No-Zero Integers",
        "enunciado": "No-Zero integer\n is a positive integer that \ndoes not contain any \n0\n in its decimal representation.\n\n\nGiven an integer \nn\n, return \na list of two integers\n \n[a, b]\n \nwhere\n:\n\n\n\n\na\n and \nb\n are \nNo-Zero integers\n.\n\n\na + b = n\n\n\n\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n [1,1]\n\nExplanation:\n Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 11\n\nOutput:\n [2,9]\n\nExplanation:\n Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 11 = n.\nNote that there are other valid answers as [8, 3] that can be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n4",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1309,
        "slug": "decrypt-string-from-alphabet-to-integer-mapping",
        "url": "https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/",
        "titulo": "Decrypt String from Alphabet to Integer Mapping",
        "enunciado": "You are given a string \ns\n formed by digits and \n'#'\n. We want to map \ns\n to English lowercase characters as follows:\n\n\n\n\nCharacters (\n'a'\n to \n'i'\n) are represented by (\n'1'\n to \n'9'\n) respectively.\n\n\nCharacters (\n'j'\n to \n'z'\n) are represented by (\n'10#'\n to \n'26#'\n) respectively.\n\n\n\n\nReturn \nthe string formed after mapping\n.\n\n\nThe test cases are generated so that a unique mapping will always exist.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"10#11#12\"\n\nOutput:\n \"jkab\"\n\nExplanation:\n \"j\" -> \"10#\" , \"k\" -> \"11#\" , \"a\" -> \"1\" , \"b\" -> \"2\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"1326#\"\n\nOutput:\n \"acz\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of digits and the \n'#'\n letter.\n\n\ns\n will be a valid string such that mapping is always possible.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 2269,
        "slug": "find-the-k-beauty-of-a-number",
        "url": "https://leetcode.com/problems/find-the-k-beauty-of-a-number/",
        "titulo": "Find the K-Beauty of a Number",
        "enunciado": "The \nk-beauty\n of an integer \nnum\n is defined as the number of \nsubstrings\n of \nnum\n when it is read as a string that meet the following conditions:\n\n\n\n\nIt has a length of \nk\n.\n\n\nIt is a divisor of \nnum\n.\n\n\n\n\nGiven integers \nnum\n and \nk\n, return \nthe k-beauty of \nnum\n.\n\n\nNote:\n\n\n\n\nLeading zeros\n are allowed.\n\n\n0\n is not a divisor of any value.\n\n\n\n\nA \nsubstring\n is a contiguous sequence of characters in a string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 240, k = 2\n\nOutput:\n 2\n\nExplanation:\n The following are the substrings of num of length k:\n- \"24\" from \"\n24\n0\": 24 is a divisor of 240.\n- \"40\" from \"2\n40\n\": 40 is a divisor of 240.\nTherefore, the k-beauty is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 430043, k = 2\n\nOutput:\n 2\n\nExplanation:\n The following are the substrings of num of length k:\n- \"43\" from \"\n43\n0043\": 43 is a divisor of 430043.\n- \"30\" from \"4\n30\n043\": 30 is not a divisor of 430043.\n- \"00\" from \"43\n00\n43\": 0 is not a divisor of 430043.\n- \"04\" from \"430\n04\n3\": 4 is not a divisor of 430043.\n- \"43\" from \"4300\n43\n\": 43 is a divisor of 430043.\nTherefore, the k-beauty is 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 10\n9\n\n\n1 <= k <= num.length\n (taking \nnum\n as a string)",
        "temas": [
            "Math",
            "String",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1304,
        "slug": "find-n-unique-integers-sum-up-to-zero",
        "url": "https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/",
        "titulo": "Find N Unique Integers Sum up to Zero",
        "enunciado": "Given an integer \nn\n, return \nany\n array containing \nn\n \nunique\n integers such that they add up to \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n [-7,-1,1,3,4]\n\nExplanation:\n These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n [-1,0,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1295,
        "slug": "find-numbers-with-even-number-of-digits",
        "url": "https://leetcode.com/problems/find-numbers-with-even-number-of-digits/",
        "titulo": "Find Numbers with Even Number of Digits",
        "enunciado": "Given an array \nnums\n of integers, return how many of them contain an \neven number\n of digits.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [12,345,2,6,7896]\n\nOutput:\n 2\n\nExplanation: \n\n12 contains 2 digits (even number of digits). \n345 contains 3 digits (odd number of digits). \n2 contains 1 digit (odd number of digits). \n6 contains 1 digit (odd number of digits). \n7896 contains 4 digits (even number of digits). \nTherefore only 12 and 7896 contain an even number of digits.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [555,901,482,1771]\n\nOutput:\n 1 \n\nExplanation: \n\nOnly 1771 contains an even number of digits.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 500\n\n\n1 <= nums[i] <= 10\n5",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1290,
        "slug": "convert-binary-number-in-a-linked-list-to-integer",
        "url": "https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/",
        "titulo": "Convert Binary Number in a Linked List to Integer",
        "enunciado": "Given \nhead\n which is a reference node to a singly-linked list. The value of each node in the linked list is either \n0\n or \n1\n. The linked list holds the binary representation of a number.\n\n\nReturn the \ndecimal value\n of the number in the linked list.\n\n\nThe \nmost significant bit\n is at the head of the linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,0,1]\n\nOutput:\n 5\n\nExplanation:\n (101) in base 2 = (5) in base 10\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [0]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe Linked List is not empty.\n\n\nNumber of nodes will not exceed \n30\n.\n\n\nEach node's value is either \n0\n or \n1\n.",
        "temas": [
            "Linked List",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 1281,
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "url": "https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/",
        "titulo": "Subtract the Product and Sum of Digits of an Integer",
        "enunciado": "Given an integer number \nn\n, return the difference between the product of its digits and the sum of its digits.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 234\n\nOutput:\n 15 \n\nExplanation:\n \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 4421\n\nOutput:\n 21\n\nExplanation: \n\nProduct of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10^5",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1275,
        "slug": "find-winner-on-a-tic-tac-toe-game",
        "url": "https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/",
        "titulo": "Find Winner on a Tic Tac Toe Game",
        "enunciado": "Tic-tac-toe\n is played by two players \nA\n and \nB\n on a \n3 x 3\n grid. The rules of Tic-Tac-Toe are:\n\n\n\n\nPlayers take turns placing characters into empty squares \n' '\n.\n\n\nThe first player \nA\n always places \n'X'\n characters, while the second player \nB\n always places \n'O'\n characters.\n\n\n'X'\n and \n'O'\n characters are always placed into empty squares, never on filled ones.\n\n\nThe game ends when there are \nthree\n of the same (non-empty) character filling any row, column, or diagonal.\n\n\nThe game also ends if all squares are non-empty.\n\n\nNo more moves can be played if the game is over.\n\n\n\n\nGiven a 2D integer array \nmoves\n where \nmoves[i] = [row\ni\n, col\ni\n]\n indicates that the \ni\nth\n move will be played on \ngrid[row\ni\n][col\ni\n]\n. return \nthe winner of the game if it exists\n (\nA\n or \nB\n). In case the game ends in a draw return \n\"Draw\"\n. If there are still movements to play return \n\"Pending\"\n.\n\n\nYou can assume that \nmoves\n is valid (i.e., it follows the rules of \nTic-Tac-Toe\n), the grid is initially empty, and \nA\n will play first.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\n\nOutput:\n \"A\"\n\nExplanation:\n A wins, they always play first.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\n\nOutput:\n \"B\"\n\nExplanation:\n B wins.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\n\nOutput:\n \"Draw\"\n\nExplanation:\n The game ends in a draw since there are no moves to make.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= moves.length <= 9\n\n\nmoves[i].length == 2\n\n\n0 <= row\ni\n, col\ni\n <= 2\n\n\nThere are no repeated elements on \nmoves\n.\n\n\nmoves\n follow the rules of tic tac toe.",
        "temas": [
            "Array",
            "Hash Table",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1266,
        "slug": "minimum-time-visiting-all-points",
        "url": "https://leetcode.com/problems/minimum-time-visiting-all-points/",
        "titulo": "Minimum Time Visiting All Points",
        "enunciado": "On a 2D plane, there are \nn\n points with integer coordinates \npoints[i] = [x\ni\n, y\ni\n]\n. Return \nthe \nminimum time\n in seconds to visit all the points in the order given by \npoints\n.\n\n\nYou can move according to these rules:\n\n\n\n\nIn \n1\n second, you can either:\n\n\t\n\n\nmove vertically by one unit,\n\n\nmove horizontally by one unit, or\n\n\nmove diagonally \nsqrt(2)\n units (in other words, move one unit vertically then one unit horizontally in \n1\n second).\n\n\n\n\n\n\nYou have to visit the points in the same order as they appear in the array.\n\n\nYou are allowed to pass through points that appear later in the order, but these do not count as visits.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,1],[3,4],[-1,0]]\n\nOutput:\n 7\n\nExplanation: \nOne optimal path is \n[1,1]\n -> [2,2] -> [3,3] -> \n[3,4] \n-> [2,3] -> [1,2] -> [0,1] -> \n[-1,0]\n   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,2],[-2,2]]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\npoints.length == n\n\n\n1 <= n <= 100\n\n\npoints[i].length == 2\n\n\n-1000 <= points[i][0], points[i][1] <= 1000",
        "temas": [
            "Array",
            "Math",
            "Geometry"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2215,
        "slug": "find-the-difference-of-two-arrays",
        "url": "https://leetcode.com/problems/find-the-difference-of-two-arrays/",
        "titulo": "Find the Difference of Two Arrays",
        "enunciado": "Given two \n0-indexed\n integer arrays \nnums1\n and \nnums2\n, return \na list\n \nanswer\n \nof size\n \n2\n \nwhere:\n\n\n\n\nanswer[0]\n \nis a list of all \ndistinct\n integers in\n \nnums1\n \nwhich are \nnot\n present in\n \nnums2\n.\n\n\nanswer[1]\n \nis a list of all \ndistinct\n integers in\n \nnums2\n \nwhich are \nnot\n present in\n \nnums1\n.\n\n\n\n\nNote\n that the integers in the lists may be returned in \nany\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3], nums2 = [2,4,6]\n\nOutput:\n [[1,3],[4,6]]\n\nExplanation:\n\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums1. Therefore, answer[1] = [4,6].\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n\nOutput:\n [[3],[]]\n\nExplanation:\n\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 1000\n\n\n-1000 <= nums1[i], nums2[i] <= 1000",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1260,
        "slug": "shift-2d-grid",
        "url": "https://leetcode.com/problems/shift-2d-grid/",
        "titulo": "Shift 2D Grid",
        "enunciado": "Given a 2D \ngrid\n of size \nm x n\n and an integer \nk\n. You need to shift the \ngrid\n \nk\n times.\n\n\nIn one shift operation:\n\n\n\n\nElement at \ngrid[i][j]\n moves to \ngrid[i][j + 1]\n.\n\n\nElement at \ngrid[i][n - 1]\n moves to \ngrid[i + 1][0]\n.\n\n\nElement at \ngrid[m - 1][n - 1]\n moves to \ngrid[0][0]\n.\n\n\n\n\nReturn the \n2D grid\n after applying shift operation \nk\n times.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \ngrid\n = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n\nOutput:\n [[9,1,2],[3,4,5],[6,7,8]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \ngrid\n = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\n\nOutput:\n [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid\n = [[1,2,3],[4,5,6],[7,8,9]], k = 9\n\nOutput:\n [[1,2,3],[4,5,6],[7,8,9]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m <= 50\n\n\n1 <= n <= 50\n\n\n-1000 <= grid[i][j] <= 1000\n\n\n0 <= k <= 100",
        "temas": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2303,
        "slug": "calculate-amount-paid-in-taxes",
        "url": "https://leetcode.com/problems/calculate-amount-paid-in-taxes/",
        "titulo": "Calculate Amount Paid in Taxes",
        "enunciado": "You are given a \n0-indexed\n 2D integer array \nbrackets\n where \nbrackets[i] = [upper\ni\n, percent\ni\n]\n means that the \ni\nth\n tax bracket has an upper bound of \nupper\ni\n and is taxed at a rate of \npercent\ni\n. The brackets are \nsorted\n by upper bound (i.e. \nupper\ni-1\n < upper\ni\n for \n0 < i < brackets.length\n).\n\n\nTax is calculated as follows:\n\n\n\n\nThe first \nupper\n0\n dollars earned are taxed at a rate of \npercent\n0\n.\n\n\nThe next \nupper\n1\n - upper\n0\n dollars earned are taxed at a rate of \npercent\n1\n.\n\n\nThe next \nupper\n2\n - upper\n1\n dollars earned are taxed at a rate of \npercent\n2\n.\n\n\nAnd so on.\n\n\n\n\nYou are given an integer \nincome\n representing the amount of money you earned. Return \nthe amount of money that you have to pay in taxes.\n Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n brackets = [[3,50],[7,10],[12,25]], income = 10\n\nOutput:\n 2.65000\n\nExplanation:\n\nBased on your income, you have 3 dollars in the 1\nst\n tax bracket, 4 dollars in the 2\nnd\n tax bracket, and 3 dollars in the 3\nrd\n tax bracket.\nThe tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.\nIn total, you pay $3 * 50% + $4 * 10% + $3 * 25% = $2.65 in taxes.\n\n\n\nExample 2:\n\n\n\n\nInput:\n brackets = [[1,0],[4,25],[5,50]], income = 2\n\nOutput:\n 0.25000\n\nExplanation:\n\nBased on your income, you have 1 dollar in the 1\nst\n tax bracket and 1 dollar in the 2\nnd\n tax bracket.\nThe tax rate for the two tax brackets is 0% and 25%, respectively.\nIn total, you pay $1 * 0% + $1 * 25% = $0.25 in taxes.\n\n\n\nExample 3:\n\n\n\n\nInput:\n brackets = [[2,50]], income = 0\n\nOutput:\n 0.00000\n\nExplanation:\n\nYou have no income to tax, so you have to pay a total of $0 in taxes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= brackets.length <= 100\n\n\n1 <= upper\ni\n <= 1000\n\n\n0 <= percent\ni\n <= 100\n\n\n0 <= income <= 1000\n\n\nupper\ni\n is sorted in ascending order.\n\n\nAll the values of \nupper\ni\n are \nunique\n.\n\n\nThe upper bound of the last tax bracket is greater than or equal to \nincome\n.",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1252,
        "slug": "cells-with-odd-values-in-a-matrix",
        "url": "https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/",
        "titulo": "Cells with Odd Values in a Matrix",
        "enunciado": "There is an \nm x n\n matrix that is initialized to all \n0\n's. There is also a 2D array \nindices\n where each \nindices[i] = [r\ni\n, c\ni\n]\n represents a \n0-indexed location\n to perform some increment operations on the matrix.\n\n\nFor each location \nindices[i]\n, do \nboth\n of the following:\n\n\n\n\nIncrement \nall\n the cells on row \nr\ni\n.\n\n\nIncrement \nall\n the cells on column \nc\ni\n.\n\n\n\n\nGiven \nm\n, \nn\n, and \nindices\n, return \nthe \nnumber of odd-valued cells\n in the matrix after applying the increment to all locations in \nindices\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 2, n = 3, indices = [[0,1],[1,1]]\n\nOutput:\n 6\n\nExplanation:\n Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 2, n = 2, indices = [[1,1],[0,0]]\n\nOutput:\n 0\n\nExplanation:\n Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 50\n\n\n1 <= indices.length <= 100\n\n\n0 <= r\ni\n < m\n\n\n0 <= c\ni\n < n\n\n\n\n\n \n\n\nFollow up:\n Could you solve this in \nO(n + m + indices.length)\n time with only \nO(n + m)\n extra space?",
        "temas": [
            "Array",
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 2309,
        "slug": "greatest-english-letter-in-upper-and-lower-case",
        "url": "https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/",
        "titulo": "Greatest English Letter in Upper and Lower Case",
        "enunciado": "Given a string of English letters \ns\n, return \nthe \ngreatest \nEnglish letter which occurs as \nboth\n a lowercase and uppercase letter in\n \ns\n. The returned letter should be in \nuppercase\n. If no such letter exists, return \nan empty string\n.\n\n\nAn English letter \nb\n is \ngreater\n than another letter \na\n if \nb\n appears \nafter\n \na\n in the English alphabet.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"l\nEe\nTcOd\nE\n\"\n\nOutput:\n \"E\"\n\nExplanation:\n\nThe letter 'E' is the only letter to appear in both lower and upper case.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\nrR\nAzFif\"\n\nOutput:\n \"R\"\n\nExplanation:\n\nThe letter 'R' is the greatest letter to appear in both lower and upper case.\nNote that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"AbCdEfGhIjK\"\n\nOutput:\n \"\"\n\nExplanation:\n\nThere is no letter that appears in both lower and upper case.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of lowercase and uppercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Enumeration"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 2273,
        "slug": "find-resultant-array-after-removing-anagrams",
        "url": "https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/",
        "titulo": "Find Resultant Array After Removing Anagrams",
        "enunciado": "You are given a \n0-indexed\n string array \nwords\n, where \nwords[i]\n consists of lowercase English letters.\n\n\nIn one operation, select any index \ni\n such that \n0 < i < words.length\n and \nwords[i - 1]\n and \nwords[i]\n are \nanagrams\n, and \ndelete\n \nwords[i]\n from \nwords\n. Keep performing this operation as long as you can select an index that satisfies the conditions.\n\n\nReturn \nwords\n \nafter performing all operations\n. It can be shown that selecting the indices for each operation in \nany\n arbitrary order will lead to the same result.\n\n\nAn \nAnagram\n is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, \n\"dacb\"\n is an anagram of \n\"abdc\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]\n\nOutput:\n [\"abba\",\"cd\"]\n\nExplanation:\n\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words[2] = \"bbaa\" and words[1] = \"baba\" are anagrams, we choose index 2 and delete words[2].\n  Now words = [\"abba\",\"baba\",\"cd\",\"cd\"].\n- Since words[1] = \"baba\" and words[0] = \"abba\" are anagrams, we choose index 1 and delete words[1].\n  Now words = [\"abba\",\"cd\",\"cd\"].\n- Since words[2] = \"cd\" and words[1] = \"cd\" are anagrams, we choose index 2 and delete words[2].\n  Now words = [\"abba\",\"cd\"].\nWe can no longer perform any operations, so [\"abba\",\"cd\"] is the final answer.\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n\nOutput:\n [\"a\",\"b\",\"c\",\"d\",\"e\"]\n\nExplanation:\n\nNo two adjacent strings in words are anagrams of each other, so no operations are performed.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1232,
        "slug": "check-if-it-is-a-straight-line",
        "url": "https://leetcode.com/problems/check-if-it-is-a-straight-line/",
        "titulo": "Check If It Is a Straight Line",
        "enunciado": "You are given an array \ncoordinates\n, \ncoordinates[i] = [x, y]\n, where \n[x, y]\n represents the coordinate of a point. Check if these points make a straight line in the XY plane.\n\n\n \n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= coordinates.length <= 1000\n\n\ncoordinates[i].length == 2\n\n\n-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4\n\n\ncoordinates\n contains no duplicate point.",
        "temas": [
            "Array",
            "Math",
            "Geometry"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1221,
        "slug": "split-a-string-in-balanced-strings",
        "url": "https://leetcode.com/problems/split-a-string-in-balanced-strings/",
        "titulo": "Split a String in Balanced Strings",
        "enunciado": "Balanced\n strings are those that have an equal quantity of \n'L'\n and \n'R'\n characters.\n\n\nGiven a \nbalanced\n string \ns\n, split it into some number of substrings such that:\n\n\n\n\nEach substring is balanced.\n\n\n\n\nReturn \nthe \nmaximum\n number of balanced strings you can obtain.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"RLRRLLRLRL\"\n\nOutput:\n 4\n\nExplanation:\n s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"RLRRRLLRLL\"\n\nOutput:\n 2\n\nExplanation:\n s can be split into \"RL\", \"RRRLLRLL\", each substring contains same number of 'L' and 'R'.\nNote that s cannot be split into \"RL\", \"RR\", \"RL\", \"LR\", \"LL\", because the 2\nnd\n and 5\nth\n substrings are not balanced.\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"LLLLRRRR\"\n\nOutput:\n 1\n\nExplanation:\n s can be split into \"LLLLRRRR\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 1000\n\n\ns[i]\n is either \n'L'\n or \n'R'\n.\n\n\ns\n is a \nbalanced\n string.",
        "temas": [
            "String",
            "Greedy",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1217,
        "slug": "minimum-cost-to-move-chips-to-the-same-position",
        "url": "https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/",
        "titulo": "Minimum Cost to Move Chips to The Same Position",
        "enunciado": "We have \nn\n chips, where the position of the \ni\nth\n chip is \nposition[i]\n.\n\n\nWe need to move all the chips to \nthe same position\n. In one step, we can change the position of the \ni\nth\n chip from \nposition[i]\n to:\n\n\n\n\nposition[i] + 2\n or \nposition[i] - 2\n with \ncost = 0\n.\n\n\nposition[i] + 1\n or \nposition[i] - 1\n with \ncost = 1\n.\n\n\n\n\nReturn \nthe minimum cost\n needed to move all the chips to the same position.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n position = [1,2,3]\n\nOutput:\n 1\n\nExplanation:\n First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n position = [2,2,2,3,3]\n\nOutput:\n 2\n\nExplanation:\n We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n position = [1,1000000000]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= position.length <= 100\n\n\n1 <= position[i] <= 10^9",
        "temas": [
            "Array",
            "Math",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1207,
        "slug": "unique-number-of-occurrences",
        "url": "https://leetcode.com/problems/unique-number-of-occurrences/",
        "titulo": "Unique Number of Occurrences",
        "enunciado": "Given an array of integers \narr\n, return \ntrue\n \nif the number of occurrences of each value in the array is \nunique\n or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [1,2,2,1,1,3]\n\nOutput:\n true\n\nExplanation:\n The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [-3,0,1,-3,1,1,1,-3,10,0]\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 1000\n\n\n-1000 <= arr[i] <= 1000",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1200,
        "slug": "minimum-absolute-difference",
        "url": "https://leetcode.com/problems/minimum-absolute-difference/",
        "titulo": "Minimum Absolute Difference",
        "enunciado": "Given an array of \ndistinct\n integers \narr\n, find all pairs of elements with the minimum absolute difference of any two elements.\n\n\nReturn a list of pairs in ascending order(with respect to pairs), each pair \n[a, b]\n follows\n\n\n\n\na, b\n are from \narr\n\n\na < b\n\n\nb - a\n equals to the minimum absolute difference of any two elements in \narr\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [4,2,1,3]\n\nOutput:\n [[1,2],[2,3],[3,4]]\n\nExplanation: \nThe minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,3,6,10,15]\n\nOutput:\n [[1,3]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [3,8,-10,23,19,-4,-14,27]\n\nOutput:\n [[-14,-10],[19,23],[23,27]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= arr.length <= 10\n5\n\n\n-10\n6\n <= arr[i] <= 10\n6",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1957,
        "slug": "delete-characters-to-make-fancy-string",
        "url": "https://leetcode.com/problems/delete-characters-to-make-fancy-string/",
        "titulo": "Delete Characters to Make Fancy String",
        "enunciado": "A \nfancy string\n is a string where no \nthree\n \nconsecutive\n characters are equal.\n\n\nGiven a string \ns\n, delete the \nminimum\n possible number of characters from \ns\n to make it \nfancy\n.\n\n\nReturn \nthe final string after the deletion\n. It can be shown that the answer will always be \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"le\ne\netcode\"\n\nOutput:\n \"leetcode\"\n\nExplanation:\n\nRemove an 'e' from the first group of 'e's to create \"leetcode\".\nNo three consecutive characters are equal, so return \"leetcode\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"\na\naab\naa\naa\"\n\nOutput:\n \"aabaa\"\n\nExplanation:\n\nRemove an 'a' from the first group of 'a's to create \"aabaaaa\".\nRemove two 'a's from the second group of 'a's to create \"aabaa\".\nNo three consecutive characters are equal, so return \"aabaa\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"aab\"\n\nOutput:\n \"aab\"\n\nExplanation:\n No three consecutive characters are equal, so return \"aab\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists only of lowercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1189,
        "slug": "maximum-number-of-balloons",
        "url": "https://leetcode.com/problems/maximum-number-of-balloons/",
        "titulo": "Maximum Number of Balloons",
        "enunciado": "Given a string \ntext\n, you want to use the characters of \ntext\n to form as many instances of the word \n\"balloon\"\n as possible.\n\n\nYou can use each character in \ntext\n \nat most once\n. Return the maximum number of instances that can be formed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n text = \"nlaebolko\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n text = \"loonbalxballpoon\"\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n text = \"leetcode\"\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text.length <= 10\n4\n\n\ntext\n consists of lower case English letters only.\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 2287: Rearrange Characters to Make Target String.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1550,
        "slug": "three-consecutive-odds",
        "url": "https://leetcode.com/problems/three-consecutive-odds/",
        "titulo": "Three Consecutive Odds",
        "enunciado": "Given an integer array \narr\n, return \ntrue\n if there are three consecutive odd numbers in the array. Otherwise, return \nfalse\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [2,6,4,1]\n\nOutput:\n false\n\nExplanation:\n There are no three consecutive odds.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,34,3,4,5,7,23,12]\n\nOutput:\n true\n\nExplanation:\n [5,7,23] are three consecutive odds.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 1000\n\n\n1 <= arr[i] <= 1000",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1185,
        "slug": "day-of-the-week",
        "url": "https://leetcode.com/problems/day-of-the-week/",
        "titulo": "Day of the Week",
        "enunciado": "Given a date, return the corresponding day of the week for that date.\n\n\nThe input is given as three integers representing the \nday\n, \nmonth\n and \nyear\n respectively.\n\n\nReturn the answer as one of the following values \n{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n day = 31, month = 8, year = 2019\n\nOutput:\n \"Saturday\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n day = 18, month = 7, year = 1999\n\nOutput:\n \"Sunday\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n day = 15, month = 8, year = 1993\n\nOutput:\n \"Sunday\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe given dates are valid dates between the years \n1971\n and \n2100\n.",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1184,
        "slug": "distance-between-bus-stops",
        "url": "https://leetcode.com/problems/distance-between-bus-stops/",
        "titulo": "Distance Between Bus Stops",
        "enunciado": "A bus has \nn\n stops numbered from \n0\n to \nn - 1\n that form a circle. We know the distance between all pairs of neighboring stops where \ndistance[i]\n is the distance between the stops number \ni\n and \n(i + 1) % n\n.\n\n\nThe bus goes along both directions i.e. clockwise and counterclockwise.\n\n\nReturn the shortest distance between the given \nstart\n and \ndestination\n stops.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n distance = [1,2,3,4], start = 0, destination = 1\r\n\nOutput:\n 1\r\n\nExplanation:\n Distance between 0 and 1 is 1 or 9, minimum is 1.\n\n\n \n\n\nExample 2:\n\n\n\n\n\r\n\nInput:\n distance = [1,2,3,4], start = 0, destination = 2\r\n\nOutput:\n 3\r\n\nExplanation:\n Distance between 0 and 2 is 3 or 7, minimum is 3.\r\n\n\n\n \n\n\nExample 3:\n\n\n\n\n\r\n\nInput:\n distance = [1,2,3,4], start = 0, destination = 3\r\n\nOutput:\n 4\r\n\nExplanation:\n Distance between 0 and 3 is 6 or 4, minimum is 4.\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10^4\n\n\ndistance.length == n\n\n\n0 <= start, destination < n\n\n\n0 <= distance[i] <= 10^4",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1507,
        "slug": "reformat-date",
        "url": "https://leetcode.com/problems/reformat-date/",
        "titulo": "Reformat Date",
        "enunciado": "Given a \ndate\n string in the form \nDay Month Year\n, where:\n\n\n\n\nDay\n is in the set \n{\"1st\", \"2nd\", \"3rd\", \"4th\", ..., \"30th\", \"31st\"}\n.\n\n\nMonth\n is in the set \n{\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"}\n.\n\n\nYear\n is in the range \n[1900, 2100]\n.\n\n\n\n\nConvert the date string to the format \nYYYY-MM-DD\n, where:\n\n\n\n\nYYYY\n denotes the 4 digit year.\n\n\nMM\n denotes the 2 digit month.\n\n\nDD\n denotes the 2 digit day.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n date = \"20th Oct 2052\"\n\nOutput:\n \"2052-10-20\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n date = \"6th Jun 1933\"\n\nOutput:\n \"1933-06-06\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n date = \"26th May 1960\"\n\nOutput:\n \"1960-05-26\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe given dates are guaranteed to be valid, so no error handling is necessary.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1175,
        "slug": "prime-arrangements",
        "url": "https://leetcode.com/problems/prime-arrangements/",
        "titulo": "Prime Arrangements",
        "enunciado": "Return the number of permutations of 1 to \nn\n so that prime numbers are at prime indices (1-indexed.)\n\n\n(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)\n\n\nSince the answer may be large, return the answer \nmodulo \n10^9 + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 12\n\nExplanation:\n For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 100\n\nOutput:\n 682289015\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1360,
        "slug": "number-of-days-between-two-dates",
        "url": "https://leetcode.com/problems/number-of-days-between-two-dates/",
        "titulo": "Number of Days Between Two Dates",
        "enunciado": "Write a program to count the number of days between two dates.\n\n\nThe two dates are given as strings, their format is \nYYYY-MM-DD\n as shown in the examples.\n\n\n \n\n\nExample 1:\n\n\nInput:\n date1 = \"2019-06-29\", date2 = \"2019-06-30\"\n\nOutput:\n 1\n\nExample 2:\n\n\nInput:\n date1 = \"2020-01-15\", date2 = \"2019-12-31\"\n\nOutput:\n 15\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe given dates are valid dates between the years \n1971\n and \n2100\n.",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1935,
        "slug": "maximum-number-of-words-you-can-type",
        "url": "https://leetcode.com/problems/maximum-number-of-words-you-can-type/",
        "titulo": "Maximum Number of Words You Can Type",
        "enunciado": "There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.\n\n\nGiven a string \ntext\n of words separated by a single space (no leading or trailing spaces) and a string \nbrokenLetters\n of all \ndistinct\n letter keys that are broken, return \nthe \nnumber of words\n in\n \ntext\n \nyou can fully type using this keyboard\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n text = \"hello world\", brokenLetters = \"ad\"\n\nOutput:\n 1\n\nExplanation:\n We cannot type \"world\" because the 'd' key is broken.\n\n\n\nExample 2:\n\n\n\n\nInput:\n text = \"leet code\", brokenLetters = \"lt\"\n\nOutput:\n 1\n\nExplanation:\n We cannot type \"leet\" because the 'l' and 't' keys are broken.\n\n\n\nExample 3:\n\n\n\n\nInput:\n text = \"leet code\", brokenLetters = \"e\"\n\nOutput:\n 0\n\nExplanation:\n We cannot type either word because the 'e' key is broken.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text.length <= 10\n4\n\n\n0 <= brokenLetters.length <= 26\n\n\ntext\n consists of words separated by a single space without any leading or trailing spaces.\n\n\nEach word only consists of lowercase English letters.\n\n\nbrokenLetters\n consists of \ndistinct\n lowercase English letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 1154,
        "slug": "day-of-the-year",
        "url": "https://leetcode.com/problems/day-of-the-year/",
        "titulo": "Day of the Year",
        "enunciado": "Given a string \ndate\n representing a \nGregorian calendar\n date formatted as \nYYYY-MM-DD\n, return \nthe day number of the year\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n date = \"2019-01-09\"\n\nOutput:\n 9\n\nExplanation:\n Given date is the 9th day of the year in 2019.\n\n\n\nExample 2:\n\n\n\n\nInput:\n date = \"2019-02-10\"\n\nOutput:\n 41\n\n\n\n \n\n\nConstraints:\n\n\n\n\ndate.length == 10\n\n\ndate[4] == date[7] == '-'\n, and all other \ndate[i]\n's are digits\n\n\ndate\n represents a calendar date between Jan 1\nst\n, 1900 and Dec 31\nst\n, 2019.",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1331,
        "slug": "rank-transform-of-an-array",
        "url": "https://leetcode.com/problems/rank-transform-of-an-array/",
        "titulo": "Rank Transform of an Array",
        "enunciado": "Given an array of integers \narr\n, replace each element with its rank.\n\n\nThe rank represents how large the element is. The rank has the following rules:\n\n\n\n\nRank is an integer starting from 1.\n\n\nThe larger the element, the larger the rank. If two elements are equal, their rank must be the same.\n\n\nRank should be as small as possible.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [40,10,20,30]\n\nOutput:\n [4,1,2,3]\n\nExplanation\n: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [100,100,100]\n\nOutput:\n [1,1,1]\n\nExplanation\n: Same elements share the same rank.\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [37,12,28,9,100,56,80,5,12]\n\nOutput:\n [5,3,4,2,8,6,7,1,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= arr.length <= 10\n5\n\n\n-10\n9\n <= arr[i] <= 10\n9",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1313,
        "slug": "decompress-run-length-encoded-list",
        "url": "https://leetcode.com/problems/decompress-run-length-encoded-list/",
        "titulo": "Decompress Run-Length Encoded List",
        "enunciado": "We are given a list \nnums\n of integers representing a list compressed with run-length encoding.\n\n\nConsider each adjacent pair of elements \n[freq, val] = [nums[2*i], nums[2*i+1]]\n (with \ni >= 0\n).  For each such pair, there are \nfreq\n elements with value \nval\n concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.\n\n\nReturn the decompressed list.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [2,4,4,4]\n\nExplanation:\n The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].\nThe second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].\nAt the end the concatenation [2] + [4,4,4] is [2,4,4,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,2,3]\n\nOutput:\n [1,3,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 100\n\n\nnums.length % 2 == 0\n\n\n1 <= nums[i] <= 100",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1137,
        "slug": "n-th-tribonacci-number",
        "url": "https://leetcode.com/problems/n-th-tribonacci-number/",
        "titulo": "N-th Tribonacci Number",
        "enunciado": "The Tribonacci sequence T\nn\n is defined as follows: \n\n\nT\n0\n = 0, T\n1\n = 1, T\n2\n = 1, and T\nn+3\n = T\nn\n + T\nn+1\n + T\nn+2\n for n >= 0.\n\n\nGiven \nn\n, return the value of T\nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 4\n\nExplanation:\n\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 25\n\nOutput:\n 1389537\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 37\n\n\nThe answer is guaranteed to fit within a 32-bit integer, ie. \nanswer <= 2^31 - 1\n.",
        "temas": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1299,
        "slug": "replace-elements-with-greatest-element-on-right-side",
        "url": "https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/",
        "titulo": "Replace Elements with Greatest Element on Right Side",
        "enunciado": "Given an array \narr\n, replace every element in that array with the greatest element among the elements to its right, and replace the last element with \n-1\n.\n\n\nAfter doing so, return the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [17,18,5,4,6,1]\n\nOutput:\n [18,6,6,6,1,-1]\n\nExplanation:\n \n- index 0 --> the greatest element to the right of index 0 is index 1 (18).\n- index 1 --> the greatest element to the right of index 1 is index 4 (6).\n- index 2 --> the greatest element to the right of index 2 is index 4 (6).\n- index 3 --> the greatest element to the right of index 3 is index 4 (6).\n- index 4 --> the greatest element to the right of index 4 is index 5 (1).\n- index 5 --> there are no elements to the right of index 5, so we put -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [400]\n\nOutput:\n [-1]\n\nExplanation:\n There are no elements to the right of index 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 10\n4\n\n\n1 <= arr[i] <= 10\n5",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1128,
        "slug": "number-of-equivalent-domino-pairs",
        "url": "https://leetcode.com/problems/number-of-equivalent-domino-pairs/",
        "titulo": "Number of Equivalent Domino Pairs",
        "enunciado": "Given a list of \ndominoes\n, \ndominoes[i] = [a, b]\n is \nequivalent to\n \ndominoes[j] = [c, d]\n if and only if either (\na == c\n and \nb == d\n), or (\na == d\n and \nb == c\n) - that is, one domino can be rotated to be equal to another domino.\n\n\nReturn \nthe number of pairs \n(i, j)\n for which \n0 <= i < j < dominoes.length\n, and \ndominoes[i]\n is \nequivalent to\n \ndominoes[j]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n dominoes = [[1,2],[2,1],[3,4],[5,6]]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= dominoes.length <= 4 * 10\n4\n\n\ndominoes[i].length == 2\n\n\n1 <= dominoes[i][j] <= 9",
        "temas": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1287,
        "slug": "element-appearing-more-than-25-in-sorted-array",
        "url": "https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/",
        "titulo": "Element Appearing More Than 25% In Sorted Array",
        "enunciado": "Given an integer array \nsorted\n in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [1,2,2,6,6,6,6,7,10]\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 10\n4\n\n\n0 <= arr[i] <= 10\n5",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1122,
        "slug": "relative-sort-array",
        "url": "https://leetcode.com/problems/relative-sort-array/",
        "titulo": "Relative Sort Array",
        "enunciado": "Given two arrays \narr1\n and \narr2\n, the elements of \narr2\n are distinct, and all elements in \narr2\n are also in \narr1\n.\n\n\nSort the elements of \narr1\n such that the relative ordering of items in \narr1\n are the same as in \narr2\n. Elements that do not appear in \narr2\n should be placed at the end of \narr1\n in \nascending\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\n\nOutput:\n [2,2,2,1,4,3,3,9,6,7,19]\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\n\nOutput:\n [22,28,8,6,17,44]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr1.length, arr2.length <= 1000\n\n\n0 <= arr1[i], arr2[i] <= 1000\n\n\nAll the elements of \narr2\n are \ndistinct\n.\n\n\nEach \narr2[i]\n is in \narr1\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting Sort"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1619,
        "slug": "mean-of-array-after-removing-some-elements",
        "url": "https://leetcode.com/problems/mean-of-array-after-removing-some-elements/",
        "titulo": "Mean of Array After Removing Some Elements",
        "enunciado": "Given an integer array \narr\n, return \nthe mean of the remaining integers after removing the smallest \n5%\n and the largest \n5%\n of the elements.\n\n\nAnswers within \n10\n-5\n of the \nactual answer\n will be considered accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n\nOutput:\n 2.00000\n\nExplanation:\n After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n\nOutput:\n 4.00000\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n\nOutput:\n 4.77778\n\n\n\n \n\n\nConstraints:\n\n\n\n\n20 <= arr.length <= 1000\n\n\narr.length\n \nis a multiple\n of \n20\n.\n\n\n0 <= arr[i] <= 10\n5",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1108,
        "slug": "defanging-an-ip-address",
        "url": "https://leetcode.com/problems/defanging-an-ip-address/",
        "titulo": "Defanging an IP Address",
        "enunciado": "Given a valid (IPv4) IP \naddress\n, return a defanged version of that IP address.\n\n\nA \ndefanged IP address\n replaces every period \n\".\"\n with \n\"[.]\"\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n address = \"1.1.1.1\"\r\n\nOutput:\n \"1[.]1[.]1[.]1\"\r\n\nExample 2:\n\n\nInput:\n address = \"255.100.50.0\"\r\n\nOutput:\n \"255[.]100[.]50[.]0\"\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe given \naddress\n is a valid IPv4 address.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1103,
        "slug": "distribute-candies-to-people",
        "url": "https://leetcode.com/problems/distribute-candies-to-people/",
        "titulo": "Distribute Candies to People",
        "enunciado": "We distribute some number of \ncandies\n, to a row of \nn = num_people\n people in the following way:\n\n\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give \nn\n candies to the last person.\n\n\nThen, we go back to the start of the row, giving \nn + 1\n candies to the first person, \nn + 2\n candies to the second person, and so on until we give \n2 * n\n candies to the last person.\n\n\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\n\n\nReturn an array (of length \nnum_people\n and sum \ncandies\n) that represents the final distribution of candies.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candies = 7, num_people = 4\n\nOutput:\n [1,2,3,1]\n\nExplanation:\n\nOn the first turn, ans[0] += 1, and the array is [1,0,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3,0].\nOn the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n candies = 10, num_people = 3\n\nOutput:\n [5,2,3]\n\nExplanation: \n\nOn the first turn, ans[0] += 1, and the array is [1,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3].\nOn the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candies <= 10^9\n\n\n1 <= num_people <= 1000",
        "temas": [
            "Math",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1089,
        "slug": "duplicate-zeros",
        "url": "https://leetcode.com/problems/duplicate-zeros/",
        "titulo": "Duplicate Zeros",
        "enunciado": "Given a fixed-length integer array \narr\n, duplicate each occurrence of zero, shifting the remaining elements to the right.\n\n\nNote\n that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [1,0,2,3,0,4,5,0]\n\nOutput:\n [1,0,0,2,3,0,0,4]\n\nExplanation:\n After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,3]\n\nOutput:\n [1,2,3]\n\nExplanation:\n After calling your function, the input array is modified to: [1,2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 10\n4\n\n\n0 <= arr[i] <= 9",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1078,
        "slug": "occurrences-after-bigram",
        "url": "https://leetcode.com/problems/occurrences-after-bigram/",
        "titulo": "Occurrences After Bigram",
        "enunciado": "Given two strings \nfirst\n and \nsecond\n, consider occurrences in some text of the form \n\"first second third\"\n, where \nsecond\n comes immediately after \nfirst\n, and \nthird\n comes immediately after \nsecond\n.\n\n\nReturn \nan array of all the words\n \nthird\n \nfor each occurrence of\n \n\"first second third\"\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n\nOutput:\n [\"girl\",\"student\"]\n\nExample 2:\n\n\nInput:\n text = \"we will we will rock you\", first = \"we\", second = \"will\"\n\nOutput:\n [\"we\",\"rock\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text.length <= 1000\n\n\ntext\n consists of lowercase English letters and spaces.\n\n\nAll the words in \ntext\n are separated by \na single space\n.\n\n\n1 <= first.length, second.length <= 10\n\n\nfirst\n and \nsecond\n consist of lowercase English letters.\n\n\ntext\n will not have any leading or trailing spaces.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1071,
        "slug": "greatest-common-divisor-of-strings",
        "url": "https://leetcode.com/problems/greatest-common-divisor-of-strings/",
        "titulo": "Greatest Common Divisor of Strings",
        "enunciado": "For two strings \ns\n and \nt\n, we say \"\nt\n divides \ns\n\" if and only if \ns = t + t + t + ... + t + t\n (i.e., \nt\n is concatenated with itself one or more times).\n\n\nGiven two strings \nstr1\n and \nstr2\n, return \nthe largest string \nx\n such that \nx\n divides both \nstr1\n and \nstr2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n str1 = \"ABCABC\", str2 = \"ABC\"\n\nOutput:\n \"ABC\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n str1 = \"ABABAB\", str2 = \"ABAB\"\n\nOutput:\n \"AB\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n str1 = \"LEET\", str2 = \"CODE\"\n\nOutput:\n \"\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= str1.length, str2.length <= 1000\n\n\nstr1\n and \nstr2\n consist of English uppercase letters.",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1051,
        "slug": "height-checker",
        "url": "https://leetcode.com/problems/height-checker/",
        "titulo": "Height Checker",
        "enunciado": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in \nnon-decreasing order\n by height. Let this ordering be represented by the integer array \nexpected\n where \nexpected[i]\n is the expected height of the \ni\nth\n student in line.\n\n\nYou are given an integer array \nheights\n representing the \ncurrent order\n that the students are standing in. Each \nheights[i]\n is the height of the \ni\nth\n student in line (\n0-indexed\n).\n\n\nReturn \nthe \nnumber of indices\n where \nheights[i] != expected[i]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n heights = [1,1,4,2,1,3]\n\nOutput:\n 3\n\nExplanation:\n \nheights:  [1,1,\n4\n,2,\n1\n,\n3\n]\nexpected: [1,1,\n1\n,2,\n3\n,\n4\n]\nIndices 2, 4, and 5 do not match.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [5,1,2,3,4]\n\nOutput:\n 5\n\nExplanation:\n\nheights:  [\n5\n,\n1\n,\n2\n,\n3\n,\n4\n]\nexpected: [\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\nAll indices do not match.\n\n\n\nExample 3:\n\n\n\n\nInput:\n heights = [1,2,3,4,5]\n\nOutput:\n 0\n\nExplanation:\n\nheights:  [1,2,3,4,5]\nexpected: [1,2,3,4,5]\nAll indices match.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 100\n\n\n1 <= heights[i] <= 100",
        "temas": [
            "Array",
            "Sorting",
            "Counting Sort"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1047,
        "slug": "remove-all-adjacent-duplicates-in-string",
        "url": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/",
        "titulo": "Remove All Adjacent Duplicates In String",
        "enunciado": "You are given a string \ns\n consisting of lowercase English letters. A \nduplicate removal\n consists of choosing two \nadjacent\n and \nequal\n letters and removing them.\n\n\nWe repeatedly make \nduplicate removals\n on \ns\n until we no longer can.\n\n\nReturn \nthe final string after all such duplicate removals have been made\n. It can be proven that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abbaca\"\n\nOutput:\n \"ca\"\n\nExplanation:\n \nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"azxxzy\"\n\nOutput:\n \"ay\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of lowercase English letters.",
        "temas": [
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1046,
        "slug": "last-stone-weight",
        "url": "https://leetcode.com/problems/last-stone-weight/",
        "titulo": "Last Stone Weight",
        "enunciado": "You are given an array of integers \nstones\n where \nstones[i]\n is the weight of the \ni\nth\n stone.\n\n\nWe are playing a game with the stones. On each turn, we choose the \nheaviest two stones\n and smash them together. Suppose the heaviest two stones have weights \nx\n and \ny\n with \nx <= y\n. The result of this smash is:\n\n\n\n\nIf \nx == y\n, both stones are destroyed, and\n\n\nIf \nx != y\n, the stone of weight \nx\n is destroyed, and the stone of weight \ny\n has new weight \ny - x\n.\n\n\n\n\nAt the end of the game, there is \nat most one\n stone left.\n\n\nReturn \nthe weight of the last remaining stone\n. If there are no stones left, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n stones = [2,7,4,1,8,1]\n\nOutput:\n 1\n\nExplanation:\n \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n\n\n\nExample 2:\n\n\n\n\nInput:\n stones = [1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= stones.length <= 30\n\n\n1 <= stones[i] <= 1000",
        "temas": [
            "Array",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1037,
        "slug": "valid-boomerang",
        "url": "https://leetcode.com/problems/valid-boomerang/",
        "titulo": "Valid Boomerang",
        "enunciado": "Given an array \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane, return \ntrue\n \nif these points are a \nboomerang\n.\n\n\nA \nboomerang\n is a set of three points that are \nall distinct\n and \nnot in a straight line\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n points = [[1,1],[2,3],[3,2]]\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n points = [[1,1],[2,2],[3,3]]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\npoints.length == 3\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 100",
        "temas": [
            "Array",
            "Math",
            "Geometry"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1160,
        "slug": "find-words-that-can-be-formed-by-characters",
        "url": "https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/",
        "titulo": "Find Words That Can Be Formed by Characters",
        "enunciado": "You are given an array of strings \nwords\n and a string \nchars\n.\n\n\nA string is \ngood\n if it can be formed by characters from \nchars\n (each character can only be used once for \neach\n word in \nwords\n).\n\n\nReturn \nthe sum of lengths of all good strings in words\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\n\nOutput:\n 6\n\nExplanation:\n The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\n\nOutput:\n 10\n\nExplanation:\n The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 1000\n\n\n1 <= words[i].length, chars.length <= 100\n\n\nwords[i]\n and \nchars\n consist of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1030,
        "slug": "matrix-cells-in-distance-order",
        "url": "https://leetcode.com/problems/matrix-cells-in-distance-order/",
        "titulo": "Matrix Cells in Distance Order",
        "enunciado": "You are given four integers \nrow\n, \ncols\n, \nrCenter\n, and \ncCenter\n. There is a \nrows x cols\n matrix and you are on the cell with the coordinates \n(rCenter, cCenter)\n.\n\n\nReturn \nthe coordinates of all cells in the matrix, sorted by their \ndistance\n from \n(rCenter, cCenter)\n from the smallest distance to the largest distance\n. You may return the answer in \nany order\n that satisfies this condition.\n\n\nThe \ndistance\n between two cells \n(r\n1\n, c\n1\n)\n and \n(r\n2\n, c\n2\n)\n is \n|r\n1\n - r\n2\n| + |c\n1\n - c\n2\n|\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n rows = 1, cols = 2, rCenter = 0, cCenter = 0\n\nOutput:\n [[0,0],[0,1]]\n\nExplanation:\n The distances from (0, 0) to other cells are: [0,1]\n\n\n\nExample 2:\n\n\n\n\nInput:\n rows = 2, cols = 2, rCenter = 0, cCenter = 1\n\nOutput:\n [[0,1],[0,0],[1,1],[1,0]]\n\nExplanation:\n The distances from (0, 1) to other cells are: [0,1,1,2]\nThe answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.\n\n\n\nExample 3:\n\n\n\n\nInput:\n rows = 2, cols = 3, rCenter = 1, cCenter = 2\n\nOutput:\n [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]\n\nExplanation:\n The distances from (1, 2) to other cells are: [0,1,1,2,2,3]\nThere are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rows, cols <= 100\n\n\n0 <= rCenter < rows\n\n\n0 <= cCenter < cols",
        "temas": [
            "Array",
            "Math",
            "Geometry",
            "Sorting",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1025,
        "slug": "divisor-game",
        "url": "https://leetcode.com/problems/divisor-game/",
        "titulo": "Divisor Game",
        "enunciado": "Alice and Bob take turns playing a game, with Alice starting first.\n\n\nInitially, there is a number \nn\n on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n\n\n\nChoosing any \nx\n with \n0 < x < n\n and \nn % x == 0\n.\n\n\nReplacing the number \nn\n on the chalkboard with \nn - x\n.\n\n\n\n\nAlso, if a player cannot make a move, they lose the game.\n\n\nReturn \ntrue\n \nif and only if Alice wins the game, assuming both players play optimally\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n true\n\nExplanation:\n Alice chooses 1, and Bob has no more moves.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n false\n\nExplanation:\n Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
        "temas": [
            "Math",
            "Dynamic Programming",
            "Brainteaser",
            "Game Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1022,
        "slug": "sum-of-root-to-leaf-binary-numbers",
        "url": "https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/",
        "titulo": "Sum of Root To Leaf Binary Numbers",
        "enunciado": "You are given the \nroot\n of a binary tree where each node has a value \n0\n or \n1\n. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n\n\n\nFor example, if the path is \n0 -> 1 -> 1 -> 0 -> 1\n, then this could represent \n01101\n in binary, which is \n13\n.\n\n\n\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return \nthe sum of these numbers\n.\n\n\nThe test cases are generated so that the answer fits in a \n32-bits\n integer.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,0,1,0,1,0,1]\n\nOutput:\n 22\n\nExplanation: \n(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\nNode.val\n is \n0\n or \n1\n.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 1021,
        "slug": "remove-outermost-parentheses",
        "url": "https://leetcode.com/problems/remove-outermost-parentheses/",
        "titulo": "Remove Outermost Parentheses",
        "enunciado": "A valid parentheses string is either empty \n\"\"\n, \n\"(\" + A + \")\"\n, or \nA + B\n, where \nA\n and \nB\n are valid parentheses strings, and \n+\n represents string concatenation.\n\n\n\n\nFor example, \n\"\"\n, \n\"()\"\n, \n\"(())()\"\n, and \n\"(()(()))\"\n are all valid parentheses strings.\n\n\n\n\nA valid parentheses string \ns\n is primitive if it is nonempty, and there does not exist a way to split it into \ns = A + B\n, with \nA\n and \nB\n nonempty valid parentheses strings.\n\n\nGiven a valid parentheses string \ns\n, consider its primitive decomposition: \ns = P\n1\n + P\n2\n + ... + P\nk\n, where \nP\ni\n are primitive valid parentheses strings.\n\n\nReturn \ns\n \nafter removing the outermost parentheses of every primitive string in the primitive decomposition of \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"(()())(())\"\n\nOutput:\n \"()()()\"\n\nExplanation:\n \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"(()())(())(()(()))\"\n\nOutput:\n \"()()()()(())\"\n\nExplanation:\n \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"()()\"\n\nOutput:\n \"\"\n\nExplanation:\n \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns[i]\n is either \n'('\n or \n')'\n.\n\n\ns\n is a valid parentheses string.",
        "temas": [
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 1018,
        "slug": "binary-prefix-divisible-by-5",
        "url": "https://leetcode.com/problems/binary-prefix-divisible-by-5/",
        "titulo": "Binary Prefix Divisible By 5",
        "enunciado": "You are given a binary array \nnums\n (\n0-indexed\n).\n\n\nWe define \nx\ni\n as the number whose binary representation is the subarray \nnums[0..i]\n (from most-significant-bit to least-significant-bit).\n\n\n\n\nFor example, if \nnums = [1,0,1]\n, then \nx\n0\n = 1\n, \nx\n1\n = 2\n, and \nx\n2\n = 5\n.\n\n\n\n\nReturn \nan array of booleans \nanswer\n where \nanswer[i]\n is \ntrue\n if \nx\ni\n is divisible by \n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n [true,false,false]\n\nExplanation:\n The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.\nOnly the first number is divisible by 5, so answer[0] is true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1]\n\nOutput:\n [false,false,false]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1013,
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "url": "https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/",
        "titulo": "Partition Array Into Three Parts With Equal Sum",
        "enunciado": "Given an array of integers \narr\n, return \ntrue\n if we can partition the array into three \nnon-empty\n parts with equal sums.\n\n\nFormally, we can partition the array if we can find indexes \ni + 1 < j\n with \n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [0,2,1,-6,6,-7,9,1,2,0,1]\n\nOutput:\n true\n\nExplanation: \n0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [0,2,1,-6,6,7,9,-1,2,0,1]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [3,3,6,5,-2,2,5,1,-9,4]\n\nOutput:\n true\n\nExplanation: \n3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= arr.length <= 5 * 10\n4\n\n\n-10\n4\n <= arr[i] <= 10\n4",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1009,
        "slug": "complement-of-base-10-integer",
        "url": "https://leetcode.com/problems/complement-of-base-10-integer/",
        "titulo": "Complement of Base 10 Integer",
        "enunciado": "The \ncomplement\n of an integer is the integer you get when you flip all the \n0\n's to \n1\n's and all the \n1\n's to \n0\n's in its binary representation.\n\n\n\n\nFor example, The integer \n5\n is \n\"101\"\n in binary and its \ncomplement\n is \n\"010\"\n which is the integer \n2\n.\n\n\n\n\nGiven an integer \nn\n, return \nits complement\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 2\n\nExplanation:\n 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 7\n\nOutput:\n 0\n\nExplanation:\n 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 10\n\nOutput:\n 5\n\nExplanation:\n 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n < 10\n9\n\n\n\n\n \n\n\nNote:\n This question is the same as 476: \nhttps://leetcode.com/problems/number-complement/",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 1005,
        "slug": "maximize-sum-of-array-after-k-negations",
        "url": "https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/",
        "titulo": "Maximize Sum Of Array After K Negations",
        "enunciado": "Given an integer array \nnums\n and an integer \nk\n, modify the array in the following way:\n\n\n\n\nchoose an index \ni\n and replace \nnums[i]\n with \n-nums[i]\n.\n\n\n\n\nYou should apply this process exactly \nk\n times. You may choose the same index \ni\n multiple times.\n\n\nReturn \nthe largest possible sum of the array after modifying it in this way\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,2,3], k = 1\n\nOutput:\n 5\n\nExplanation:\n Choose index 1 and nums becomes [4,-2,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,-1,0,2], k = 3\n\nOutput:\n 6\n\nExplanation:\n Choose indices (1, 2, 2) and nums becomes [3,1,0,2].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,-3,-1,5,-4], k = 2\n\nOutput:\n 13\n\nExplanation:\n Choose indices (1, 4) and nums becomes [2,3,-1,5,4].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-100 <= nums[i] <= 100\n\n\n1 <= k <= 10\n4",
        "temas": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 1002,
        "slug": "find-common-characters",
        "url": "https://leetcode.com/problems/find-common-characters/",
        "titulo": "Find Common Characters",
        "enunciado": "Given a string array \nwords\n, return \nan array of all characters that show up in all strings within the \nwords\n (including duplicates)\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n words = [\"bella\",\"label\",\"roller\"]\n\nOutput:\n [\"e\",\"l\",\"l\"]\n\nExample 2:\n\n\nInput:\n words = [\"cool\",\"lock\",\"cook\"]\n\nOutput:\n [\"c\",\"o\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 999,
        "slug": "available-captures-for-rook",
        "url": "https://leetcode.com/problems/available-captures-for-rook/",
        "titulo": "Available Captures for Rook",
        "enunciado": "You are given an \n8 x 8\n \nmatrix\n representing a chessboard. There is \nexactly one\n white rook represented by \n'R'\n, some number of white bishops \n'B'\n, and some number of black pawns \n'p'\n. Empty squares are represented by \n'.'\n.\n\n\nA rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece \nor\n the edge of the board. A rook is \nattacking\n a pawn if it can move to the pawn's square in one move.\n\n\nNote: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.\n\n\nReturn the \nnumber of pawns\n the white rook is \nattacking\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nboard = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nIn this example, the rook is attacking all the pawns.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nboard = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe bishops are blocking the rook from attacking any of the pawns.\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n \nboard = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe rook is attacking the pawns at positions b5, d6, and f5.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 8\n\n\nboard[i].length == 8\n\n\nboard[i][j]\n is either \n'R'\n, \n'.'\n, \n'B'\n, or \n'p'\n\n\nThere is exactly one cell with \nboard[i][j] == 'R'",
        "temas": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 997,
        "slug": "find-the-town-judge",
        "url": "https://leetcode.com/problems/find-the-town-judge/",
        "titulo": "Find the Town Judge",
        "enunciado": "In a town, there are \nn\n people labeled from \n1\n to \nn\n. There is a rumor that one of these people is secretly the town judge.\n\n\nIf the town judge exists, then:\n\n\n\n\nThe town judge trusts nobody.\n\n\nEverybody (except for the town judge) trusts the town judge.\n\n\nThere is exactly one person that satisfies properties \n1\n and \n2\n.\n\n\n\n\nYou are given an array \ntrust\n where \ntrust[i] = [a\ni\n, b\ni\n]\n representing that the person labeled \na\ni\n trusts the person labeled \nb\ni\n. If a trust relationship does not exist in \ntrust\n array, then such a trust relationship does not exist.\n\n\nReturn \nthe label of the town judge if the town judge exists and can be identified, or return \n-1\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2, trust = [[1,2]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, trust = [[1,3],[2,3]]\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3, trust = [[1,3],[2,3],[3,1]]\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n0 <= trust.length <= 10\n4\n\n\ntrust[i].length == 2\n\n\nAll the pairs of \ntrust\n are \nunique\n.\n\n\na\ni\n != b\ni\n\n\n1 <= a\ni\n, b\ni\n <= n",
        "temas": [
            "Array",
            "Hash Table",
            "Graph"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 993,
        "slug": "cousins-in-binary-tree",
        "url": "https://leetcode.com/problems/cousins-in-binary-tree/",
        "titulo": "Cousins in Binary Tree",
        "enunciado": "Given the \nroot\n of a binary tree with unique values and the values of two different nodes of the tree \nx\n and \ny\n, return \ntrue\n \nif the nodes corresponding to the values \nx\n and \ny\n in the tree are \ncousins\n, or \nfalse\n otherwise.\n\n\nTwo nodes of a binary tree are \ncousins\n if they have the same depth with different parents.\n\n\nNote that in a binary tree, the root node is at the depth \n0\n, and children of each depth \nk\n node are at the depth \nk + 1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4], x = 4, y = 3\n\nOutput:\n false\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4,null,5], x = 5, y = 4\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4], x = 2, y = 3\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nEach node has a \nunique\n value.\n\n\nx != y\n\n\nx\n and \ny\n are exist in the tree.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 989,
        "slug": "add-to-array-form-of-integer",
        "url": "https://leetcode.com/problems/add-to-array-form-of-integer/",
        "titulo": "Add to Array-Form of Integer",
        "enunciado": "The \narray-form\n of an integer \nnum\n is an array representing its digits in left to right order.\n\n\n\n\nFor example, for \nnum = 1321\n, the array form is \n[1,3,2,1]\n.\n\n\n\n\nGiven \nnum\n, the \narray-form\n of an integer, and an integer \nk\n, return \nthe \narray-form\n of the integer\n \nnum + k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = [1,2,0,0], k = 34\n\nOutput:\n [1,2,3,4]\n\nExplanation:\n 1200 + 34 = 1234\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = [2,7,4], k = 181\n\nOutput:\n [4,5,5]\n\nExplanation:\n 274 + 181 = 455\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = [2,1,5], k = 806\n\nOutput:\n [1,0,2,1]\n\nExplanation:\n 215 + 806 = 1021\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num.length <= 10\n4\n\n\n0 <= num[i] <= 9\n\n\nnum\n does not contain any leading zeros except for the zero itself.\n\n\n1 <= k <= 10\n4",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 977,
        "slug": "squares-of-a-sorted-array",
        "url": "https://leetcode.com/problems/squares-of-a-sorted-array/",
        "titulo": "Squares of a Sorted Array",
        "enunciado": "Given an integer array \nnums\n sorted in \nnon-decreasing\n order, return \nan array of \nthe squares of each number\n sorted in non-decreasing order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-4,-1,0,3,10]\n\nOutput:\n [0,1,9,16,100]\n\nExplanation:\n After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-7,-3,2,3,11]\n\nOutput:\n [4,9,9,49,121]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= \n10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in \nnon-decreasing\n order.\n\n\n\n\n \n\n\nFollow up:\n Squaring each element and sorting the new array is very trivial, could you find an \nO(n)\n solution using a different approach?",
        "temas": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 976,
        "slug": "largest-perimeter-triangle",
        "url": "https://leetcode.com/problems/largest-perimeter-triangle/",
        "titulo": "Largest Perimeter Triangle",
        "enunciado": "Given an integer array \nnums\n, return \nthe largest perimeter of a triangle with a non-zero area, formed from three of these lengths\n. If it is impossible to form any triangle of a non-zero area, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,1,2]\n\nOutput:\n 5\n\nExplanation:\n You can form a triangle with three side lengths: 1, 2, and 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,10]\n\nOutput:\n 0\n\nExplanation:\n \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 10\n4\n\n\n1 <= nums[i] <= 10\n6",
        "temas": [
            "Array",
            "Math",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 509,
        "slug": "fibonacci-number",
        "url": "https://leetcode.com/problems/fibonacci-number/",
        "titulo": "Fibonacci Number",
        "enunciado": "The \nFibonacci numbers\n, commonly denoted \nF(n)\n form a sequence, called the \nFibonacci sequence\n, such that each number is the sum of the two preceding ones, starting from \n0\n and \n1\n. That is,\n\n\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\n\n\nGiven \nn\n, calculate \nF(n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 3\n\nExplanation:\n F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 30",
        "temas": [
            "Math",
            "Dynamic Programming",
            "Recursion",
            "Memoization"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 965,
        "slug": "univalued-binary-tree",
        "url": "https://leetcode.com/problems/univalued-binary-tree/",
        "titulo": "Univalued Binary Tree",
        "enunciado": "A binary tree is \nuni-valued\n if every node in the tree has the same value.\n\n\nGiven the \nroot\n of a binary tree, return \ntrue\n if the given tree is \nuni-valued\n, or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,1,1,1,1,null,1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,2,2,5,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n0 <= Node.val < 100",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 961,
        "slug": "n-repeated-element-in-size-2n-array",
        "url": "https://leetcode.com/problems/n-repeated-element-in-size-2n-array/",
        "titulo": "N-Repeated Element in Size 2N Array",
        "enunciado": "You are given an integer array \nnums\n with the following properties:\n\n\n\n\nnums.length == 2 * n\n.\n\n\nnums\n contains \nn + 1\n \nunique\n elements.\n\n\nExactly one element of \nnums\n is repeated \nn\n times.\n\n\n\n\nReturn \nthe element that is repeated \nn\n times\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,1,2,5,3,2]\n\nOutput:\n 2\n\nExample 3:\n\n\nInput:\n nums = [5,1,5,2,5,3,5,4]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5000\n\n\nnums.length == 2 * n\n\n\n0 <= nums[i] <= 10\n4\n\n\nnums\n contains \nn + 1\n \nunique\n elements and one of them is repeated exactly \nn\n times.",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 953,
        "slug": "verifying-an-alien-dictionary",
        "url": "https://leetcode.com/problems/verifying-an-alien-dictionary/",
        "titulo": "Verifying an Alien Dictionary",
        "enunciado": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different \norder\n. The \norder\n of the alphabet is some permutation of lowercase letters.\n\n\nGiven a sequence of \nwords\n written in the alien language, and the \norder\n of the alphabet, return \ntrue\n if and only if the given \nwords\n are sorted lexicographically in this alien language.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n\nOutput:\n true\n\nExplanation: \nAs 'h' comes before 'l' in this language, then the sequence is sorted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n\nOutput:\n false\n\nExplanation: \nAs 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n\nOutput:\n false\n\nExplanation: \nThe first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (\nMore info\n).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 20\n\n\norder.length == 26\n\n\nAll characters in \nwords[i]\n and \norder\n are English lowercase letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 944,
        "slug": "delete-columns-to-make-sorted",
        "url": "https://leetcode.com/problems/delete-columns-to-make-sorted/",
        "titulo": "Delete Columns to Make Sorted",
        "enunciado": "You are given an array of \nn\n strings \nstrs\n, all of the same length.\n\n\nThe strings can be arranged such that there is one on each line, making a grid.\n\n\n\n\nFor example, \nstrs = [\"abc\", \"bce\", \"cae\"]\n can be arranged as follows:\n\n\n\n\n\nabc\nbce\ncae\n\n\n\nYou want to \ndelete\n the columns that are \nnot sorted lexicographically\n. In the above example (\n0-indexed\n), columns 0 (\n'a'\n, \n'b'\n, \n'c'\n) and 2 (\n'c'\n, \n'e'\n, \n'e'\n) are sorted, while column 1 (\n'b'\n, \n'c'\n, \n'a'\n) is not, so you would delete column 1.\n\n\nReturn \nthe number of columns that you will delete\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"cba\",\"daf\",\"ghi\"]\n\nOutput:\n 1\n\nExplanation:\n The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"a\",\"b\"]\n\nOutput:\n 0\n\nExplanation:\n The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns.\n\n\n\nExample 3:\n\n\n\n\nInput:\n strs = [\"zyx\",\"wvu\",\"tsr\"]\n\nOutput:\n 3\n\nExplanation:\n The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == strs.length\n\n\n1 <= n <= 100\n\n\n1 <= strs[i].length <= 1000\n\n\nstrs[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 942,
        "slug": "di-string-match",
        "url": "https://leetcode.com/problems/di-string-match/",
        "titulo": "DI String Match",
        "enunciado": "A permutation \nperm\n of \nn + 1\n integers of all the integers in the range \n[0, n]\n can be represented as a string \ns\n of length \nn\n where:\n\n\n\n\ns[i] == 'I'\n if \nperm[i] < perm[i + 1]\n, and\n\n\ns[i] == 'D'\n if \nperm[i] > perm[i + 1]\n.\n\n\n\n\nGiven a string \ns\n, reconstruct the permutation \nperm\n and return it. If there are multiple valid permutations perm, return \nany of them\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"IDID\"\n\nOutput:\n [0,4,1,3,2]\n\nExample 2:\n\n\nInput:\n s = \"III\"\n\nOutput:\n [0,1,2,3]\n\nExample 3:\n\n\nInput:\n s = \"DDI\"\n\nOutput:\n [3,2,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns[i]\n is either \n'I'\n or \n'D'\n.",
        "temas": [
            "Array",
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 941,
        "slug": "valid-mountain-array",
        "url": "https://leetcode.com/problems/valid-mountain-array/",
        "titulo": "Valid Mountain Array",
        "enunciado": "Given an array of integers \narr\n, return \ntrue\n if and only if it is a valid mountain array\n.\n\n\nRecall that arr is a mountain array if and only if:\n\n\n\n\narr.length >= 3\n\n\nThere exists some \ni\n with \n0 < i < arr.length - 1\n such that:\n\t\n\n\narr[0] < arr[1] < ... < arr[i - 1] < arr[i] \n\n\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\n\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n arr = [2,1]\n\nOutput:\n false\n\nExample 2:\n\n\nInput:\n arr = [3,5,5]\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n arr = [0,3,2,1]\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 10\n4\n\n\n0 <= arr[i] <= 10\n4",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 938,
        "slug": "range-sum-of-bst",
        "url": "https://leetcode.com/problems/range-sum-of-bst/",
        "titulo": "Range Sum of BST",
        "enunciado": "Given the \nroot\n node of a binary search tree and two integers \nlow\n and \nhigh\n, return \nthe sum of values of all nodes with a value in the \ninclusive\n range \n[low, high]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,null,18], low = 7, high = 15\n\nOutput:\n 32\n\nExplanation:\n Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n\nOutput:\n 23\n\nExplanation:\n Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n1 <= low <= high <= 10\n5\n\n\nAll \nNode.val\n are \nunique\n.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 933,
        "slug": "number-of-recent-calls",
        "url": "https://leetcode.com/problems/number-of-recent-calls/",
        "titulo": "Number of Recent Calls",
        "enunciado": "You have a \nRecentCounter\n class which counts the number of recent requests within a certain time frame.\n\n\nImplement the \nRecentCounter\n class:\n\n\n\n\nRecentCounter()\n Initializes the counter with zero recent requests.\n\n\nint ping(int t)\n Adds a new request at time \nt\n, where \nt\n represents some time in milliseconds, and returns the number of requests that has happened in the past \n3000\n milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range \n[t - 3000, t]\n.\n\n\n\n\nIt is \nguaranteed\n that every call to \nping\n uses a strictly larger value of \nt\n than the previous call.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\n\nOutput\n\n[null, 1, 2, 3, 3]\n\n\nExplanation\n\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [\n1\n], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [\n1\n, \n100\n], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [\n1\n, \n100\n, \n3001\n], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, \n100\n, \n3001\n, \n3002\n], range is [2,3002], return 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= t <= 10\n9\n\n\nEach test case will call \nping\n with \nstrictly increasing\n values of \nt\n.\n\n\nAt most \n10\n4\n calls will be made to \nping\n.",
        "temas": [
            "Design",
            "Queue",
            "Data Stream"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Design"
    },
    {
        "id": 929,
        "slug": "unique-email-addresses",
        "url": "https://leetcode.com/problems/unique-email-addresses/",
        "titulo": "Unique Email Addresses",
        "enunciado": "Every \nvalid email\n consists of a \nlocal name\n and a \ndomain name\n, separated by the \n'@'\n sign. Besides lowercase letters, the email may contain one or more \n'.'\n or \n'+'\n.\n\n\n\n\nFor example, in \n\"alice@leetcode.com\"\n, \n\"alice\"\n is the \nlocal name\n, and \n\"leetcode.com\"\n is the \ndomain name\n.\n\n\n\n\nIf you add periods \n'.'\n between some characters in the \nlocal name\n part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule \ndoes not apply\n to \ndomain names\n.\n\n\n\n\nFor example, \n\"alice.z@leetcode.com\"\n and \n\"alicez@leetcode.com\"\n forward to the same email address.\n\n\n\n\nIf you add a plus \n'+'\n in the \nlocal name\n, everything after the first plus sign \nwill be ignored\n. This allows certain emails to be filtered. Note that this rule \ndoes not apply\n to \ndomain names\n.\n\n\n\n\nFor example, \n\"m.y+name@email.com\"\n will be forwarded to \n\"my@email.com\"\n.\n\n\n\n\nIt is possible to use both of these rules at the same time.\n\n\nGiven an array of strings \nemails\n where we send one email to each \nemails[i]\n, return \nthe number of different addresses that actually receive mails\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n\nOutput:\n 2\n\nExplanation:\n \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\n\n\n\nExample 2:\n\n\n\n\nInput:\n emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= emails.length <= 100\n\n\n1 <= emails[i].length <= 100\n\n\nemails[i]\n consist of lowercase English letters, \n'+'\n, \n'.'\n and \n'@'\n.\n\n\nEach \nemails[i]\n contains exactly one \n'@'\n character.\n\n\nAll local and domain names are non-empty.\n\n\nLocal names do not start with a \n'+'\n character.\n\n\nDomain names end with the \n\".com\"\n suffix.\n\n\nDomain names must contain at least one character before \n\".com\"\n suffix.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 925,
        "slug": "long-pressed-name",
        "url": "https://leetcode.com/problems/long-pressed-name/",
        "titulo": "Long Pressed Name",
        "enunciado": "Your friend is typing his \nname\n into a keyboard. Sometimes, when typing a character \nc\n, the key might get \nlong pressed\n, and the character will be typed 1 or more times.\n\n\nYou examine the \ntyped\n characters of the keyboard. Return \nTrue\n if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n name = \"alex\", typed = \"aaleex\"\n\nOutput:\n true\n\nExplanation: \n'a' and 'e' in 'alex' were long pressed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n name = \"saeed\", typed = \"ssaaedd\"\n\nOutput:\n false\n\nExplanation: \n'e' must have been pressed twice, but it was not in the typed output.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= name.length, typed.length <= 1000\n\n\nname\n and \ntyped\n consist of only lowercase English letters.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 922,
        "slug": "sort-array-by-parity-ii",
        "url": "https://leetcode.com/problems/sort-array-by-parity-ii/",
        "titulo": "Sort Array By Parity II",
        "enunciado": "Given an array of integers \nnums\n, half of the integers in \nnums\n are \nodd\n, and the other half are \neven\n.\n\n\nSort the array so that whenever \nnums[i]\n is odd, \ni\n is \nodd\n, and whenever \nnums[i]\n is even, \ni\n is \neven\n.\n\n\nReturn \nany answer array that satisfies this condition\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,2,5,7]\n\nOutput:\n [4,5,2,7]\n\nExplanation:\n [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3]\n\nOutput:\n [2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 2 * 10\n4\n\n\nnums.length\n is even.\n\n\nHalf of the integers in \nnums\n are even.\n\n\n0 <= nums[i] <= 1000\n\n\n\n\n \n\n\nFollow Up:\n Could you solve it in-place?",
        "temas": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 917,
        "slug": "reverse-only-letters",
        "url": "https://leetcode.com/problems/reverse-only-letters/",
        "titulo": "Reverse Only Letters",
        "enunciado": "Given a string \ns\n, reverse the string according to the following rules:\n\n\n\n\nAll the characters that are not English letters remain in the same position.\n\n\nAll the English letters (lowercase or uppercase) should be reversed.\n\n\n\n\nReturn \ns\n after reversing it\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"ab-cd\"\n\nOutput:\n \"dc-ba\"\n\nExample 2:\n\n\nInput:\n s = \"a-bC-dEf-ghIj\"\n\nOutput:\n \"j-Ih-gfE-dCba\"\n\nExample 3:\n\n\nInput:\n s = \"Test1ng-Leet=code-Q!\"\n\nOutput:\n \"Qedo1ct-eeLg=ntse-T!\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of characters with ASCII values in the range \n[33, 122]\n.\n\n\ns\n does not contain \n'\\\"'\n or \n'\\\\'\n.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 914,
        "slug": "x-of-a-kind-in-a-deck-of-cards",
        "url": "https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/",
        "titulo": "X of a Kind in a Deck of Cards",
        "enunciado": "You are given an integer array \ndeck\n where \ndeck[i]\n represents the number written on the \ni\nth\n card.\n\n\nPartition the cards into \none or more groups\n such that:\n\n\n\n\nEach group has \nexactly\n \nx\n cards where \nx > 1\n, and\n\n\nAll the cards in one group have the same integer written on them.\n\n\n\n\nReturn \ntrue\n if such partition is possible, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n deck = [1,2,3,4,4,3,2,1]\n\nOutput:\n true\n\nExplanation\n: Possible partition [1,1],[2,2],[3,3],[4,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n deck = [1,1,1,2,2,2,3,3]\n\nOutput:\n false\n\nExplanation\n: No possible partition.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= deck.length <= 10\n4\n\n\n0 <= deck[i] < 10\n4",
        "temas": [
            "Array",
            "Hash Table",
            "Math",
            "Counting",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 908,
        "slug": "smallest-range-i",
        "url": "https://leetcode.com/problems/smallest-range-i/",
        "titulo": "Smallest Range I",
        "enunciado": "You are given an integer array \nnums\n and an integer \nk\n.\n\n\nIn one operation, you can choose any index \ni\n where \n0 <= i < nums.length\n and change \nnums[i]\n to \nnums[i] + x\n where \nx\n is an integer from the range \n[-k, k]\n. You can apply this operation \nat most once\n for each index \ni\n.\n\n\nThe \nscore\n of \nnums\n is the difference between the maximum and minimum elements in \nnums\n.\n\n\nReturn \nthe minimum \nscore\n of \nnums\n after applying the mentioned operation at most once for each index in it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1], k = 0\n\nOutput:\n 0\n\nExplanation:\n The score is max(nums) - min(nums) = 1 - 1 = 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,10], k = 2\n\nOutput:\n 6\n\nExplanation:\n Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,6], k = 3\n\nOutput:\n 0\n\nExplanation:\n Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) = 4 - 4 = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 10\n4\n\n\n0 <= k <= 10\n4",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 905,
        "slug": "sort-array-by-parity",
        "url": "https://leetcode.com/problems/sort-array-by-parity/",
        "titulo": "Sort Array By Parity",
        "enunciado": "Given an integer array \nnums\n, move all the even integers at the beginning of the array followed by all the odd integers.\n\n\nReturn \nany array\n that satisfies this condition\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,1,2,4]\n\nOutput:\n [2,4,3,1]\n\nExplanation:\n The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n0 <= nums[i] <= 5000",
        "temas": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 897,
        "slug": "increasing-order-search-tree",
        "url": "https://leetcode.com/problems/increasing-order-search-tree/",
        "titulo": "Increasing Order Search Tree",
        "enunciado": "Given the \nroot\n of a binary search tree, rearrange the tree in \nin-order\n so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n\nOutput:\n [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,1,7]\n\nOutput:\n [1,null,5,null,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the given tree will be in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 1000",
        "temas": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 896,
        "slug": "monotonic-array",
        "url": "https://leetcode.com/problems/monotonic-array/",
        "titulo": "Monotonic Array",
        "enunciado": "An array is \nmonotonic\n if it is either monotone increasing or monotone decreasing.\n\n\nAn array \nnums\n is monotone increasing if for all \ni <= j\n, \nnums[i] <= nums[j]\n. An array \nnums\n is monotone decreasing if for all \ni <= j\n, \nnums[i] >= nums[j]\n.\n\n\nGiven an integer array \nnums\n, return \ntrue\n if the given array is monotonic, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,2,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [6,5,4,4]\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n5\n <= nums[i] <= 10\n5",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 892,
        "slug": "surface-area-of-3d-shapes",
        "url": "https://leetcode.com/problems/surface-area-of-3d-shapes/",
        "titulo": "Surface Area of 3D Shapes",
        "enunciado": "You are given an \nn x n\n \ngrid\n where you have placed some \n1 x 1 x 1\n cubes. Each value \nv = grid[i][j]\n represents a tower of \nv\n cubes placed on top of cell \n(i, j)\n.\n\n\nAfter placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.\n\n\nReturn \nthe total surface area of the resulting shapes\n.\n\n\nNote:\n The bottom face of each shape counts toward its surface area.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2],[3,4]]\n\nOutput:\n 34\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n 32\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[2,2,2],[2,1,2],[2,2,2]]\n\nOutput:\n 46\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] <= 50",
        "temas": [
            "Array",
            "Math",
            "Geometry",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 888,
        "slug": "fair-candy-swap",
        "url": "https://leetcode.com/problems/fair-candy-swap/",
        "titulo": "Fair Candy Swap",
        "enunciado": "Alice and Bob have a different total number of candies. You are given two integer arrays \naliceSizes\n and \nbobSizes\n where \naliceSizes[i]\n is the number of candies of the \ni\nth\n box of candy that Alice has and \nbobSizes[j]\n is the number of candies of the \nj\nth\n box of candy that Bob has.\n\n\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\n\n\nReturn a\nn integer array \nanswer\n where \nanswer[0]\n is the number of candies in the box that Alice must exchange, and \nanswer[1]\n is the number of candies in the box that Bob must exchange\n. If there are multiple answers, you may \nreturn any\n one of them. It is guaranteed that at least one answer exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n aliceSizes = [1,1], bobSizes = [2,2]\n\nOutput:\n [1,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n aliceSizes = [1,2], bobSizes = [2,3]\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n aliceSizes = [2], bobSizes = [1,3]\n\nOutput:\n [2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= aliceSizes.length, bobSizes.length <= 10\n4\n\n\n1 <= aliceSizes[i], bobSizes[j] <= 10\n5\n\n\nAlice and Bob have a different total number of candies.\n\n\nThere will be at least one valid answer for the given input.",
        "temas": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 884,
        "slug": "uncommon-words-from-two-sentences",
        "url": "https://leetcode.com/problems/uncommon-words-from-two-sentences/",
        "titulo": "Uncommon Words from Two Sentences",
        "enunciado": "A \nsentence\n is a string of single-space separated words where each word consists only of lowercase letters.\n\n\nA word is \nuncommon\n if it appears exactly once in one of the sentences, and \ndoes not appear\n in the other sentence.\n\n\nGiven two \nsentences\n \ns1\n and \ns2\n, return \na list of all the \nuncommon words\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n\n\nOutput:\n \n[\"sweet\",\"sour\"]\n\n\nExplanation:\n\n\nThe word \n\"sweet\"\n appears only in \ns1\n, while the word \n\"sour\"\n appears only in \ns2\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns1 = \"apple apple\", s2 = \"banana\"\n\n\nOutput:\n \n[\"banana\"]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s1.length, s2.length <= 200\n\n\ns1\n and \ns2\n consist of lowercase English letters and spaces.\n\n\ns1\n and \ns2\n do not have leading or trailing spaces.\n\n\nAll the words in \ns1\n and \ns2\n are separated by a single space.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 883,
        "slug": "projection-area-of-3d-shapes",
        "url": "https://leetcode.com/problems/projection-area-of-3d-shapes/",
        "titulo": "Projection Area of 3D Shapes",
        "enunciado": "You are given an \nn x n\n \ngrid\n where we place some \n1 x 1 x 1\n cubes that are axis-aligned with the \nx\n, \ny\n, and \nz\n axes.\n\n\nEach value \nv = grid[i][j]\n represents a tower of \nv\n cubes placed on top of the cell \n(i, j)\n.\n\n\nWe view the projection of these cubes onto the \nxy\n, \nyz\n, and \nzx\n planes.\n\n\nA \nprojection\n is like a shadow, that maps our \n3-dimensional\n figure to a \n2-dimensional\n plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n\n\nReturn \nthe total area of all three projections\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2],[3,4]]\n\nOutput:\n 17\n\nExplanation:\n Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[2]]\n\nOutput:\n 5\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0],[0,2]]\n\nOutput:\n 8\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] <= 50",
        "temas": [
            "Array",
            "Math",
            "Geometry",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 876,
        "slug": "middle-of-the-linked-list",
        "url": "https://leetcode.com/problems/middle-of-the-linked-list/",
        "titulo": "Middle of the Linked List",
        "enunciado": "Given the \nhead\n of a singly linked list, return \nthe middle node of the linked list\n.\n\n\nIf there are two middle nodes, return \nthe second middle\n node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [3,4,5]\n\nExplanation:\n The middle node of the list is node 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6]\n\nOutput:\n [4,5,6]\n\nExplanation:\n Since the list has two middle nodes with values 3 and 4, we return the second one.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 100]\n.\n\n\n1 <= Node.val <= 100",
        "temas": [
            "Linked List",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 872,
        "slug": "leaf-similar-trees",
        "url": "https://leetcode.com/problems/leaf-similar-trees/",
        "titulo": "Leaf-Similar Trees",
        "enunciado": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a \nleaf value sequence\n.\n\n\n\n\nFor example, in the given tree above, the leaf value sequence is \n(6, 7, 4, 9, 8)\n.\n\n\nTwo binary trees are considered \nleaf-similar\n if their leaf value sequence is the same.\n\n\nReturn \ntrue\n if and only if the two given trees with head nodes \nroot1\n and \nroot2\n are leaf-similar.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root1 = [1,2,3], root2 = [1,3,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each tree will be in the range \n[1, 200]\n.\n\n\nBoth of the given trees will have values in the range \n[0, 200]\n.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 868,
        "slug": "binary-gap",
        "url": "https://leetcode.com/problems/binary-gap/",
        "titulo": "Binary Gap",
        "enunciado": "Given a positive integer \nn\n, find and return \nthe \nlongest distance\n between any two \nadjacent\n \n1\n's in the binary representation of \nn\n. If there are no two adjacent \n1\n's, return \n0\n.\n\n\nTwo \n1\n's are \nadjacent\n if there are only \n0\n's separating them (possibly no \n0\n's). The \ndistance\n between two \n1\n's is the absolute difference between their bit positions. For example, the two \n1\n's in \n\"1001\"\n have a distance of 3.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 22\n\nOutput:\n 2\n\nExplanation:\n 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"\n1\n0\n1\n10\" with a distance of 2.\nThe second adjacent pair of 1's is \"10\n11\n0\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"\n1\n01\n1\n0\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 8\n\nOutput:\n 0\n\nExplanation:\n 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 2\n\nExplanation:\n 5 in binary is \"101\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n9",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 867,
        "slug": "transpose-matrix",
        "url": "https://leetcode.com/problems/transpose-matrix/",
        "titulo": "Transpose Matrix",
        "enunciado": "Given a 2D integer array \nmatrix\n, return \nthe \ntranspose\n of\n \nmatrix\n.\n\n\nThe \ntranspose\n of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[1,4,7],[2,5,8],[3,6,9]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6]]\n\nOutput:\n [[1,4],[2,5],[3,6]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 1000\n\n\n1 <= m * n <= 10\n5\n\n\n-10\n9\n <= matrix[i][j] <= 10\n9",
        "temas": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 860,
        "slug": "lemonade-change",
        "url": "https://leetcode.com/problems/lemonade-change/",
        "titulo": "Lemonade Change",
        "enunciado": "At a lemonade stand, each lemonade costs \n$5\n. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a \n$5\n, \n$10\n, or \n$20\n bill. You must provide the correct change to each customer so that the net transaction is that the customer pays \n$5\n.\n\n\nNote that you do not have any change in hand at first.\n\n\nGiven an integer array \nbills\n where \nbills[i]\n is the bill the \ni\nth\n customer pays, return \ntrue\n \nif you can provide every customer with the correct change, or\n \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n bills = [5,5,5,10,20]\n\nOutput:\n true\n\nExplanation:\n \nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n bills = [5,5,10,10,20]\n\nOutput:\n false\n\nExplanation:\n \nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can not give the change of $15 back because we only have two $10 bills.\nSince not every customer received the correct change, the answer is false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= bills.length <= 10\n5\n\n\nbills[i]\n is either \n5\n, \n10\n, or \n20\n.",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 859,
        "slug": "buddy-strings",
        "url": "https://leetcode.com/problems/buddy-strings/",
        "titulo": "Buddy Strings",
        "enunciado": "Given two strings \ns\n and \ngoal\n, return \ntrue\n if you can swap two letters in \ns\n so the result is equal to \ngoal\n, otherwise, return \nfalse\n.\n\n\nSwapping letters is defined as taking two indices \ni\n and \nj\n (0-indexed) such that \ni != j\n and swapping the characters at \ns[i]\n and \ns[j]\n.\n\n\n\n\nFor example, swapping at indices \n0\n and \n2\n in \n\"abcd\"\n results in \n\"cbad\"\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ab\", goal = \"ba\"\n\nOutput:\n true\n\nExplanation:\n You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"ab\", goal = \"ab\"\n\nOutput:\n false\n\nExplanation:\n The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"aa\", goal = \"aa\"\n\nOutput:\n true\n\nExplanation:\n You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, goal.length <= 2 * 10\n4\n\n\ns\n and \ngoal\n consist of lowercase letters.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 844,
        "slug": "backspace-string-compare",
        "url": "https://leetcode.com/problems/backspace-string-compare/",
        "titulo": "Backspace String Compare",
        "enunciado": "Given two strings \ns\n and \nt\n, return \ntrue\n \nif they are equal when both are typed into empty text editors\n. \n'#'\n means a backspace character.\n\n\nNote that after backspacing an empty text, the text will continue empty.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ab#c\", t = \"ad#c\"\n\nOutput:\n true\n\nExplanation:\n Both s and t become \"ac\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"ab##\", t = \"c#d#\"\n\nOutput:\n true\n\nExplanation:\n Both s and t become \"\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a#c\", t = \"b\"\n\nOutput:\n false\n\nExplanation:\n s becomes \"c\" while t becomes \"b\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, t.length <= 200\n\n\ns\n and \nt\n only contain lowercase letters and \n'#'\n characters.\n\n\n\n\n \n\n\nFollow up:\n Can you solve it in \nO(n)\n time and \nO(1)\n space?",
        "temas": [
            "Two Pointers",
            "String",
            "Stack",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 836,
        "slug": "rectangle-overlap",
        "url": "https://leetcode.com/problems/rectangle-overlap/",
        "titulo": "Rectangle Overlap",
        "enunciado": "An axis-aligned rectangle is represented as a list \n[x1, y1, x2, y2]\n, where \n(x1, y1)\n is the coordinate of its bottom-left corner, and \n(x2, y2)\n is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\n\nTwo rectangles overlap if the area of their intersection is \npositive\n. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\n\nGiven two axis-aligned rectangles \nrec1\n and \nrec2\n, return \ntrue\n if they overlap, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrec1.length == 4\n\n\nrec2.length == 4\n\n\n-10\n9\n <= rec1[i], rec2[i] <= 10\n9\n\n\nrec1\n and \nrec2\n represent a valid rectangle with a non-zero area.",
        "temas": [
            "Math",
            "Geometry"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 832,
        "slug": "flipping-an-image",
        "url": "https://leetcode.com/problems/flipping-an-image/",
        "titulo": "Flipping an Image",
        "enunciado": "Given an \nn x n\n binary matrix \nimage\n, flip the image \nhorizontally\n, then invert it, and return \nthe resulting image\n.\n\n\nTo flip an image horizontally means that each row of the image is reversed.\n\n\n\n\nFor example, flipping \n[1,1,0]\n horizontally results in \n[0,1,1]\n.\n\n\n\n\nTo invert an image means that each \n0\n is replaced by \n1\n, and each \n1\n is replaced by \n0\n.\n\n\n\n\nFor example, inverting \n[0,1,1]\n results in \n[1,0,0]\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n image = [[1,1,0],[1,0,1],[0,0,0]]\n\nOutput:\n [[1,0,0],[0,1,0],[1,1,1]]\n\nExplanation:\n First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n\nOutput:\n [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\nExplanation:\n First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == image.length\n\n\nn == image[i].length\n\n\n1 <= n <= 20\n\n\nimages[i][j]\n is either \n0\n or \n1\n.",
        "temas": [
            "Array",
            "Two Pointers",
            "Bit Manipulation",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 830,
        "slug": "positions-of-large-groups",
        "url": "https://leetcode.com/problems/positions-of-large-groups/",
        "titulo": "Positions of Large Groups",
        "enunciado": "In a string \ns\n of lowercase letters, these letters form consecutive groups of the same character.\n\n\nFor example, a string like \ns = \"abbxxxxzyy\"\n has the groups \n\"a\"\n, \n\"bb\"\n, \n\"xxxx\"\n, \n\"z\"\n, and \n\"yy\"\n.\n\n\nA group is identified by an interval \n[start, end]\n, where \nstart\n and \nend\n denote the start and end indices (inclusive) of the group. In the above example, \n\"xxxx\"\n has the interval \n[3,6]\n.\n\n\nA group is considered \nlarge\n if it has 3 or more characters.\n\n\nReturn \nthe intervals of every \nlarge\n group sorted in \nincreasing order by start index\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abbxxxxzzy\"\n\nOutput:\n [[3,6]]\n\nExplanation:\n \n\"xxxx\" is the only \nlarge group with start index 3 and end index 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abc\"\n\nOutput:\n []\n\nExplanation:\n We have groups \"a\", \"b\", and \"c\", none of which are large groups.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"abcdddeeeeaabbbcd\"\n\nOutput:\n [[3,5],[6,9],[12,14]]\n\nExplanation:\n The large groups are \"ddd\", \"eeee\", and \"bbb\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n contains lowercase English letters only.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 824,
        "slug": "goat-latin",
        "url": "https://leetcode.com/problems/goat-latin/",
        "titulo": "Goat Latin",
        "enunciado": "You are given a string \nsentence\n that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\n\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\n\n\n\nIf a word begins with a vowel (\n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, or \n'u'\n), append \n\"ma\"\n to the end of the word.\n\n\t\n\n\nFor example, the word \n\"apple\"\n becomes \n\"applema\"\n.\n\n\n\n\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \n\"ma\"\n.\n\t\n\n\nFor example, the word \n\"goat\"\n becomes \n\"oatgma\"\n.\n\n\n\n\n\n\nAdd one letter \n'a'\n to the end of each word per its word index in the sentence, starting with \n1\n.\n\t\n\n\nFor example, the first word gets \n\"a\"\n added to the end, the second word gets \n\"aa\"\n added to the end, and so on.\n\n\n\n\n\n\n\n\nReturn\n the final sentence representing the conversion from sentence to Goat Latin\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n sentence = \"I speak Goat Latin\"\n\nOutput:\n \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n\nExample 2:\n\n\nInput:\n sentence = \"The quick brown fox jumped over the lazy dog\"\n\nOutput:\n \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 150\n\n\nsentence\n consists of English letters and spaces.\n\n\nsentence\n has no leading or trailing spaces.\n\n\nAll the words in \nsentence\n are separated by a single space.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 821,
        "slug": "shortest-distance-to-a-character",
        "url": "https://leetcode.com/problems/shortest-distance-to-a-character/",
        "titulo": "Shortest Distance to a Character",
        "enunciado": "Given a string \ns\n and a character \nc\n that occurs in \ns\n, return \nan array of integers \nanswer\n where \nanswer.length == s.length\n and \nanswer[i]\n is the \ndistance\n from index \ni\n to the \nclosest\n occurrence of character \nc\n in \ns\n.\n\n\nThe \ndistance\n between two indices \ni\n and \nj\n is \nabs(i - j)\n, where \nabs\n is the absolute value function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"loveleetcode\", c = \"e\"\n\nOutput:\n [3,2,1,0,1,0,0,1,2,2,1,0]\n\nExplanation:\n The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aaab\", c = \"b\"\n\nOutput:\n [3,2,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns[i]\n and \nc\n are lowercase English letters.\n\n\nIt is guaranteed that \nc\n occurs at least once in \ns\n.",
        "temas": [
            "Array",
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 819,
        "slug": "most-common-word",
        "url": "https://leetcode.com/problems/most-common-word/",
        "titulo": "Most Common Word",
        "enunciado": "Given a string \nparagraph\n and a string array of the banned words \nbanned\n, return \nthe most frequent word that is not banned\n. It is \nguaranteed\n there is \nat least one word\n that is not banned, and that the answer is \nunique\n.\n\n\nThe words in \nparagraph\n are \ncase-insensitive\n and the answer should be returned in \nlowercase\n.\n\n\nNote\n that words can not contain punctuation symbols.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\n\nOutput:\n \"ball\"\n\nExplanation:\n \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n paragraph = \"a.\", banned = []\n\nOutput:\n \"a\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= paragraph.length <= 1000\n\n\nparagraph consists of English letters, space \n' '\n, or one of the symbols: \n\"!?',;.\"\n.\n\n\n0 <= banned.length <= 100\n\n\n1 <= banned[i].length <= 10\n\n\nbanned[i]\n consists of only lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 812,
        "slug": "largest-triangle-area",
        "url": "https://leetcode.com/problems/largest-triangle-area/",
        "titulo": "Largest Triangle Area",
        "enunciado": "Given an array of points on the \nX-Y\n plane \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n, return \nthe area of the largest triangle that can be formed by any three different points\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n\nOutput:\n 2.00000\n\nExplanation:\n The five points are shown in the above figure. The red triangle is the largest.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[1,0],[0,0],[0,1]]\n\nOutput:\n 0.50000\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= points.length <= 50\n\n\n-50 <= x\ni\n, y\ni\n <= 50\n\n\nAll the given points are \nunique\n.",
        "temas": [
            "Array",
            "Math",
            "Geometry"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 806,
        "slug": "number-of-lines-to-write-string",
        "url": "https://leetcode.com/problems/number-of-lines-to-write-string/",
        "titulo": "Number of Lines To Write String",
        "enunciado": "You are given a string \ns\n of lowercase English letters and an array \nwidths\n denoting \nhow many pixels wide\n each lowercase English letter is. Specifically, \nwidths[0]\n is the width of \n'a'\n, \nwidths[1]\n is the width of \n'b'\n, and so on.\n\n\nYou are trying to write \ns\n across several lines, where \neach line is no longer than \n100\n pixels\n. Starting at the beginning of \ns\n, write as many letters on the first line such that the total width does not exceed \n100\n pixels. Then, from where you stopped in \ns\n, continue writing as many letters as you can on the second line. Continue this process until you have written all of \ns\n.\n\n\nReturn \nan array \nresult\n of length 2 where:\n\n\n\n\nresult[0]\n is the total number of lines.\n\n\nresult[1]\n is the width of the last line in pixels.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\"\n\nOutput:\n [3,60]\n\nExplanation:\n You can write s as follows:\nabcdefghij  // 100 pixels wide\nklmnopqrst  // 100 pixels wide\nuvwxyz      // 60 pixels wide\nThere are a total of 3 lines, and the last line is 60 pixels wide.\n\n\nExample 2:\n\n\n\n\nInput:\n widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaa\"\n\nOutput:\n [2,4]\n\nExplanation:\n You can write s as follows:\nbbbcccdddaa  // 98 pixels wide\na            // 4 pixels wide\nThere are a total of 2 lines, and the last line is 4 pixels wide.\n\n\n \n\n\nConstraints:\n\n\n\n\nwidths.length == 26\n\n\n2 <= widths[i] <= 10\n\n\n1 <= s.length <= 1000\n\n\ns\n contains only lowercase English letters.",
        "temas": [
            "Array",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 804,
        "slug": "unique-morse-code-words",
        "url": "https://leetcode.com/problems/unique-morse-code-words/",
        "titulo": "Unique Morse Code Words",
        "enunciado": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n\n\n\n'a'\n maps to \n\".-\"\n,\n\n\n'b'\n maps to \n\"-...\"\n,\n\n\n'c'\n maps to \n\"-.-.\"\n, and so on.\n\n\n\n\nFor convenience, the full table for the \n26\n letters of the English alphabet is given below:\n\n\n\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n\n\nGiven an array of strings \nwords\n where each word can be written as a concatenation of the Morse code of each letter.\n\n\n\n\nFor example, \n\"cab\"\n can be written as \n\"-.-..--...\"\n, which is the concatenation of \n\"-.-.\"\n, \n\".-\"\n, and \n\"-...\"\n. We will call such a concatenation the \ntransformation\n of a word.\n\n\n\n\nReturn \nthe number of different \ntransformations\n among all words we have\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"gin\",\"zen\",\"gig\",\"msg\"]\n\nOutput:\n 2\n\nExplanation:\n The transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\nThere are 2 different transformations: \"--...-.\" and \"--...--.\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"a\"]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\n1 <= words[i].length <= 12\n\n\nwords[i]\n consists of lowercase English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 706,
        "slug": "design-hashmap",
        "url": "https://leetcode.com/problems/design-hashmap/",
        "titulo": "Design HashMap",
        "enunciado": "Design a HashMap without using any built-in hash table libraries.\n\n\nImplement the \nMyHashMap\n class:\n\n\n\n\nMyHashMap()\n initializes the object with an empty map.\n\n\nvoid put(int key, int value)\n inserts a \n(key, value)\n pair into the HashMap. If the \nkey\n already exists in the map, update the corresponding \nvalue\n.\n\n\nint get(int key)\n returns the \nvalue\n to which the specified \nkey\n is mapped, or \n-1\n if this map contains no mapping for the \nkey\n.\n\n\nvoid remove(key)\n removes the \nkey\n and its corresponding \nvalue\n if the map contains the mapping for the \nkey\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n\nOutput\n\n[null, null, null, 1, -1, null, 1, null, -1]\n\n\nExplanation\n\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= key, value <= 10\n6\n\n\nAt most \n10\n4\n calls will be made to \nput\n, \nget\n, and \nremove\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Linked List",
            "Design",
            "Hash Function"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 705,
        "slug": "design-hashset",
        "url": "https://leetcode.com/problems/design-hashset/",
        "titulo": "Design HashSet",
        "enunciado": "Design a HashSet without using any built-in hash table libraries.\n\n\nImplement \nMyHashSet\n class:\n\n\n\n\nvoid add(key)\n Inserts the value \nkey\n into the HashSet.\n\n\nbool contains(key)\n Returns whether the value \nkey\n exists in the HashSet or not.\n\n\nvoid remove(key)\n Removes the value \nkey\n in the HashSet. If \nkey\n does not exist in the HashSet, do nothing.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n\nOutput\n\n[null, null, null, true, false, null, true, null, false]\n\n\nExplanation\n\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= key <= 10\n6\n\n\nAt most \n10\n4\n calls will be made to \nadd\n, \nremove\n, and \ncontains\n.",
        "temas": [
            "Array",
            "Hash Table",
            "Linked List",
            "Design",
            "Hash Function"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 796,
        "slug": "rotate-string",
        "url": "https://leetcode.com/problems/rotate-string/",
        "titulo": "Rotate String",
        "enunciado": "Given two strings \ns\n and \ngoal\n, return \ntrue\n \nif and only if\n \ns\n \ncan become\n \ngoal\n \nafter some number of \nshifts\n on\n \ns\n.\n\n\nA \nshift\n on \ns\n consists of moving the leftmost character of \ns\n to the rightmost position.\n\n\n\n\nFor example, if \ns = \"abcde\"\n, then it will be \n\"bcdea\"\n after one shift.\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"abcde\", goal = \"cdeab\"\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n s = \"abcde\", goal = \"abced\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, goal.length <= 100\n\n\ns\n and \ngoal\n consist of lowercase English letters.",
        "temas": [
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 783,
        "slug": "minimum-distance-between-bst-nodes",
        "url": "https://leetcode.com/problems/minimum-distance-between-bst-nodes/",
        "titulo": "Minimum Distance Between BST Nodes",
        "enunciado": "Given the \nroot\n of a Binary Search Tree (BST), return \nthe minimum difference between the values of any two different nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,48,null,null,12,49]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 100]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nNote:\n This question is the same as 530: \nhttps://leetcode.com/problems/minimum-absolute-difference-in-bst/",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 704,
        "slug": "binary-search",
        "url": "https://leetcode.com/problems/binary-search/",
        "titulo": "Binary Search",
        "enunciado": "Given an array of integers \nnums\n which is sorted in ascending order, and an integer \ntarget\n, write a function to search \ntarget\n in \nnums\n. If \ntarget\n exists, then return its index. Otherwise, return \n-1\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,3,5,9,12], target = 9\n\nOutput:\n 4\n\nExplanation:\n 9 exists in nums and its index is 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,0,3,5,9,12], target = 2\n\nOutput:\n -1\n\nExplanation:\n 2 does not exist in nums so return -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n < nums[i], target < 10\n4\n\n\nAll the integers in \nnums\n are \nunique\n.\n\n\nnums\n is sorted in ascending order.",
        "temas": [
            "Array",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 703,
        "slug": "kth-largest-element-in-a-stream",
        "url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
        "titulo": "Kth Largest Element in a Stream",
        "enunciado": "You are part of a university admissions office and need to keep track of the \nkth\n highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\n\n\nYou are tasked to implement a class which, for a given integer \nk\n, maintains a stream of test scores and continuously returns the \nk\nth highest test score \nafter\n a new score has been submitted. More specifically, we are looking for the \nk\nth highest score in the sorted list of all scores.\n\n\nImplement the \nKthLargest\n class:\n\n\n\n\nKthLargest(int k, int[] nums)\n Initializes the object with the integer \nk\n and the stream of test scores \nnums\n.\n\n\nint add(int val)\n Adds a new test score \nval\n to the stream and returns the element representing the \nk\nth\n largest element in the pool of test scores so far.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n\n\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n\n\nOutput:\n \n[null, 4, 5, 5, 8, 8]\n\n\nExplanation:\n\n\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\n\nkthLargest.add(3); // return 4\n\nkthLargest.add(5); // return 5\n\nkthLargest.add(10); // return 5\n\nkthLargest.add(9); // return 8\n\nkthLargest.add(4); // return 8\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n\n\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"]\n\n[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]\n\n\nOutput:\n \n[null, 7, 7, 7, 8]\n\n\nExplanation:\n\nKthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);\n\nkthLargest.add(2); // return 7\n\nkthLargest.add(10); // return 7\n\nkthLargest.add(9); // return 7\n\nkthLargest.add(9); // return 8\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n4\n\n\n1 <= k <= nums.length + 1\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n-10\n4\n <= val <= 10\n4\n\n\nAt most \n10\n4\n calls will be made to \nadd\n.",
        "temas": [
            "Tree",
            "Design",
            "Binary Search Tree",
            "Heap (Priority Queue)",
            "Binary Tree",
            "Data Stream"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 700,
        "slug": "search-in-a-binary-search-tree",
        "url": "https://leetcode.com/problems/search-in-a-binary-search-tree/",
        "titulo": "Search in a Binary Search Tree",
        "enunciado": "You are given the \nroot\n of a binary search tree (BST) and an integer \nval\n.\n\n\nFind the node in the BST that the node's value equals \nval\n and return the subtree rooted with that node. If such a node does not exist, return \nnull\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3], val = 2\n\nOutput:\n [2,1,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3], val = 5\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 5000]\n.\n\n\n1 <= Node.val <= 10\n7\n\n\nroot\n is a binary search tree.\n\n\n1 <= val <= 10\n7",
        "temas": [
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 771,
        "slug": "jewels-and-stones",
        "url": "https://leetcode.com/problems/jewels-and-stones/",
        "titulo": "Jewels and Stones",
        "enunciado": "You're given strings \njewels\n representing the types of stones that are jewels, and \nstones\n representing the stones you have. Each character in \nstones\n is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\n\nLetters are case sensitive, so \n\"a\"\n is considered a different type of stone from \n\"A\"\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n jewels = \"aA\", stones = \"aAAbbbb\"\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n jewels = \"z\", stones = \"ZZ\"\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= jewels.length, stones.length <= 50\n\n\njewels\n and \nstones\n consist of only English letters.\n\n\nAll the characters of \njewels\n are \nunique\n.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 766,
        "slug": "toeplitz-matrix",
        "url": "https://leetcode.com/problems/toeplitz-matrix/",
        "titulo": "Toeplitz Matrix",
        "enunciado": "Given an \nm x n\n \nmatrix\n, return \ntrue\n if the matrix is Toeplitz. Otherwise, return \nfalse\n.\n\n\nA matrix is \nToeplitz\n if every diagonal from top-left to bottom-right has the same elements.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n\nOutput:\n true\n\nExplanation:\n\nIn the above grid, the diagonals are:\n\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\".\nIn each diagonal all elements are the same, so the answer is True.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2],[2,2]]\n\nOutput:\n false\n\nExplanation:\n\nThe diagonal \"[1, 2]\" has different elements.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 20\n\n\n0 <= matrix[i][j] <= 99\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nWhat if the \nmatrix\n is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\n\n\nWhat if the \nmatrix\n is so large that you can only load up a partial row into the memory at once?",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 590,
        "slug": "n-ary-tree-postorder-traversal",
        "url": "https://leetcode.com/problems/n-ary-tree-postorder-traversal/",
        "titulo": "N-ary Tree Postorder Traversal",
        "enunciado": "Given the \nroot\n of an n-ary tree, return \nthe postorder traversal of its nodes' values\n.\n\n\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n [5,6,3,2,4,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4\n\n\nThe height of the n-ary tree is less than or equal to \n1000\n.\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
        "temas": [
            "Stack",
            "Tree",
            "Depth-First Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 589,
        "slug": "n-ary-tree-preorder-traversal",
        "url": "https://leetcode.com/problems/n-ary-tree-preorder-traversal/",
        "titulo": "N-ary Tree Preorder Traversal",
        "enunciado": "Given the \nroot\n of an n-ary tree, return \nthe preorder traversal of its nodes' values\n.\n\n\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n [1,3,5,6,2,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4\n\n\nThe height of the n-ary tree is less than or equal to \n1000\n.\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
        "temas": [
            "Stack",
            "Tree",
            "Depth-First Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 559,
        "slug": "maximum-depth-of-n-ary-tree",
        "url": "https://leetcode.com/problems/maximum-depth-of-n-ary-tree/",
        "titulo": "Maximum Depth of N-ary Tree",
        "enunciado": "Given a n-ary tree, find its maximum depth.\n\n\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe total number of nodes is in the range \n[0, 10\n4\n]\n.\n\n\nThe depth of the n-ary tree is less than or equal to \n1000\n.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 762,
        "slug": "prime-number-of-set-bits-in-binary-representation",
        "url": "https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/",
        "titulo": "Prime Number of Set Bits in Binary Representation",
        "enunciado": "Given two integers \nleft\n and \nright\n, return \nthe \ncount\n of numbers in the \ninclusive\n range \n[left, right]\n having a \nprime number of set bits\n in their binary representation\n.\n\n\nRecall that the \nnumber of set bits\n an integer has is the number of \n1\n's present when written in binary.\n\n\n\n\nFor example, \n21\n written in binary is \n10101\n, which has \n3\n set bits.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n left = 6, right = 10\n\nOutput:\n 4\n\nExplanation:\n\n6  -> 110 (2 set bits, 2 is prime)\n7  -> 111 (3 set bits, 3 is prime)\n8  -> 1000 (1 set bit, 1 is not prime)\n9  -> 1001 (2 set bits, 2 is prime)\n10 -> 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits.\n\n\n\nExample 2:\n\n\n\n\nInput:\n left = 10, right = 15\n\nOutput:\n 5\n\nExplanation:\n\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= left <= right <= 10\n6\n\n\n0 <= right - left <= 10\n4",
        "temas": [
            "Math",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 748,
        "slug": "shortest-completing-word",
        "url": "https://leetcode.com/problems/shortest-completing-word/",
        "titulo": "Shortest Completing Word",
        "enunciado": "Given a string \nlicensePlate\n and an array of strings \nwords\n, find the \nshortest completing\n word in \nwords\n.\n\n\nA \ncompleting\n word is a word that \ncontains all the letters\n in \nlicensePlate\n. \nIgnore numbers and spaces\n in \nlicensePlate\n, and treat letters as \ncase insensitive\n. If a letter appears more than once in \nlicensePlate\n, then it must appear in the word the same number of times or more.\n\n\nFor example, if \nlicensePlate\n = \"aBc 12c\"\n, then it contains letters \n'a'\n, \n'b'\n (ignoring case), and \n'c'\n twice. Possible \ncompleting\n words are \n\"abccdef\"\n, \n\"caaacab\"\n, and \n\"cbca\"\n.\n\n\nReturn \nthe shortest \ncompleting\n word in \nwords\n.\n It is guaranteed an answer exists. If there are multiple shortest \ncompleting\n words, return the \nfirst\n one that occurs in \nwords\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n\nOutput:\n \"steps\"\n\nExplanation:\n licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n\"step\" contains 't' and 'p', but only contains 1 's'.\n\"steps\" contains 't', 'p', and both 's' characters.\n\"stripe\" is missing an 's'.\n\"stepple\" is missing an 's'.\nSince \"steps\" is the only word containing all the letters, that is the answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]\n\nOutput:\n \"pest\"\n\nExplanation:\n licensePlate only contains the letter 's'. All the words contain 's', but among these \"pest\", \"stew\", and \"show\" are shortest. The answer is \"pest\" because it is the word that appears earliest of the 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= licensePlate.length <= 7\n\n\nlicensePlate\n contains digits, letters (uppercase or lowercase), or space \n' '\n.\n\n\n1 <= words.length <= 1000\n\n\n1 <= words[i].length <= 15\n\n\nwords[i]\n consists of lower case English letters.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 747,
        "slug": "largest-number-at-least-twice-of-others",
        "url": "https://leetcode.com/problems/largest-number-at-least-twice-of-others/",
        "titulo": "Largest Number At Least Twice of Others",
        "enunciado": "You are given an integer array \nnums\n where the largest integer is \nunique\n.\n\n\nDetermine whether the largest element in the array is \nat least twice\n as much as every other number in the array. If it is, return \nthe \nindex\n of the largest element, or return \n-1\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,6,1,0]\n\nOutput:\n 1\n\nExplanation:\n 6 is the largest integer.\nFor every other number in the array x, 6 is at least twice as big as x.\nThe index of value 6 is 1, so we return 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n -1\n\nExplanation:\n 4 is less than twice the value of 3, so we return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 50\n\n\n0 <= nums[i] <= 100\n\n\nThe largest element in \nnums\n is unique.",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 746,
        "slug": "min-cost-climbing-stairs",
        "url": "https://leetcode.com/problems/min-cost-climbing-stairs/",
        "titulo": "Min Cost Climbing Stairs",
        "enunciado": "You are given an integer array \ncost\n where \ncost[i]\n is the cost of \ni\nth\n step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\n\nYou can either start from the step with index \n0\n, or the step with index \n1\n.\n\n\nReturn \nthe minimum cost to reach the top of the floor\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n cost = [10,\n15\n,20]\n\nOutput:\n 15\n\nExplanation:\n You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cost = [\n1\n,100,\n1\n,1,\n1\n,100,\n1\n,\n1\n,100,\n1\n]\n\nOutput:\n 6\n\nExplanation:\n You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= cost.length <= 1000\n\n\n0 <= cost[i] <= 999",
        "temas": [
            "Array",
            "Dynamic Programming"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 744,
        "slug": "find-smallest-letter-greater-than-target",
        "url": "https://leetcode.com/problems/find-smallest-letter-greater-than-target/",
        "titulo": "Find Smallest Letter Greater Than Target",
        "enunciado": "You are given an array of characters \nletters\n that is sorted in \nnon-decreasing order\n, and a character \ntarget\n. There are \nat least two different\n characters in \nletters\n.\n\n\nReturn \nthe smallest character in \nletters\n that is lexicographically greater than \ntarget\n. If such a character does not exist, return the first character in \nletters\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n letters = [\"c\",\"f\",\"j\"], target = \"a\"\n\nOutput:\n \"c\"\n\nExplanation:\n The smallest character that is lexicographically greater than 'a' in letters is 'c'.\n\n\n\nExample 2:\n\n\n\n\nInput:\n letters = [\"c\",\"f\",\"j\"], target = \"c\"\n\nOutput:\n \"f\"\n\nExplanation:\n The smallest character that is lexicographically greater than 'c' in letters is 'f'.\n\n\n\nExample 3:\n\n\n\n\nInput:\n letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\n\nOutput:\n \"x\"\n\nExplanation:\n There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= letters.length <= 10\n4\n\n\nletters[i]\n is a lowercase English letter.\n\n\nletters\n is sorted in \nnon-decreasing\n order.\n\n\nletters\n contains at least two different characters.\n\n\ntarget\n is a lowercase English letter.",
        "temas": [
            "Array",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 709,
        "slug": "to-lower-case",
        "url": "https://leetcode.com/problems/to-lower-case/",
        "titulo": "To Lower Case",
        "enunciado": "Given a string \ns\n, return \nthe string after replacing every uppercase letter with the same lowercase letter\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"Hello\"\n\nOutput:\n \"hello\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"here\"\n\nOutput:\n \"here\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"LOVELY\"\n\nOutput:\n \"lovely\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n consists of printable ASCII characters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 733,
        "slug": "flood-fill",
        "url": "https://leetcode.com/problems/flood-fill/",
        "titulo": "Flood Fill",
        "enunciado": "You are given an image represented by an \nm x n\n grid of integers \nimage\n, where \nimage[i][j]\n represents the pixel value of the image. You are also given three integers \nsr\n, \nsc\n, and \ncolor\n. Your task is to perform a \nflood fill\n on the image starting from the pixel \nimage[sr][sc]\n.\n\n\nTo perform a \nflood fill\n:\n\n\n\n\nBegin with the starting pixel and change its color to \ncolor\n.\n\n\nPerform the same process for each pixel that is \ndirectly adjacent\n (pixels that share a side with the original pixel, either horizontally or vertically) and shares the \nsame color\n as the starting pixel.\n\n\nKeep \nrepeating\n this process by checking neighboring pixels of the \nupdated\n pixels and modifying their color if it matches the original color of the starting pixel.\n\n\nThe process \nstops\n when there are \nno more\n adjacent pixels of the original color to update.\n\n\n\n\nReturn the \nmodified\n image after performing the flood fill.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nimage = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n\n\nOutput:\n \n[[2,2,2],[2,2,0],[2,0,1]]\n\n\nExplanation:\n\n\n\n\nFrom the center of the image with position \n(sr, sc) = (1, 1)\n (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n\n\nNote the bottom corner is \nnot\n colored 2, because it is not horizontally or vertically connected to the starting pixel.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nimage = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n\n\nOutput:\n \n[[0,0,0],[0,0,0]]\n\n\nExplanation:\n\n\nThe starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == image.length\n\n\nn == image[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= image[i][j], color < 2\n16\n\n\n0 <= sr < m\n\n\n0 <= sc < n",
        "temas": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 728,
        "slug": "self-dividing-numbers",
        "url": "https://leetcode.com/problems/self-dividing-numbers/",
        "titulo": "Self Dividing Numbers",
        "enunciado": "A \nself-dividing number\n is a number that is divisible by every digit it contains.\n\n\n\n\nFor example, \n128\n is \na self-dividing number\n because \n128 % 1 == 0\n, \n128 % 2 == 0\n, and \n128 % 8 == 0\n.\n\n\n\n\nA \nself-dividing number\n is not allowed to contain the digit zero.\n\n\nGiven two integers \nleft\n and \nright\n, return \na list of all the \nself-dividing numbers\n in the range\n \n[left, right]\n (both \ninclusive\n).\n\n\n \n\n\nExample 1:\n\n\nInput:\n left = 1, right = 22\n\nOutput:\n [1,2,3,4,5,6,7,8,9,11,12,15,22]\n\nExample 2:\n\n\nInput:\n left = 47, right = 85\n\nOutput:\n [48,55,66,77]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= left <= right <= 10\n4",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 724,
        "slug": "find-pivot-index",
        "url": "https://leetcode.com/problems/find-pivot-index/",
        "titulo": "Find Pivot Index",
        "enunciado": "Given an array of integers \nnums\n, calculate the \npivot index\n of this array.\n\n\nThe \npivot index\n is the index where the sum of all the numbers \nstrictly\n to the left of the index is equal to the sum of all the numbers \nstrictly\n to the index's right.\n\n\nIf the index is on the left edge of the array, then the left sum is \n0\n because there are no elements to the left. This also applies to the right edge of the array.\n\n\nReturn \nthe \nleftmost pivot index\n. If no such index exists, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,7,3,6,5,6]\n\nOutput:\n 3\n\nExplanation:\n\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n -1\n\nExplanation:\n\nThere is no index that satisfies the conditions in the problem statement.\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,1,-1]\n\nOutput:\n 0\n\nExplanation:\n\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n\n\n \n\n\nNote:\n This question is the same as 1991: \nhttps://leetcode.com/problems/find-the-middle-index-in-array/",
        "temas": [
            "Array",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 717,
        "slug": "1-bit-and-2-bit-characters",
        "url": "https://leetcode.com/problems/1-bit-and-2-bit-characters/",
        "titulo": "1-bit and 2-bit Characters",
        "enunciado": "We have two special characters:\n\n\n\n\nThe first character can be represented by one bit \n0\n.\n\n\nThe second character can be represented by two bits (\n10\n or \n11\n).\n\n\n\n\nGiven a binary array \nbits\n that ends with \n0\n, return \ntrue\n if the last character must be a one-bit character.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n bits = [1,0,0]\n\nOutput:\n true\n\nExplanation:\n The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character.\n\n\n\nExample 2:\n\n\n\n\nInput:\n bits = [1,1,1,0]\n\nOutput:\n false\n\nExplanation:\n The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= bits.length <= 1000\n\n\nbits[i]\n is either \n0\n or \n1\n.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 697,
        "slug": "degree-of-an-array",
        "url": "https://leetcode.com/problems/degree-of-an-array/",
        "titulo": "Degree of an Array",
        "enunciado": "Given a non-empty array of non-negative integers \nnums\n, the \ndegree\n of this array is defined as the maximum frequency of any one of its elements.\n\n\nYour task is to find the smallest possible length of a (contiguous) subarray of \nnums\n, that has the same degree as \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length is 2. So return 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,2,3,1,4,2]\n\nOutput:\n 6\n\nExplanation:\n \nThe degree is 3 because the element 2 is repeated 3 times.\nSo [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums.length\n will be between 1 and 50,000.\n\n\nnums[i]\n will be an integer between 0 and 49,999.",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 696,
        "slug": "count-binary-substrings",
        "url": "https://leetcode.com/problems/count-binary-substrings/",
        "titulo": "Count Binary Substrings",
        "enunciado": "Given a binary string \ns\n, return the number of non-empty substrings that have the same number of \n0\n's and \n1\n's, and all the \n0\n's and all the \n1\n's in these substrings are grouped consecutively.\n\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"00110011\"\n\nOutput:\n 6\n\nExplanation:\n There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"10101\"\n\nOutput:\n 4\n\nExplanation:\n There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns[i]\n is either \n'0'\n or \n'1'\n.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 693,
        "slug": "binary-number-with-alternating-bits",
        "url": "https://leetcode.com/problems/binary-number-with-alternating-bits/",
        "titulo": "Binary Number with Alternating Bits",
        "enunciado": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n true\n\nExplanation:\n The binary representation of 5 is: 101\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 7\n\nOutput:\n false\n\nExplanation:\n The binary representation of 7 is: 111.\n\n\nExample 3:\n\n\n\n\nInput:\n n = 11\n\nOutput:\n false\n\nExplanation:\n The binary representation of 11 is: 1011.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 682,
        "slug": "baseball-game",
        "url": "https://leetcode.com/problems/baseball-game/",
        "titulo": "Baseball Game",
        "enunciado": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\n\nYou are given a list of strings \noperations\n, where \noperations[i]\n is the \ni\nth\n operation you must apply to the record and is one of the following:\n\n\n\n\nAn integer \nx\n.\n\n\t\n\n\nRecord a new score of \nx\n.\n\n\n\n\n\n\n'+'\n.\n\t\n\n\nRecord a new score that is the sum of the previous two scores.\n\n\n\n\n\n\n'D'\n.\n\t\n\n\nRecord a new score that is the double of the previous score.\n\n\n\n\n\n\n'C'\n.\n\t\n\n\nInvalidate the previous score, removing it from the record.\n\n\n\n\n\n\n\n\nReturn \nthe sum of all the scores on the record after applying all the operations\n.\n\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a \n32-bit\n integer and that all operations are valid.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\n\nOutput:\n 30\n\nExplanation:\n\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.\n\n\n\nExample 2:\n\n\n\n\nInput:\n ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n\nOutput:\n 27\n\nExplanation:\n\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n\n\nExample 3:\n\n\n\n\nInput:\n ops = [\"1\",\"C\"]\n\nOutput:\n 0\n\nExplanation:\n\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= operations.length <= 1000\n\n\noperations[i]\n is \n\"C\"\n, \n\"D\"\n, \n\"+\"\n, or a string representing an integer in the range \n[-3 * 10\n4\n, 3 * 10\n4\n]\n.\n\n\nFor operation \n\"+\"\n, there will always be at least two previous scores on the record.\n\n\nFor operations \n\"C\"\n and \n\"D\"\n, there will always be at least one previous score on the record.",
        "temas": [
            "Array",
            "Stack",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 680,
        "slug": "valid-palindrome-ii",
        "url": "https://leetcode.com/problems/valid-palindrome-ii/",
        "titulo": "Valid Palindrome II",
        "enunciado": "Given a string \ns\n, return \ntrue\n \nif the \ns\n can be palindrome after deleting \nat most one\n character from it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aba\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abca\"\n\nOutput:\n true\n\nExplanation:\n You could delete the character 'c'.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"abc\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of lowercase English letters.",
        "temas": [
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 674,
        "slug": "longest-continuous-increasing-subsequence",
        "url": "https://leetcode.com/problems/longest-continuous-increasing-subsequence/",
        "titulo": "Longest Continuous Increasing Subsequence",
        "enunciado": "Given an unsorted array of integers \nnums\n, return \nthe length of the longest \ncontinuous increasing subsequence\n (i.e. subarray)\n. The subsequence must be \nstrictly\n increasing.\n\n\nA \ncontinuous increasing subsequence\n is defined by two indices \nl\n and \nr\n (\nl < r\n) such that it is \n[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]\n and for each \nl <= i < r\n, \nnums[i] < nums[i + 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,4,7]\n\nOutput:\n 3\n\nExplanation:\n The longest continuous increasing subsequence is [1,3,5] with length 3.\nEven though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2]\n\nOutput:\n 1\n\nExplanation:\n The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\nincreasing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 671,
        "slug": "second-minimum-node-in-a-binary-tree",
        "url": "https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/",
        "titulo": "Second Minimum Node In a Binary Tree",
        "enunciado": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly \ntwo\n or \nzero\n sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property \nroot.val = min(root.left.val, root.right.val)\n always holds.\n\n\nGiven such a binary tree, you need to output the \nsecond minimum\n value in the set made of all the nodes' value in the whole tree.\n\n\nIf no such second minimum value exists, output -1 instead.\n\n\n \n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,2,5,null,null,5,7]\n\nOutput:\n 5\n\nExplanation:\n The smallest value is 2, the second smallest value is 5.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,2,2]\n\nOutput:\n -1\n\nExplanation:\n The smallest value is 2, but there isn't any second smallest value.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 25]\n.\n\n\n1 <= Node.val <= 2\n31\n - 1\n\n\nroot.val == min(root.left.val, root.right.val)\n for each internal node of the tree.",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 661,
        "slug": "image-smoother",
        "url": "https://leetcode.com/problems/image-smoother/",
        "titulo": "Image Smoother",
        "enunciado": "An \nimage smoother\n is a filter of the size \n3 x 3\n that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\n\n\n\nGiven an \nm x n\n integer matrix \nimg\n representing the grayscale of an image, return \nthe image after applying the smoother on each cell of it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n img = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n [[0,0,0],[0,0,0],[0,0,0]]\n\nExplanation:\n\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n img = [[100,200,100],[200,50,200],[100,200,100]]\n\nOutput:\n [[137,141,137],[141,138,141],[137,141,137]]\n\nExplanation:\n\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == img.length\n\n\nn == img[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= img[i][j] <= 255",
        "temas": [
            "Array",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 657,
        "slug": "robot-return-to-origin",
        "url": "https://leetcode.com/problems/robot-return-to-origin/",
        "titulo": "Robot Return to Origin",
        "enunciado": "There is a robot starting at the position \n(0, 0)\n, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot \nends up at \n(0, 0)\n after it completes its moves.\n\n\nYou are given a string \nmoves\n that represents the move sequence of the robot where \nmoves[i]\n represents its \ni\nth\n move. Valid moves are \n'R'\n (right), \n'L'\n (left), \n'U'\n (up), and \n'D'\n (down).\n\n\nReturn \ntrue\n if the robot returns to the origin after it finishes all of its moves, or \nfalse\n otherwise\n.\n\n\nNote\n: The way that the robot is \"facing\" is irrelevant. \n'R'\n will always make the robot move to the right once, \n'L'\n will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n moves = \"UD\"\n\nOutput:\n true\n\nExplanation\n: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n moves = \"LL\"\n\nOutput:\n false\n\nExplanation\n: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= moves.length <= 2 * 10\n4\n\n\nmoves\n only contains the characters \n'U'\n, \n'D'\n, \n'L'\n and \n'R'\n.",
        "temas": [
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 653,
        "slug": "two-sum-iv-input-is-a-bst",
        "url": "https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",
        "titulo": "Two Sum IV - Input is a BST",
        "enunciado": "Given the \nroot\n of a binary search tree and an integer \nk\n, return \ntrue\n \nif there exist two elements in the BST such that their sum is equal to\n \nk\n, \nor\n \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,7], k = 9\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,7], k = 28\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nroot\n is guaranteed to be a \nvalid\n binary search tree.\n\n\n-10\n5\n <= k <= 10\n5",
        "temas": [
            "Hash Table",
            "Two Pointers",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 645,
        "slug": "set-mismatch",
        "url": "https://leetcode.com/problems/set-mismatch/",
        "titulo": "Set Mismatch",
        "enunciado": "You have a set of integers \ns\n, which originally contains all the numbers from \n1\n to \nn\n. Unfortunately, due to some error, one of the numbers in \ns\n got duplicated to another number in the set, which results in \nrepetition of one\n number and \nloss of another\n number.\n\n\nYou are given an integer array \nnums\n representing the data status of this set after the error.\n\n\nFind the number that occurs twice and the number that is missing and return \nthem in the form of an array\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,2,4]\n\nOutput:\n [2,3]\n\nExample 2:\n\n\nInput:\n nums = [1,1]\n\nOutput:\n [1,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n1 <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 643,
        "slug": "maximum-average-subarray-i",
        "url": "https://leetcode.com/problems/maximum-average-subarray-i/",
        "titulo": "Maximum Average Subarray I",
        "enunciado": "You are given an integer array \nnums\n consisting of \nn\n elements, and an integer \nk\n.\n\n\nFind a contiguous subarray whose \nlength is equal to\n \nk\n that has the maximum average value and return \nthis value\n. Any answer with a calculation error less than \n10\n-5\n will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,12,-5,-6,50,3], k = 4\n\nOutput:\n 12.75000\n\nExplanation:\n Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5], k = 1\n\nOutput:\n 5.00000\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= k <= n <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 637,
        "slug": "average-of-levels-in-binary-tree",
        "url": "https://leetcode.com/problems/average-of-levels-in-binary-tree/",
        "titulo": "Average of Levels in Binary Tree",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe average value of the nodes on each level in the form of an array\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,9,20,15,7]\n\nOutput:\n [3.00000,14.50000,11.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 628,
        "slug": "maximum-product-of-three-numbers",
        "url": "https://leetcode.com/problems/maximum-product-of-three-numbers/",
        "titulo": "Maximum Product of Three Numbers",
        "enunciado": "Given an integer array \nnums\n, \nfind three numbers whose product is maximum and return the maximum product\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n 6\n\nExample 2:\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n 24\n\nExample 3:\n\n\nInput:\n nums = [-1,-2,-3]\n\nOutput:\n -6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 10\n4\n\n\n-1000 <= nums[i] <= 1000",
        "temas": [
            "Array",
            "Math",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 617,
        "slug": "merge-two-binary-trees",
        "url": "https://leetcode.com/problems/merge-two-binary-trees/",
        "titulo": "Merge Two Binary Trees",
        "enunciado": "You are given two binary trees \nroot1\n and \nroot2\n.\n\n\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n\n\nReturn \nthe merged tree\n.\n\n\nNote:\n The merging process must start from the root nodes of both trees.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n\nOutput:\n [3,4,5,5,4,null,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root1 = [1], root2 = [1,2]\n\nOutput:\n [2,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 2000]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 605,
        "slug": "can-place-flowers",
        "url": "https://leetcode.com/problems/can-place-flowers/",
        "titulo": "Can Place Flowers",
        "enunciado": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in \nadjacent\n plots.\n\n\nGiven an integer array \nflowerbed\n containing \n0\n's and \n1\n's, where \n0\n means empty and \n1\n means not empty, and an integer \nn\n, return \ntrue\n \nif\n \nn\n \nnew flowers can be planted in the\n \nflowerbed\n \nwithout violating the no-adjacent-flowers rule and\n \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n flowerbed = [1,0,0,0,1], n = 1\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n flowerbed = [1,0,0,0,1], n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= flowerbed.length <= 2 * 10\n4\n\n\nflowerbed[i]\n is \n0\n or \n1\n.\n\n\nThere are no two adjacent flowers in \nflowerbed\n.\n\n\n0 <= n <= flowerbed.length",
        "temas": [
            "Array",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 599,
        "slug": "minimum-index-sum-of-two-lists",
        "url": "https://leetcode.com/problems/minimum-index-sum-of-two-lists/",
        "titulo": "Minimum Index Sum of Two Lists",
        "enunciado": "Given two arrays of strings \nlist1\n and \nlist2\n, find the \ncommon strings with the least index sum\n.\n\n\nA \ncommon string\n is a string that appeared in both \nlist1\n and \nlist2\n.\n\n\nA \ncommon string with the least index sum\n is a common string such that if it appeared at \nlist1[i]\n and \nlist2[j]\n then \ni + j\n should be the minimum value among all the other \ncommon strings\n.\n\n\nReturn \nall the \ncommon strings with the least index sum\n. Return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\n\nOutput:\n [\"Shogun\"]\n\nExplanation:\n The only common string is \"Shogun\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\n\nOutput:\n [\"Shogun\"]\n\nExplanation:\n The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\n\nOutput:\n [\"sad\",\"happy\"]\n\nExplanation:\n There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= list1.length, list2.length <= 1000\n\n\n1 <= list1[i].length, list2[i].length <= 30\n\n\nlist1[i]\n and \nlist2[i]\n consist of spaces \n' '\n and English letters.\n\n\nAll the strings of \nlist1\n are \nunique\n.\n\n\nAll the strings of \nlist2\n are \nunique\n.\n\n\nThere is at least a common string between \nlist1\n and \nlist2\n.",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 598,
        "slug": "range-addition-ii",
        "url": "https://leetcode.com/problems/range-addition-ii/",
        "titulo": "Range Addition II",
        "enunciado": "You are given an \nm x n\n matrix \nM\n initialized with all \n0\n's and an array of operations \nops\n, where \nops[i] = [a\ni\n, b\ni\n]\n means \nM[x][y]\n should be incremented by one for all \n0 <= x < a\ni\n and \n0 <= y < b\ni\n.\n\n\nCount and return \nthe number of maximum integers in the matrix after performing all the operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 3, ops = [[2,2],[3,3]]\n\nOutput:\n 4\n\nExplanation:\n The maximum integer in M is 2, and there are four of it in M. So return 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n m = 3, n = 3, ops = []\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 4 * 10\n4\n\n\n0 <= ops.length <= 10\n4\n\n\nops[i].length == 2\n\n\n1 <= a\ni\n <= m\n\n\n1 <= b\ni\n <= n",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 594,
        "slug": "longest-harmonious-subsequence",
        "url": "https://leetcode.com/problems/longest-harmonious-subsequence/",
        "titulo": "Longest Harmonious Subsequence",
        "enunciado": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is \nexactly\n \n1\n.\n\n\nGiven an integer array \nnums\n, return the length of its longest harmonious \nsubsequence\n among all its possible subsequences.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,3,2,2,5,2,3,7]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\nThe longest harmonious subsequence is \n[3,2,2,2,3]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe longest harmonious subsequences are \n[1,2]\n, \n[2,3]\n, and \n[3,4]\n, all of which have a length of 2.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,1]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo harmonic subsequence exists.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9",
        "temas": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 575,
        "slug": "distribute-candies",
        "url": "https://leetcode.com/problems/distribute-candies/",
        "titulo": "Distribute Candies",
        "enunciado": "Alice has \nn\n candies, where the \ni\nth\n candy is of type \ncandyType[i]\n. Alice noticed that she started to gain weight, so she visited a doctor.\n\n\nThe doctor advised Alice to only eat \nn / 2\n of the candies she has (\nn\n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\n\nGiven the integer array \ncandyType\n of length \nn\n, return \nthe \nmaximum\n number of different types of candies she can eat if she only eats \nn / 2\n of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candyType = [1,1,2,2,3,3]\n\nOutput:\n 3\n\nExplanation:\n Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n\n\n\nExample 2:\n\n\n\n\nInput:\n candyType = [1,1,2,3]\n\nOutput:\n 2\n\nExplanation:\n Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.\n\n\n\nExample 3:\n\n\n\n\nInput:\n candyType = [6,6,6,6]\n\nOutput:\n 1\n\nExplanation:\n Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == candyType.length\n\n\n2 <= n <= 10\n4\n\n\nn\n is even.\n\n\n-10\n5\n <= candyType[i] <= 10\n5",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 572,
        "slug": "subtree-of-another-tree",
        "url": "https://leetcode.com/problems/subtree-of-another-tree/",
        "titulo": "Subtree of Another Tree",
        "enunciado": "Given the roots of two binary trees \nroot\n and \nsubRoot\n, return \ntrue\n if there is a subtree of \nroot\n with the same structure and node values of\n subRoot\n and \nfalse\n otherwise.\n\n\nA subtree of a binary tree \ntree\n is a tree that consists of a node in \ntree\n and all of this node's descendants. The tree \ntree\n could also be considered as a subtree of itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,4,5,1,2], subRoot = [4,1,2]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the \nroot\n tree is in the range \n[1, 2000]\n.\n\n\nThe number of nodes in the \nsubRoot\n tree is in the range \n[1, 1000]\n.\n\n\n-10\n4\n <= root.val <= 10\n4\n\n\n-10\n4\n <= subRoot.val <= 10\n4",
        "temas": [
            "Tree",
            "Depth-First Search",
            "String Matching",
            "Binary Tree",
            "Hash Function"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 566,
        "slug": "reshape-the-matrix",
        "url": "https://leetcode.com/problems/reshape-the-matrix/",
        "titulo": "Reshape the Matrix",
        "enunciado": "In MATLAB, there is a handy function called \nreshape\n which can reshape an \nm x n\n matrix into a new one with a different size \nr x c\n keeping its original data.\n\n\nYou are given an \nm x n\n matrix \nmat\n and two integers \nr\n and \nc\n representing the number of rows and the number of columns of the wanted reshaped matrix.\n\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\n\nIf the \nreshape\n operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,2],[3,4]], r = 1, c = 4\n\nOutput:\n [[1,2,3,4]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[1,2],[3,4]], r = 2, c = 4\n\nOutput:\n [[1,2],[3,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 100\n\n\n-1000 <= mat[i][j] <= 1000\n\n\n1 <= r, c <= 300",
        "temas": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 563,
        "slug": "binary-tree-tilt",
        "url": "https://leetcode.com/problems/binary-tree-tilt/",
        "titulo": "Binary Tree Tilt",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe sum of every tree node's \ntilt\n.\n\n\nThe \ntilt\n of a tree node is the \nabsolute difference\n between the sum of all left subtree node \nvalues\n and all right subtree node \nvalues\n. If a node does not have a left child, then the sum of the left subtree node \nvalues\n is treated as \n0\n. The rule is similar if the node does not have a right child.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 1\n\nExplanation:\n \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,2,9,3,5,null,7]\n\nOutput:\n 15\n\nExplanation:\n \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [21,7,14,1,1,2,2,3,3]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 561,
        "slug": "array-partition",
        "url": "https://leetcode.com/problems/array-partition/",
        "titulo": "Array Partition",
        "enunciado": "Given an integer array \nnums\n of \n2n\n integers, group these integers into \nn\n pairs \n(a\n1\n, b\n1\n), (a\n2\n, b\n2\n), ..., (a\nn\n, b\nn\n)\n such that the sum of \nmin(a\ni\n, b\ni\n)\n for all \ni\n is \nmaximized\n. Return\n the maximized sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,4,3,2]\n\nOutput:\n 4\n\nExplanation:\n All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [6,2,6,5,1,2]\n\nOutput:\n 9\n\nExplanation:\n The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4\n\n\nnums.length == 2 * n\n\n\n-10\n4\n <= nums[i] <= 10\n4",
        "temas": [
            "Array",
            "Greedy",
            "Sorting",
            "Counting Sort"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 557,
        "slug": "reverse-words-in-a-string-iii",
        "url": "https://leetcode.com/problems/reverse-words-in-a-string-iii/",
        "titulo": "Reverse Words in a String III",
        "enunciado": "Given a string \ns\n, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"Let's take LeetCode contest\"\n\nOutput:\n \"s'teL ekat edoCteeL tsetnoc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"Mr Ding\"\n\nOutput:\n \"rM gniD\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 5 * 10\n4\n\n\ns\n contains printable \nASCII\n characters.\n\n\ns\n does not contain any leading or trailing spaces.\n\n\nThere is \nat least one\n word in \ns\n.\n\n\nAll the words in \ns\n are separated by a single space.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 551,
        "slug": "student-attendance-record-i",
        "url": "https://leetcode.com/problems/student-attendance-record-i/",
        "titulo": "Student Attendance Record I",
        "enunciado": "You are given a string \ns\n representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n\n\n\n'A'\n: Absent.\n\n\n'L'\n: Late.\n\n\n'P'\n: Present.\n\n\n\n\nThe student is eligible for an attendance award if they meet \nboth\n of the following criteria:\n\n\n\n\nThe student was absent (\n'A'\n) for \nstrictly\n fewer than 2 days \ntotal\n.\n\n\nThe student was \nnever\n late (\n'L'\n) for 3 or more \nconsecutive\n days.\n\n\n\n\nReturn \ntrue\n if the student is eligible for an attendance award, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"PPALLP\"\n\nOutput:\n true\n\nExplanation:\n The student has fewer than 2 absences and was never late 3 or more consecutive days.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"PPALLL\"\n\nOutput:\n false\n\nExplanation:\n The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns[i]\n is either \n'A'\n, \n'L'\n, or \n'P'\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 543,
        "slug": "diameter-of-binary-tree",
        "url": "https://leetcode.com/problems/diameter-of-binary-tree/",
        "titulo": "Diameter of Binary Tree",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 541,
        "slug": "reverse-string-ii",
        "url": "https://leetcode.com/problems/reverse-string-ii/",
        "titulo": "Reverse String II",
        "enunciado": "Given a string \ns\n and an integer \nk\n, reverse the first \nk\n characters for every \n2k\n characters counting from the start of the string.\n\n\nIf there are fewer than \nk\n characters left, reverse all of them. If there are less than \n2k\n but greater than or equal to \nk\n characters, then reverse the first \nk\n characters and leave the other as original.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"abcdefg\", k = 2\n\nOutput:\n \"bacdfeg\"\n\nExample 2:\n\n\nInput:\n s = \"abcd\", k = 2\n\nOutput:\n \"bacd\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of only lowercase English letters.\n\n\n1 <= k <= 10\n4",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 530,
        "slug": "minimum-absolute-difference-in-bst",
        "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
        "titulo": "Minimum Absolute Difference in BST",
        "enunciado": "Given the \nroot\n of a Binary Search Tree (BST), return \nthe minimum absolute difference between the values of any two different nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,48,null,null,12,49]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nNote:\n This question is the same as 783: \nhttps://leetcode.com/problems/minimum-distance-between-bst-nodes/",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 521,
        "slug": "longest-uncommon-subsequence-i",
        "url": "https://leetcode.com/problems/longest-uncommon-subsequence-i/",
        "titulo": "Longest Uncommon Subsequence I",
        "enunciado": "Given two strings \na\n and \nb\n, return \nthe length of the \nlongest uncommon subsequence\n between \na\n \nand\n \nb\n. \nIf no such uncommon subsequence exists, return\n \n-1\n.\n\n\nAn \nuncommon subsequence\n between two strings is a string that is a \nsubsequence\n of exactly one of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n a = \"aba\", b = \"cdc\"\n\nOutput:\n 3\n\nExplanation:\n One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\n\n\n\nExample 2:\n\n\n\n\nInput:\n a = \"aaa\", b = \"bbb\"\n\nOutput:\n 3\n\nExplanation:\n The longest uncommon subsequences are \"aaa\" and \"bbb\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n a = \"aaa\", b = \"aaa\"\n\nOutput:\n -1\n\nExplanation:\n Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be \n-1\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a.length, b.length <= 100\n\n\na\n and \nb\n consist of lower-case English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 520,
        "slug": "detect-capital",
        "url": "https://leetcode.com/problems/detect-capital/",
        "titulo": "Detect Capital",
        "enunciado": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\n\n\n\nAll letters in this word are capitals, like \n\"USA\"\n.\n\n\nAll letters in this word are not capitals, like \n\"leetcode\"\n.\n\n\nOnly the first letter in this word is capital, like \n\"Google\"\n.\n\n\n\n\nGiven a string \nword\n, return \ntrue\n if the usage of capitals in it is right.\n\n\n \n\n\nExample 1:\n\n\nInput:\n word = \"USA\"\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n word = \"FlaG\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 100\n\n\nword\n consists of lowercase and uppercase English letters.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 507,
        "slug": "perfect-number",
        "url": "https://leetcode.com/problems/perfect-number/",
        "titulo": "Perfect Number",
        "enunciado": "A \nperfect number\n is a \npositive integer\n that is equal to the sum of its \npositive divisors\n, excluding the number itself. A \ndivisor\n of an integer \nx\n is an integer that can divide \nx\n evenly.\n\n\nGiven an integer \nn\n, return \ntrue\n if \nn\n is a perfect number, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 28\n\nOutput:\n true\n\nExplanation:\n 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 7\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 10\n8",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 506,
        "slug": "relative-ranks",
        "url": "https://leetcode.com/problems/relative-ranks/",
        "titulo": "Relative Ranks",
        "enunciado": "You are given an integer array \nscore\n of size \nn\n, where \nscore[i]\n is the score of the \ni\nth\n athlete in a competition. All the scores are guaranteed to be \nunique\n.\n\n\nThe athletes are \nplaced\n based on their scores, where the \n1\nst\n place athlete has the highest score, the \n2\nnd\n place athlete has the \n2\nnd\n highest score, and so on. The placement of each athlete determines their rank:\n\n\n\n\nThe \n1\nst\n place athlete's rank is \n\"Gold Medal\"\n.\n\n\nThe \n2\nnd\n place athlete's rank is \n\"Silver Medal\"\n.\n\n\nThe \n3\nrd\n place athlete's rank is \n\"Bronze Medal\"\n.\n\n\nFor the \n4\nth\n place to the \nn\nth\n place athlete, their rank is their placement number (i.e., the \nx\nth\n place athlete's rank is \n\"x\"\n).\n\n\n\n\nReturn an array \nanswer\n of size \nn\n where \nanswer[i]\n is the \nrank\n of the \ni\nth\n athlete.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n score = [5,4,3,2,1]\n\nOutput:\n [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\n\nExplanation:\n The placements are [1\nst\n, 2\nnd\n, 3\nrd\n, 4\nth\n, 5\nth\n].\n\n\nExample 2:\n\n\n\n\nInput:\n score = [10,3,8,9,4]\n\nOutput:\n [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\n\nExplanation:\n The placements are [1\nst\n, 5\nth\n, 3\nrd\n, 2\nnd\n, 4\nth\n].\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == score.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= score[i] <= 10\n6\n\n\nAll the values in \nscore\n are \nunique\n.",
        "temas": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 504,
        "slug": "base-7",
        "url": "https://leetcode.com/problems/base-7/",
        "titulo": "Base 7",
        "enunciado": "Given an integer \nnum\n, return \na string of its \nbase 7\n representation\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n num = 100\n\nOutput:\n \"202\"\n\nExample 2:\n\n\nInput:\n num = -7\n\nOutput:\n \"-10\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-10\n7\n <= num <= 10\n7",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 501,
        "slug": "find-mode-in-binary-search-tree",
        "url": "https://leetcode.com/problems/find-mode-in-binary-search-tree/",
        "titulo": "Find Mode in Binary Search Tree",
        "enunciado": "Given the \nroot\n of a binary search tree (BST) with duplicates, return \nall the \nmode(s)\n (i.e., the most frequently occurred element) in it\n.\n\n\nIf the tree has more than one mode, return them in \nany order\n.\n\n\nAssume a BST is defined as follows:\n\n\n\n\nThe left subtree of a node contains only nodes with keys \nless than or equal to\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \ngreater than or equal to\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,2,2]\n\nOutput:\n [2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 500,
        "slug": "keyboard-row",
        "url": "https://leetcode.com/problems/keyboard-row/",
        "titulo": "Keyboard Row",
        "enunciado": "Given an array of strings \nwords\n, return \nthe words that can be typed using letters of the alphabet on only one row of American keyboard like the image below\n.\n\n\nNote\n that the strings are \ncase-insensitive\n, both lowercased and uppercased of the same letter are treated as if they are at the same row.\n\n\nIn the \nAmerican keyboard\n:\n\n\n\n\nthe first row consists of the characters \n\"qwertyuiop\"\n,\n\n\nthe second row consists of the characters \n\"asdfghjkl\"\n, and\n\n\nthe third row consists of the characters \n\"zxcvbnm\"\n.\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nwords = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\n\n\nOutput:\n \n[\"Alaska\",\"Dad\"]\n\n\nExplanation:\n\n\nBoth \n\"a\"\n and \n\"A\"\n are in the 2nd row of the American keyboard due to case insensitivity.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nwords = [\"omk\"]\n\n\nOutput:\n \n[]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nwords = [\"adsdf\",\"sfd\"]\n\n\nOutput:\n \n[\"adsdf\",\"sfd\"]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 20\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n consists of English letters (both lowercase and uppercase).",
        "temas": [
            "Array",
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 496,
        "slug": "next-greater-element-i",
        "url": "https://leetcode.com/problems/next-greater-element-i/",
        "titulo": "Next Greater Element I",
        "enunciado": "The \nnext greater element\n of some element \nx\n in an array is the \nfirst greater\n element that is \nto the right\n of \nx\n in the same array.\n\n\nYou are given two \ndistinct 0-indexed\n integer arrays \nnums1\n and \nnums2\n, where \nnums1\n is a subset of \nnums2\n.\n\n\nFor each \n0 <= i < nums1.length\n, find the index \nj\n such that \nnums1[i] == nums2[j]\n and determine the \nnext greater element\n of \nnums2[j]\n in \nnums2\n. If there is no next greater element, then the answer for this query is \n-1\n.\n\n\nReturn \nan array \nans\n of length \nnums1.length\n such that \nans[i]\n is the \nnext greater element\n as described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,2], nums2 = [1,3,4,2]\n\nOutput:\n [-1,3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\n4\n,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\n1\n,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\n2\n]. There is no next greater element, so the answer is -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,4], nums2 = [1,2,3,4]\n\nOutput:\n [3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\n2\n,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\n4\n]. There is no next greater element, so the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length <= nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 10\n4\n\n\nAll integers in \nnums1\n and \nnums2\n are \nunique\n.\n\n\nAll the integers of \nnums1\n also appear in \nnums2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(nums1.length + nums2.length)\n solution?",
        "temas": [
            "Array",
            "Hash Table",
            "Stack",
            "Monotonic Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 495,
        "slug": "teemo-attacking",
        "url": "https://leetcode.com/problems/teemo-attacking/",
        "titulo": "Teemo Attacking",
        "enunciado": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly \nduration\n seconds. More formally, an attack at second \nt\n will mean Ashe is poisoned during the \ninclusive\n time interval \n[t, t + duration - 1]\n. If Teemo attacks again \nbefore\n the poison effect ends, the timer for it is \nreset\n, and the poison effect will end \nduration\n seconds after the new attack.\n\n\nYou are given a \nnon-decreasing\n integer array \ntimeSeries\n, where \ntimeSeries[i]\n denotes that Teemo attacks Ashe at second \ntimeSeries[i]\n, and an integer \nduration\n.\n\n\nReturn \nthe \ntotal\n number of seconds that Ashe is poisoned\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n timeSeries = [1,4], duration = 2\n\nOutput:\n 4\n\nExplanation:\n Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n\n\n\nExample 2:\n\n\n\n\nInput:\n timeSeries = [1,2], duration = 2\n\nOutput:\n 3\n\nExplanation:\n Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= timeSeries.length <= 10\n4\n\n\n0 <= timeSeries[i], duration <= 10\n7\n\n\ntimeSeries\n is sorted in \nnon-decreasing\n order.",
        "temas": [
            "Array",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 492,
        "slug": "construct-the-rectangle",
        "url": "https://leetcode.com/problems/construct-the-rectangle/",
        "titulo": "Construct the Rectangle",
        "enunciado": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n\n\n\nThe area of the rectangular web page you designed must equal to the given target area.\n\n\nThe width \nW\n should not be larger than the length \nL\n, which means \nL >= W\n.\n\n\nThe difference between length \nL\n and width \nW\n should be as small as possible.\n\n\n\n\nReturn \nan array \n[L, W]\n where \nL\n and \nW\n are the length and width of the web page you designed in sequence.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n area = 4\n\nOutput:\n [2,2]\n\nExplanation:\n The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n area = 37\n\nOutput:\n [37,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n area = 122122\n\nOutput:\n [427,286]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= area <= 10\n7",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 485,
        "slug": "max-consecutive-ones",
        "url": "https://leetcode.com/problems/max-consecutive-ones/",
        "titulo": "Max Consecutive Ones",
        "enunciado": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 482,
        "slug": "license-key-formatting",
        "url": "https://leetcode.com/problems/license-key-formatting/",
        "titulo": "License Key Formatting",
        "enunciado": "You are given a license key represented as a string \ns\n that consists of only alphanumeric characters and dashes. The string is separated into \nn + 1\n groups by \nn\n dashes. You are also given an integer \nk\n.\n\n\nWe want to reformat the string \ns\n such that each group contains exactly \nk\n characters, except for the first group, which could be shorter than \nk\n but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\n\nReturn \nthe reformatted license key\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"5F3Z-2e-9-w\", k = 4\n\nOutput:\n \"5F3Z-2E9W\"\n\nExplanation:\n The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"2-5g-3-J\", k = 2\n\nOutput:\n \"2-5G-3J\"\n\nExplanation:\n The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of English letters, digits, and dashes \n'-'\n.\n\n\n1 <= k <= 10\n4",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 476,
        "slug": "number-complement",
        "url": "https://leetcode.com/problems/number-complement/",
        "titulo": "Number Complement",
        "enunciado": "The \ncomplement\n of an integer is the integer you get when you flip all the \n0\n's to \n1\n's and all the \n1\n's to \n0\n's in its binary representation.\n\n\n\n\nFor example, The integer \n5\n is \n\"101\"\n in binary and its \ncomplement\n is \n\"010\"\n which is the integer \n2\n.\n\n\n\n\nGiven an integer \nnum\n, return \nits complement\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 5\n\nOutput:\n 2\n\nExplanation:\n The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 1\n\nOutput:\n 0\n\nExplanation:\n The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num < 2\n31\n\n\n\n\n \n\n\nNote:\n This question is the same as 1009: \nhttps://leetcode.com/problems/complement-of-base-10-integer/",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 463,
        "slug": "island-perimeter",
        "url": "https://leetcode.com/problems/island-perimeter/",
        "titulo": "Island Perimeter",
        "enunciado": "You are given \nrow x col\n \ngrid\n representing a map where \ngrid[i][j] = 1\n represents land and \ngrid[i][j] = 0\n represents water.\n\n\nGrid cells are connected \nhorizontally/vertically\n (not diagonally). The \ngrid\n is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\n\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n\nOutput:\n 16\n\nExplanation:\n The perimeter is the 16 yellow stripes in the image above.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrow == grid.length\n\n\ncol == grid[i].length\n\n\n1 <= row, col <= 100\n\n\ngrid[i][j]\n is \n0\n or \n1\n.\n\n\nThere is exactly one island in \ngrid\n.",
        "temas": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 461,
        "slug": "hamming-distance",
        "url": "https://leetcode.com/problems/hamming-distance/",
        "titulo": "Hamming Distance",
        "enunciado": "The \nHamming distance\n between two integers is the number of positions at which the corresponding bits are different.\n\n\nGiven two integers \nx\n and \ny\n, return \nthe \nHamming distance\n between them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 1, y = 4\n\nOutput:\n 2\n\nExplanation:\n\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\nThe above arrows point to positions where the corresponding bits are different.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 3, y = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= x, y <= 2\n31\n - 1\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 2220: Minimum Bit Flips to Convert Number.",
        "temas": [
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Bit Manipulation"
    },
    {
        "id": 459,
        "slug": "repeated-substring-pattern",
        "url": "https://leetcode.com/problems/repeated-substring-pattern/",
        "titulo": "Repeated Substring Pattern",
        "enunciado": "Given a string \ns\n, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abab\"\n\nOutput:\n true\n\nExplanation:\n It is the substring \"ab\" twice.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aba\"\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"abcabcabcabc\"\n\nOutput:\n true\n\nExplanation:\n It is the substring \"abc\" four times or the substring \"abcabc\" twice.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of lowercase English letters.",
        "temas": [
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 455,
        "slug": "assign-cookies",
        "url": "https://leetcode.com/problems/assign-cookies/",
        "titulo": "Assign Cookies",
        "enunciado": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\n\nEach child \ni\n has a greed factor \ng[i]\n, which is the minimum size of a cookie that the child will be content with; and each cookie \nj\n has a size \ns[j]\n. If \ns[j] >= g[i]\n, we can assign the cookie \nj\n to the child \ni\n, and the child \ni\n will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n g = [1,2,3], s = [1,1]\n\nOutput:\n 1\n\nExplanation:\n You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n g = [1,2], s = [1,2,3]\n\nOutput:\n 2\n\nExplanation:\n You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= g.length <= 3 * 10\n4\n\n\n0 <= s.length <= 3 * 10\n4\n\n\n1 <= g[i], s[j] <= 2\n31\n - 1\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 2410: Maximum Matching of Players With Trainers.",
        "temas": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 448,
        "slug": "find-all-numbers-disappeared-in-an-array",
        "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
        "titulo": "Find All Numbers Disappeared in an Array",
        "enunciado": "Given an array \nnums\n of \nn\n integers where \nnums[i]\n is in the range \n[1, n]\n, return \nan array of all the integers in the range\n \n[1, n]\n \nthat do not appear in\n \nnums\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,3,2,7,8,2,3,1]\n\nOutput:\n [5,6]\n\nExample 2:\n\n\nInput:\n nums = [1,1]\n\nOutput:\n [2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= nums[i] <= n\n\n\n\n\n \n\n\nFollow up:\n Could you do it without extra space and in \nO(n)\n runtime? You may assume the returned list does not count as extra space.",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 441,
        "slug": "arranging-coins",
        "url": "https://leetcode.com/problems/arranging-coins/",
        "titulo": "Arranging Coins",
        "enunciado": "You have \nn\n coins and you want to build a staircase with these coins. The staircase consists of \nk\n rows where the \ni\nth\n row has exactly \ni\n coins. The last row of the staircase \nmay be\n incomplete.\n\n\nGiven the integer \nn\n, return \nthe number of \ncomplete rows\n of the staircase you will build\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 2\n\nExplanation:\n Because the 3\nrd\n row is incomplete, we return 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 8\n\nOutput:\n 3\n\nExplanation:\n Because the 4\nth\n row is incomplete, we return 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
        "temas": [
            "Math",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 434,
        "slug": "number-of-segments-in-a-string",
        "url": "https://leetcode.com/problems/number-of-segments-in-a-string/",
        "titulo": "Number of Segments in a String",
        "enunciado": "Given a string \ns\n, return \nthe number of segments in the string\n.\n\n\nA \nsegment\n is defined to be a contiguous sequence of \nnon-space characters\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"Hello, my name is John\"\n\nOutput:\n 5\n\nExplanation:\n The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"Hello\"\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 300\n\n\ns\n consists of lowercase and uppercase English letters, digits, or one of the following characters \n\"!@#$%^&*()_+-=',.:\"\n.\n\n\nThe only space character in \ns\n is \n' '\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 415,
        "slug": "add-strings",
        "url": "https://leetcode.com/problems/add-strings/",
        "titulo": "Add Strings",
        "enunciado": "Given two non-negative integers, \nnum1\n and \nnum2\n represented as string, return \nthe sum of\n \nnum1\n \nand\n \nnum2\n \nas a string\n.\n\n\nYou must solve the problem without using any built-in library for handling large integers (such as \nBigInteger\n). You must also not convert the inputs to integers directly.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = \"11\", num2 = \"123\"\n\nOutput:\n \"134\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = \"456\", num2 = \"77\"\n\nOutput:\n \"533\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num1 = \"0\", num2 = \"0\"\n\nOutput:\n \"0\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num1.length, num2.length <= 10\n4\n\n\nnum1\n and \nnum2\n consist of only digits.\n\n\nnum1\n and \nnum2\n don't have any leading zeros except for the zero itself.",
        "temas": [
            "Math",
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 414,
        "slug": "third-maximum-number",
        "url": "https://leetcode.com/problems/third-maximum-number/",
        "titulo": "Third Maximum Number",
        "enunciado": "Given an integer array \nnums\n, return \nthe \nthird distinct maximum\n number in this array. If the third maximum does not exist, return the \nmaximum\n number\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n 1\n\nExplanation:\n\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2]\n\nOutput:\n 2\n\nExplanation:\n\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,2,3,1]\n\nOutput:\n 1\n\nExplanation:\n\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Can you find an \nO(n)\n solution?",
        "temas": [
            "Array",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 412,
        "slug": "fizz-buzz",
        "url": "https://leetcode.com/problems/fizz-buzz/",
        "titulo": "Fizz Buzz",
        "enunciado": "Given an integer \nn\n, return \na string array \nanswer\n (\n1-indexed\n) where\n:\n\n\n\n\nanswer[i] == \"FizzBuzz\"\n if \ni\n is divisible by \n3\n and \n5\n.\n\n\nanswer[i] == \"Fizz\"\n if \ni\n is divisible by \n3\n.\n\n\nanswer[i] == \"Buzz\"\n if \ni\n is divisible by \n5\n.\n\n\nanswer[i] == i\n (as a string) if none of the above conditions are true.\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"1\",\"2\",\"Fizz\"]\n\nExample 2:\n\n\nInput:\n n = 5\n\nOutput:\n [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n\nExample 3:\n\n\nInput:\n n = 15\n\nOutput:\n [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
        "temas": [
            "Math",
            "String",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 409,
        "slug": "longest-palindrome",
        "url": "https://leetcode.com/problems/longest-palindrome/",
        "titulo": "Longest Palindrome",
        "enunciado": "Given a string \ns\n which consists of lowercase or uppercase letters, return the length of the \nlongest \npalindrome\n that can be built with those letters.\n\n\nLetters are \ncase sensitive\n, for example, \n\"Aa\"\n is not considered a palindrome.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abccccdd\"\n\nOutput:\n 7\n\nExplanation:\n One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\"\n\nOutput:\n 1\n\nExplanation:\n The longest palindrome that can be built is \"a\", whose length is 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 2000\n\n\ns\n consists of lowercase \nand/or\n uppercase English letters only.",
        "temas": [
            "Hash Table",
            "String",
            "Greedy"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 405,
        "slug": "convert-a-number-to-hexadecimal",
        "url": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/",
        "titulo": "Convert a Number to Hexadecimal",
        "enunciado": "Given a 32-bit integer \nnum\n, return \na string representing its hexadecimal representation\n. For negative integers, \ntwo’s complement\n method is used.\n\n\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\n\n\nNote: \nYou are not allowed to use any built-in library method to directly solve this problem.\n\n\n \n\n\nExample 1:\n\n\nInput:\n num = 26\n\nOutput:\n \"1a\"\n\nExample 2:\n\n\nInput:\n num = -1\n\nOutput:\n \"ffffffff\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= num <= 2\n31\n - 1",
        "temas": [
            "Math",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 404,
        "slug": "sum-of-left-leaves",
        "url": "https://leetcode.com/problems/sum-of-left-leaves/",
        "titulo": "Sum of Left Leaves",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe sum of all left leaves.\n\n\nA \nleaf\n is a node with no children. A \nleft leaf\n is a leaf that is the left child of another node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n 24\n\nExplanation:\n There are two left leaves in the binary tree, with values 9 and 15 respectively.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n-1000 <= Node.val <= 1000",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 401,
        "slug": "binary-watch",
        "url": "https://leetcode.com/problems/binary-watch/",
        "titulo": "Binary Watch",
        "enunciado": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n\n\n\nFor example, the below binary watch reads \n\"4:51\"\n.\n\n\n\n\n\n\nGiven an integer \nturnedOn\n which represents the number of LEDs that are currently on (ignoring the PM), return \nall possible times the watch could represent\n. You may return the answer in \nany order\n.\n\n\nThe hour must not contain a leading zero.\n\n\n\n\nFor example, \n\"01:00\"\n is not valid. It should be \n\"1:00\"\n.\n\n\n\n\nThe minute must consist of two digits and may contain a leading zero.\n\n\n\n\nFor example, \n\"10:2\"\n is not valid. It should be \n\"10:02\"\n.\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n turnedOn = 1\n\nOutput:\n [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n\nExample 2:\n\n\nInput:\n turnedOn = 9\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= turnedOn <= 10",
        "temas": [
            "Backtracking",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Backtracking"
    },
    {
        "id": 392,
        "slug": "is-subsequence",
        "url": "https://leetcode.com/problems/is-subsequence/",
        "titulo": "Is Subsequence",
        "enunciado": "Given two strings \ns\n and \nt\n, return \ntrue\n if \ns\n is a \nsubsequence\n of \nt\n, or \nfalse\n otherwise\n.\n\n\nA \nsubsequence\n of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \n\"ace\"\n is a subsequence of \n\"\na\nb\nc\nd\ne\n\"\n while \n\"aec\"\n is not).\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"abc\", t = \"ahbgdc\"\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n s = \"axc\", t = \"ahbgdc\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 100\n\n\n0 <= t.length <= 10\n4\n\n\ns\n and \nt\n consist only of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Suppose there are lots of incoming \ns\n, say \ns\n1\n, s\n2\n, ..., s\nk\n where \nk >= 10\n9\n, and you want to check one by one to see if \nt\n has its subsequence. In this scenario, how would you change your code?",
        "temas": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 389,
        "slug": "find-the-difference",
        "url": "https://leetcode.com/problems/find-the-difference/",
        "titulo": "Find the Difference",
        "enunciado": "You are given two strings \ns\n and \nt\n.\n\n\nString \nt\n is generated by random shuffling string \ns\n and then add one more letter at a random position.\n\n\nReturn the letter that was added to \nt\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcd\", t = \"abcde\"\n\nOutput:\n \"e\"\n\nExplanation:\n 'e' is the letter that was added.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"\", t = \"y\"\n\nOutput:\n \"y\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 1000\n\n\nt.length == s.length + 1\n\n\ns\n and \nt\n consist of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 387,
        "slug": "first-unique-character-in-a-string",
        "url": "https://leetcode.com/problems/first-unique-character-in-a-string/",
        "titulo": "First Unique Character in a String",
        "enunciado": "Given a string \ns\n, find the \nfirst\n non-repeating character in it and return its index. If it \ndoes not\n exist, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"leetcode\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe character \n'l'\n at index 0 is the first character that does not occur at any other index.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"loveleetcode\"\n\n\nOutput:\n \n2\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"aabb\"\n\n\nOutput:\n \n-1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of only lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Queue",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 383,
        "slug": "ransom-note",
        "url": "https://leetcode.com/problems/ransom-note/",
        "titulo": "Ransom Note",
        "enunciado": "Given two strings \nransomNote\n and \nmagazine\n, return \ntrue\n if \nransomNote\n can be constructed by using the letters from \nmagazine\n and \nfalse\n otherwise\n.\n\n\nEach letter in \nmagazine\n can only be used once in \nransomNote\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n ransomNote = \"a\", magazine = \"b\"\n\nOutput:\n false\n\nExample 2:\n\n\nInput:\n ransomNote = \"aa\", magazine = \"ab\"\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n ransomNote = \"aa\", magazine = \"aab\"\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= ransomNote.length, magazine.length <= 10\n5\n\n\nransomNote\n and \nmagazine\n consist of lowercase English letters.",
        "temas": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 374,
        "slug": "guess-number-higher-or-lower",
        "url": "https://leetcode.com/problems/guess-number-higher-or-lower/",
        "titulo": "Guess Number Higher or Lower",
        "enunciado": "We are playing the Guess Game. The game is as follows:\n\n\nI pick a number from \n1\n to \nn\n. You have to guess which number I picked.\n\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\n\nYou call a pre-defined API \nint guess(int num)\n, which returns three possible results:\n\n\n\n\n-1\n: Your guess is higher than the number I picked (i.e. \nnum > pick\n).\n\n\n1\n: Your guess is lower than the number I picked (i.e. \nnum < pick\n).\n\n\n0\n: your guess is equal to the number I picked (i.e. \nnum == pick\n).\n\n\n\n\nReturn \nthe number that I picked\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 10, pick = 6\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, pick = 1\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2, pick = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1\n\n\n1 <= pick <= n",
        "temas": [
            "Binary Search",
            "Interactive"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Binary Search"
    },
    {
        "id": 367,
        "slug": "valid-perfect-square",
        "url": "https://leetcode.com/problems/valid-perfect-square/",
        "titulo": "Valid Perfect Square",
        "enunciado": "Given a positive integer num, return \ntrue\n \nif\n \nnum\n \nis a perfect square or\n \nfalse\n \notherwise\n.\n\n\nA \nperfect square\n is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\n\nYou must not use any built-in library function, such as \nsqrt\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 16\n\nOutput:\n true\n\nExplanation:\n We return true because 4 * 4 = 16 and 4 is an integer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 14\n\nOutput:\n false\n\nExplanation:\n We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 2\n31\n - 1",
        "temas": [
            "Math",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 350,
        "slug": "intersection-of-two-arrays-ii",
        "url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/",
        "titulo": "Intersection of Two Arrays II",
        "enunciado": "Given two integer arrays \nnums1\n and \nnums2\n, return \nan array of their intersection\n. Each element in the result must appear as many times as it shows in both arrays and you may return the result in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,2,1], nums2 = [2,2]\n\nOutput:\n [2,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\nOutput:\n [4,9]\n\nExplanation:\n [9,4] is also accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 1000\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nWhat if the given array is already sorted? How would you optimize your algorithm?\n\n\nWhat if \nnums1\n's size is small compared to \nnums2\n's size? Which algorithm is better?\n\n\nWhat if elements of \nnums2\n are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 349,
        "slug": "intersection-of-two-arrays",
        "url": "https://leetcode.com/problems/intersection-of-two-arrays/",
        "titulo": "Intersection of Two Arrays",
        "enunciado": "Given two integer arrays \nnums1\n and \nnums2\n, return \nan array of their \nintersection\n. Each element in the result must be \nunique\n and you may return the result in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,2,1], nums2 = [2,2]\n\nOutput:\n [2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\nOutput:\n [9,4]\n\nExplanation:\n [4,9] is also accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 1000",
        "temas": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 345,
        "slug": "reverse-vowels-of-a-string",
        "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/",
        "titulo": "Reverse Vowels of a String",
        "enunciado": "Given a string \ns\n, reverse only all the vowels in the string and return it.\n\n\nThe vowels are \n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, and \n'u'\n, and they can appear in both lower and upper cases, more than once.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"IceCreAm\"\n\n\nOutput:\n \n\"AceCreIm\"\n\n\nExplanation:\n\n\nThe vowels in \ns\n are \n['I', 'e', 'e', 'A']\n. On reversing the vowels, s becomes \n\"AceCreIm\"\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"leetcode\"\n\n\nOutput:\n \n\"leotcede\"\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consist of \nprintable ASCII\n characters.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 344,
        "slug": "reverse-string",
        "url": "https://leetcode.com/problems/reverse-string/",
        "titulo": "Reverse String",
        "enunciado": "Write a function that reverses a string. The input string is given as an array of characters \ns\n.\n\n\nYou must do this by modifying the input array \nin-place\n with \nO(1)\n extra memory.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n\nOutput:\n [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nExample 2:\n\n\nInput:\n s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n\nOutput:\n [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns[i]\n is a \nprintable ascii character\n.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 342,
        "slug": "power-of-four",
        "url": "https://leetcode.com/problems/power-of-four/",
        "titulo": "Power of Four",
        "enunciado": "Given an integer \nn\n, return \ntrue\n if it is a power of four. Otherwise, return \nfalse\n.\n\n\nAn integer \nn\n is a power of four, if there exists an integer \nx\n such that \nn == 4\nx\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 16\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n n = 5\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n n = 1\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without loops/recursion?",
        "temas": [
            "Math",
            "Bit Manipulation",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 338,
        "slug": "counting-bits",
        "url": "https://leetcode.com/problems/counting-bits/",
        "titulo": "Counting Bits",
        "enunciado": "Given an integer \nn\n, return \nan array \nans\n of length \nn + 1\n such that for each \ni\n \n(\n0 <= i <= n\n)\n, \nans[i]\n is the \nnumber of \n1\n's\n in the binary representation of \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n [0,1,1]\n\nExplanation:\n\n0 --> 0\n1 --> 1\n2 --> 10\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n [0,1,1,2,1,2]\n\nExplanation:\n\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nIt is very easy to come up with a solution with a runtime of \nO(n log n)\n. Can you do it in linear time \nO(n)\n and possibly in a single pass?\n\n\nCan you do it without using any built-in function (i.e., like \n__builtin_popcount\n in C++)?",
        "temas": [
            "Dynamic Programming",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Dynamic Programming"
    },
    {
        "id": 326,
        "slug": "power-of-three",
        "url": "https://leetcode.com/problems/power-of-three/",
        "titulo": "Power of Three",
        "enunciado": "Given an integer \nn\n, return \ntrue\n if it is a power of three. Otherwise, return \nfalse\n.\n\n\nAn integer \nn\n is a power of three, if there exists an integer \nx\n such that \nn == 3\nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 27\n\nOutput:\n true\n\nExplanation:\n 27 = 3\n3\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 0\n\nOutput:\n false\n\nExplanation:\n There is no x where 3\nx\n = 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = -1\n\nOutput:\n false\n\nExplanation:\n There is no x where 3\nx\n = (-1).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without loops/recursion?",
        "temas": [
            "Math",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 303,
        "slug": "range-sum-query-immutable",
        "url": "https://leetcode.com/problems/range-sum-query-immutable/",
        "titulo": "Range Sum Query - Immutable",
        "enunciado": "Given an integer array \nnums\n, handle multiple queries of the following type:\n\n\n\n\nCalculate the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n where \nleft <= right\n.\n\n\n\n\nImplement the \nNumArray\n class:\n\n\n\n\nNumArray(int[] nums)\n Initializes the object with the integer array \nnums\n.\n\n\nint sumRange(int left, int right)\n Returns the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n (i.e. \nnums[left] + nums[left + 1] + ... + nums[right]\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n\nOutput\n\n[null, 1, -1, -3]\n\n\nExplanation\n\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n5\n <= nums[i] <= 10\n5\n\n\n0 <= left <= right < nums.length\n\n\nAt most \n10\n4\n calls will be made to \nsumRange\n.",
        "temas": [
            "Array",
            "Design",
            "Prefix Sum"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 292,
        "slug": "nim-game",
        "url": "https://leetcode.com/problems/nim-game/",
        "titulo": "Nim Game",
        "enunciado": "You are playing the following Nim Game with your friend:\n\n\n\n\nInitially, there is a heap of stones on the table.\n\n\nYou and your friend will alternate taking turns, and \nyou go first\n.\n\n\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n\n\nThe one who removes the last stone is the winner.\n\n\n\n\nGiven \nn\n, the number of stones in the heap, return \ntrue\n if you can win the game assuming both you and your friend play optimally, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n false\n\nExplanation:\n These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
        "temas": [
            "Math",
            "Brainteaser",
            "Game Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 290,
        "slug": "word-pattern",
        "url": "https://leetcode.com/problems/word-pattern/",
        "titulo": "Word Pattern",
        "enunciado": "Given a \npattern\n and a string \ns\n, find if \ns\n follows the same pattern.\n\n\nHere \nfollow\n means a full match, such that there is a bijection between a letter in \npattern\n and a \nnon-empty\n word in \ns\n. Specifically:\n\n\n\n\nEach letter in \npattern\n maps to \nexactly\n one unique word in \ns\n.\n\n\nEach unique word in \ns\n maps to \nexactly\n one letter in \npattern\n.\n\n\nNo two letters map to the same word, and no two words map to the same letter.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \npattern = \"abba\", s = \"dog cat cat dog\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe bijection can be established as:\n\n\n\n\n'a'\n maps to \n\"dog\"\n.\n\n\n'b'\n maps to \n\"cat\"\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \npattern = \"abba\", s = \"dog cat cat fish\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npattern = \"aaaa\", s = \"dog cat cat dog\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= pattern.length <= 300\n\n\npattern\n contains only lower-case English letters.\n\n\n1 <= s.length <= 3000\n\n\ns\n contains only lowercase English letters and spaces \n' '\n.\n\n\ns\n \ndoes not contain\n any leading or trailing spaces.\n\n\nAll the words in \ns\n are separated by a \nsingle space\n.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 283,
        "slug": "move-zeroes",
        "url": "https://leetcode.com/problems/move-zeroes/",
        "titulo": "Move Zeroes",
        "enunciado": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 278,
        "slug": "first-bad-version",
        "url": "https://leetcode.com/problems/first-bad-version/",
        "titulo": "First Bad Version",
        "enunciado": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\n\nSuppose you have \nn\n versions \n[1, 2, ..., n]\n and you want to find out the first bad one, which causes all the following ones to be bad.\n\n\nYou are given an API \nbool isBadVersion(version)\n which returns whether \nversion\n is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5, bad = 4\n\nOutput:\n 4\n\nExplanation:\n\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, bad = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= bad <= n <= 2\n31\n - 1",
        "temas": [
            "Binary Search",
            "Interactive"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Binary Search"
    },
    {
        "id": 268,
        "slug": "missing-number",
        "url": "https://leetcode.com/problems/missing-number/",
        "titulo": "Missing Number",
        "enunciado": "Given an array \nnums\n containing \nn\n distinct numbers in the range \n[0, n]\n, return \nthe only number in the range that is missing from the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [3,0,1]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nn = 3\n since there are 3 numbers, so all numbers are in the range \n[0,3]\n. 2 is the missing number in the range since it does not appear in \nnums\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [0,1]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nn = 2\n since there are 2 numbers, so all numbers are in the range \n[0,2]\n. 2 is the missing number in the range since it does not appear in \nnums\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [9,6,4,2,3,5,7,0,1]\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\nn = 9\n since there are 9 numbers, so all numbers are in the range \n[0,9]\n. 8 is the missing number in the range since it does not appear in \nnums\n.\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n \n\n\n\n\n \n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= nums[i] <= n\n\n\nAll the numbers of \nnums\n are \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Could you implement a solution using only \nO(1)\n extra space complexity and \nO(n)\n runtime complexity?",
        "temas": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Bit Manipulation",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 263,
        "slug": "ugly-number",
        "url": "https://leetcode.com/problems/ugly-number/",
        "titulo": "Ugly Number",
        "enunciado": "An \nugly number\n is a \npositive\n integer which does not have a prime factor other than 2, 3, and 5.\n\n\nGiven an integer \nn\n, return \ntrue\n \nif\n \nn\n \nis an \nugly number\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 6\n\nOutput:\n true\n\nExplanation:\n 6 = 2 × 3\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n true\n\nExplanation:\n 1 has no prime factors.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 14\n\nOutput:\n false\n\nExplanation:\n 14 is not ugly since it includes the prime factor 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= n <= 2\n31\n - 1",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 258,
        "slug": "add-digits",
        "url": "https://leetcode.com/problems/add-digits/",
        "titulo": "Add Digits",
        "enunciado": "Given an integer \nnum\n, repeatedly add all its digits until the result has only one digit, and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 38\n\nOutput:\n 2\n\nExplanation:\n The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you do it without any loop/recursion in \nO(1)\n runtime?",
        "temas": [
            "Math",
            "Simulation",
            "Number Theory"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 257,
        "slug": "binary-tree-paths",
        "url": "https://leetcode.com/problems/binary-tree-paths/",
        "titulo": "Binary Tree Paths",
        "enunciado": "Given the \nroot\n of a binary tree, return \nall root-to-leaf paths in \nany order\n.\n\n\nA \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,5]\n\nOutput:\n [\"1->2->5\",\"1->3\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [\"1\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n-100 <= Node.val <= 100",
        "temas": [
            "String",
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 242,
        "slug": "valid-anagram",
        "url": "https://leetcode.com/problems/valid-anagram/",
        "titulo": "Valid Anagram",
        "enunciado": "Given two strings \ns\n and \nt\n, return \ntrue\n if \nt\n is an \nanagram\n of \ns\n, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"anagram\", t = \"nagaram\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"rat\", t = \"car\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, t.length <= 5 * 10\n4\n\n\ns\n and \nt\n consist of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "temas": [
            "Hash Table",
            "String",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 234,
        "slug": "palindrome-linked-list",
        "url": "https://leetcode.com/problems/palindrome-linked-list/",
        "titulo": "Palindrome Linked List",
        "enunciado": "Given the \nhead\n of a singly linked list, return \ntrue\n if it is a \npalindrome\n or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,2,1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 9\n\n\n\n\n \n\n\nFollow up:\n Could you do it in \nO(n)\n time and \nO(1)\n space?",
        "temas": [
            "Linked List",
            "Two Pointers",
            "Stack",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 232,
        "slug": "implement-queue-using-stacks",
        "url": "https://leetcode.com/problems/implement-queue-using-stacks/",
        "titulo": "Implement Queue using Stacks",
        "enunciado": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (\npush\n, \npeek\n, \npop\n, and \nempty\n).\n\n\nImplement the \nMyQueue\n class:\n\n\n\n\nvoid push(int x)\n Pushes element x to the back of the queue.\n\n\nint pop()\n Removes the element from the front of the queue and returns it.\n\n\nint peek()\n Returns the element at the front of the queue.\n\n\nboolean empty()\n Returns \ntrue\n if the queue is empty, \nfalse\n otherwise.\n\n\n\n\nNotes:\n\n\n\n\nYou must use \nonly\n standard operations of a stack, which means only \npush to top\n, \npeek/pop from top\n, \nsize\n, and \nis empty\n operations are valid.\n\n\nDepending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n\nOutput\n\n[null, null, null, 1, 1, false]\n\n\nExplanation\n\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= x <= 9\n\n\nAt most \n100\n calls will be made to \npush\n, \npop\n, \npeek\n, and \nempty\n.\n\n\nAll the calls to \npop\n and \npeek\n are valid.\n\n\n\n\n \n\n\nFollow-up:\n Can you implement the queue such that each operation is \namortized\n \nO(1)\n time complexity? In other words, performing \nn\n operations will take overall \nO(n)\n time even if one of those operations may take longer.",
        "temas": [
            "Stack",
            "Design",
            "Queue"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 231,
        "slug": "power-of-two",
        "url": "https://leetcode.com/problems/power-of-two/",
        "titulo": "Power of Two",
        "enunciado": "Given an integer \nn\n, return \ntrue\n if it is a power of two. Otherwise, return \nfalse\n.\n\n\nAn integer \nn\n is a power of two, if there exists an integer \nx\n such that \nn == 2\nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n true\n\nExplanation: \n2\n0\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 16\n\nOutput:\n true\n\nExplanation: \n2\n4\n = 16\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without loops/recursion?",
        "temas": [
            "Math",
            "Bit Manipulation",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 228,
        "slug": "summary-ranges",
        "url": "https://leetcode.com/problems/summary-ranges/",
        "titulo": "Summary Ranges",
        "enunciado": "You are given a \nsorted unique\n integer array \nnums\n.\n\n\nA \nrange\n \n[a,b]\n is the set of all integers from \na\n to \nb\n (inclusive).\n\n\nReturn \nthe \nsmallest sorted\n list of ranges that \ncover all the numbers in the array exactly\n. That is, each element of \nnums\n is covered by exactly one of the ranges, and there is no integer \nx\n such that \nx\n is in one of the ranges but not in \nnums\n.\n\n\nEach range \n[a,b]\n in the list should be output as:\n\n\n\n\n\"a->b\"\n if \na != b\n\n\n\"a\"\n if \na == b\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1,2,4,5,7]\n\nOutput:\n [\"0->2\",\"4->5\",\"7\"]\n\nExplanation:\n The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,2,3,4,6,8,9]\n\nOutput:\n [\"0\",\"2->4\",\"6\",\"8->9\"]\n\nExplanation:\n The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 20\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nAll the values of \nnums\n are \nunique\n.\n\n\nnums\n is sorted in ascending order.",
        "temas": [
            "Array"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 226,
        "slug": "invert-binary-tree",
        "url": "https://leetcode.com/problems/invert-binary-tree/",
        "titulo": "Invert Binary Tree",
        "enunciado": "Given the \nroot\n of a binary tree, invert the tree, and return \nits root\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3,6,9]\n\nOutput:\n [4,7,2,9,6,3,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n [2,3,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 225,
        "slug": "implement-stack-using-queues",
        "url": "https://leetcode.com/problems/implement-stack-using-queues/",
        "titulo": "Implement Stack using Queues",
        "enunciado": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (\npush\n, \ntop\n, \npop\n, and \nempty\n).\n\n\nImplement the \nMyStack\n class:\n\n\n\n\nvoid push(int x)\n Pushes element x to the top of the stack.\n\n\nint pop()\n Removes the element on the top of the stack and returns it.\n\n\nint top()\n Returns the element on the top of the stack.\n\n\nboolean empty()\n Returns \ntrue\n if the stack is empty, \nfalse\n otherwise.\n\n\n\n\nNotes:\n\n\n\n\nYou must use \nonly\n standard operations of a queue, which means that only \npush to back\n, \npeek/pop from front\n, \nsize\n and \nis empty\n operations are valid.\n\n\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n\nOutput\n\n[null, null, null, 2, 2, false]\n\n\nExplanation\n\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= x <= 9\n\n\nAt most \n100\n calls will be made to \npush\n, \npop\n, \ntop\n, and \nempty\n.\n\n\nAll the calls to \npop\n and \ntop\n are valid.\n\n\n\n\n \n\n\nFollow-up:\n Can you implement the stack using only one queue?",
        "temas": [
            "Stack",
            "Design",
            "Queue"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 222,
        "slug": "count-complete-tree-nodes",
        "url": "https://leetcode.com/problems/count-complete-tree-nodes/",
        "titulo": "Count Complete Tree Nodes",
        "enunciado": "Given the \nroot\n of a \ncomplete\n binary tree, return the number of the nodes in the tree.\n\n\nAccording to \nWikipedia\n, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between \n1\n and \n2\nh\n nodes inclusive at the last level \nh\n.\n\n\nDesign an algorithm that runs in less than \nO(n)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6]\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5 * 10\n4\n]\n.\n\n\n0 <= Node.val <= 5 * 10\n4\n\n\nThe tree is guaranteed to be \ncomplete\n.",
        "temas": [
            "Binary Search",
            "Bit Manipulation",
            "Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Binary Search"
    },
    {
        "id": 219,
        "slug": "contains-duplicate-ii",
        "url": "https://leetcode.com/problems/contains-duplicate-ii/",
        "titulo": "Contains Duplicate II",
        "enunciado": "Given an integer array \nnums\n and an integer \nk\n, return \ntrue\n \nif there are two \ndistinct indices\n \ni\n and \nj\n in the array such that \nnums[i] == nums[j]\n and \nabs(i - j) <= k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1], k = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1], k = 1\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,1,2,3], k = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n0 <= k <= 10\n5",
        "temas": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 217,
        "slug": "contains-duplicate",
        "url": "https://leetcode.com/problems/contains-duplicate/",
        "titulo": "Contains Duplicate",
        "enunciado": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
        "temas": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 206,
        "slug": "reverse-linked-list",
        "url": "https://leetcode.com/problems/reverse-linked-list/",
        "titulo": "Reverse Linked List",
        "enunciado": "Given the \nhead\n of a singly linked list, reverse the list, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [5,4,3,2,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n [2,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is the range \n[0, 5000]\n.\n\n\n-5000 <= Node.val <= 5000\n\n\n\n\n \n\n\nFollow up:\n A linked list can be reversed either iteratively or recursively. Could you implement both?",
        "temas": [
            "Linked List",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 205,
        "slug": "isomorphic-strings",
        "url": "https://leetcode.com/problems/isomorphic-strings/",
        "titulo": "Isomorphic Strings",
        "enunciado": "Given two strings \ns\n and \nt\n, \ndetermine if they are isomorphic\n.\n\n\nTwo strings \ns\n and \nt\n are isomorphic if the characters in \ns\n can be replaced to get \nt\n.\n\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"egg\", t = \"add\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe strings \ns\n and \nt\n can be made identical by:\n\n\n\n\nMapping \n'e'\n to \n'a'\n.\n\n\nMapping \n'g'\n to \n'd'\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"foo\", t = \"bar\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nThe strings \ns\n and \nt\n can not be made identical as \n'o'\n needs to be mapped to both \n'a'\n and \n'r'\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"paper\", t = \"title\"\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 5 * 10\n4\n\n\nt.length == s.length\n\n\ns\n and \nt\n consist of any valid ascii character.",
        "temas": [
            "Hash Table",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 203,
        "slug": "remove-linked-list-elements",
        "url": "https://leetcode.com/problems/remove-linked-list-elements/",
        "titulo": "Remove Linked List Elements",
        "enunciado": "Given the \nhead\n of a linked list and an integer \nval\n, remove all the nodes of the linked list that has \nNode.val == val\n, and return \nthe new head\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,6,3,4,5,6], val = 6\n\nOutput:\n [1,2,3,4,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [], val = 1\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [7,7,7,7], val = 7\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 10\n4\n]\n.\n\n\n1 <= Node.val <= 50\n\n\n0 <= val <= 50",
        "temas": [
            "Linked List",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 202,
        "slug": "happy-number",
        "url": "https://leetcode.com/problems/happy-number/",
        "titulo": "Happy Number",
        "enunciado": "Write an algorithm to determine if a number \nn\n is happy.\n\n\nA \nhappy number\n is a number defined by the following process:\n\n\n\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\n\nRepeat the process until the number equals 1 (where it will stay), or it \nloops endlessly in a cycle\n which does not include 1.\n\n\nThose numbers for which this process \nends in 1\n are happy.\n\n\n\n\nReturn \ntrue\n \nif\n \nn\n \nis a happy number, and\n \nfalse\n \nif not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 19\n\nOutput:\n true\n\nExplanation:\n\n1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
        "temas": [
            "Hash Table",
            "Math",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 191,
        "slug": "number-of-1-bits",
        "url": "https://leetcode.com/problems/number-of-1-bits/",
        "titulo": "Number of 1 Bits",
        "enunciado": "Given a positive integer \nn\n, write a function that returns the number of \nset bits\n in its binary representation (also known as the \nHamming weight\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 11\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe input binary string \n1011\n has a total of three set bits.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 128\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe input binary string \n10000000\n has a total of one set bit.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 2147483645\n\n\nOutput:\n \n30\n\n\nExplanation:\n\n\nThe input binary string \n1111111111111111111111111111101\n has a total of thirty set bits.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n If this function is called many times, how would you optimize it?",
        "temas": [
            "Divide and Conquer",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Divide and Conquer"
    },
    {
        "id": 190,
        "slug": "reverse-bits",
        "url": "https://leetcode.com/problems/reverse-bits/",
        "titulo": "Reverse Bits",
        "enunciado": "Reverse bits of a given 32 bits unsigned integer.\n\n\nNote:\n\n\n\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n\n\nIn Java, the compiler represents the signed integers using \n2's complement notation\n. Therefore, in \nExample 2\n above, the input represents the signed integer \n-3\n and the output represents the signed integer \n-1073741825\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 00000010100101000001111010011100\n\nOutput:\n    964176192 (00111001011110000010100101000000)\n\nExplanation: \nThe input binary string \n00000010100101000001111010011100\n represents the unsigned integer 43261596, so return 964176192 which its binary representation is \n00111001011110000010100101000000\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 11111111111111111111111111111101\n\nOutput:\n   3221225471 (10111111111111111111111111111111)\n\nExplanation: \nThe input binary string \n11111111111111111111111111111101\n represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is \n10111111111111111111111111111111\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe input must be a \nbinary string\n of length \n32\n\n\n\n\n \n\n\nFollow up:\n If this function is called many times, how would you optimize it?",
        "temas": [
            "Divide and Conquer",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Divide and Conquer"
    },
    {
        "id": 171,
        "slug": "excel-sheet-column-number",
        "url": "https://leetcode.com/problems/excel-sheet-column-number/",
        "titulo": "Excel Sheet Column Number",
        "enunciado": "Given a string \ncolumnTitle\n that represents the column title as appears in an Excel sheet, return \nits corresponding column number\n.\n\n\nFor example:\n\n\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n columnTitle = \"A\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n columnTitle = \"AB\"\n\nOutput:\n 28\n\n\n\nExample 3:\n\n\n\n\nInput:\n columnTitle = \"ZY\"\n\nOutput:\n 701\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= columnTitle.length <= 7\n\n\ncolumnTitle\n consists only of uppercase English letters.\n\n\ncolumnTitle\n is in the range \n[\"A\", \"FXSHRXW\"]\n.",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 169,
        "slug": "majority-element",
        "url": "https://leetcode.com/problems/majority-element/",
        "titulo": "Majority Element",
        "enunciado": "Given an array \nnums\n of size \nn\n, return \nthe majority element\n.\n\n\nThe majority element is the element that appears more than \n⌊n / 2⌋\n times. You may assume that the majority element always exists in the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,2,1,1,1,2,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n\n\n \n\n\nFollow-up:\n Could you solve the problem in linear time and in \nO(1)\n space?",
        "temas": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Counting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 168,
        "slug": "excel-sheet-column-title",
        "url": "https://leetcode.com/problems/excel-sheet-column-title/",
        "titulo": "Excel Sheet Column Title",
        "enunciado": "Given an integer \ncolumnNumber\n, return \nits corresponding column title as it appears in an Excel sheet\n.\n\n\nFor example:\n\n\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n columnNumber = 1\n\nOutput:\n \"A\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n columnNumber = 28\n\nOutput:\n \"AB\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n columnNumber = 701\n\nOutput:\n \"ZY\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= columnNumber <= 2\n31\n - 1",
        "temas": [
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 160,
        "slug": "intersection-of-two-linked-lists",
        "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/",
        "titulo": "Intersection of Two Linked Lists",
        "enunciado": "Given the heads of two singly linked-lists \nheadA\n and \nheadB\n, return \nthe node at which the two lists intersect\n. If the two linked lists have no intersection at all, return \nnull\n.\n\n\nFor example, the following two linked lists begin to intersect at node \nc1\n:\n\n\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n\nNote\n that the linked lists must \nretain their original structure\n after the function returns.\n\n\nCustom Judge:\n\n\nThe inputs to the \njudge\n are given as follows (your program is \nnot\n given these inputs):\n\n\n\n\nintersectVal\n - The value of the node where the intersection occurs. This is \n0\n if there is no intersected node.\n\n\nlistA\n - The first linked list.\n\n\nlistB\n - The second linked list.\n\n\nskipA\n - The number of nodes to skip ahead in \nlistA\n (starting from the head) to get to the intersected node.\n\n\nskipB\n - The number of nodes to skip ahead in \nlistB\n (starting from the head) to get to the intersected node.\n\n\n\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, \nheadA\n and \nheadB\n to your program. If you correctly return the intersected node, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\nOutput:\n Intersected at '8'\n\nExplanation:\n The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2\nnd\n node in A and 3\nrd\n node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3\nrd\n node in A and 4\nth\n node in B) point to the same location in memory.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\nOutput:\n Intersected at '2'\n\nExplanation:\n The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\nOutput:\n No intersection\n\nExplanation:\n From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes of \nlistA\n is in the \nm\n.\n\n\nThe number of nodes of \nlistB\n is in the \nn\n.\n\n\n1 <= m, n <= 3 * 10\n4\n\n\n1 <= Node.val <= 10\n5\n\n\n0 <= skipA <= m\n\n\n0 <= skipB <= n\n\n\nintersectVal\n is \n0\n if \nlistA\n and \nlistB\n do not intersect.\n\n\nintersectVal == listA[skipA] == listB[skipB]\n if \nlistA\n and \nlistB\n intersect.\n\n\n\n\n \n\n\nFollow up:\n Could you write a solution that runs in \nO(m + n)\n time and use only \nO(1)\n memory?",
        "temas": [
            "Hash Table",
            "Linked List",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 145,
        "slug": "binary-tree-postorder-traversal",
        "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
        "titulo": "Binary Tree Postorder Traversal",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe postorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[3,2,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[4,6,7,5,2,9,8,3,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
        "temas": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 144,
        "slug": "binary-tree-preorder-traversal",
        "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
        "titulo": "Binary Tree Preorder Traversal",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe preorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[1,2,3]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[1,2,4,5,6,7,3,8,9]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
        "temas": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 141,
        "slug": "linked-list-cycle",
        "url": "https://leetcode.com/problems/linked-list-cycle/",
        "titulo": "Linked List Cycle",
        "enunciado": "Given \nhead\n, the head of a linked list, determine if the linked list has a cycle in it.\n\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the \nnext\n pointer. Internally, \npos\n is used to denote the index of the node that tail's \nnext\n pointer is connected to. \nNote that \npos\n is not passed as a parameter\n.\n\n\nReturn \ntrue\n if there is a cycle in the linked list\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [3,2,0,-4], pos = 1\n\nOutput:\n true\n\nExplanation:\n There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2], pos = 0\n\nOutput:\n true\n\nExplanation:\n There is a cycle in the linked list, where the tail connects to the 0th node.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1], pos = -1\n\nOutput:\n false\n\nExplanation:\n There is no cycle in the linked list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the list is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\npos\n is \n-1\n or a \nvalid index\n in the linked-list.\n\n\n\n\n \n\n\nFollow up:\n Can you solve it using \nO(1)\n (i.e. constant) memory?",
        "temas": [
            "Hash Table",
            "Linked List",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 136,
        "slug": "single-number",
        "url": "https://leetcode.com/problems/single-number/",
        "titulo": "Single Number",
        "enunciado": "Given a \nnon-empty\n array of integers \nnums\n, every element appears \ntwice\n except for one. Find that single one.\n\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,2,1]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,2,1,2]\n\n\nOutput:\n \n4\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4\n\n\nEach element in the array appears twice except for one element which appears only once.",
        "temas": [
            "Array",
            "Bit Manipulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 125,
        "slug": "valid-palindrome",
        "url": "https://leetcode.com/problems/valid-palindrome/",
        "titulo": "Valid Palindrome",
        "enunciado": "A phrase is a \npalindrome\n if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\n\nGiven a string \ns\n, return \ntrue\n if it is a \npalindrome\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"A man, a plan, a canal: Panama\"\n\nOutput:\n true\n\nExplanation:\n \"amanaplanacanalpanama\" is a palindrome.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"race a car\"\n\nOutput:\n false\n\nExplanation:\n \"raceacar\" is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \" \"\n\nOutput:\n true\n\nExplanation:\n s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 2 * 10\n5\n\n\ns\n consists only of printable ASCII characters.",
        "temas": [
            "Two Pointers",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 121,
        "slug": "best-time-to-buy-and-sell-stock",
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
        "titulo": "Best Time to Buy and Sell Stock",
        "enunciado": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
        "temas": [
            "Array",
            "Dynamic Programming"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 119,
        "slug": "pascals-triangle-ii",
        "url": "https://leetcode.com/problems/pascals-triangle-ii/",
        "titulo": "Pascal's Triangle II",
        "enunciado": "Given an integer \nrowIndex\n, return the \nrowIndex\nth\n (\n0-indexed\n) row of the \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n rowIndex = 3\n\nOutput:\n [1,3,3,1]\n\nExample 2:\n\n\nInput:\n rowIndex = 0\n\nOutput:\n [1]\n\nExample 3:\n\n\nInput:\n rowIndex = 1\n\nOutput:\n [1,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= rowIndex <= 33\n\n\n\n\n \n\n\nFollow up:\n Could you optimize your algorithm to use only \nO(rowIndex)\n extra space?",
        "temas": [
            "Array",
            "Dynamic Programming"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 118,
        "slug": "pascals-triangle",
        "url": "https://leetcode.com/problems/pascals-triangle/",
        "titulo": "Pascal's Triangle",
        "enunciado": "Given an integer \nnumRows\n, return the first numRows of \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n numRows = 5\n\nOutput:\n [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\n\nInput:\n numRows = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numRows <= 30",
        "temas": [
            "Array",
            "Dynamic Programming"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 112,
        "slug": "path-sum",
        "url": "https://leetcode.com/problems/path-sum/",
        "titulo": "Path Sum",
        "enunciado": "Given the \nroot\n of a binary tree and an integer \ntargetSum\n, return \ntrue\n if the tree has a \nroot-to-leaf\n path such that adding up all the values along the path equals \ntargetSum\n.\n\n\nA \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n\nOutput:\n true\n\nExplanation:\n The root-to-leaf path with the target sum is shown.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3], targetSum = 5\n\nOutput:\n false\n\nExplanation:\n There are two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [], targetSum = 0\n\nOutput:\n false\n\nExplanation:\n Since the tree is empty, there are no root-to-leaf paths.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5000]\n.\n\n\n-1000 <= Node.val <= 1000\n\n\n-1000 <= targetSum <= 1000",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 111,
        "slug": "minimum-depth-of-binary-tree",
        "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/",
        "titulo": "Minimum Depth of Binary Tree",
        "enunciado": "Given a binary tree, find its minimum depth.\n\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n\nNote:\n A leaf is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [2,null,3,null,4,null,5,null,6]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n5\n]\n.\n\n\n-1000 <= Node.val <= 1000",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 110,
        "slug": "balanced-binary-tree",
        "url": "https://leetcode.com/problems/balanced-binary-tree/",
        "titulo": "Balanced Binary Tree",
        "enunciado": "Given a binary tree, determine if it is \nheight-balanced\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,2,3,3,null,null,4,4]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5000]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 108,
        "slug": "convert-sorted-array-to-binary-search-tree",
        "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/",
        "titulo": "Convert Sorted Array to Binary Search Tree",
        "enunciado": "Given an integer array \nnums\n where the elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n [0,-10,5,null,-3,null,9] is also accepted:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,3]\n\nOutput:\n [3,1]\n\nExplanation:\n [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in a \nstrictly increasing\n order.",
        "temas": [
            "Array",
            "Divide and Conquer",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 104,
        "slug": "maximum-depth-of-binary-tree",
        "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
        "titulo": "Maximum Depth of Binary Tree",
        "enunciado": "Given the \nroot\n of a binary tree, return \nits maximum depth\n.\n\n\nA binary tree's \nmaximum depth\n is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,null,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 101,
        "slug": "symmetric-tree",
        "url": "https://leetcode.com/problems/symmetric-tree/",
        "titulo": "Symmetric Tree",
        "enunciado": "Given the \nroot\n of a binary tree, \ncheck whether it is a mirror of itself\n (i.e., symmetric around its center).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,2,3,4,4,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,2,null,3,null,3]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Could you solve it both recursively and iteratively?",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 100,
        "slug": "same-tree",
        "url": "https://leetcode.com/problems/same-tree/",
        "titulo": "Same Tree",
        "enunciado": "Given the roots of two binary trees \np\n and \nq\n, write a function to check if they are the same or not.\n\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n p = [1,2,3], q = [1,2,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n p = [1,2], q = [1,null,2]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n p = [1,2,1], q = [1,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 100]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
        "temas": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Tree"
    },
    {
        "id": 94,
        "slug": "binary-tree-inorder-traversal",
        "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
        "titulo": "Binary Tree Inorder Traversal",
        "enunciado": "Given the \nroot\n of a binary tree, return \nthe inorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[1,3,2]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[4,2,6,5,7,1,3,9,8]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
        "temas": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Stack"
    },
    {
        "id": 88,
        "slug": "merge-sorted-array",
        "url": "https://leetcode.com/problems/merge-sorted-array/",
        "titulo": "Merge Sorted Array",
        "enunciado": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
        "temas": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 83,
        "slug": "remove-duplicates-from-sorted-list",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/",
        "titulo": "Remove Duplicates from Sorted List",
        "enunciado": "Given the \nhead\n of a sorted linked list, \ndelete all duplicates such that each element appears only once\n. Return \nthe linked list \nsorted\n as well\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,1,2]\n\nOutput:\n [1,2]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,1,2,3,3]\n\nOutput:\n [1,2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 300]\n.\n\n\n-100 <= Node.val <= 100\n\n\nThe list is guaranteed to be \nsorted\n in ascending order.",
        "temas": [
            "Linked List"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 70,
        "slug": "climbing-stairs",
        "url": "https://leetcode.com/problems/climbing-stairs/",
        "titulo": "Climbing Stairs",
        "enunciado": "You are climbing a staircase. It takes \nn\n steps to reach the top.\n\n\nEach time you can either climb \n1\n or \n2\n steps. In how many distinct ways can you climb to the top?\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 45",
        "temas": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 69,
        "slug": "sqrtx",
        "url": "https://leetcode.com/problems/sqrtx/",
        "titulo": "Sqrt(x)",
        "enunciado": "Given a non-negative integer \nx\n, return \nthe square root of \nx\n rounded down to the nearest integer\n. The returned integer should be \nnon-negative\n as well.\n\n\nYou \nmust not use\n any built-in exponent function or operator.\n\n\n\n\nFor example, do not use \npow(x, 0.5)\n in c++ or \nx ** 0.5\n in python.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 4\n\nOutput:\n 2\n\nExplanation:\n The square root of 4 is 2, so we return 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 8\n\nOutput:\n 2\n\nExplanation:\n The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= x <= 2\n31\n - 1",
        "temas": [
            "Math",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 67,
        "slug": "add-binary",
        "url": "https://leetcode.com/problems/add-binary/",
        "titulo": "Add Binary",
        "enunciado": "Given two binary strings \na\n and \nb\n, return \ntheir sum as a binary string\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n a = \"11\", b = \"1\"\n\nOutput:\n \"100\"\n\nExample 2:\n\n\nInput:\n a = \"1010\", b = \"1011\"\n\nOutput:\n \"10101\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a.length, b.length <= 10\n4\n\n\na\n and \nb\n consist only of \n'0'\n or \n'1'\n characters.\n\n\nEach string does not contain leading zeros except for the zero itself.",
        "temas": [
            "Math",
            "String",
            "Bit Manipulation",
            "Simulation"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 66,
        "slug": "plus-one",
        "url": "https://leetcode.com/problems/plus-one/",
        "titulo": "Plus One",
        "enunciado": "You are given a \nlarge integer\n represented as an integer array \ndigits\n, where each \ndigits[i]\n is the \ni\nth\n digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading \n0\n's.\n\n\nIncrement the large integer by one and return \nthe resulting array of digits\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = [1,2,3]\n\nOutput:\n [1,2,4]\n\nExplanation:\n The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = [4,3,2,1]\n\nOutput:\n [4,3,2,2]\n\nExplanation:\n The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = [9]\n\nOutput:\n [1,0]\n\nExplanation:\n The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= digits.length <= 100\n\n\n0 <= digits[i] <= 9\n\n\ndigits\n does not contain any leading \n0\n's.",
        "temas": [
            "Array",
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 58,
        "slug": "length-of-last-word",
        "url": "https://leetcode.com/problems/length-of-last-word/",
        "titulo": "Length of Last Word",
        "enunciado": "Given a string \ns\n consisting of words and spaces, return \nthe length of the \nlast\n word in the string.\n\n\nA \nword\n is a maximal \nsubstring\n consisting of non-space characters only.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"Hello World\"\n\nOutput:\n 5\n\nExplanation:\n The last word is \"World\" with length 5.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"   fly me   to   the moon  \"\n\nOutput:\n 4\n\nExplanation:\n The last word is \"moon\" with length 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"luffy is still joyboy\"\n\nOutput:\n 6\n\nExplanation:\n The last word is \"joyboy\" with length 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of only English letters and spaces \n' '\n.\n\n\nThere will be at least one word in \ns\n.",
        "temas": [
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 35,
        "slug": "search-insert-position",
        "url": "https://leetcode.com/problems/search-insert-position/",
        "titulo": "Search Insert Position",
        "enunciado": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 5\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 2\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 7\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n contains \ndistinct\n values sorted in \nascending\n order.\n\n\n-10\n4\n <= target <= 10\n4",
        "temas": [
            "Array",
            "Binary Search"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 28,
        "slug": "find-the-index-of-the-first-occurrence-in-a-string",
        "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",
        "titulo": "Find the Index of the First Occurrence in a String",
        "enunciado": "Given two strings \nneedle\n and \nhaystack\n, return the index of the first occurrence of \nneedle\n in \nhaystack\n, or \n-1\n if \nneedle\n is not part of \nhaystack\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n haystack = \"sadbutsad\", needle = \"sad\"\n\nOutput:\n 0\n\nExplanation:\n \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n haystack = \"leetcode\", needle = \"leeto\"\n\nOutput:\n -1\n\nExplanation:\n \"leeto\" did not occur in \"leetcode\", so we return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= haystack.length, needle.length <= 10\n4\n\n\nhaystack\n and \nneedle\n consist of only lowercase English characters.",
        "temas": [
            "Two Pointers",
            "String",
            "String Matching"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Two Pointers"
    },
    {
        "id": 27,
        "slug": "remove-element",
        "url": "https://leetcode.com/problems/remove-element/",
        "titulo": "Remove Element",
        "enunciado": "Given an integer array \nnums\n and an integer \nval\n, remove all occurrences of \nval\n in \nnums\n \nin-place\n. The order of the elements may be changed. Then return \nthe number of elements in \nnums\n which are not equal to \nval\n.\n\n\nConsider the number of elements in \nnums\n which are not equal to \nval\n be \nk\n, to get accepted, you need to do the following things:\n\n\n\n\nChange the array \nnums\n such that the first \nk\n elements of \nnums\n contain the elements which are not equal to \nval\n. The remaining elements of \nnums\n are not important as well as the size of \nnums\n.\n\n\nReturn \nk\n.\n\n\n\n\nCustom Judge:\n\n\nThe judge will test your solution with the following code:\n\n\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\n\nIf all assertions pass, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,2,2,3], val = 3\n\nOutput:\n 2, nums = [2,2,_,_]\n\nExplanation:\n Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,2,2,3,0,4,2], val = 2\n\nOutput:\n 5, nums = [0,1,4,0,3,_,_,_]\n\nExplanation:\n Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 100\n\n\n0 <= nums[i] <= 50\n\n\n0 <= val <= 100",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 26,
        "slug": "remove-duplicates-from-sorted-array",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
        "titulo": "Remove Duplicates from Sorted Array",
        "enunciado": "Given an integer array \nnums\n sorted in \nnon-decreasing order\n, remove the duplicates \nin-place\n such that each unique element appears only \nonce\n. The \nrelative order\n of the elements should be kept the \nsame\n. Then return \nthe number of unique elements in \nnums\n.\n\n\nConsider the number of unique elements of \nnums\n to be \nk\n, to get accepted, you need to do the following things:\n\n\n\n\nChange the array \nnums\n such that the first \nk\n elements of \nnums\n contain the unique elements in the order they were present in \nnums\n initially. The remaining elements of \nnums\n are not important as well as the size of \nnums\n.\n\n\nReturn \nk\n.\n\n\n\n\nCustom Judge:\n\n\nThe judge will test your solution with the following code:\n\n\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\n\nIf all assertions pass, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,2]\n\nOutput:\n 2, nums = [1,2,_]\n\nExplanation:\n Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,1,2,2,3,3,4]\n\nOutput:\n 5, nums = [0,1,2,3,4,_,_,_,_,_]\n\nExplanation:\n Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-100 <= nums[i] <= 100\n\n\nnums\n is sorted in \nnon-decreasing\n order.",
        "temas": [
            "Array",
            "Two Pointers"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    },
    {
        "id": 21,
        "slug": "merge-two-sorted-lists",
        "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
        "titulo": "Merge Two Sorted Lists",
        "enunciado": "You are given the heads of two sorted linked lists \nlist1\n and \nlist2\n.\n\n\nMerge the two lists into one \nsorted\n list. The list should be made by splicing together the nodes of the first two lists.\n\n\nReturn \nthe head of the merged linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n list1 = [1,2,4], list2 = [1,3,4]\n\nOutput:\n [1,1,2,3,4,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n list1 = [], list2 = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n list1 = [], list2 = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both lists is in the range \n[0, 50]\n.\n\n\n-100 <= Node.val <= 100\n\n\nBoth \nlist1\n and \nlist2\n are sorted in \nnon-decreasing\n order.",
        "temas": [
            "Linked List",
            "Recursion"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Linked List"
    },
    {
        "id": 20,
        "slug": "valid-parentheses",
        "url": "https://leetcode.com/problems/valid-parentheses/",
        "titulo": "Valid Parentheses",
        "enunciado": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
        "temas": [
            "String",
            "Stack"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 14,
        "slug": "longest-common-prefix",
        "url": "https://leetcode.com/problems/longest-common-prefix/",
        "titulo": "Longest Common Prefix",
        "enunciado": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
        "temas": [
            "String",
            "Trie"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "String"
    },
    {
        "id": 13,
        "slug": "roman-to-integer",
        "url": "https://leetcode.com/problems/roman-to-integer/",
        "titulo": "Roman to Integer",
        "enunciado": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
        "temas": [
            "Hash Table",
            "Math",
            "String"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Hash Table"
    },
    {
        "id": 9,
        "slug": "palindrome-number",
        "url": "https://leetcode.com/problems/palindrome-number/",
        "titulo": "Palindrome Number",
        "enunciado": "Given an integer \nx\n, return \ntrue\n if \nx\n is a \npalindrome\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 121\n\nOutput:\n true\n\nExplanation:\n 121 reads as 121 from left to right and from right to left.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -121\n\nOutput:\n false\n\nExplanation:\n From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 10\n\nOutput:\n false\n\nExplanation:\n Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without converting the integer to a string?",
        "temas": [
            "Math"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Math"
    },
    {
        "id": 1,
        "slug": "two-sum",
        "url": "https://leetcode.com/problems/two-sum/",
        "titulo": "Two Sum",
        "enunciado": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
        "temas": [
            "Array",
            "Hash Table"
        ],
        "dificuldade": "Fácil",
        "tema_principal": "Array"
    }
]