[
  {
    "id": 3575,
    "slug": "maximum-good-subtree-score",
    "url": "https://leetcode.com/problems/maximum-good-subtree-score/",
    "titulo": "Maximum Good Subtree Score",
    "enunciado": "You are given an undirected tree rooted at node 0 with \nn\n nodes numbered from 0 to \nn - 1\n. Each node \ni\n has an integer value \nvals[i]\n, and its parent is given by \npar[i]\n.\n\n\nA \nsubset\n of nodes within the \nsubtree\n of a node is called \ngood\n if every digit from 0 to 9 appears \nat most\n once in the decimal representation of the values of the selected nodes.\n\n\nThe \nscore\n of a good subset is the sum of the values of its nodes.\n\n\nDefine an array \nmaxScore\n of length \nn\n, where \nmaxScore[u]\n represents the \nmaximum\n possible sum of values of a good subset of nodes that belong to the subtree rooted at node \nu\n, including \nu\n itself and all its descendants.\n\n\nReturn the sum of all values in \nmaxScore\n.\n\n\nSince the answer may be large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nvals = [2,3], par = [-1,0]\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\n\n\nThe subtree rooted at node 0 includes nodes \n{0, 1}\n. The subset \n{2, 3}\n is\n \ngood as the digits 2 and 3 appear only once. The score of this subset is \n2 + 3 = 5\n.\n\n\nThe subtree rooted at node 1 includes only node \n{1}\n. The subset \n{3}\n is\n \ngood. The score of this subset is 3.\n\n\nThe \nmaxScore\n array is \n[5, 3]\n, and the sum of all values in \nmaxScore\n is \n5 + 3 = 8\n. Thus, the answer is 8.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nvals = [1,5,2], par = [-1,0,0]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\n\n\n\n\nThe subtree rooted at node 0 includes nodes \n{0, 1, 2}\n. The subset \n{1, 5, 2}\n is\n \ngood as the digits 1, 5 and 2 appear only once. The score of this subset is \n1 + 5 + 2 = 8\n.\n\n\nThe subtree rooted at node 1 includes only node \n{1}\n. The subset \n{5}\n is\n \ngood. The score of this subset is 5.\n\n\nThe subtree rooted at node 2 includes only node \n{2}\n. The subset \n{2}\n is\n \ngood. The score of this subset is 2.\n\n\nThe \nmaxScore\n array is \n[8, 5, 2]\n, and the sum of all values in \nmaxScore\n is \n8 + 5 + 2 = 15\n. Thus, the answer is 15.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nvals = [34,1,2], par = [-1,0,1]\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\n\n\n\nThe subtree rooted at node 0 includes nodes \n{0, 1, 2}\n. The subset \n{34, 1, 2}\n is\n \ngood as the digits 3, 4, 1 and 2 appear only once. The score of this subset is \n34 + 1 + 2 = 37\n.\n\n\nThe subtree rooted at node 1 includes node \n{1, 2}\n. The subset \n{1, 2}\n is\n \ngood as the digits 1 and 2 appear only once. The score of this subset is \n1 + 2 = 3\n.\n\n\nThe subtree rooted at node 2 includes only node \n{2}\n. The subset \n{2}\n is\n \ngood. The score of this subset is 2.\n\n\nThe \nmaxScore\n array is \n[37, 3, 2]\n, and the sum of all values in \nmaxScore\n is \n37 + 3 + 2 = 42\n. Thus, the answer is 42.\n\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nvals = [3,22,5], par = [-1,0,1]\n\n\nOutput:\n \n18\n\n\nExplanation:\n\n\n\n\nThe subtree rooted at node 0 includes nodes \n{0, 1, 2}\n. The subset \n{3, 22, 5}\n is\n \nnot good, as digit 2 appears twice. Therefore, the subset \n{3, 5}\n is valid. The score of this subset is \n3 + 5 = 8\n.\n\n\nThe subtree rooted at node 1 includes nodes \n{1, 2}\n. The subset \n{22, 5}\n is\n \nnot good, as digit 2 appears twice. Therefore, the subset \n{5}\n is valid. The score of this subset is 5.\n\n\nThe subtree rooted at node 2 includes \n{2}\n. The subset \n{5}\n is\n \ngood. The score of this subset is 5.\n\n\nThe \nmaxScore\n array is \n[8, 5, 5]\n, and the sum of all values in \nmaxScore\n is \n8 + 5 + 5 = 18\n. Thus, the answer is 18.\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == vals.length <= 500\n\n\n1 <= vals[i] <= 10\n9\n\n\npar.length == n\n\n\npar[0] == -1\n\n\n0 <= par[i] < n\n for \ni\n in \n[1, n - 1]\n\n\nThe input is generated such that the parent array \npar\n represents a valid tree.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Tree",
      "Depth-First Search",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3544,
    "slug": "subtree-inversion-sum",
    "url": "https://leetcode.com/problems/subtree-inversion-sum/",
    "titulo": "Subtree Inversion Sum",
    "enunciado": "You are given an undirected tree rooted at node \n0\n, with \nn\n nodes numbered from 0 to \nn - 1\n. The tree is represented by a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates an edge between nodes \nu\ni\n and \nv\ni\n.\n\n\nYou are also given an integer array \nnums\n of length \nn\n, where \nnums[i]\n represents the value at node \ni\n, and an integer \nk\n.\n\n\nYou may perform \ninversion operations\n on a subset of nodes subject to the following rules:\n\n\n\n\n\n\nSubtree Inversion Operation:\n\n\n\n\n\n\nWhen you invert a node, every value in the \nsubtree\n rooted at that node is multiplied by -1.\n\n\n\n\n\n\n\n\n\n\nDistance Constraint on Inversions:\n\n\n\n\n\n\nYou may only invert a node if it is \"sufficiently far\" from any other inverted node.\n\n\n\n\n\n\nSpecifically, if you invert two nodes \na\n and \nb\n such that one is an ancestor of the other (i.e., if \nLCA(a, b) = a\n or \nLCA(a, b) = b\n), then the distance (the number of edges on the unique path between them) must be at least \nk\n.\n\n\n\n\n\n\n\n\n\n\nReturn the \nmaximum\n possible \nsum\n of the tree's node values after applying \ninversion operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], nums = [4,-8,-6,3,7,-2,5], k = 2\n\n\nOutput:\n \n27\n\n\nExplanation:\n\n\n\n\n\n\nApply inversion operations at nodes 0, 3, 4 and 6.\n\n\nThe final \nnums\n array is \n[-4, 8, 6, 3, 7, 2, 5]\n, and the total sum is 27.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[0,1],[1,2],[2,3],[3,4]], nums = [-1,3,-2,4,-5], k = 2\n\n\nOutput:\n \n9\n\n\nExplanation:\n\n\n\n\n\n\nApply the inversion operation at node 4.\n\n\nThe final \nnums\n array becomes \n[-1, 3, -2, 4, 5]\n, and the total sum is 9.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nedges = [[0,1],[0,2]], nums = [0,-1,-2], k = 3\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nApply inversion operations at nodes 1 and 2.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i] = [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\nnums.length == n\n\n\n-5 * 10\n4\n <= nums[i] <= 5 * 10\n4\n\n\n1 <= k <= 50\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3543,
    "slug": "maximum-weighted-k-edge-path",
    "url": "https://leetcode.com/problems/maximum-weighted-k-edge-path/",
    "titulo": "Maximum Weighted K-Edge Path",
    "enunciado": "You are given an integer \nn\n and a \nDirected Acyclic Graph (DAG)\n with \nn\n nodes labeled from 0 to \nn - 1\n. This is represented by a 2D array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n indicates a directed edge from node \nu\ni\n to \nv\ni\n with weight \nw\ni\n.\n\n\nYou are also given two integers, \nk\n and \nt\n.\n\n\nYour task is to determine the \nmaximum\n possible sum of edge weights for any path in the graph such that:\n\n\n\n\nThe path contains \nexactly\n \nk\n edges.\n\n\nThe total sum of edge weights in the path is \nstrictly\n less than \nt\n.\n\n\n\n\nReturn the \nmaximum\n possible sum of weights for such a path. If no such path exists, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 3, edges = [[0,1,1],[1,2,2]], k = 2, t = 4\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\n\n\nThe only path with \nk = 2\n edges is \n0 -> 1 -> 2\n with weight \n1 + 2 = 3 < t\n.\n\n\nThus, the maximum possible sum of weights less than \nt\n is 3.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, edges = [[0,1,2],[0,2,3]], k = 1, t = 3\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\nThere are two paths with \nk = 1\n edge:\n\n\t\n\n\n0 -> 1\n with weight \n2 < t\n.\n\n\n0 -> 2\n with weight \n3 = t\n, which is not strictly less than \nt\n.\n\n\n\n\n\n\nThus, the maximum possible sum of weights less than \nt\n is 2.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 3, edges = [[0,1,6],[1,2,8]], k = 1, t = 6\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\n\n\n\n\nThere are two paths with k = 1 edge:\n\t\n\n\n0 -> 1\n with weight \n6 = t\n, which is not strictly less than \nt\n.\n\n\n1 -> 2\n with weight \n8 > t\n, which is not strictly less than \nt\n.\n\n\n\n\n\n\nSince there is no path with sum of weights strictly less than \nt\n, the answer is -1.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 300\n\n\n0 <= edges.length <= 300\n\n\nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\nu\ni\n != v\ni\n\n\n1 <= w\ni\n <= 10\n\n\n0 <= k <= 300\n\n\n1 <= t <= 600\n\n\nThe input graph is \nguaranteed\n to be a \nDAG\n.\n\n\nThere are no duplicate edges.",
    "temas": [
      "Hash Table",
      "Dynamic Programming",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 3562,
    "slug": "maximum-profit-from-trading-stocks-with-discounts",
    "url": "https://leetcode.com/problems/maximum-profit-from-trading-stocks-with-discounts/",
    "titulo": "Maximum Profit from Trading Stocks with Discounts",
    "enunciado": "You are given an integer \nn\n, representing the number of employees in a company. Each employee is assigned a unique ID from 1 to \nn\n, and employee 1 is the CEO. You are given two \n1-based \ninteger arrays, \npresent\n and \nfuture\n, each of length \nn\n, where:\n\n\n\n\npresent[i]\n represents the \ncurrent\n price at which the \ni\nth\n employee can buy a stock today.\n\n\nfuture[i]\n represents the \nexpected\n price at which the \ni\nth\n employee can sell the stock tomorrow.\n\n\n\n\nThe company's hierarchy is represented by a 2D integer array \nhierarchy\n, where \nhierarchy[i] = [u\ni\n, v\ni\n]\n means that employee \nu\ni\n is the direct boss of employee \nv\ni\n.\n\n\nAdditionally, you have an integer \nbudget\n representing the total funds available for investment.\n\n\nHowever, the company has a discount policy: if an employee's direct boss purchases their own stock, then the employee can buy their stock at \nhalf\n the original price (\nfloor(present[v] / 2)\n).\n\n\nReturn the \nmaximum\n profit that can be achieved without exceeding the given budget.\n\n\nNote:\n\n\n\n\nYou may buy each stock at most \nonce\n.\n\n\nYou \ncannot\n use any profit earned from future stock prices to fund additional investments and must buy only from \nbudget\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 2, present = [1,2], future = [4,3], hierarchy = [[1,2]], budget = 3\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\n\n\n\n\nEmployee 1 buys the stock at price 1 and earns a profit of \n4 - 1 = 3\n.\n\n\nSince Employee 1 is the direct boss of Employee 2, Employee 2 gets a discounted price of \nfloor(2 / 2) = 1\n.\n\n\nEmployee 2 buys the stock at price 1 and earns a profit of \n3 - 1 = 2\n.\n\n\nThe total buying cost is \n1 + 1 = 2 <= budget\n. Thus, the maximum total profit achieved is \n3 + 2 = 5\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 2, present = [3,4], future = [5,8], hierarchy = [[1,2]], budget = 4\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\n\n\n\n\nEmployee 2 buys the stock at price 4 and earns a profit of \n8 - 4 = 4\n.\n\n\nSince both employees cannot buy together, the maximum profit is 4.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 3, present = [4,6,8], future = [7,9,11], hierarchy = [[1,2],[1,3]], budget = 10\n\n\nOutput:\n 10\n\n\nExplanation:\n\n\n\n\n\n\nEmployee 1 buys the stock at price 4 and earns a profit of \n7 - 4 = 3\n.\n\n\nEmployee 3 would get a discounted price of \nfloor(8 / 2) = 4\n and earns a profit of \n11 - 4 = 7\n.\n\n\nEmployee 1 and Employee 3 buy their stocks at a total cost of \n4 + 4 = 8 <= budget\n. Thus, the maximum total profit achieved is \n3 + 7 = 10\n.\n\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nn = 3, present = [5,2,3], future = [8,5,6], hierarchy = [[1,2],[2,3]], budget = 7\n\n\nOutput:\n \n12\n\n\nExplanation:\n\n\n\n\n\n\nEmployee 1 buys the stock at price 5 and earns a profit of \n8 - 5 = 3\n.\n\n\nEmployee 2 would get a discounted price of \nfloor(2 / 2) = 1\n and earns a profit of \n5 - 1 = 4\n.\n\n\nEmployee 3 would get a discounted price of \nfloor(3 / 2) = 1\n and earns a profit of \n6 - 1 = 5\n.\n\n\nThe total cost becomes \n5 + 1 + 1 = 7 <= budget\n. Thus, the maximum total profit achieved is \n3 + 4 + 5 = 12\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 160\n\n\npresent.length, future.length == n\n\n\n1 <= present[i], future[i] <= 50\n\n\nhierarchy.length == n - 1\n\n\nhierarchy[i] == [u\ni\n, v\ni\n]\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni\n != v\ni\n\n\n1 <= budget <= 160\n\n\nThere are no duplicate edges.\n\n\nEmployee 1 is the direct or indirect boss of every employee.\n\n\nThe input graph \nhierarchy \nis \nguaranteed\n to have no cycles.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3553,
    "slug": "minimum-weighted-subgraph-with-the-required-paths-ii",
    "url": "https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths-ii/",
    "titulo": "Minimum Weighted Subgraph With the Required Paths II",
    "enunciado": "You are given an \nundirected weighted\n tree with \nn\n nodes, numbered from \n0\n to \nn - 1\n. It is represented by a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n with weight \nw\ni\n.​\n\n\nAdditionally, you are given a 2D integer array \nqueries\n, where \nqueries[j] = [src1\nj\n, src2\nj\n, dest\nj\n]\n.\n\n\nReturn an array \nanswer\n of length equal to \nqueries.length\n, where \nanswer[j]\n is the \nminimum total weight\n of a subtree such that it is possible to reach \ndest\nj\n from both \nsrc1\nj\n and \nsrc2\nj\n using edges in this subtree.\n\n\nA \nsubtree\n here is any connected subset of nodes and edges of the original tree forming a valid tree.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries = [[2,3,4],[0,2,5]]\n\n\nOutput:\n \n[12,11]\n\n\nExplanation:\n\n\nThe blue edges represent one of the subtrees that yield the optimal answer.\n\n\n\n\n\n\n\n\nanswer[0]\n: The total weight of the selected subtree that ensures a path from \nsrc1 = 2\n and \nsrc2 = 3\n to \ndest = 4\n is \n3 + 5 + 4 = 12\n.\n\n\n\n\n\n\nanswer[1]\n: The total weight of the selected subtree that ensures a path from \nsrc1 = 0\n and \nsrc2 = 2\n to \ndest = 5\n is \n2 + 3 + 6 = 11\n.\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[1,0,8],[0,2,7]], queries = [[0,1,2]]\n\n\nOutput:\n \n[15]\n\n\nExplanation:\n\n\n\n\n\n\nanswer[0]\n: The total weight of the selected subtree that ensures a path from \nsrc1 = 0\n and \nsrc2 = 1\n to \ndest = 2\n is \n8 + 7 = 15\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\n1 <= w\ni\n <= 10\n4\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[j].length == 3\n\n\n0 <= src1\nj\n, src2\nj\n, dest\nj\n < n\n\n\nsrc1\nj\n, \nsrc2\nj\n, and \ndest\nj\n are pairwise distinct.\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3534,
    "slug": "path-existence-queries-in-a-graph-ii",
    "url": "https://leetcode.com/problems/path-existence-queries-in-a-graph-ii/",
    "titulo": "Path Existence Queries in a Graph II",
    "enunciado": "You are given an integer \nn\n representing the number of nodes in a graph, labeled from 0 to \nn - 1\n.\n\n\nYou are also given an integer array \nnums\n of length \nn\n and an integer \nmaxDiff\n.\n\n\nAn \nundirected \nedge exists between nodes \ni\n and \nj\n if the \nabsolute\n difference between \nnums[i]\n and \nnums[j]\n is \nat most\n \nmaxDiff\n (i.e., \n|nums[i] - nums[j]| <= maxDiff\n).\n\n\nYou are also given a 2D integer array \nqueries\n. For each \nqueries[i] = [u\ni\n, v\ni\n]\n, find the \nminimum\n distance between nodes \nu\ni\n and \nv\ni\n.\n If no path exists between the two nodes, return -1 for that query.\n\n\nReturn an array \nanswer\n, where \nanswer[i]\n is the result of the \ni\nth\n query.\n\n\nNote:\n The edges between the nodes are unweighted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5, nums = [1,8,3,4,2], maxDiff = 3, queries = [[0,3],[2,4]]\n\n\nOutput:\n \n[1,1]\n\n\nExplanation:\n\n\nThe resulting graph is:\n\n\n\n\n\n\n\n\n\n\nQuery\n\n\nShortest Path\n\n\nMinimum Distance\n\n\n\n\n\n\n[0, 3]\n\n\n0 → 3\n\n\n1\n\n\n\n\n\n\n[2, 4]\n\n\n2 → 4\n\n\n1\n\n\n\n\n\n\n\n\nThus, the output is \n[1, 1]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 5, nums = [5,3,1,9,10], maxDiff = 2, queries = [[0,1],[0,2],[2,3],[4,3]]\n\n\nOutput:\n \n[1,2,-1,1]\n\n\nExplanation:\n\n\nThe resulting graph is:\n\n\n\n\n\n\n\n\n\n\n\n\nQuery\n\n\nShortest Path\n\n\nMinimum Distance\n\n\n\n\n\n\n[0, 1]\n\n\n0 → 1\n\n\n1\n\n\n\n\n\n\n[0, 2]\n\n\n0 → 1 → 2\n\n\n2\n\n\n\n\n\n\n[2, 3]\n\n\nNone\n\n\n-1\n\n\n\n\n\n\n[4, 3]\n\n\n3 → 4\n\n\n1\n\n\n\n\n\n\n\n\nThus, the output is \n[1, 2, -1, 1]\n.\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 3, nums = [3,6,1], maxDiff = 1, queries = [[0,0],[0,1],[1,2]]\n\n\nOutput:\n \n[0,-1,-1]\n\n\nExplanation:\n\n\nThere are no edges between any two nodes because:\n\n\n\n\nNodes 0 and 1: \n|nums[0] - nums[1]| = |3 - 6| = 3 > 1\n\n\nNodes 0 and 2: \n|nums[0] - nums[2]| = |3 - 1| = 2 > 1\n\n\nNodes 1 and 2: \n|nums[1] - nums[2]| = |6 - 1| = 5 > 1\n\n\n\n\nThus, no node can reach any other node, and the output is \n[0, -1, -1]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n0 <= maxDiff <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i] == [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < n",
    "temas": [
      "Array",
      "Binary Search",
      "Greedy",
      "Graph",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3548,
    "slug": "equal-sum-grid-partition-ii",
    "url": "https://leetcode.com/problems/equal-sum-grid-partition-ii/",
    "titulo": "Equal Sum Grid Partition II",
    "enunciado": "You are given an \nm x n\n matrix \ngrid\n of positive integers. Your task is to determine if it is possible to make \neither one horizontal or one vertical cut\n on the grid such that:\n\n\n\n\nEach of the two resulting sections formed by the cut is \nnon-empty\n.\n\n\nThe sum of elements in both sections is \nequal\n, or can be made equal by discounting \nat most\n one single cell in total (from either section).\n\n\nIf a cell is discounted, the rest of the section must \nremain connected\n.\n\n\n\n\nReturn \ntrue\n if such a partition exists; otherwise, return \nfalse\n.\n\n\nNote:\n A section is \nconnected\n if every cell in it can be reached from any other cell by moving up, down, left, or right through other cells in the section.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,4],[2,3]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\n\n\nA horizontal cut after the first row gives sums \n1 + 4 = 5\n and \n2 + 3 = 5\n, which are equal. Thus, the answer is \ntrue\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,2],[3,4]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\n\n\nA vertical cut after the first column gives sums \n1 + 3 = 4\n and \n2 + 4 = 6\n.\n\n\nBy discounting 2 from the right section (\n6 - 2 = 4\n), both sections have equal sums and remain connected. Thus, the answer is \ntrue\n.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1,2,4],[2,3,5]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\n\n\nA horizontal cut after the first row gives \n1 + 2 + 4 = 7\n and \n2 + 3 + 5 = 10\n.\n\n\nBy discounting 3 from the bottom section (\n10 - 3 = 7\n), both sections have equal sums, but they do not remain connected as it splits the bottom section into two parts (\n[2]\n and \n[5]\n). Thus, the answer is \nfalse\n.\n\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ngrid = [[4,1,8],[3,2,6]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nNo valid cut exists, so the answer is \nfalse\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m == grid.length <= 10\n5\n\n\n1 <= n == grid[i].length <= 10\n5\n\n\n2 <= m * n <= 10\n5\n\n\n1 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix",
      "Enumeration",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3546,
    "slug": "equal-sum-grid-partition-i",
    "url": "https://leetcode.com/problems/equal-sum-grid-partition-i/",
    "titulo": "Equal Sum Grid Partition I",
    "enunciado": "You are given an \nm x n\n matrix \ngrid\n of positive integers. Your task is to determine if it is possible to make \neither one horizontal or one vertical cut\n on the grid such that:\n\n\n\n\nEach of the two resulting sections formed by the cut is \nnon-empty\n.\n\n\nThe sum of the elements in both sections is \nequal\n.\n\n\n\n\nReturn \ntrue\n if such a partition exists; otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,4],[2,3]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nA horizontal cut between row 0 and row 1 results in two non-empty sections, each with a sum of 5. Thus, the answer is \ntrue\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,3],[2,4]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nNo horizontal or vertical cut results in two non-empty sections with equal sums. Thus, the answer is \nfalse\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m == grid.length <= 10\n5\n\n\n1 <= n == grid[i].length <= 10\n5\n\n\n2 <= m * n <= 10\n5\n\n\n1 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Matrix",
      "Enumeration",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3547,
    "slug": "maximum-sum-of-edge-values-in-a-graph",
    "url": "https://leetcode.com/problems/maximum-sum-of-edge-values-in-a-graph/",
    "titulo": "Maximum Sum of Edge Values in a Graph",
    "enunciado": "You are given an \nundirected connected\n graph of \nn\n nodes, numbered from \n0\n to \nn - 1\n. Each node is connected to \nat most\n 2 other nodes.\n\n\nThe graph consists of \nm\n edges, represented by a 2D array \nedges\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n.\n\n\nYou have to assign a \nunique\n value from \n1\n to \nn\n to each node. The value of an edge will be the \nproduct\n of the values assigned to the two nodes it connects.\n\n\nYour score is the sum of the values of all edges in the graph.\n\n\nReturn the \nmaximum\n score you can achieve.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nn = 4, edges = \n[[0,1],[1,2],[2,3]]\n\n\nOutput:\n 23\n\n\nExplanation:\n\n\nThe diagram above illustrates an optimal assignment of values to nodes. The sum of the values of the edges is: \n(1 * 3) + (3 * 4) + (4 * 2) = 23\n.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nn = 6, edges = [[0,3],[4,5],[2,0],[1,3],[2,4],[1,5]]\n\n\nOutput:\n \n82\n\n\nExplanation:\n\n\nThe diagram above illustrates an optimal assignment of values to nodes. The sum of the values of the edges is: \n(1 * 2) + (2 * 4) + (4 * 6) + (6 * 5) + (5 * 3) + (3 * 1) = 82\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 5 * 10\n4\n\n\nm == edges.length\n\n\n1 <= m <= n\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nThere are no repeated edges.\n\n\nThe graph is connected.\n\n\nEach node is connected to at most 2 other nodes.",
    "temas": [
      "Greedy",
      "Depth-First Search",
      "Graph",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Greedy",
    "has_image": true
  },
  {
    "id": 3558,
    "slug": "number-of-ways-to-assign-edge-weights-i",
    "url": "https://leetcode.com/problems/number-of-ways-to-assign-edge-weights-i/",
    "titulo": "Number of Ways to Assign Edge Weights I",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from 1 to \nn\n, rooted at node 1. The tree is represented by a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n.\n\n\nInitially, all edges have a weight of 0. You must assign each edge a weight of either \n1\n or \n2\n.\n\n\nThe \ncost\n of a path between any two nodes \nu\n and \nv\n is the total weight of all edges in the path connecting them.\n\n\nSelect any one node \nx\n at the \nmaximum\n depth. Return the number of ways to assign edge weights in the path from node 1 to \nx\n such that its total cost is \nodd\n.\n\n\nSince the answer may be large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\nNote:\n Ignore all edges \nnot\n in the path from node 1 to \nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nedges = [[1,2]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nThe path from Node 1 to Node 2 consists of one edge (\n1 → 2\n).\n\n\nAssigning weight 1 makes the cost odd, while 2 makes it even. Thus, the number of valid assignments is 1.\n\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nedges = [[1,2],[1,3],[3,4],[3,5]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nThe maximum depth is 2, with nodes 4 and 5 at the same depth. Either node can be selected for processing.\n\n\nFor example, the path from Node 1 to Node 4 consists of two edges (\n1 → 3\n and \n3 → 4\n).\n\n\nAssigning weights (1,2) or (2,1) results in an odd cost. Thus, the number of valid assignments is 2.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i] == [u\ni\n, v\ni\n]\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nedges\n represents a valid tree.",
    "temas": [
      "Math",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 3559,
    "slug": "number-of-ways-to-assign-edge-weights-ii",
    "url": "https://leetcode.com/problems/number-of-ways-to-assign-edge-weights-ii/",
    "titulo": "Number of Ways to Assign Edge Weights II",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from 1 to \nn\n, rooted at node 1. The tree is represented by a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n.\n\n\nInitially, all edges have a weight of 0. You must assign each edge a weight of either \n1\n or \n2\n.\n\n\nThe \ncost\n of a path between any two nodes \nu\n and \nv\n is the total weight of all edges in the path connecting them.\n\n\nYou are given a 2D integer array \nqueries\n. For each \nqueries[i] = [u\ni\n, v\ni\n]\n, determine the number of ways to assign weights to edges \nin the path\n such that the cost of the path between \nu\ni\n and \nv\ni\n is \nodd\n.\n\n\nReturn an array \nanswer\n, where \nanswer[i]\n is the number of valid assignments for \nqueries[i]\n.\n\n\nSince the answer may be large, apply \nmodulo\n \n10\n9\n + 7\n to each \nanswer[i]\n.\n\n\nNote:\n For each query, disregard all edges \nnot\n in the path between node \nu\ni\n and \nv\ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nedges = [[1,2]], queries = [[1,1],[1,2]]\n\n\nOutput:\n \n[0,1]\n\n\nExplanation:\n\n\n\n\nQuery \n[1,1]\n: The path from Node 1 to itself consists of no edges, so the cost is 0. Thus, the number of valid assignments is 0.\n\n\nQuery \n[1,2]\n: The path from Node 1 to Node 2 consists of one edge (\n1 → 2\n). Assigning weight 1 makes the cost odd, while 2 makes it even. Thus, the number of valid assignments is 1.\n\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nedges = [[1,2],[1,3],[3,4],[3,5]], queries = [[1,4],[3,4],[2,5]]\n\n\nOutput:\n \n[2,1,4]\n\n\nExplanation:\n\n\n\n\nQuery \n[1,4]\n: The path from Node 1 to Node 4 consists of two edges (\n1 → 3\n and \n3 → 4\n). Assigning weights (1,2) or (2,1) results in an odd cost. Thus, the number of valid assignments is 2.\n\n\nQuery \n[3,4]\n: The path from Node 3 to Node 4 consists of one edge (\n3 → 4\n). Assigning weight 1 makes the cost odd, while 2 makes it even. Thus, the number of valid assignments is 1.\n\n\nQuery \n[2,5]\n: The path from Node 2 to Node 5 consists of three edges (\n2 → 1, 1 → 3\n, and \n3 → 5\n). Assigning (1,2,2), (2,1,2), (2,2,1), or (1,1,1) makes the cost odd. Thus, the number of valid assignments is 4.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i] == [u\ni\n, v\ni\n]\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i] == [u\ni\n, v\ni\n]\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Math",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3532,
    "slug": "path-existence-queries-in-a-graph-i",
    "url": "https://leetcode.com/problems/path-existence-queries-in-a-graph-i/",
    "titulo": "Path Existence Queries in a Graph I",
    "enunciado": "You are given an integer \nn\n representing the number of nodes in a graph, labeled from 0 to \nn - 1\n.\n\n\nYou are also given an integer array \nnums\n of length \nn\n sorted in \nnon-decreasing\n order, and an integer \nmaxDiff\n.\n\n\nAn \nundirected \nedge exists between nodes \ni\n and \nj\n if the \nabsolute\n difference between \nnums[i]\n and \nnums[j]\n is \nat most\n \nmaxDiff\n (i.e., \n|nums[i] - nums[j]| <= maxDiff\n).\n\n\nYou are also given a 2D integer array \nqueries\n. For each \nqueries[i] = [u\ni\n, v\ni\n]\n, determine whether there exists a path between nodes \nu\ni\n and \nv\ni\n.\n\n\nReturn a boolean array \nanswer\n, where \nanswer[i]\n is \ntrue\n if there exists a path between \nu\ni\n and \nv\ni\n in the \ni\nth\n query and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 2, nums = [1,3], maxDiff = 1, queries = [[0,0],[0,1]]\n\n\nOutput:\n \n[true,false]\n\n\nExplanation:\n\n\n\n\nQuery \n[0,0]\n: Node 0 has a trivial path to itself.\n\n\nQuery \n[0,1]\n: There is no edge between Node 0 and Node 1 because \n|nums[0] - nums[1]| = |1 - 3| = 2\n, which is greater than \nmaxDiff\n.\n\n\nThus, the final answer after processing all the queries is \n[true, false]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 4, nums = [2,5,6,8], maxDiff = 2, queries = [[0,1],[0,2],[1,3],[2,3]]\n\n\nOutput:\n \n[false,false,true,true]\n\n\nExplanation:\n\n\nThe resulting graph is:\n\n\n\n\n\n\nQuery \n[0,1]\n: There is no edge between Node 0 and Node 1 because \n|nums[0] - nums[1]| = |2 - 5| = 3\n, which is greater than \nmaxDiff\n.\n\n\nQuery \n[0,2]\n: There is no edge between Node 0 and Node 2 because \n|nums[0] - nums[2]| = |2 - 6| = 4\n, which is greater than \nmaxDiff\n.\n\n\nQuery \n[1,3]\n: There is a path between Node 1 and Node 3 through Node 2 since \n|nums[1] - nums[2]| = |5 - 6| = 1\n and \n|nums[2] - nums[3]| = |6 - 8| = 2\n, both of which are within \nmaxDiff\n.\n\n\nQuery \n[2,3]\n: There is an edge between Node 2 and Node 3 because \n|nums[2] - nums[3]| = |6 - 8| = 2\n, which is equal to \nmaxDiff\n.\n\n\nThus, the final answer after processing all the queries is \n[false, false, true, true]\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\nnums\n is sorted in \nnon-decreasing\n order.\n\n\n0 <= maxDiff <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i] == [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < n",
    "temas": [
      "Array",
      "Hash Table",
      "Binary Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3552,
    "slug": "grid-teleportation-traversal",
    "url": "https://leetcode.com/problems/grid-teleportation-traversal/",
    "titulo": "Grid Teleportation Traversal",
    "enunciado": "You are given a 2D character grid \nmatrix\n of size \nm x n\n, represented as an array of strings, where \nmatrix[i][j]\n represents the cell at the intersection of the \ni\nth\n row and \nj\nth\n column. Each cell is one of the following:\n\n\n\n\n'.'\n representing an empty cell.\n\n\n'#'\n representing an obstacle.\n\n\nAn uppercase letter (\n'A'\n-\n'Z'\n) representing a teleportation portal.\n\n\n\n\nYou start at the top-left cell \n(0, 0)\n, and your goal is to reach the bottom-right cell \n(m - 1, n - 1)\n. You can move from the current cell to any adjacent cell (up, down, left, right) as long as the destination cell is within the grid bounds and is not an obstacle\n.\n\n\nIf you step on a cell containing a portal letter and you haven't used that portal letter before, you may instantly teleport to any other cell in the grid with the same letter. This teleportation does not count as a move, but each portal letter can be used\n at most \nonce during your journey.\n\n\nReturn the \nminimum\n number of moves required to reach the bottom-right cell. If it is not possible to reach the destination, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nmatrix = [\"A..\",\".A.\",\"...\"]\n\n\nOutput:\n 2\n\n\nExplanation:\n\n\n\n\n\n\nBefore the first move, teleport from \n(0, 0)\n to \n(1, 1)\n.\n\n\nIn the first move, move from \n(1, 1)\n to \n(1, 2)\n.\n\n\nIn the second move, move from \n(1, 2)\n to \n(2, 2)\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nmatrix = [\".#...\",\".#.#.\",\".#.#.\",\"...#.\"]\n\n\nOutput:\n \n13\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m == matrix.length <= 10\n3\n\n\n1 <= n == matrix[i].length <= 10\n3\n\n\nmatrix[i][j]\n is either \n'#'\n, \n'.'\n, or an uppercase English letter.\n\n\nmatrix[0][0]\n is not an obstacle.",
    "temas": [
      "Array",
      "Hash Table",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3515,
    "slug": "shortest-path-in-a-weighted-tree",
    "url": "https://leetcode.com/problems/shortest-path-in-a-weighted-tree/",
    "titulo": "Shortest Path in a Weighted Tree",
    "enunciado": "You are given an integer \nn\n and an undirected, weighted tree rooted at node 1 with \nn\n nodes numbered from 1 to \nn\n. This is represented by a 2D array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n indicates an undirected edge from node \nu\ni\n to \nv\ni\n with weight \nw\ni\n.\n\n\nYou are also given a 2D integer array \nqueries\n of length \nq\n, where each \nqueries[i]\n is either:\n\n\n\n\n[1, u, v, w']\n – \nUpdate\n the weight of the edge between nodes \nu\n and \nv\n to \nw'\n, where \n(u, v)\n is guaranteed to be an edge present in \nedges\n.\n\n\n[2, x]\n – \nCompute\n the \nshortest\n path distance from the root node 1 to node \nx\n.\n\n\n\n\nReturn an integer array \nanswer\n, where \nanswer[i]\n is the \nshortest\n path distance from node 1 to \nx\n for the \ni\nth\n query of \n[2, x]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 2, edges = [[1,2,7]], queries = [[2,2],[1,1,2,4],[2,2]]\n\n\nOutput:\n \n[7,4]\n\n\nExplanation:\n\n\n\n\n\n\nQuery \n[2,2]\n: The shortest path from root node 1 to node 2 is 7.\n\n\nQuery \n[1,1,2,4]\n: The weight of edge \n(1,2)\n changes from 7 to 4.\n\n\nQuery \n[2,2]\n: The shortest path from root node 1 to node 2 is 4.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, edges = [[1,2,2],[1,3,4]], queries = [[2,1],[2,3],[1,1,3,7],[2,2],[2,3]]\n\n\nOutput:\n \n[0,4,2,7]\n\n\nExplanation:\n\n\n\n\n\n\nQuery \n[2,1]\n: The shortest path from root node 1 to node 1 is 0.\n\n\nQuery \n[2,3]\n: The shortest path from root node 1 to node 3 is 4.\n\n\nQuery \n[1,1,3,7]\n: The weight of edge \n(1,3)\n changes from 4 to 7.\n\n\nQuery \n[2,2]\n: The shortest path from root node 1 to node 2 is 2.\n\n\nQuery \n[2,3]\n: The shortest path from root node 1 to node 3 is 7.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 4, edges = [[1,2,2],[2,3,1],[3,4,5]], queries = [[2,4],[2,3],[1,2,3,3],[2,2],[2,3]]\n\n\nOutput:\n [8,3,2,5]\n\n\nExplanation:\n\n\n\n\n\n\nQuery \n[2,4]\n: The shortest path from root node 1 to node 4 consists of edges \n(1,2)\n, \n(2,3)\n, and \n(3,4)\n with weights \n2 + 1 + 5 = 8\n.\n\n\nQuery \n[2,3]\n: The shortest path from root node 1 to node 3 consists of edges \n(1,2)\n and \n(2,3)\n with weights \n2 + 1 = 3\n.\n\n\nQuery \n[1,2,3,3]\n: The weight of edge \n(2,3)\n changes from 1 to 3.\n\n\nQuery \n[2,2]\n: The shortest path from root node 1 to node 2 is 2.\n\n\nQuery \n[2,3]\n: The shortest path from root node 1 to node 3 consists of edges \n(1,2)\n and \n(2,3)\n with updated weights \n2 + 3 = 5\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i] == [u\ni\n, v\ni\n, w\ni\n]\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\n1 <= w\ni\n <= 10\n4\n\n\nThe input is generated such that \nedges\n represents a valid tree.\n\n\n1 <= queries.length == q <= 10\n5\n\n\nqueries[i].length == 2\n or \n4\n\n\n\n\nqueries[i] == [1, u, v, w']\n or,\n\n\nqueries[i] == [2, x]\n\n\n1 <= u, v, x <= n\n\n\n(u, v)\n is always an edge from \nedges\n.\n\n\n1 <= w' <= 10\n4",
    "temas": [
      "Array",
      "Tree",
      "Depth-First Search",
      "Binary Indexed Tree",
      "Segment Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3530,
    "slug": "maximum-profit-from-valid-topological-order-in-dag",
    "url": "https://leetcode.com/problems/maximum-profit-from-valid-topological-order-in-dag/",
    "titulo": "Maximum Profit from Valid Topological Order in DAG",
    "enunciado": "You are given a \nDirected Acyclic Graph (DAG)\n with \nn\n nodes labeled from \n0\n to \nn - 1\n, represented by a 2D array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates a directed edge from node \nu\ni\n to \nv\ni\n. Each node has an associated \nscore\n given in an array \nscore\n, where \nscore[i]\n represents the score of node \ni\n.\n\n\nYou must process the nodes in a \nvalid topological order\n. Each node is assigned a \n1-based position\n in the processing order.\n\n\nThe \nprofit\n is calculated by summing up the product of each node's score and its position in the ordering.\n\n\nReturn the \nmaximum \npossible profit achievable with an optimal topological order.\n\n\nA \ntopological order\n of a DAG is a linear ordering of its nodes such that for every directed edge \nu → v\n, node \nu\n comes before \nv\n in the ordering.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 2, edges = [[0,1]], score = [2,3]\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\nNode 1 depends on node 0, so a valid order is \n[0, 1]\n.\n\n\n\n\n\n\n\n\nNode\n\n\nProcessing Order\n\n\nScore\n\n\nMultiplier\n\n\nProfit Calculation\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1st\n\n\n2\n\n\n1\n\n\n2 × 1 = 2\n\n\n\n\n\n\n1\n\n\n2nd\n\n\n3\n\n\n2\n\n\n3 × 2 = 6\n\n\n\n\n\n\n\n\nThe maximum total profit achievable over all valid topological orders is \n2 + 6 = 8\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, edges = [[0,1],[0,2]], score = [1,6,3]\n\n\nOutput:\n \n25\n\n\nExplanation:\n\n\n\n\nNodes 1 and 2 depend on node 0, so the most optimal valid order is \n[0, 2, 1]\n.\n\n\n\n\n\n\n\n\nNode\n\n\nProcessing Order\n\n\nScore\n\n\nMultiplier\n\n\nProfit Calculation\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1st\n\n\n1\n\n\n1\n\n\n1 × 1 = 1\n\n\n\n\n\n\n2\n\n\n2nd\n\n\n3\n\n\n2\n\n\n3 × 2 = 6\n\n\n\n\n\n\n1\n\n\n3rd\n\n\n6\n\n\n3\n\n\n6 × 3 = 18\n\n\n\n\n\n\n\n\nThe maximum total profit achievable over all valid topological orders is \n1 + 6 + 18 = 25\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == score.length <= 22\n\n\n1 <= score[i] <= 10\n5\n\n\n0 <= edges.length <= n * (n - 1) / 2\n\n\nedges[i] == [u\ni\n, v\ni\n]\n denotes a directed edge from \nu\ni\n to \nv\ni\n.\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\nu\ni\n != v\ni\n\n\nThe input graph is \nguaranteed\n to be a \nDAG\n.\n\n\nThere are no duplicate edges.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Graph",
      "Topological Sort",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3537,
    "slug": "fill-a-special-grid",
    "url": "https://leetcode.com/problems/fill-a-special-grid/",
    "titulo": "Fill a Special Grid",
    "enunciado": "You are given a non-negative integer \nn\n representing a \n2\nn\n x 2\nn\n grid. You must fill the grid with integers from 0 to \n2\n2n\n - 1\n to make it \nspecial\n. A grid is \nspecial\n if it satisfies \nall\n the following conditions:\n\n\n\n\nAll numbers in the top-right quadrant are smaller than those in the bottom-right quadrant.\n\n\nAll numbers in the bottom-right quadrant are smaller than those in the bottom-left quadrant.\n\n\nAll numbers in the bottom-left quadrant are smaller than those in the top-left quadrant.\n\n\nEach of its quadrants is also a special grid.\n\n\n\n\nReturn the \nspecial\n \n2\nn\n x 2\nn\n grid.\n\n\nNote\n: Any 1x1 grid is special.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 0\n\n\nOutput:\n \n[[0]]\n\n\nExplanation:\n\n\nThe only number that can be placed is 0, and there is only one possible position in the grid.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 1\n\n\nOutput:\n \n[[3,0],[2,1]]\n\n\nExplanation:\n\n\nThe numbers in each quadrant are:\n\n\n\n\nTop-right: 0\n\n\nBottom-right: 1\n\n\nBottom-left: 2\n\n\nTop-left: 3\n\n\n\n\nSince \n0 < 1 < 2 < 3\n, this satisfies the given constraints.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 2\n\n\nOutput:\n \n[[15,12,3,0],[14,13,2,1],[11,8,7,4],[10,9,6,5]]\n\n\nExplanation:\n\n\n\n\nThe numbers in each quadrant are:\n\n\n\n\nTop-right: 3, 0, 2, 1\n\n\nBottom-right: 7, 4, 6, 5\n\n\nBottom-left: 11, 8, 10, 9\n\n\nTop-left: 15, 12, 14, 13\n\n\nmax(3, 0, 2, 1) < min(7, 4, 6, 5)\n\n\nmax(7, 4, 6, 5) < min(11, 8, 10, 9)\n\n\nmax(11, 8, 10, 9) < min(15, 12, 14, 13)\n\n\n\n\nThis satisfies the first three requirements. Additionally, each quadrant is also a special grid. Thus, this is a special grid.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10",
    "temas": [
      "Array",
      "Divide and Conquer",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3529,
    "slug": "count-cells-in-overlapping-horizontal-and-vertical-substrings",
    "url": "https://leetcode.com/problems/count-cells-in-overlapping-horizontal-and-vertical-substrings/",
    "titulo": "Count Cells in Overlapping Horizontal and Vertical Substrings",
    "enunciado": "You are given an \nm x n\n matrix \ngrid\n consisting of characters and a string \npattern\n.\n\n\nA \nhorizontal substring\n is a contiguous sequence of characters read from left to right. If the end of a row is reached before the substring is complete, it wraps to the first column of the next row and continues as needed. You do \nnot\n wrap from the bottom row back to the top.\n\n\nA \nvertical substring\n is a contiguous sequence of characters read from top to bottom. If the bottom of a column is reached before the substring is complete, it wraps to the first row of the next column and continues as needed. You do \nnot\n wrap from the last column back to the first.\n\n\nCount the number of cells in the matrix that satisfy the following condition:\n\n\n\n\nThe cell must be part of \nat least\n one horizontal substring and \nat least\n one vertical substring, where \nboth\n substrings are equal to the given \npattern\n.\n\n\n\n\nReturn the count of these cells.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \ngrid = [[\"a\",\"a\",\"c\",\"c\"],[\"b\",\"b\",\"b\",\"c\"],[\"a\",\"a\",\"b\",\"a\"],[\"c\",\"a\",\"a\",\"c\"],[\"a\",\"a\",\"b\",\"a\"]], pattern = \"abaca\"\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe pattern \n\"abaca\"\n appears once as a horizontal substring (colored blue) and once as a vertical substring (colored red), intersecting at one cell (colored purple).\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \ngrid = [[\"c\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"b\",\"a\"],[\"b\",\"b\",\"a\",\"a\"],[\"a\",\"a\",\"b\",\"a\"]], pattern = \"aba\"\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nThe cells colored above are all part of at least one horizontal and one vertical substring matching the pattern \n\"aba\"\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[\"a\"]], pattern = \"a\"\n\n\nOutput:\n 1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 1000\n\n\n1 <= m * n <= 10\n5\n\n\n1 <= pattern.length <= m * n\n\n\ngrid\n and \npattern\n consist of only lowercase English letters.",
    "temas": [
      "Array",
      "String",
      "Rolling Hash",
      "String Matching",
      "Matrix",
      "Hash Function"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3531,
    "slug": "count-covered-buildings",
    "url": "https://leetcode.com/problems/count-covered-buildings/",
    "titulo": "Count Covered Buildings",
    "enunciado": "You are given a positive integer \nn\n, representing an \nn x n\n city. You are also given a 2D grid \nbuildings\n, where \nbuildings[i] = [x, y]\n denotes a \nunique\n building located at coordinates \n[x, y]\n.\n\n\nA building is \ncovered\n if there is at least one building in all \nfour\n directions: left, right, above, and below.\n\n\nReturn the number of \ncovered\n buildings.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nn = 3, buildings = [[1,2],[2,2],[3,2],[2,1],[2,3]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nOnly building \n[2,2]\n is covered as it has at least one building:\n\n\t\n\n\nabove (\n[1,2]\n)\n\n\nbelow (\n[3,2]\n)\n\n\nleft (\n[2,1]\n)\n\n\nright (\n[2,3]\n)\n\n\n\n\n\n\nThus, the count of covered buildings is 1.\n\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nn = 3, buildings = [[1,1],[1,2],[2,1],[2,2]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\nNo building has at least one building in all four directions.\n\n\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n \nn = 5, buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nOnly building \n[3,3]\n is covered as it has at least one building:\n\n\t\n\n\nabove (\n[1,3]\n)\n\n\nbelow (\n[5,3]\n)\n\n\nleft (\n[3,2]\n)\n\n\nright (\n[3,5]\n)\n\n\n\n\n\n\nThus, the count of covered buildings is 1.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n1 <= buildings.length <= 10\n5\n \n\n\nbuildings[i] = [x, y]\n\n\n1 <= x, y <= n\n\n\nAll coordinates of \nbuildings\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3493,
    "slug": "properties-graph",
    "url": "https://leetcode.com/problems/properties-graph/",
    "titulo": "Properties Graph",
    "enunciado": "You are given a 2D integer array \nproperties\n having dimensions \nn x m\n and an integer \nk\n.\n\n\nDefine a function \nintersect(a, b)\n that returns the \nnumber of distinct integers\n common to both arrays \na\n and \nb\n.\n\n\nConstruct an \nundirected\n graph where each index \ni\n corresponds to \nproperties[i]\n. There is an edge between node \ni\n and node \nj\n if and only if \nintersect(properties[i], properties[j]) >= k\n, where \ni\n and \nj\n are in the range \n[0, n - 1]\n and \ni != j\n.\n\n\nReturn the number of \nconnected components\n in the resulting graph.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nproperties = [[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k = 1\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe graph formed has 3 connected components:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nproperties = [[1,2,3],[2,3,4],[4,3,5]], k = 2\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe graph formed has 1 connected component:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nproperties = [[1,1],[1,1]], k = 2\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nintersect(properties[0], properties[1]) = 1\n, which is less than \nk\n. This means there is no edge between \nproperties[0]\n and \nproperties[1]\n in the graph.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == properties.length <= 100\n\n\n1 <= m == properties[i].length <= 100\n\n\n1 <= properties[i][j] <= 100\n\n\n1 <= k <= m",
    "temas": [
      "Array",
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3486,
    "slug": "longest-special-path-ii",
    "url": "https://leetcode.com/problems/longest-special-path-ii/",
    "titulo": "Longest Special Path II",
    "enunciado": "You are given an undirected tree rooted at node \n0\n, with \nn\n nodes numbered from \n0\n to \nn - 1\n. This is represented by a 2D array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n, length\ni\n]\n indicates an edge between nodes \nu\ni\n and \nv\ni\n with length \nlength\ni\n. You are also given an integer array \nnums\n, where \nnums[i]\n represents the value at node \ni\n.\n\n\nA \nspecial path\n is defined as a \ndownward\n path from an ancestor node to a descendant node in which all node values are \ndistinct\n, except for \nat most\n one value that may appear twice.\n\n\nReturn an array \nresult\n of size 2, where \nresult[0]\n is the \nlength\n of the \nlongest\n special path, and \nresult[1]\n is the \nminimum\n number of nodes in all \npossible\n \nlongest\n special paths.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1,1],[1,2,3],[1,3,1],[2,4,6],[4,7,2],[3,5,2],[3,6,5],[6,8,3]], nums = [1,1,0,3,1,2,1,1,0]\n\n\nOutput:\n \n[9,3]\n\n\nExplanation:\n\n\nIn the image below, nodes are colored by their corresponding values in \nnums\n.\n\n\n\n\nThe longest special paths are \n1 -> 2 -> 4\n and \n1 -> 3 -> 6 -> 8\n, both having a length of 9. The minimum number of nodes across all longest special paths is 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[1,0,3],[0,2,4],[0,3,5]], nums = [1,1,0,2]\n\n\nOutput:\n \n[5,2]\n\n\nExplanation:\n\n\n\n\nThe longest path is \n0 -> 3\n consisting of 2 nodes with a length of 5.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\n1 <= length\ni\n <= 10\n3\n\n\nnums.length == n\n\n\n0 <= nums[i] <= 5 * 10\n4\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3464,
    "slug": "maximize-the-distance-between-points-on-a-square",
    "url": "https://leetcode.com/problems/maximize-the-distance-between-points-on-a-square/",
    "titulo": "Maximize the Distance Between Points on a Square",
    "enunciado": "You are given an integer \nside\n, representing the edge length of a square with corners at \n(0, 0)\n, \n(0, side)\n, \n(side, 0)\n, and \n(side, side)\n on a Cartesian plane.\n\n\nYou are also given a \npositive\n integer \nk\n and a 2D integer array \npoints\n, where \npoints[i] = [x\ni\n, y\ni\n]\n represents the coordinate of a point lying on the \nboundary\n of the square.\n\n\nYou need to select \nk\n elements among \npoints\n such that the \nminimum\n Manhattan distance between any two points is \nmaximized\n.\n\n\nReturn the \nmaximum\n possible \nminimum\n Manhattan distance between the selected \nk\n points.\n\n\nThe Manhattan Distance between two cells \n(x\ni\n, y\ni\n)\n and \n(x\nj\n, y\nj\n)\n is \n|x\ni\n - x\nj\n| + |y\ni\n - y\nj\n|\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nside = 2, points = [[0,2],[2,0],[2,2],[0,0]], k = 4\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nSelect all four points.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nside = 2, points = [[0,0],[1,2],[2,0],[2,2],[2,1]], k = 4\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nSelect the points \n(0, 0)\n, \n(2, 0)\n, \n(2, 2)\n, and \n(2, 1)\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nside = 2, points = [[0,0],[0,1],[0,2],[1,2],[2,0],[2,2],[2,1]], k = 5\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nSelect the points \n(0, 0)\n, \n(0, 1)\n, \n(0, 2)\n, \n(1, 2)\n, and \n(2, 2)\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= side <= 10\n9\n\n\n4 <= points.length <= min(4 * side, 15 * 10\n3\n)\n\n\npoints[i] == [xi, yi]\n\n\nThe input is generated such that:\n\t\n\n\npoints[i]\n lies on the boundary of the square.\n\n\nAll \npoints[i]\n are \nunique\n.\n\n\n\n\n\n\n4 <= k <= min(25, points.length)",
    "temas": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3454,
    "slug": "separate-squares-ii",
    "url": "https://leetcode.com/problems/separate-squares-ii/",
    "titulo": "Separate Squares II",
    "enunciado": "You are given a 2D integer array \nsquares\n. Each \nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.\n\n\nFind the \nminimum\n y-coordinate value of a horizontal line such that the total area covered by squares above the line \nequals\n the total area covered by squares below the line.\n\n\nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\nNote\n: Squares \nmay\n overlap. Overlapping areas should be counted \nonly once\n in this version.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nsquares = [[0,0,1],[2,2,1]]\n\n\nOutput:\n \n1.00000\n\n\nExplanation:\n\n\n\n\nAny horizontal line between \ny = 1\n and \ny = 2\n results in an equal split, with 1 square unit above and 1 square unit below. The minimum y-value is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nsquares = [[0,0,2],[1,1,1]]\n\n\nOutput:\n \n1.00000\n\n\nExplanation:\n\n\n\n\nSince the blue square overlaps with the red square, it will not be counted again. Thus, the line \ny = 1\n splits the squares into two equal parts.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= squares.length <= 5 * 10\n4\n\n\nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n\n\nsquares[i].length == 3\n\n\n0 <= x\ni\n, y\ni\n <= 10\n9\n\n\n1 <= l\ni\n <= 10\n9\n\n\nThe total area of all the squares will not exceed \n10\n15\n.",
    "temas": [
      "Array",
      "Binary Search",
      "Segment Tree",
      "Line Sweep"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3453,
    "slug": "separate-squares-i",
    "url": "https://leetcode.com/problems/separate-squares-i/",
    "titulo": "Separate Squares I",
    "enunciado": "You are given a 2D integer array \nsquares\n. Each \nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.\n\n\nFind the \nminimum\n y-coordinate value of a horizontal line such that the total area of the squares above the line \nequals\n the total area of the squares below the line.\n\n\nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\nNote\n: Squares \nmay\n overlap. Overlapping areas should be counted \nmultiple times\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nsquares = [[0,0,1],[2,2,1]]\n\n\nOutput:\n \n1.00000\n\n\nExplanation:\n\n\n\n\nAny horizontal line between \ny = 1\n and \ny = 2\n will have 1 square unit above it and 1 square unit below it. The lowest option is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nsquares = [[0,0,2],[1,1,1]]\n\n\nOutput:\n \n1.16667\n\n\nExplanation:\n\n\n\n\nThe areas are:\n\n\n\n\nBelow the line: \n7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5\n.\n\n\nAbove the line: \n5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5\n.\n\n\n\n\nSince the areas above and below the line are equal, the output is \n7/6 = 1.16667\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= squares.length <= 5 * 10\n4\n\n\nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n\n\nsquares[i].length == 3\n\n\n0 <= x\ni\n, y\ni\n <= 10\n9\n\n\n1 <= l\ni\n <= 10\n9\n\n\nThe total area of all the squares will not exceed \n10\n12\n.",
    "temas": [
      "Array",
      "Binary Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3446,
    "slug": "sort-matrix-by-diagonals",
    "url": "https://leetcode.com/problems/sort-matrix-by-diagonals/",
    "titulo": "Sort Matrix by Diagonals",
    "enunciado": "You are given an \nn x n\n square matrix of integers \ngrid\n. Return the matrix such that:\n\n\n\n\nThe diagonals in the \nbottom-left triangle\n (including the middle diagonal) are sorted in \nnon-increasing order\n.\n\n\nThe diagonals in the \ntop-right triangle\n are sorted in \nnon-decreasing order\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,7,3],[9,8,2],[4,5,6]]\n\n\nOutput:\n \n[[8,2,3],[9,6,7],[4,5,1]]\n\n\nExplanation:\n\n\n\n\nThe diagonals with a black arrow (bottom-left triangle) should be sorted in non-increasing order:\n\n\n\n\n[1, 8, 6]\n becomes \n[8, 6, 1]\n.\n\n\n[9, 5]\n and \n[4]\n remain unchanged.\n\n\n\n\nThe diagonals with a blue arrow (top-right triangle) should be sorted in non-decreasing order:\n\n\n\n\n[7, 2]\n becomes \n[2, 7]\n.\n\n\n[3]\n remains unchanged.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[0,1],[1,2]]\n\n\nOutput:\n \n[[2,1],[1,0]]\n\n\nExplanation:\n\n\n\n\nThe diagonals with a black arrow must be non-increasing, so \n[0, 2]\n is changed to \n[2, 0]\n. The other diagonals are already in the correct order.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1]]\n\n\nOutput:\n \n[[1]]\n\n\nExplanation:\n\n\nDiagonals with exactly one element are already in order, so no changes are needed.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\ngrid.length == grid[i].length == n\n\n\n1 <= n <= 10\n\n\n-10\n5\n <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Sorting",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3439,
    "slug": "reschedule-meetings-for-maximum-free-time-i",
    "url": "https://leetcode.com/problems/reschedule-meetings-for-maximum-free-time-i/",
    "titulo": "Reschedule Meetings for Maximum Free Time I",
    "enunciado": "You are given an integer \neventTime\n denoting the duration of an event, where the event occurs from time \nt = 0\n to time \nt = eventTime\n.\n\n\nYou are also given two integer arrays \nstartTime\n and \nendTime\n, each of length \nn\n. These represent the start and end time of \nn\n \nnon-overlapping\n meetings, where the \ni\nth\n meeting occurs during the time \n[startTime[i], endTime[i]]\n.\n\n\nYou can reschedule \nat most\n \nk\n meetings by moving their start time while maintaining the \nsame duration\n, to \nmaximize\n the \nlongest\n \ncontinuous period of free time\n during the event.\n\n\nThe \nrelative\n order of all the meetings should stay the\n same\n and they should remain non-overlapping.\n\n\nReturn the \nmaximum\n amount of free time possible after rearranging the meetings.\n\n\nNote\n that the meetings can \nnot\n be rescheduled to a time outside the event.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \neventTime = 5, k = 1, startTime = [1,3], endTime = [2,5]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nReschedule the meeting at \n[1, 2]\n to \n[2, 3]\n, leaving no meetings during the time \n[0, 2]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \neventTime = 10, k = 1, startTime = [0,2,9], endTime = [1,4,10]\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\n\nReschedule the meeting at \n[2, 4]\n to \n[1, 3]\n, leaving no meetings during the time \n[3, 9]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \neventTime = 5, k = 2, startTime = [0,1,2,3,4], endTime = [1,2,3,4,5]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThere is no time during the event not occupied by meetings.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= eventTime <= 10\n9\n\n\nn == startTime.length == endTime.length\n\n\n2 <= n <= 10\n5\n\n\n1 <= k <= n\n\n\n0 <= startTime[i] < endTime[i] <= eventTime\n\n\nendTime[i] <= startTime[i + 1]\n where \ni\n lies in the range \n[0, n - 2]\n.",
    "temas": [
      "Array",
      "Greedy",
      "Sliding Window"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3440,
    "slug": "reschedule-meetings-for-maximum-free-time-ii",
    "url": "https://leetcode.com/problems/reschedule-meetings-for-maximum-free-time-ii/",
    "titulo": "Reschedule Meetings for Maximum Free Time II",
    "enunciado": "You are given an integer \neventTime\n denoting the duration of an event. You are also given two integer arrays \nstartTime\n and \nendTime\n, each of length \nn\n.\n\n\nThese represent the start and end times of \nn\n \nnon-overlapping\n meetings that occur during the event between time \nt = 0\n and time \nt = eventTime\n, where the \ni\nth\n meeting occurs during the time \n[startTime[i], endTime[i]].\n\n\nYou can reschedule \nat most \none meeting by moving its start time while maintaining the \nsame duration\n, such that the meetings remain non-overlapping, to \nmaximize\n the \nlongest\n \ncontinuous period of free time\n during the event.\n\n\nReturn the \nmaximum\n amount of free time possible after rearranging the meetings.\n\n\nNote\n that the meetings can \nnot\n be rescheduled to a time outside the event and they should remain non-overlapping.\n\n\nNote:\n \nIn this version\n, it is \nvalid\n for the relative ordering of the meetings to change after rescheduling one meeting.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \neventTime = 5, startTime = [1,3], endTime = [2,5]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nReschedule the meeting at \n[1, 2]\n to \n[2, 3]\n, leaving no meetings during the time \n[0, 2]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \neventTime = 10, startTime = [0,7,9], endTime = [1,8,10]\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\n\n\nReschedule the meeting at \n[0, 1]\n to \n[8, 9]\n, leaving no meetings during the time \n[0, 7]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \neventTime = 10, startTime = [0,3,7,9], endTime = [1,4,8,10]\n\n\nOutput:\n 6\n\n\nExplanation:\n\n\n\n\nReschedule the meeting at \n[3, 4]\n to \n[8, 9]\n, leaving no meetings during the time \n[1, 7]\n.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \neventTime = 5, startTime = [0,1,2,3,4], endTime = [1,2,3,4,5]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThere is no time during the event not occupied by meetings.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= eventTime <= 10\n9\n\n\nn == startTime.length == endTime.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= startTime[i] < endTime[i] <= eventTime\n\n\nendTime[i] <= startTime[i + 1]\n where \ni\n lies in the range \n[0, n - 2]\n.",
    "temas": [
      "Array",
      "Greedy",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3426,
    "slug": "manhattan-distances-of-all-arrangements-of-pieces",
    "url": "https://leetcode.com/problems/manhattan-distances-of-all-arrangements-of-pieces/",
    "titulo": "Manhattan Distances of All Arrangements of Pieces",
    "enunciado": "You are given three integers \nm\n, \nn\n, and \nk\n.\n\n\nThere is a rectangular grid of size \nm × n\n containing \nk\n identical pieces. Return the sum of Manhattan distances between every pair of pieces over all \nvalid arrangements\n of pieces.\n\n\nA \nvalid arrangement\n is a placement of all \nk\n pieces on the grid with \nat most\n one piece per cell.\n\n\nSince the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\nThe Manhattan Distance between two cells \n(x\ni\n, y\ni\n)\n and \n(x\nj\n, y\nj\n)\n is \n|x\ni\n - x\nj\n| + |y\ni\n - y\nj\n|\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nm = 2, n = 2, k = 2\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\nThe valid arrangements of pieces on the board are:\n\n\n\n\n\n\nIn the first 4 arrangements, the Manhattan distance between the two pieces is 1.\n\n\nIn the last 2 arrangements, the Manhattan distance between the two pieces is 2.\n\n\n\n\nThus, the total Manhattan distance across all valid arrangements is \n1 + 1 + 1 + 1 + 2 + 2 = 8\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nm = 1, n = 4, k = 3\n\n\nOutput:\n \n20\n\n\nExplanation:\n\n\nThe valid arrangements of pieces on the board are:\n\n\n\n\n\n\nThe first and last arrangements have a total Manhattan distance of \n1 + 1 + 2 = 4\n.\n\n\nThe middle two arrangements have a total Manhattan distance of \n1 + 2 + 3 = 6\n.\n\n\n\n\nThe total Manhattan distance between all pairs of pieces across all arrangements is \n4 + 6 + 6 + 4 = 20\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 10\n5\n\n\n2 <= m * n <= 10\n5\n\n\n2 <= k <= m * n",
    "temas": [
      "Math",
      "Combinatorics"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 3459,
    "slug": "length-of-longest-v-shaped-diagonal-segment",
    "url": "https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/",
    "titulo": "Length of Longest V-Shaped Diagonal Segment",
    "enunciado": "You are given a 2D integer matrix \ngrid\n of size \nn x m\n, where each element is either \n0\n, \n1\n, or \n2\n.\n\n\nA \nV-shaped diagonal segment\n is defined as:\n\n\n\n\nThe segment starts with \n1\n.\n\n\nThe subsequent elements follow this infinite sequence: \n2, 0, 2, 0, ...\n.\n\n\nThe segment:\n\t\n\n\nStarts \nalong\n a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).\n\n\nContinues the\n sequence\n in the same diagonal direction.\n\n\nMakes\n at most one clockwise 90-degree\n turn\n to another diagonal direction while \nmaintaining\n the sequence.\n\n\n\n\n\n\n\n\n\n\nReturn the \nlength\n of the \nlongest\n \nV-shaped diagonal segment\n. If no valid segment \nexists\n, return 0.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\n\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: \n(0,2) → (1,3) → (2,4)\n, takes a \n90-degree clockwise turn\n at \n(2,4)\n, and continues as \n(3,3) → (4,2)\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\n\n\nThe longest V-shaped diagonal segment has a length of 4 and follows these coordinates: \n(2,3) → (3,2)\n, takes a \n90-degree clockwise turn\n at \n(3,2)\n, and continues as \n(2,1) → (1,0)\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\n\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: \n(0,0) → (1,1) → (2,2) → (3,3) → (4,4)\n.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ngrid = [[1]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe longest V-shaped diagonal segment has a length of 1 and follows these coordinates: \n(0,0)\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nm == grid[i].length\n\n\n1 <= n, m <= 500\n\n\ngrid[i][j]\n is either \n0\n, \n1\n or \n2\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Memoization",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3528,
    "slug": "unit-conversion-i",
    "url": "https://leetcode.com/problems/unit-conversion-i/",
    "titulo": "Unit Conversion I",
    "enunciado": "There are \nn\n types of units indexed from \n0\n to \nn - 1\n. You are given a 2D integer array \nconversions\n of length \nn - 1\n, where \nconversions[i] = [sourceUnit\ni\n, targetUnit\ni\n, conversionFactor\ni\n]\n. This indicates that a single unit of type \nsourceUnit\ni\n is equivalent to \nconversionFactor\ni\n units of type \ntargetUnit\ni\n.\n\n\nReturn an array \nbaseUnitConversion\n of length \nn\n, where \nbaseUnitConversion[i]\n is the number of units of type \ni\n equivalent to a single unit of type 0. Since the answer may be large, return each \nbaseUnitConversion[i]\n \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nconversions = [[0,1,2],[1,2,3]]\n\n\nOutput:\n \n[1,2,6]\n\n\nExplanation:\n\n\n\n\nConvert a single unit of type 0 into 2 units of type 1 using \nconversions[0]\n.\n\n\nConvert a single unit of type 0 into 6 units of type 2 using \nconversions[0]\n, then \nconversions[1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nconversions = [[0,1,2],[0,2,3],[1,3,4],[1,4,5],[2,5,2],[4,6,3],[5,7,4]]\n\n\nOutput:\n \n[1,2,3,8,10,6,30,24]\n\n\nExplanation:\n\n\n\n\nConvert a single unit of type 0 into 2 units of type 1 using \nconversions[0]\n.\n\n\nConvert a single unit of type 0 into 3 units of type 2 using \nconversions[1]\n.\n\n\nConvert a single unit of type 0 into 8 units of type 3 using \nconversions[0]\n, then \nconversions[2]\n.\n\n\nConvert a single unit of type 0 into 10 units of type 4 using \nconversions[0]\n, then \nconversions[3]\n.\n\n\nConvert a single unit of type 0 into 6 units of type 5 using \nconversions[1]\n, then \nconversions[4]\n.\n\n\nConvert a single unit of type 0 into 30 units of type 6 using \nconversions[0]\n, \nconversions[3]\n, then \nconversions[5]\n.\n\n\nConvert a single unit of type 0 into 24 units of type 7 using \nconversions[1]\n, \nconversions[4]\n, then \nconversions[6]\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nconversions.length == n - 1\n\n\n0 <= sourceUnit\ni\n, targetUnit\ni\n < n\n\n\n1 <= conversionFactor\ni\n <= 10\n9\n\n\nIt is guaranteed that unit 0 can be converted into any other unit through a \nunique\n combination of conversions without using any conversions in the opposite direction.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 3419,
    "slug": "minimize-the-maximum-edge-weight-of-graph",
    "url": "https://leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/",
    "titulo": "Minimize the Maximum Edge Weight of Graph",
    "enunciado": "You are given two integers, \nn\n and \nthreshold\n, as well as a \ndirected\n weighted graph of \nn\n nodes numbered from 0 to \nn - 1\n. The graph is represented by a \n2D\n integer array \nedges\n, where \nedges[i] = [A\ni\n, B\ni\n, W\ni\n]\n indicates that there is an edge going from node \nA\ni\n to node \nB\ni\n with weight \nW\ni\n.\n\n\nYou have to remove some edges from this graph (possibly \nnone\n), so that it satisfies the following conditions:\n\n\n\n\nNode 0 must be reachable from all other nodes.\n\n\nThe \nmaximum\n edge weight in the resulting graph is \nminimized\n.\n\n\nEach node has \nat most\n \nthreshold\n outgoing edges.\n\n\n\n\nReturn the \nminimum\n possible value of the \nmaximum\n edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nRemove the edge \n2 -> 0\n. The maximum weight among the remaining edges is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1\n\n\nOutput:\n \n-1\n\n\nExplanation:\n \n\n\nIt is impossible to reach node 0 from node 2.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n \n\n\n\n\nRemove the edges \n1 -> 3\n and \n1 -> 4\n. The maximum weight among the remaining edges is 2.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nn = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1\n\n\nOutput:\n \n-1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n1 <= threshold <= n - 1\n\n\n1 <= edges.length <= min(10\n5\n, n * (n - 1) / 2).\n\n\nedges[i].length == 3\n\n\n0 <= A\ni\n, B\ni\n < n\n\n\nA\ni\n != B\ni\n\n\n1 <= W\ni\n <= 10\n6\n\n\nThere \nmay be\n multiple edges between a pair of nodes, but they must have unique weights.",
    "temas": [
      "Binary Search",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Binary Search",
    "has_image": true
  },
  {
    "id": 3417,
    "slug": "zigzag-grid-traversal-with-skip",
    "url": "https://leetcode.com/problems/zigzag-grid-traversal-with-skip/",
    "titulo": "Zigzag Grid Traversal With Skip",
    "enunciado": "You are given an \nm x n\n 2D array \ngrid\n of \npositive\n integers.\n\n\nYour task is to traverse \ngrid\n in a \nzigzag\n pattern while skipping every \nalternate\n cell.\n\n\nZigzag pattern traversal is defined as following the below actions:\n\n\n\n\nStart at the top-left cell \n(0, 0)\n.\n\n\nMove \nright\n within a row until the end of the row is reached.\n\n\nDrop down to the next row, then traverse \nleft\n until the beginning of the row is reached.\n\n\nContinue \nalternating\n between right and left traversal until every row has been traversed.\n\n\n\n\nNote \nthat you \nmust skip\n every \nalternate\n cell during the traversal.\n\n\nReturn an array of integers \nresult\n containing, \nin order\n, the value of the cells visited during the zigzag traversal with skips.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,2],[3,4]]\n\n\nOutput:\n \n[1,4]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[2,1],[2,1],[2,1]]\n\n\nOutput:\n \n[2,1,2]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1,2,3],[4,5,6],[7,8,9]]\n\n\nOutput:\n \n[1,3,5,7,9]\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == grid.length <= 50\n\n\n2 <= m == grid[i].length <= 50\n\n\n1 <= grid[i][j] <= 2500",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3402,
    "slug": "minimum-operations-to-make-columns-strictly-increasing",
    "url": "https://leetcode.com/problems/minimum-operations-to-make-columns-strictly-increasing/",
    "titulo": "Minimum Operations to Make Columns Strictly Increasing",
    "enunciado": "You are given a \nm x n\n matrix \ngrid\n consisting of \nnon-negative\n integers.\n\n\nIn one operation, you can increment the value of any \ngrid[i][j]\n by 1.\n\n\nReturn the \nminimum\n number of operations needed to make all columns of \ngrid\n \nstrictly increasing\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[3,2],[1,3],[3,4],[0,1]]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\n\n\nTo make the \n0\nth\n column strictly increasing, we can apply 3 operations on \ngrid[1][0]\n, 2 operations on \ngrid[2][0]\n, and 6 operations on \ngrid[3][0]\n.\n\n\nTo make the \n1\nst\n column strictly increasing, we can apply 4 operations on \ngrid[3][1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[3,2,1],[2,1,0],[1,2,3]]\n\n\nOutput:\n \n12\n\n\nExplanation:\n\n\n\n\nTo make the \n0\nth\n column strictly increasing, we can apply 2 operations on \ngrid[1][0]\n, and 4 operations on \ngrid[2][0]\n.\n\n\nTo make the \n1\nst\n column strictly increasing, we can apply 2 operations on \ngrid[1][1]\n, and 2 operations on \ngrid[2][1]\n.\n\n\nTo make the \n2\nnd\n column strictly increasing, we can apply 2 operations on \ngrid[1][2]\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= grid[i][j] < 2500",
    "temas": [
      "Array",
      "Greedy",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3382,
    "slug": "maximum-area-rectangle-with-point-constraints-ii",
    "url": "https://leetcode.com/problems/maximum-area-rectangle-with-point-constraints-ii/",
    "titulo": "Maximum Area Rectangle With Point Constraints II",
    "enunciado": "There are n points on an infinite plane. You are given two integer arrays \nxCoord\n and \nyCoord\n where \n(xCoord[i], yCoord[i])\n represents the coordinates of the \ni\nth\n point.\n\n\nYour task is to find the \nmaximum \narea of a rectangle that:\n\n\n\n\nCan be formed using \nfour\n of these points as its corners.\n\n\nDoes \nnot\n contain any other point inside or on its border.\n\n\nHas its edges \nparallel\n to the axes.\n\n\n\n\nReturn the \nmaximum area\n that you can obtain or -1 if no such rectangle is possible.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nxCoord = [1,1,3,3], yCoord = [1,3,1,3]\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\n\n\nWe can make a rectangle with these 4 points as corners and there is no other point that lies inside or on the border. Hence, the maximum possible area would be 4.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nxCoord = [1,1,3,3,2], yCoord = [1,3,1,3,2]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\n\n\nThere is only one rectangle possible is with points \n[1,1], [1,3], [3,1]\n and \n[3,3]\n but \n[2,2]\n will always lie inside it. Hence, returning -1.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nxCoord = [1,1,3,3,1,3], yCoord = [1,3,1,3,2,2]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nThe maximum area rectangle is formed by the points \n[1,3], [1,2], [3,2], [3,3]\n, which has an area of 2. Additionally, the points \n[1,1], [1,2], [3,1], [3,2]\n also form a valid rectangle with the same area.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= xCoord.length == yCoord.length <= 2 * 10\n5\n\n\n0 <= xCoord[i], yCoord[i] <= 8 * 10\n7\n\n\nAll the given points are \nunique\n.",
    "temas": [
      "Array",
      "Math",
      "Binary Indexed Tree",
      "Segment Tree",
      "Geometry",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3425,
    "slug": "longest-special-path",
    "url": "https://leetcode.com/problems/longest-special-path/",
    "titulo": "Longest Special Path",
    "enunciado": "You are given an undirected tree rooted at node \n0\n with \nn\n nodes numbered from \n0\n to \nn - 1\n, represented by a 2D array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n, length\ni\n]\n indicates an edge between nodes \nu\ni\n and \nv\ni\n with length \nlength\ni\n. You are also given an integer array \nnums\n, where \nnums[i]\n represents the value at node \ni\n.\n\n\nA \nspecial path\n is defined as a \ndownward\n path from an ancestor node to a descendant node such that all the values of the nodes in that path are \nunique\n.\n\n\nNote\n that a path may start and end at the same node.\n\n\nReturn an array \nresult\n of size 2, where \nresult[0]\n is the \nlength\n of the \nlongest\n special path, and \nresult[1]\n is the \nminimum\n number of nodes in all \npossible\n \nlongest\n special paths.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]\n\n\nOutput:\n \n[6,2]\n\n\nExplanation:\n\n\nIn the image below, nodes are colored by their corresponding values in \nnums\n\n\n\n\nThe longest special paths are \n2 -> 5\n and \n0 -> 1 -> 4\n, both having a length of 6. The minimum number of nodes across all longest special paths is 2.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[1,0,8]], nums = [2,2]\n\n\nOutput:\n \n[0,1]\n\n\nExplanation:\n\n\n\n\nThe longest special paths are \n0\n and \n1\n, both having a length of 0. The minimum number of nodes across all longest special paths is 1.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\n1 <= length\ni\n <= 10\n3\n\n\nnums.length == n\n\n\n0 <= nums[i] <= 5 * 10\n4\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3380,
    "slug": "maximum-area-rectangle-with-point-constraints-i",
    "url": "https://leetcode.com/problems/maximum-area-rectangle-with-point-constraints-i/",
    "titulo": "Maximum Area Rectangle With Point Constraints I",
    "enunciado": "You are given an array \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents the coordinates of a point on an infinite plane.\n\n\nYour task is to find the \nmaximum \narea of a rectangle that:\n\n\n\n\nCan be formed using \nfour\n of these points as its corners.\n\n\nDoes \nnot\n contain any other point inside or on its border.\n\n\nHas its edges \nparallel\n to the axes.\n\n\n\n\nReturn the \nmaximum area\n that you can obtain or -1 if no such rectangle is possible.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \npoints = [[1,1],[1,3],[3,1],[3,3]]\n\n\nOutput: \n4\n\n\nExplanation:\n\n\n\n\nWe can make a rectangle with these 4 points as corners and there is no other point that lies inside or on the border\n. Hence, the maximum possible area would be 4.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \npoints = [[1,1],[1,3],[3,1],[3,3],[2,2]]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\n\n\nThere is only one rectangle possible is with points \n[1,1], [1,3], [3,1]\n and \n[3,3]\n but \n[2,2]\n will always lie inside it. Hence, returning -1.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npoints = [[1,1],[1,3],[3,1],[3,3],[1,2],[3,2]]\n\n\nOutput: \n2\n\n\nExplanation:\n\n\n\n\nThe maximum area rectangle is formed by the points \n[1,3], [1,2], [3,2], [3,3]\n, which has an area of 2. Additionally, the points \n[1,1], [1,2], [3,1], [3,2]\n also form a valid rectangle with the same area.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 10\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 100\n\n\nAll the given points are \nunique\n.",
    "temas": [
      "Array",
      "Math",
      "Binary Indexed Tree",
      "Segment Tree",
      "Geometry",
      "Sorting",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3378,
    "slug": "count-connected-components-in-lcm-graph",
    "url": "https://leetcode.com/problems/count-connected-components-in-lcm-graph/",
    "titulo": "Count Connected Components in LCM Graph",
    "enunciado": "You are given an array of integers \nnums\n of size \nn\n and a \npositive\n integer \nthreshold\n.\n\n\nThere is a graph consisting of \nn\n nodes with the \ni\nth\n node having a value of \nnums[i]\n. Two nodes \ni\n and \nj\n in the graph are connected via an \nundirected\n edge if \nlcm(nums[i], nums[j]) <= threshold\n.\n\n\nReturn the number of \nconnected components\n in this graph.\n\n\nA \nconnected component\n is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\n\n\nThe term \nlcm(a, b)\n denotes the \nleast common multiple\n of \na\n and \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,4,8,3,9], threshold = 5\n\n\nOutput:\n \n4\n\n\nExplanation:\n \n\n\n\n\n \n\n\nThe four connected components are \n(2, 4)\n, \n(3)\n, \n(8)\n, \n(9)\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,4,8,3,9,12], threshold = 10\n\n\nOutput:\n \n2\n\n\nExplanation:\n \n\n\n\n\nThe two connected components are \n(2, 3, 4, 8, 9)\n, and \n(12)\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n9\n\n\nAll elements of \nnums\n are unique.\n\n\n1 <= threshold <= 2 * 10\n5",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Union Find",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3367,
    "slug": "maximize-sum-of-weights-after-edge-removals",
    "url": "https://leetcode.com/problems/maximize-sum-of-weights-after-edge-removals/",
    "titulo": "Maximize Sum of Weights after Edge Removals",
    "enunciado": "There exists an \nundirected\n tree with \nn\n nodes numbered \n0\n to \nn - 1\n. You are given a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n with weight \nw\ni\n in the tree.\n\n\nYour task is to remove \nzero or more\n edges such that:\n\n\n\n\nEach node has an edge with \nat most\n \nk\n other nodes, where \nk\n is given.\n\n\nThe sum of the weights of the remaining edges is \nmaximized\n.\n\n\n\n\nReturn the \nmaximum \npossible sum of weights for the remaining edges after making the necessary removals.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1,4],[0,2,2],[2,3,12],[2,4,6]], k = 2\n\n\nOutput:\n \n22\n\n\nExplanation:\n\n\n\n\n\n\nNode 2 has edges with 3 other nodes. We remove the edge \n[0, 2, 2]\n, ensuring that no node has edges with more than \nk = 2\n nodes.\n\n\nThe sum of weights is 22, and we can't achieve a greater sum. Thus, the answer is 22.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[0,1,5],[1,2,10],[0,3,15],[3,4,20],[3,5,5],[0,6,10]], k = 3\n\n\nOutput:\n \n65\n\n\nExplanation:\n\n\n\n\nSince no node has edges connecting it to more than \nk = 3\n nodes, we don't remove any edges.\n\n\nThe sum of weights is 65. Thus, the answer is 65.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n1 <= k <= n - 1\n\n\nedges.length == n - 1\n\n\nedges[i].length == 3\n\n\n0 <= edges[i][0] <= n - 1\n\n\n0 <= edges[i][1] <= n - 1\n\n\n1 <= edges[i][2] <= 10\n6\n\n\nThe input is generated such that \nedges\n form a valid tree.",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 3394,
    "slug": "check-if-grid-can-be-cut-into-sections",
    "url": "https://leetcode.com/problems/check-if-grid-can-be-cut-into-sections/",
    "titulo": "Check if Grid can be Cut into Sections",
    "enunciado": "You are given an integer \nn\n representing the dimensions of an \nn x n\n grid, with the origin at the bottom-left corner of the grid. You are also given a 2D array of coordinates \nrectangles\n, where \nrectangles[i]\n is in the form \n[start\nx\n, start\ny\n, end\nx\n, end\ny\n]\n, representing a rectangle on the grid. Each rectangle is defined as follows:\n\n\n\n\n(start\nx\n, start\ny\n)\n: The bottom-left corner of the rectangle.\n\n\n(end\nx\n, end\ny\n)\n: The top-right corner of the rectangle.\n\n\n\n\nNote \nthat the rectangles do not overlap. Your task is to determine if it is possible to make \neither two horizontal or two vertical cuts\n on the grid such that:\n\n\n\n\nEach of the three resulting sections formed by the cuts contains \nat least\n one rectangle.\n\n\nEvery rectangle belongs to \nexactly\n one section.\n\n\n\n\nReturn \ntrue\n if such cuts can be made; otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5, rectangles = [[1,0,5,2],[0,2,2,4],[3,2,5,3],[0,4,4,5]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nThe grid is shown in the diagram. We can make horizontal cuts at \ny = 2\n and \ny = 4\n. Hence, output is true.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 4, rectangles = [[0,0,1,1],[2,0,3,4],[0,2,2,3],[3,0,4,3]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nWe can make vertical cuts at \nx = 2\n and \nx = 3\n. Hence, output is true.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 4, rectangles = [[0,2,2,4],[1,0,3,2],[2,2,3,4],[3,0,4,2],[3,2,4,4]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nWe cannot make two horizontal or two vertical cuts that satisfy the conditions. Hence, output is false.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n9\n\n\n3 <= rectangles.length <= 10\n5\n\n\n0 <= rectangles[i][0] < rectangles[i][2] <= n\n\n\n0 <= rectangles[i][1] < rectangles[i][3] <= n\n\n\nNo two rectangles overlap.",
    "temas": [
      "Array",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3363,
    "slug": "find-the-maximum-number-of-fruits-collected",
    "url": "https://leetcode.com/problems/find-the-maximum-number-of-fruits-collected/",
    "titulo": "Find the Maximum Number of Fruits Collected",
    "enunciado": "There is a game dungeon comprised of \nn x n\n rooms arranged in a grid.\n\n\nYou are given a 2D array \nfruits\n of size \nn x n\n, where \nfruits[i][j]\n represents the number of fruits in the room \n(i, j)\n. Three children will play in the game dungeon, with \ninitial\n positions at the corner rooms \n(0, 0)\n, \n(0, n - 1)\n, and \n(n - 1, 0)\n.\n\n\nThe children will make \nexactly\n \nn - 1\n moves according to the following rules to reach the room \n(n - 1, n - 1)\n:\n\n\n\n\nThe child starting from \n(0, 0)\n must move from their current room \n(i, j)\n to one of the rooms \n(i + 1, j + 1)\n, \n(i + 1, j)\n, and \n(i, j + 1)\n if the target room exists.\n\n\nThe child starting from \n(0, n - 1)\n must move from their current room \n(i, j)\n to one of the rooms \n(i + 1, j - 1)\n, \n(i + 1, j)\n, and \n(i + 1, j + 1)\n if the target room exists.\n\n\nThe child starting from \n(n - 1, 0)\n must move from their current room \n(i, j)\n to one of the rooms \n(i - 1, j + 1)\n, \n(i, j + 1)\n, and \n(i + 1, j + 1)\n if the target room exists.\n\n\n\n\nWhen a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.\n\n\nReturn the \nmaximum\n number of fruits the children can collect from the dungeon.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nfruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]\n\n\nOutput:\n \n100\n\n\nExplanation:\n\n\n\n\nIn this example:\n\n\n\n\nThe 1\nst\n child (green) moves on the path \n(0,0) -> (1,1) -> (2,2) -> (3, 3)\n.\n\n\nThe 2\nnd\n child (red) moves on the path \n(0,3) -> (1,2) -> (2,3) -> (3, 3)\n.\n\n\nThe 3\nrd\n child (blue) moves on the path \n(3,0) -> (3,1) -> (3,2) -> (3, 3)\n.\n\n\n\n\nIn total they collect \n1 + 6 + 11 + 16 + 4 + 8 + 12 + 13 + 14 + 15 = 100\n fruits.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nfruits = [[1,1],[1,1]]\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nIn this example:\n\n\n\n\nThe 1\nst\n child moves on the path \n(0,0) -> (1,1)\n.\n\n\nThe 2\nnd\n child moves on the path \n(0,1) -> (1,1)\n.\n\n\nThe 3\nrd\n child moves on the path \n(1,0) -> (1,1)\n.\n\n\n\n\nIn total they collect \n1 + 1 + 1 + 1 = 4\n fruits.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == fruits.length == fruits[i].length <= 1000\n\n\n0 <= fruits[i][j] <= 1000",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3373,
    "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-ii",
    "url": "https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii/",
    "titulo": "Maximize the Number of Target Nodes After Connecting Trees II",
    "enunciado": "There exist two \nundirected \ntrees with \nn\n and \nm\n nodes, labeled from \n[0, n - 1]\n and \n[0, m - 1]\n, respectively.\n\n\nYou are given two 2D integer arrays \nedges1\n and \nedges2\n of lengths \nn - 1\n and \nm - 1\n, respectively, where \nedges1[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the first tree and \nedges2[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the second tree.\n\n\nNode \nu\n is \ntarget\n to node \nv\n if the number of edges on the path from \nu\n to \nv\n is even. \nNote\n that a node is \nalways\n \ntarget\n to itself.\n\n\nReturn an array of \nn\n integers \nanswer\n, where \nanswer[i]\n is the \nmaximum\n possible number of nodes that are \ntarget\n to node \ni\n of the first tree if you had to connect one node from the first tree to another node in the second tree.\n\n\nNote\n that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]]\n\n\nOutput:\n \n[8,7,7,8,8]\n\n\nExplanation:\n\n\n\n\nFor \ni = 0\n, connect node 0 from the first tree to node 0 from the second tree.\n\n\nFor \ni = 1\n, connect node 1 from the first tree to node 4 from the second tree.\n\n\nFor \ni = 2\n, connect node 2 from the first tree to node 7 from the second tree.\n\n\nFor \ni = 3\n, connect node 3 from the first tree to node 0 from the second tree.\n\n\nFor \ni = 4\n, connect node 4 from the first tree to node 4 from the second tree.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]]\n\n\nOutput:\n \n[3,6,6,6,6]\n\n\nExplanation:\n\n\nFor every \ni\n, connect node \ni\n of the first tree with any node of the second tree.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n, m <= 10\n5\n\n\nedges1.length == n - 1\n\n\nedges2.length == m - 1\n\n\nedges1[i].length == edges2[i].length == 2\n\n\nedges1[i] = [a\ni\n, b\ni\n]\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nedges2[i] = [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < m\n\n\nThe input is generated such that \nedges1\n and \nedges2\n represent valid trees.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 3372,
    "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-i",
    "url": "https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/",
    "titulo": "Maximize the Number of Target Nodes After Connecting Trees I",
    "enunciado": "There exist two \nundirected \ntrees with \nn\n and \nm\n nodes, with \ndistinct\n labels in ranges \n[0, n - 1]\n and \n[0, m - 1]\n, respectively.\n\n\nYou are given two 2D integer arrays \nedges1\n and \nedges2\n of lengths \nn - 1\n and \nm - 1\n, respectively, where \nedges1[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the first tree and \nedges2[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the second tree. You are also given an integer \nk\n.\n\n\nNode \nu\n is \ntarget\n to node \nv\n if the number of edges on the path from \nu\n to \nv\n is less than or equal to \nk\n. \nNote\n that a node is \nalways\n \ntarget\n to itself.\n\n\nReturn an array of \nn\n integers \nanswer\n, where \nanswer[i]\n is the \nmaximum\n possible number of nodes \ntarget\n to node \ni\n of the first tree if you have to connect one node from the first tree to another node in the second tree.\n\n\nNote\n that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]], k = 2\n\n\nOutput:\n \n[9,7,9,8,8]\n\n\nExplanation:\n\n\n\n\nFor \ni = 0\n, connect node 0 from the first tree to node 0 from the second tree.\n\n\nFor \ni = 1\n, connect node 1 from the first tree to node 0 from the second tree.\n\n\nFor \ni = 2\n, connect node 2 from the first tree to node 4 from the second tree.\n\n\nFor \ni = 3\n, connect node 3 from the first tree to node 4 from the second tree.\n\n\nFor \ni = 4\n, connect node 4 from the first tree to node 4 from the second tree.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]], k = 1\n\n\nOutput:\n \n[6,3,3,3,3]\n\n\nExplanation:\n\n\nFor every \ni\n, connect node \ni\n of the first tree with any node of the second tree.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n, m <= 1000\n\n\nedges1.length == n - 1\n\n\nedges2.length == m - 1\n\n\nedges1[i].length == edges2[i].length == 2\n\n\nedges1[i] = [a\ni\n, b\ni\n]\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nedges2[i] = [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < m\n\n\nThe input is generated such that \nedges1\n and \nedges2\n represent valid trees.\n\n\n0 <= k <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 3327,
    "slug": "check-if-dfs-strings-are-palindromes",
    "url": "https://leetcode.com/problems/check-if-dfs-strings-are-palindromes/",
    "titulo": "Check if DFS Strings Are Palindromes",
    "enunciado": "You are given a tree rooted at node 0, consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n. The tree is represented by an array \nparent\n of size \nn\n, where \nparent[i]\n is the parent of node \ni\n. Since node 0 is the root, \nparent[0] == -1\n.\n\n\nYou are also given a string \ns\n of length \nn\n, where \ns[i]\n is the character assigned to node \ni\n.\n\n\nConsider an empty string \ndfsStr\n, and define a recursive function \ndfs(int x)\n that takes a node \nx\n as a parameter and performs the following steps in order:\n\n\n\n\nIterate over each child \ny\n of \nx\n \nin increasing order of their numbers\n, and call \ndfs(y)\n.\n\n\nAdd the character \ns[x]\n to the end of the string \ndfsStr\n.\n\n\n\n\nNote\n that \ndfsStr\n is shared across all recursive calls of \ndfs\n.\n\n\nYou need to find a boolean array \nanswer\n of size \nn\n, where for each index \ni\n from \n0\n to \nn - 1\n, you do the following:\n\n\n\n\nEmpty the string \ndfsStr\n and call \ndfs(i)\n.\n\n\nIf the resulting string \ndfsStr\n is a \npalindrome\n, then set \nanswer[i]\n to \ntrue\n. Otherwise, set \nanswer[i]\n to \nfalse\n.\n\n\n\n\nReturn the array \nanswer\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nparent = [-1,0,0,1,1,2], s = \"aababa\"\n\n\nOutput:\n \n[true,true,false,true,true,true]\n\n\nExplanation:\n\n\n\n\nCalling \ndfs(0)\n results in the string \ndfsStr = \"abaaba\"\n, which is a palindrome.\n\n\nCalling \ndfs(1)\n results in the string \ndfsStr = \"aba\"\n, which is a palindrome.\n\n\nCalling \ndfs(2)\n results in the string \ndfsStr = \"ab\"\n, which is \nnot\n a palindrome.\n\n\nCalling \ndfs(3)\n results in the string \ndfsStr = \"a\"\n, which is a palindrome.\n\n\nCalling \ndfs(4)\n results in the string \ndfsStr = \"b\"\n, which is a palindrome.\n\n\nCalling \ndfs(5)\n results in the string \ndfsStr = \"a\"\n, which is a palindrome.\n\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nparent = [-1,0,0,0,0], s = \"aabcb\"\n\n\nOutput:\n \n[true,true,true,true,true]\n\n\nExplanation:\n\n\nEvery call on \ndfs(x)\n results in a palindrome string.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parent.length == s.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= parent[i] <= n - 1\n for all \ni >= 1\n.\n\n\nparent[0] == -1\n\n\nparent\n represents a valid tree.\n\n\ns\n consists only of lowercase English letters.",
    "temas": [
      "Array",
      "Hash Table",
      "String",
      "Tree",
      "Depth-First Search",
      "Hash Function"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3311,
    "slug": "construct-2d-grid-matching-graph-layout",
    "url": "https://leetcode.com/problems/construct-2d-grid-matching-graph-layout/",
    "titulo": "Construct 2D Grid Matching Graph Layout",
    "enunciado": "You are given a 2D integer array \nedges\n representing an \nundirected\n graph having \nn\n nodes, where \nedges[i] = [u\ni\n, v\ni\n]\n denotes an edge between nodes \nu\ni\n and \nv\ni\n.\n\n\nConstruct a 2D grid that satisfies these conditions:\n\n\n\n\nThe grid contains \nall nodes\n from \n0\n to \nn - 1\n in its cells, with each node appearing exactly \nonce\n.\n\n\nTwo nodes should be in adjacent grid cells (\nhorizontally\n or \nvertically\n) \nif and only if\n there is an edge between them in \nedges\n.\n\n\n\n\nIt is guaranteed that \nedges\n can form a 2D grid that satisfies the conditions.\n\n\nReturn a 2D integer array satisfying the conditions above. If there are multiple solutions, return \nany\n of them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 4, edges = [[0,1],[0,2],[1,3],[2,3]]\n\n\nOutput:\n \n[[3,1],[2,0]]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 5, edges = [[0,1],[1,3],[2,3],[2,4]]\n\n\nOutput:\n \n[[4,2,3,1,0]]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]\n\n\nOutput:\n \n[[8,6,3],[7,4,2],[1,0,5]]\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\n1 <= edges.length <= 10\n5\n\n\nedges[i] = [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n < v\ni\n < n\n\n\nAll the edges are distinct.\n\n\nThe input is generated such that \nedges\n can form a 2D grid that satisfies the conditions.",
    "temas": [
      "Array",
      "Hash Table",
      "Graph",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3331,
    "slug": "find-subtree-sizes-after-changes",
    "url": "https://leetcode.com/problems/find-subtree-sizes-after-changes/",
    "titulo": "Find Subtree Sizes After Changes",
    "enunciado": "You are given a tree rooted at node 0 that consists of \nn\n nodes numbered from \n0\n to \nn - 1\n. The tree is represented by an array \nparent\n of size \nn\n, where \nparent[i]\n is the parent of node \ni\n. Since node 0 is the root, \nparent[0] == -1\n.\n\n\nYou are also given a string \ns\n of length \nn\n, where \ns[i]\n is the character assigned to node \ni\n.\n\n\nWe make the following changes on the tree \none\n time \nsimultaneously\n for all nodes \nx\n from \n1\n to \nn - 1\n:\n\n\n\n\nFind the \nclosest\n node \ny\n to node \nx\n such that \ny\n is an ancestor of \nx\n, and \ns[x] == s[y]\n.\n\n\nIf node \ny\n does not exist, do nothing.\n\n\nOtherwise, \nremove\n the edge between \nx\n and its current parent and make node \ny\n the new parent of \nx\n by adding an edge between them.\n\n\n\n\nReturn an array \nanswer\n of size \nn\n where \nanswer[i]\n is the \nsize\n of the \nsubtree\n rooted at node \ni\n in the \nfinal\n tree.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nparent = [-1,0,0,1,1,1], s = \"abaabc\"\n\n\nOutput:\n \n[6,3,1,1,1,1]\n\n\nExplanation:\n\n\n\n\nThe parent of node 3 will change from node 1 to node 0.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nparent = [-1,0,4,0,1], s = \"abbba\"\n\n\nOutput:\n \n[5,2,1,1,1]\n\n\nExplanation:\n\n\n\n\nThe following changes will happen at the same time:\n\n\n\n\nThe parent of node 4 will change from node 1 to node 0.\n\n\nThe parent of node 2 will change from node 4 to node 1.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parent.length == s.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= parent[i] <= n - 1\n for all \ni >= 1\n.\n\n\nparent[0] == -1\n\n\nparent\n represents a valid tree.\n\n\ns\n consists only of lowercase English letters.",
    "temas": [
      "Array",
      "Hash Table",
      "String",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3276,
    "slug": "select-cells-in-grid-with-maximum-score",
    "url": "https://leetcode.com/problems/select-cells-in-grid-with-maximum-score/",
    "titulo": "Select Cells in Grid With Maximum Score",
    "enunciado": "You are given a 2D matrix \ngrid\n consisting of positive integers.\n\n\nYou have to select \none or more\n cells from the matrix such that the following conditions are satisfied:\n\n\n\n\nNo two selected cells are in the \nsame\n row of the matrix.\n\n\nThe values in the set of selected cells are \nunique\n.\n\n\n\n\nYour score will be the \nsum\n of the values of the selected cells.\n\n\nReturn the \nmaximum\n score you can achieve.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,2,3],[4,3,2],[1,1,1]]\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\nWe can select the cells with values 1, 3, and 4 that are colored above.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[8,7,6],[8,3,2]]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\n\n\nWe can select the cells with values 7 and 8 that are colored above.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= grid.length, grid[i].length <= 10\n\n\n1 <= grid[i][j] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Matrix",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3310,
    "slug": "remove-methods-from-project",
    "url": "https://leetcode.com/problems/remove-methods-from-project/",
    "titulo": "Remove Methods From Project",
    "enunciado": "You are maintaining a project that has \nn\n methods numbered from \n0\n to \nn - 1\n.\n\n\nYou are given two integers \nn\n and \nk\n, and a 2D integer array \ninvocations\n, where \ninvocations[i] = [a\ni\n, b\ni\n]\n indicates that method \na\ni\n invokes method \nb\ni\n.\n\n\nThere is a known bug in method \nk\n. Method \nk\n, along with any method invoked by it, either \ndirectly\n or \nindirectly\n, are considered \nsuspicious\n and we aim to remove them.\n\n\nA group of methods can only be removed if no method \noutside\n the group invokes any methods \nwithin\n it.\n\n\nReturn an array containing all the remaining methods after removing all the \nsuspicious\n methods. You may return the answer in \nany order\n. If it is not possible to remove \nall\n the suspicious methods, \nnone\n should be removed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 4, k = 1, invocations = [[1,2],[0,1],[3,2]]\n\n\nOutput:\n \n[0,1,2,3]\n\n\nExplanation:\n\n\n\n\nMethod 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]]\n\n\nOutput:\n \n[3,4]\n\n\nExplanation:\n\n\n\n\nMethods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 3, k = 2, invocations = [[1,2],[0,1],[2,0]]\n\n\nOutput:\n \n[]\n\n\nExplanation:\n\n\n\n\nAll methods are suspicious. We can remove them.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n0 <= k <= n - 1\n\n\n0 <= invocations.length <= 2 * 10\n5\n\n\ninvocations[i] == [a\ni\n, b\ni\n]\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni\n\n\ninvocations[i] != invocations[j]",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 3283,
    "slug": "maximum-number-of-moves-to-kill-all-pawns",
    "url": "https://leetcode.com/problems/maximum-number-of-moves-to-kill-all-pawns/",
    "titulo": "Maximum Number of Moves to Kill All Pawns",
    "enunciado": "There is a \n50 x 50\n chessboard with \none\n knight and some pawns on it. You are given two integers \nkx\n and \nky\n where \n(kx, ky)\n denotes the position of the knight, and a 2D array \npositions\n where \npositions[i] = [x\ni\n, y\ni\n]\n denotes the position of the pawns on the chessboard.\n\n\nAlice and Bob play a \nturn-based\n game, where Alice goes first. In each player's turn:\n\n\n\n\nThe player \nselects \na pawn that still exists on the board and captures it with the knight in the \nfewest\n possible \nmoves\n. \nNote\n that the player can select \nany\n pawn, it \nmight not\n be one that can be captured in the \nleast\n number of moves.\n\n\nIn the process of capturing the \nselected\n pawn, the knight \nmay\n pass other pawns \nwithout\n capturing them\n. \nOnly\n the \nselected\n pawn can be captured in \nthis\n turn.\n\n\n\n\nAlice is trying to \nmaximize\n the \nsum\n of the number of moves made by \nboth\n players until there are no more pawns on the board, whereas Bob tries to \nminimize\n them.\n\n\nReturn the \nmaximum\n \ntotal\n number of moves made during the game that Alice can achieve, assuming both players play \noptimally\n.\n\n\nNote that in one \nmove, \na chess knight has eight possible positions it can move to, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nkx = 1, ky = 1, positions = [[0,0]]\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\n\n\nThe knight takes 4 moves to reach the pawn at \n(0, 0)\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nkx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\n\n\nAlice picks the pawn at \n(2, 2)\n and captures it in two moves: \n(0, 2) -> (1, 4) -> (2, 2)\n.\n\n\nBob picks the pawn at \n(3, 3)\n and captures it in two moves: \n(2, 2) -> (4, 1) -> (3, 3)\n.\n\n\nAlice picks the pawn at \n(1, 1)\n and captures it in four moves: \n(3, 3) -> (4, 1) -> (2, 2) -> (0, 3) -> (1, 1)\n.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nkx = 0, ky = 0, positions = [[1,2],[2,4]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nAlice picks the pawn at \n(2, 4)\n and captures it in two moves: \n(0, 0) -> (1, 2) -> (2, 4)\n. Note that the pawn at \n(1, 2)\n is not captured.\n\n\nBob picks the pawn at \n(1, 2)\n and captures it in one move: \n(2, 4) -> (1, 2)\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= kx, ky <= 49\n\n\n1 <= positions.length <= 15\n\n\npositions[i].length == 2\n\n\n0 <= positions[i][0], positions[i][1] <= 49\n\n\nAll \npositions[i]\n are unique.\n\n\nThe input is generated such that \npositions[i] != [kx, ky]\n for all \n0 <= i < positions.length\n.",
    "temas": [
      "Array",
      "Math",
      "Bit Manipulation",
      "Breadth-First Search",
      "Game Theory",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3286,
    "slug": "find-a-safe-walk-through-a-grid",
    "url": "https://leetcode.com/problems/find-a-safe-walk-through-a-grid/",
    "titulo": "Find a Safe Walk Through a Grid",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n and an integer \nhealth\n.\n\n\nYou start on the upper-left corner \n(0, 0)\n and would like to get to the lower-right corner \n(m - 1, n - 1)\n.\n\n\nYou can move up, down, left, or right from one cell to another adjacent cell as long as your health \nremains\n \npositive\n.\n\n\nCells \n(i, j)\n with \ngrid[i][j] = 1\n are considered \nunsafe\n and reduce your health by 1.\n\n\nReturn \ntrue\n if you can reach the final cell with a health value of 1 or more, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe final cell can be reached safely by walking along the gray cells below.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nA minimum of 4 health points is needed to reach the final cell safely.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1,1,1],[1,0,1],[1,1,1]], health = 5\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe final cell can be reached safely by walking along the gray cells below.\n\n\n\n\nAny path that does not go through the cell \n(1, 1)\n is unsafe since your health will drop to 0 when reaching the final cell.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n2 <= m * n\n\n\n1 <= health <= m + n\n\n\ngrid[i][j]\n is either 0 or 1.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3274,
    "slug": "check-if-two-chessboard-squares-have-the-same-color",
    "url": "https://leetcode.com/problems/check-if-two-chessboard-squares-have-the-same-color/",
    "titulo": "Check if Two Chessboard Squares Have the Same Color",
    "enunciado": "You are given two strings, \ncoordinate1\n and \ncoordinate2\n, representing the coordinates of a square on an \n8 x 8\n chessboard.\n\n\nBelow is the chessboard for reference.\n\n\n\n\nReturn \ntrue\n if these two squares have the same color and \nfalse\n otherwise.\n\n\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncoordinate1 = \"a1\", coordinate2 = \"c3\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nBoth squares are black.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncoordinate1 = \"a1\", coordinate2 = \"h3\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nSquare \n\"a1\"\n is black and \n\"h3\"\n is white.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\ncoordinate1.length == coordinate2.length == 2\n\n\n'a' <= coordinate1[0], coordinate2[0] <= 'h'\n\n\n'1' <= coordinate1[1], coordinate2[1] <= '8'",
    "temas": [
      "Math",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 3256,
    "slug": "maximum-value-sum-by-placing-three-rooks-i",
    "url": "https://leetcode.com/problems/maximum-value-sum-by-placing-three-rooks-i/",
    "titulo": "Maximum Value Sum by Placing Three Rooks I",
    "enunciado": "You are given a \nm x n\n 2D array \nboard\n representing a chessboard, where \nboard[i][j]\n represents the \nvalue\n of the cell \n(i, j)\n.\n\n\nRooks in the \nsame\n row or column \nattack\n each other. You need to place \nthree\n rooks on the chessboard such that the rooks \ndo not\n \nattack\n each other.\n\n\nReturn the \nmaximum\n sum of the cell \nvalues\n on which the rooks are placed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nboard = \n[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]\n\n\nOutput:\n 4\n\n\nExplanation:\n\n\n\n\nWe can place the rooks in the cells \n(0, 2)\n, \n(1, 3)\n, and \n(2, 1)\n for a sum of \n1 + 1 + 2 = 4\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nboard = [[1,2,3],[4,5,6],[7,8,9]]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\nWe can place the rooks in the cells \n(0, 0)\n, \n(1, 1)\n, and \n(2, 2)\n for a sum of \n1 + 5 + 9 = 15\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nboard = [[1,1,1],[1,1,1],[1,1,1]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nWe can place the rooks in the cells \n(0, 2)\n, \n(1, 1)\n, and \n(2, 0)\n for a sum of \n1 + 1 + 1 = 3\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= m == board.length <= 100\n\n\n3 <= n == board[i].length <= 100\n\n\n-10\n9\n <= board[i][j] <= 10\n9",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3257,
    "slug": "maximum-value-sum-by-placing-three-rooks-ii",
    "url": "https://leetcode.com/problems/maximum-value-sum-by-placing-three-rooks-ii/",
    "titulo": "Maximum Value Sum by Placing Three Rooks II",
    "enunciado": "You are given a \nm x n\n 2D array \nboard\n representing a chessboard, where \nboard[i][j]\n represents the \nvalue\n of the cell \n(i, j)\n.\n\n\nRooks in the \nsame\n row or column \nattack\n each other. You need to place \nthree\n rooks on the chessboard such that the rooks \ndo not\n \nattack\n each other.\n\n\nReturn the \nmaximum\n sum of the cell \nvalues\n on which the rooks are placed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nboard = \n[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]\n\n\nOutput:\n 4\n\n\nExplanation:\n\n\n\n\nWe can place the rooks in the cells \n(0, 2)\n, \n(1, 3)\n, and \n(2, 1)\n for a sum of \n1 + 1 + 2 = 4\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nboard = [[1,2,3],[4,5,6],[7,8,9]]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\nWe can place the rooks in the cells \n(0, 0)\n, \n(1, 1)\n, and \n(2, 2)\n for a sum of \n1 + 5 + 9 = 15\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nboard = [[1,1,1],[1,1,1],[1,1,1]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nWe can place the rooks in the cells \n(0, 2)\n, \n(1, 1)\n, and \n(2, 0)\n for a sum of \n1 + 1 + 1 = 3\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= m == board.length <= 500\n\n\n3 <= n == board[i].length <= 500\n\n\n-10\n9\n <= board[i][j] <= 10\n9",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3241,
    "slug": "time-taken-to-mark-all-nodes",
    "url": "https://leetcode.com/problems/time-taken-to-mark-all-nodes/",
    "titulo": "Time Taken to Mark All Nodes",
    "enunciado": "There exists an \nundirected\n tree with \nn\n nodes numbered \n0\n to \nn - 1\n. You are given a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the tree.\n\n\nInitially, \nall\n nodes are \nunmarked\n. For each node \ni\n:\n\n\n\n\nIf \ni\n is odd, the node will get marked at time \nx\n if there is \nat least\n one node \nadjacent\n to it which was marked at time \nx - 1\n.\n\n\nIf \ni\n is even, the node will get marked at time \nx\n if there is \nat least\n one node \nadjacent\n to it which was marked at time \nx - 2\n.\n\n\n\n\nReturn an array \ntimes\n where \ntimes[i]\n is the time when all nodes get marked in the tree, if you mark node \ni\n at time \nt = 0\n.\n\n\nNote\n that the answer for each \ntimes[i]\n is \nindependent\n, i.e. when you mark node \ni\n all other nodes are \nunmarked\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1],[0,2]]\n\n\nOutput:\n [2,4,3]\n\n\nExplanation:\n\n\n\n\n\n\nFor \ni = 0\n:\n\n\t\n\n\nNode 1 is marked at \nt = 1\n, and Node 2 at \nt = 2\n.\n\n\n\n\n\n\nFor \ni = 1\n:\n\t\n\n\nNode 0 is marked at \nt = 2\n, and Node 2 at \nt = 4\n.\n\n\n\n\n\n\nFor \ni = 2\n:\n\t\n\n\nNode 0 is marked at \nt = 2\n, and Node 1 at \nt = 3\n.\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[0,1]]\n\n\nOutput:\n [1,2]\n\n\nExplanation:\n\n\n\n\n\n\nFor \ni = 0\n:\n\n\t\n\n\nNode 1 is marked at \nt = 1\n.\n\n\n\n\n\n\nFor \ni = 1\n:\n\t\n\n\nNode 0 is marked at \nt = 2\n.\n\n\n\n\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nedges = \n[[2,4],[0,1],[2,3],[0,2]]\n\n\nOutput:\n [4,6,3,5,5]\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= edges[i][0], edges[i][1] <= n - 1\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 3245,
    "slug": "alternating-groups-iii",
    "url": "https://leetcode.com/problems/alternating-groups-iii/",
    "titulo": "Alternating Groups III",
    "enunciado": "There are some red and blue tiles arranged circularly. You are given an array of integers \ncolors\n and a 2D integers array \nqueries\n.\n\n\nThe color of tile \ni\n is represented by \ncolors[i]\n:\n\n\n\n\ncolors[i] == 0\n means that tile \ni\n is \nred\n.\n\n\ncolors[i] == 1\n means that tile \ni\n is \nblue\n.\n\n\n\n\nAn \nalternating\n group is a contiguous subset of tiles in the circle with \nalternating\n colors (each tile in the group except the first and last one has a different color from its \nadjacent\n tiles in the group).\n\n\nYou have to process queries of two types:\n\n\n\n\nqueries[i] = [1, size\ni\n]\n, determine the count of \nalternating\n groups with size \nsize\ni\n.\n\n\nqueries[i] = [2, index\ni\n, color\ni\n]\n, change \ncolors[index\ni\n]\n to \ncolor\ni\n.\n\n\n\n\nReturn an array \nanswer\n containing the results of the queries of the first type \nin order\n.\n\n\nNote\n that since \ncolors\n represents a \ncircle\n, the \nfirst\n and the \nlast\n tiles are considered to be next to each other.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncolors = [0,1,1,0,1], queries = [[2,1,0],[1,4]]\n\n\nOutput:\n \n[2]\n\n\nExplanation:\n\n\n\n\nFirst query:\n\n\nChange \ncolors[1]\n to 0.\n\n\n\n\nSecond query:\n\n\nCount of the alternating groups with size 4:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncolors = [0,0,1,0,1,1], queries = [[1,3],[2,3,0],[1,5]]\n\n\nOutput:\n \n[2,0]\n\n\nExplanation:\n\n\n\n\nFirst query:\n\n\nCount of the alternating groups with size 3:\n\n\n\n\nSecond query: \ncolors\n will not change.\n\n\nThird query: There is no alternating group with size 5.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n4 <= colors.length <= 5 * 10\n4\n\n\n0 <= colors[i] <= 1\n\n\n1 <= queries.length <= 5 * 10\n4\n\n\nqueries[i][0] == 1\n or \nqueries[i][0] == 2\n\n\nFor all \ni\n that:\n\t\n\n\nqueries[i][0] == 1\n: \nqueries[i].length == 2\n, \n3 <= queries[i][1] <= colors.length - 1\n\n\nqueries[i][0] == 2\n: \nqueries[i].length == 3\n, \n0 <= queries[i][1] <= colors.length - 1\n, \n0 <= queries[i][2] <= 1",
    "temas": [
      "Array",
      "Binary Indexed Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3239,
    "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-i",
    "url": "https://leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-i/",
    "titulo": "Minimum Number of Flips to Make Binary Grid Palindromic I",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n.\n\n\nA row or column is considered \npalindromic\n if its values read the same forward and backward.\n\n\nYou can \nflip\n any number of cells in \ngrid\n from \n0\n to \n1\n, or from \n1\n to \n0\n.\n\n\nReturn the \nminimum\n number of cells that need to be flipped to make \neither\n all rows \npalindromic\n or all columns \npalindromic\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,0,0],[0,0,0],[0,0,1]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nFlipping the highlighted cells makes all the rows palindromic.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = \n[[0,1],[0,1],[0,0]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nFlipping the highlighted cell makes all the columns palindromic.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1],[0]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nAll rows are already palindromic.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m * n <= 2 * 10\n5\n\n\n0 <= grid[i][j] <= 1",
    "temas": [
      "Array",
      "Two Pointers",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3240,
    "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-ii",
    "url": "https://leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-ii/",
    "titulo": "Minimum Number of Flips to Make Binary Grid Palindromic II",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n.\n\n\nA row or column is considered \npalindromic\n if its values read the same forward and backward.\n\n\nYou can \nflip\n any number of cells in \ngrid\n from \n0\n to \n1\n, or from \n1\n to \n0\n.\n\n\nReturn the \nminimum\n number of cells that need to be flipped to make \nall\n rows and columns \npalindromic\n, and the total number of \n1\n's in \ngrid\n \ndivisible\n by \n4\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,0,0],[0,1,0],[0,0,1]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[0,1],[0,1],[0,0]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1],[1]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m * n <= 2 * 10\n5\n\n\n0 <= grid[i][j] <= 1",
    "temas": [
      "Array",
      "Two Pointers",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3243,
    "slug": "shortest-distance-after-road-addition-queries-i",
    "url": "https://leetcode.com/problems/shortest-distance-after-road-addition-queries-i/",
    "titulo": "Shortest Distance After Road Addition Queries I",
    "enunciado": "You are given an integer \nn\n and a 2D integer array \nqueries\n.\n\n\nThere are \nn\n cities numbered from \n0\n to \nn - 1\n. Initially, there is a \nunidirectional\n road from city \ni\n to city \ni + 1\n for all \n0 <= i < n - 1\n.\n\n\nqueries[i] = [u\ni\n, v\ni\n]\n represents the addition of a new \nunidirectional\n road from city \nu\ni\n to city \nv\ni\n. After each query, you need to find the \nlength\n of the \nshortest path\n from city \n0\n to city \nn - 1\n.\n\n\nReturn an array \nanswer\n where for each \ni\n in the range \n[0, queries.length - 1]\n, \nanswer[i]\n is the \nlength of the shortest path\n from city \n0\n to city \nn - 1\n after processing the \nfirst \ni + 1\n queries.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5, queries = [[2,4],[0,2],[0,4]]\n\n\nOutput:\n \n[3,2,1]\n\n\nExplanation: \n\n\n\n\nAfter the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.\n\n\n\n\nAfter the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.\n\n\n\n\nAfter the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 4, queries = [[0,3],[0,2]]\n\n\nOutput:\n \n[1,1]\n\n\nExplanation:\n\n\n\n\nAfter the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.\n\n\n\n\nAfter the addition of the road from 0 to 2, the length of the shortest path remains 1.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 500\n\n\n1 <= queries.length <= 500\n\n\nqueries[i].length == 2\n\n\n0 <= queries[i][0] < queries[i][1] < n\n\n\n1 < queries[i][1] - queries[i][0]\n\n\nThere are no repeated roads among the queries.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3242,
    "slug": "design-neighbor-sum-service",
    "url": "https://leetcode.com/problems/design-neighbor-sum-service/",
    "titulo": "Design Neighbor Sum Service",
    "enunciado": "You are given a \nn x n\n 2D array \ngrid\n containing \ndistinct\n elements in the range \n[0, n\n2\n - 1]\n.\n\n\nImplement the \nNeighborSum\n class:\n\n\n\n\nNeighborSum(int [][]grid)\n initializes the object.\n\n\nint adjacentSum(int value)\n returns the \nsum\n of elements which are adjacent neighbors of \nvalue\n, that is either to the top, left, right, or bottom of \nvalue\n in \ngrid\n.\n\n\nint diagonalSum(int value)\n returns the \nsum\n of elements which are diagonal neighbors of \nvalue\n, that is either to the top-left, top-right, bottom-left, or bottom-right of \nvalue\n in \ngrid\n.\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n\n\n[\"NeighborSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\"]\n\n\n[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]\n\n\nOutput:\n [null, 6, 16, 16, 4]\n\n\nExplanation:\n\n\n\n\n\n\nThe adjacent neighbors of 1 are 0, 2, and 4.\n\n\nThe adjacent neighbors of 4 are 1, 3, 5, and 7.\n\n\nThe diagonal neighbors of 4 are 0, 2, 6, and 8.\n\n\nThe diagonal neighbor of 8 is 4.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n\n\n[\"NeighborSum\", \"adjacentSum\", \"diagonalSum\"]\n\n\n[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]\n\n\nOutput:\n [null, 23, 45]\n\n\nExplanation:\n\n\n\n\n\n\nThe adjacent neighbors of 15 are 0, 10, 7, and 6.\n\n\nThe diagonal neighbors of 9 are 4, 12, 14, and 15.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n == grid.length == grid[0].length <= 10\n\n\n0 <= grid[i][j] <= n\n2\n - 1\n\n\nAll \ngrid[i][j]\n are distinct.\n\n\nvalue\n in \nadjacentSum\n and \ndiagonalSum\n will be in the range \n[0, n\n2\n - 1]\n.\n\n\nAt most \n2 * n\n2\n calls will be made to \nadjacentSum\n and \ndiagonalSum\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Design",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3244,
    "slug": "shortest-distance-after-road-addition-queries-ii",
    "url": "https://leetcode.com/problems/shortest-distance-after-road-addition-queries-ii/",
    "titulo": "Shortest Distance After Road Addition Queries II",
    "enunciado": "You are given an integer \nn\n and a 2D integer array \nqueries\n.\n\n\nThere are \nn\n cities numbered from \n0\n to \nn - 1\n. Initially, there is a \nunidirectional\n road from city \ni\n to city \ni + 1\n for all \n0 <= i < n - 1\n.\n\n\nqueries[i] = [u\ni\n, v\ni\n]\n represents the addition of a new \nunidirectional\n road from city \nu\ni\n to city \nv\ni\n. After each query, you need to find the \nlength\n of the \nshortest path\n from city \n0\n to city \nn - 1\n.\n\n\nThere are no two queries such that \nqueries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]\n.\n\n\nReturn an array \nanswer\n where for each \ni\n in the range \n[0, queries.length - 1]\n, \nanswer[i]\n is the \nlength of the shortest path\n from city \n0\n to city \nn - 1\n after processing the \nfirst \ni + 1\n queries.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5, queries = [[2,4],[0,2],[0,4]]\n\n\nOutput:\n \n[3,2,1]\n\n\nExplanation: \n\n\n\n\nAfter the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.\n\n\n\n\nAfter the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.\n\n\n\n\nAfter the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 4, queries = [[0,3],[0,2]]\n\n\nOutput:\n \n[1,1]\n\n\nExplanation:\n\n\n\n\nAfter the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.\n\n\n\n\nAfter the addition of the road from 0 to 2, the length of the shortest path remains 1.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= queries[i][0] < queries[i][1] < n\n\n\n1 < queries[i][1] - queries[i][0]\n\n\nThere are no repeated roads among the queries.\n\n\nThere are no two queries such that \ni != j\n and \nqueries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]\n.",
    "temas": [
      "Array",
      "Greedy",
      "Graph",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3319,
    "slug": "k-th-largest-perfect-subtree-size-in-binary-tree",
    "url": "https://leetcode.com/problems/k-th-largest-perfect-subtree-size-in-binary-tree/",
    "titulo": "K-th Largest Perfect Subtree Size in Binary Tree",
    "enunciado": "You are given the \nroot\n of a \nbinary tree\n and an integer \nk\n.\n\n\nReturn an integer denoting the size of the \nk\nth\n \nlargest\n \nperfect binary\n \nsubtree\n, or \n-1\n if it doesn't exist.\n\n\nA \nperfect binary tree\n is a tree where all leaves are on the same level, and every parent has two children.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nThe roots of the perfect binary subtrees are highlighted in black. Their sizes, in non-increasing order are \n[3, 3, 1, 1, 1, 1, 1, 1]\n.\n\nThe \n2\nnd\n largest size is 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,6,7], k = 1\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\n\n\nThe sizes of the perfect binary subtrees in non-increasing order are \n[7, 3, 3, 1, 1, 1, 1]\n. The size of the largest perfect binary subtree is 7.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = [1,2,3,null,4], k = 3\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\n\n\nThe sizes of the perfect binary subtrees in non-increasing order are \n[1, 1]\n. There are fewer than 3 perfect binary subtrees.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2000]\n.\n\n\n1 <= Node.val <= 2000\n\n\n1 <= k <= 1024",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Sorting",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 3217,
    "slug": "delete-nodes-from-linked-list-present-in-array",
    "url": "https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/",
    "titulo": "Delete Nodes From Linked List Present in Array",
    "enunciado": "You are given an array of integers \nnums\n and the \nhead\n of a linked list. Return the \nhead\n of the modified linked list after \nremoving\n all nodes from the linked list that have a value that exists in \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3], head = [1,2,3,4,5]\n\n\nOutput:\n \n[4,5]\n\n\nExplanation:\n\n\n\n\nRemove the nodes with values 1, 2, and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1], head = [1,2,1,2,1,2]\n\n\nOutput:\n \n[2,2,2]\n\n\nExplanation:\n\n\n\n\nRemove the nodes with value 1.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [5], head = [1,2,3,4]\n\n\nOutput:\n \n[1,2,3,4]\n\n\nExplanation:\n\n\n\n\nNo node has value 5.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n5\n\n\nAll elements in \nnums\n are unique.\n\n\nThe number of nodes in the given list is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\nThe input is generated such that there is at least one node in the linked list that has a value not present in \nnums\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3219,
    "slug": "minimum-cost-for-cutting-cake-ii",
    "url": "https://leetcode.com/problems/minimum-cost-for-cutting-cake-ii/",
    "titulo": "Minimum Cost for Cutting Cake II",
    "enunciado": "There is an \nm x n\n cake that needs to be cut into \n1 x 1\n pieces.\n\n\nYou are given integers \nm\n, \nn\n, and two arrays:\n\n\n\n\nhorizontalCut\n of size \nm - 1\n, where \nhorizontalCut[i]\n represents the cost to cut along the horizontal line \ni\n.\n\n\nverticalCut\n of size \nn - 1\n, where \nverticalCut[j]\n represents the cost to cut along the vertical line \nj\n.\n\n\n\n\nIn one operation, you can choose any piece of cake that is not yet a \n1 x 1\n square and perform one of the following cuts:\n\n\n\n\nCut along a horizontal line \ni\n at a cost of \nhorizontalCut[i]\n.\n\n\nCut along a vertical line \nj\n at a cost of \nverticalCut[j]\n.\n\n\n\n\nAfter the cut, the piece of cake is divided into two distinct pieces.\n\n\nThe cost of a cut depends only on the initial cost of the line and does not change.\n\n\nReturn the \nminimum\n total cost to cut the entire cake into \n1 x 1\n pieces.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nm = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]\n\n\nOutput:\n \n13\n\n\nExplanation:\n\n\n\n\n\n\nPerform a cut on the vertical line 0 with cost 5, current total cost is 5.\n\n\nPerform a cut on the horizontal line 0 on \n3 x 1\n subgrid with cost 1.\n\n\nPerform a cut on the horizontal line 0 on \n3 x 1\n subgrid with cost 1.\n\n\nPerform a cut on the horizontal line 1 on \n2 x 1\n subgrid with cost 3.\n\n\nPerform a cut on the horizontal line 1 on \n2 x 1\n subgrid with cost 3.\n\n\n\n\nThe total cost is \n5 + 1 + 1 + 3 + 3 = 13\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nm = 2, n = 2, horizontalCut = [7], verticalCut = [4]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\n\n\nPerform a cut on the horizontal line 0 with cost 7.\n\n\nPerform a cut on the vertical line 0 on \n1 x 2\n subgrid with cost 4.\n\n\nPerform a cut on the vertical line 0 on \n1 x 2\n subgrid with cost 4.\n\n\n\n\nThe total cost is \n7 + 4 + 4 = 15\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 10\n5\n\n\nhorizontalCut.length == m - 1\n\n\nverticalCut.length == n - 1\n\n\n1 <= horizontalCut[i], verticalCut[i] <= 10\n3",
    "temas": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3218,
    "slug": "minimum-cost-for-cutting-cake-i",
    "url": "https://leetcode.com/problems/minimum-cost-for-cutting-cake-i/",
    "titulo": "Minimum Cost for Cutting Cake I",
    "enunciado": "There is an \nm x n\n cake that needs to be cut into \n1 x 1\n pieces.\n\n\nYou are given integers \nm\n, \nn\n, and two arrays:\n\n\n\n\nhorizontalCut\n of size \nm - 1\n, where \nhorizontalCut[i]\n represents the cost to cut along the horizontal line \ni\n.\n\n\nverticalCut\n of size \nn - 1\n, where \nverticalCut[j]\n represents the cost to cut along the vertical line \nj\n.\n\n\n\n\nIn one operation, you can choose any piece of cake that is not yet a \n1 x 1\n square and perform one of the following cuts:\n\n\n\n\nCut along a horizontal line \ni\n at a cost of \nhorizontalCut[i]\n.\n\n\nCut along a vertical line \nj\n at a cost of \nverticalCut[j]\n.\n\n\n\n\nAfter the cut, the piece of cake is divided into two distinct pieces.\n\n\nThe cost of a cut depends only on the initial cost of the line and does not change.\n\n\nReturn the \nminimum\n total cost to cut the entire cake into \n1 x 1\n pieces.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nm = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]\n\n\nOutput:\n \n13\n\n\nExplanation:\n\n\n\n\n\n\nPerform a cut on the vertical line 0 with cost 5, current total cost is 5.\n\n\nPerform a cut on the horizontal line 0 on \n3 x 1\n subgrid with cost 1.\n\n\nPerform a cut on the horizontal line 0 on \n3 x 1\n subgrid with cost 1.\n\n\nPerform a cut on the horizontal line 1 on \n2 x 1\n subgrid with cost 3.\n\n\nPerform a cut on the horizontal line 1 on \n2 x 1\n subgrid with cost 3.\n\n\n\n\nThe total cost is \n5 + 1 + 1 + 3 + 3 = 13\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nm = 2, n = 2, horizontalCut = [7], verticalCut = [4]\n\n\nOutput:\n \n15\n\n\nExplanation:\n\n\n\n\nPerform a cut on the horizontal line 0 with cost 7.\n\n\nPerform a cut on the vertical line 0 on \n1 x 2\n subgrid with cost 4.\n\n\nPerform a cut on the vertical line 0 on \n1 x 2\n subgrid with cost 4.\n\n\n\n\nThe total cost is \n7 + 4 + 4 = 15\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 20\n\n\nhorizontalCut.length == m - 1\n\n\nverticalCut.length == n - 1\n\n\n1 <= horizontalCut[i], verticalCut[i] <= 10\n3",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3212,
    "slug": "count-submatrices-with-equal-frequency-of-x-and-y",
    "url": "https://leetcode.com/problems/count-submatrices-with-equal-frequency-of-x-and-y/",
    "titulo": "Count Submatrices With Equal Frequency of X and Y",
    "enunciado": "Given a 2D character matrix \ngrid\n, where \ngrid[i][j]\n is either \n'X'\n, \n'Y'\n, or \n'.'\n, return the number of \nsubmatrices\n that contain:\n\n\n\n\ngrid[0][0]\n\n\nan \nequal\n frequency of \n'X'\n and \n'Y'\n.\n\n\nat least\n one \n'X'\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo submatrix has an equal frequency of \n'X'\n and \n'Y'\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[\".\",\".\"],[\".\",\".\"]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nNo submatrix has at least one \n'X'\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= grid.length, grid[i].length <= 1000\n\n\ngrid[i][j]\n is either \n'X'\n, \n'Y'\n, or \n'.'\n.",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3249,
    "slug": "count-the-number-of-good-nodes",
    "url": "https://leetcode.com/problems/count-the-number-of-good-nodes/",
    "titulo": "Count the Number of Good Nodes",
    "enunciado": "There is an \nundirected\n tree with \nn\n nodes labeled from \n0\n to \nn - 1\n, and rooted at node \n0\n. You are given a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nA node is \ngood\n if all the \nsubtrees\n rooted at its children have the same size.\n\n\nReturn the number of \ngood\n nodes in the given tree.\n\n\nA \nsubtree\n of \ntreeName\n is a tree consisting of a node in \ntreeName\n and all of its descendants.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\n\n\nOutput:\n \n7\n\n\nExplanation:\n\n\n\n\nAll of the nodes of the given tree are good.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nedges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\n\nThere are 6 good nodes in the given tree. They are colored in the image above.\n\n\nExample 3:\n\n\n\n\nInput:\n \nedges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]\n\n\nOutput:\n \n12\n\n\nExplanation:\n\n\n\n\nAll nodes except node 9 are good.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 3208,
    "slug": "alternating-groups-ii",
    "url": "https://leetcode.com/problems/alternating-groups-ii/",
    "titulo": "Alternating Groups II",
    "enunciado": "There is a circle of red and blue tiles. You are given an array of integers \ncolors\n and an integer \nk\n. The color of tile \ni\n is represented by \ncolors[i]\n:\n\n\n\n\ncolors[i] == 0\n means that tile \ni\n is \nred\n.\n\n\ncolors[i] == 1\n means that tile \ni\n is \nblue\n.\n\n\n\n\nAn \nalternating\n group is every \nk\n contiguous tiles in the circle with \nalternating\n colors (each tile in the group except the first and last one has a different color from its \nleft\n and \nright\n tiles).\n\n\nReturn the number of \nalternating\n groups.\n\n\nNote\n that since \ncolors\n represents a \ncircle\n, the \nfirst\n and the \nlast\n tiles are considered to be next to each other.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncolors = [0,1,0,1,0], k = 3\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\n\nAlternating groups:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncolors = [0,1,0,0,1,0,1], k = 6\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\nAlternating groups:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ncolors = [1,1,0,1], k = 4\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= colors.length <= 10\n5\n\n\n0 <= colors[i] <= 1\n\n\n3 <= k <= colors.length",
    "temas": [
      "Array",
      "Sliding Window"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3235,
    "slug": "check-if-the-rectangle-corner-is-reachable",
    "url": "https://leetcode.com/problems/check-if-the-rectangle-corner-is-reachable/",
    "titulo": "Check if the Rectangle Corner Is Reachable",
    "enunciado": "You are given two positive integers \nxCorner\n and \nyCorner\n, and a 2D array \ncircles\n, where \ncircles[i] = [x\ni\n, y\ni\n, r\ni\n]\n denotes a circle with center at \n(x\ni\n, y\ni\n)\n and radius \nr\ni\n.\n\n\nThere is a rectangle in the coordinate plane with its bottom left corner at the origin and top right corner at the coordinate \n(xCorner, yCorner)\n. You need to check whether there is a path from the bottom left corner to the top right corner such that the \nentire path\n lies inside the rectangle, \ndoes not\n touch or lie inside \nany\n circle, and touches the rectangle \nonly\n at the two corners.\n\n\nReturn \ntrue\n if such a path exists, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nxCorner = 3, yCorner = 4, circles = [[2,1,1]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nThe black curve shows a possible path between \n(0, 0)\n and \n(3, 4)\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nxCorner = 3, yCorner = 3, circles = [[1,1,2]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nNo path exists from \n(0, 0)\n to \n(3, 3)\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nxCorner = 3, yCorner = 3, circles = [[2,1,1],[1,2,1]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nNo path exists from \n(0, 0)\n to \n(3, 3)\n.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nxCorner = 4, yCorner = 4, circles = [[5,5,1]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= xCorner, yCorner <= 10\n9\n\n\n1 <= circles.length <= 1000\n\n\ncircles[i].length == 3\n\n\n1 <= x\ni\n, y\ni\n, r\ni\n <= 10\n9",
    "temas": [
      "Array",
      "Math",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Geometry"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3225,
    "slug": "maximum-score-from-grid-operations",
    "url": "https://leetcode.com/problems/maximum-score-from-grid-operations/",
    "titulo": "Maximum Score From Grid Operations",
    "enunciado": "You are given a 2D matrix \ngrid\n of size \nn x n\n. Initially, all cells of the grid are colored white. In one operation, you can select any cell of indices \n(i, j)\n, and color black all the cells of the \nj\nth\n column starting from the top row down to the \ni\nth\n row.\n\n\nThe grid score is the sum of all \ngrid[i][j]\n such that cell \n(i, j)\n is white and it has a horizontally adjacent black cell.\n\n\nReturn the \nmaximum\n score that can be achieved after some number of operations.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]]\n\n\nOutput:\n \n11\n\n\nExplanation:\n\n\n\n\nIn the first operation, we color all cells in column 1 down to row 3, and in the second operation, we color all cells in column 4 down to the last row. The score of the resulting grid is \ngrid[3][0] + grid[1][2] + grid[3][3]\n which is equal to 11.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]]\n\n\nOutput:\n \n94\n\n\nExplanation:\n\n\n\n\nWe perform operations on 1, 2, and 3 down to rows 1, 4, and 0, respectively. The score of the resulting grid is \ngrid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3] + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4]\n which is equal to 94.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == grid.length <= 100\n\n\nn == grid[i].length\n\n\n0 <= grid[i][j] <= 10\n9",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3200,
    "slug": "maximum-height-of-a-triangle",
    "url": "https://leetcode.com/problems/maximum-height-of-a-triangle/",
    "titulo": "Maximum Height of a Triangle",
    "enunciado": "You are given two integers \nred\n and \nblue\n representing the count of red and blue colored balls. You have to arrange these balls to form a triangle such that the 1\nst\n row will have 1 ball, the 2\nnd\n row will have 2 balls, the 3\nrd\n row will have 3 balls, and so on.\n\n\nAll the balls in a particular row should be the \nsame\n color, and adjacent rows should have \ndifferent\n colors.\n\n\nReturn the \nmaximum\n height of the triangle\n that can be achieved.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nred = 2, blue = 4\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nThe only possible arrangement is shown above.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nred = 2, blue = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\nThe only possible arrangement is shown above.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nred = 1, blue = 1\n\n\nOutput:\n \n1\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nred = 10, blue = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\nThe only possible arrangement is shown above.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= red, blue <= 100",
    "temas": [
      "Array",
      "Enumeration"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3206,
    "slug": "alternating-groups-i",
    "url": "https://leetcode.com/problems/alternating-groups-i/",
    "titulo": "Alternating Groups I",
    "enunciado": "There is a circle of red and blue tiles. You are given an array of integers \ncolors\n. The color of tile \ni\n is represented by \ncolors[i]\n:\n\n\n\n\ncolors[i] == 0\n means that tile \ni\n is \nred\n.\n\n\ncolors[i] == 1\n means that tile \ni\n is \nblue\n.\n\n\n\n\nEvery 3 contiguous tiles in the circle with \nalternating\n colors (the middle tile has a different color from its \nleft\n and \nright\n tiles) is called an \nalternating\n group.\n\n\nReturn the number of \nalternating\n groups.\n\n\nNote\n that since \ncolors\n represents a \ncircle\n, the \nfirst\n and the \nlast\n tiles are considered to be next to each other.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncolors = [1,1,1]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncolors = [0,1,0,0,1]\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nAlternating groups:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= colors.length <= 100\n\n\n0 <= colors[i] <= 1",
    "temas": [
      "Array",
      "Sliding Window"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3195,
    "slug": "find-the-minimum-area-to-cover-all-ones-i",
    "url": "https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-i/",
    "titulo": "Find the Minimum Area to Cover All Ones I",
    "enunciado": "You are given a 2D \nbinary\n array \ngrid\n. Find a rectangle with horizontal and vertical sides with the\n smallest\n area, such that all the 1's in \ngrid\n lie inside this rectangle.\n\n\nReturn the \nminimum\n possible area of the rectangle.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[0,1,0],[1,0,1]]\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\n\nThe smallest rectangle has a height of 2 and a width of 3, so it has an area of \n2 * 3 = 6\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,0],[0,0]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\nThe smallest rectangle has both height and width 1, so its area is \n1 * 1 = 1\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= grid.length, grid[i].length <= 1000\n\n\ngrid[i][j]\n is either 0 or 1.\n\n\nThe input is generated such that there is at least one 1 in \ngrid\n.",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3197,
    "slug": "find-the-minimum-area-to-cover-all-ones-ii",
    "url": "https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-ii/",
    "titulo": "Find the Minimum Area to Cover All Ones II",
    "enunciado": "You are given a 2D \nbinary\n array \ngrid\n. You need to find 3 \nnon-overlapping\n rectangles having \nnon-zero\n areas with horizontal and vertical sides such that all the 1's in \ngrid\n lie inside these rectangles.\n\n\nReturn the \nminimum\n possible sum of the area of these rectangles.\n\n\nNote\n that the rectangles are allowed to touch.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,0,1],[1,1,1]]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\n\n\n\n\nThe 1's at \n(0, 0)\n and \n(1, 0)\n are covered by a rectangle of area 2.\n\n\nThe 1's at \n(0, 2)\n and \n(1, 2)\n are covered by a rectangle of area 2.\n\n\nThe 1 at \n(1, 1)\n is covered by a rectangle of area 1.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,0,1,0],[0,1,0,1]]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\n\n\n\n\nThe 1's at \n(0, 0)\n and \n(0, 2)\n are covered by a rectangle of area 3.\n\n\nThe 1 at \n(1, 1)\n is covered by a rectangle of area 1.\n\n\nThe 1 at \n(1, 3)\n is covered by a rectangle of area 1.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= grid.length, grid[i].length <= 30\n\n\ngrid[i][j]\n is either 0 or 1.\n\n\nThe input is generated such that there are at least three 1's in \ngrid\n.",
    "temas": [
      "Array",
      "Matrix",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3203,
    "slug": "find-minimum-diameter-after-merging-two-trees",
    "url": "https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/",
    "titulo": "Find Minimum Diameter After Merging Two Trees",
    "enunciado": "There exist two \nundirected \ntrees with \nn\n and \nm\n nodes, numbered from \n0\n to \nn - 1\n and from \n0\n to \nm - 1\n, respectively. You are given two 2D integer arrays \nedges1\n and \nedges2\n of lengths \nn - 1\n and \nm - 1\n, respectively, where \nedges1[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the first tree and \nedges2[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the second tree.\n\n\nYou must connect one node from the first tree with another node from the second tree with an edge.\n\n\nReturn the \nminimum \npossible \ndiameter \nof the resulting tree.\n\n\nThe \ndiameter\n of a tree is the length of the \nlongest\n path between any two nodes in the tree.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nedges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nWe can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nedges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n\n\nOutput:\n \n5\n\n\nExplanation:\n\n\nWe can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 10\n5\n\n\nedges1.length == n - 1\n\n\nedges2.length == m - 1\n\n\nedges1[i].length == edges2[i].length == 2\n\n\nedges1[i] = [a\ni\n, b\ni\n]\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nedges2[i] = [u\ni\n, v\ni\n]\n\n\n0 <= u\ni\n, v\ni\n < m\n\n\nThe input is generated such that \nedges1\n and \nedges2\n represent valid trees.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 3161,
    "slug": "block-placement-queries",
    "url": "https://leetcode.com/problems/block-placement-queries/",
    "titulo": "Block Placement Queries",
    "enunciado": "There exists an infinite number line, with its origin at 0 and extending towards the \npositive\n x-axis.\n\n\nYou are given a 2D array \nqueries\n, which contains two types of queries:\n\n\n\n\nFor a query of type 1, \nqueries[i] = [1, x]\n. Build an obstacle at distance \nx\n from the origin. It is guaranteed that there is \nno\n obstacle at distance \nx\n when the query is asked.\n\n\nFor a query of type 2, \nqueries[i] = [2, x, sz]\n. Check if it is possible to place a block of size \nsz\n \nanywhere\n in the range \n[0, x]\n on the line, such that the block \nentirely\n lies in the range \n[0, x]\n. A block \ncannot \nbe placed if it intersects with any obstacle, but it may touch it. Note that you do\n not\n actually place the block. Queries are separate.\n\n\n\n\nReturn a boolean array \nresults\n, where \nresults[i]\n is \ntrue\n if you can place the block specified in the \ni\nth\n query of type 2, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nqueries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n\n\nOutput:\n \n[false,true,true]\n\n\nExplanation:\n\n\n\n\nFor query 0, place an obstacle at \nx = 2\n. A block of size at most 2 can be placed before \nx = 3\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nqueries = \n[[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n\n\nOutput:\n [true,true,false]\n\n\nExplanation:\n\n\n\n\n\n\nPlace an obstacle at \nx = 7\n for query 0. A block of size at most 7 can be placed before \nx = 7\n.\n\n\nPlace an obstacle at \nx = 2\n for query 2. Now, a block of size at most 5 can be placed before \nx = 7\n, and a block of size at most 2 before \nx = 2\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= queries.length <= 15 * 10\n4\n\n\n2 <= queries[i].length <= 3\n\n\n1 <= queries[i][0] <= 2\n\n\n1 <= x, sz <= min(5 * 10\n4\n, 3 * queries.length)\n\n\nThe input is generated such that for queries of type 1, no obstacle exists at distance \nx\n when the query is asked.\n\n\nThe input is generated such that there is at least one query of type 2.",
    "temas": [
      "Array",
      "Binary Search",
      "Binary Indexed Tree",
      "Segment Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3160,
    "slug": "find-the-number-of-distinct-colors-among-the-balls",
    "url": "https://leetcode.com/problems/find-the-number-of-distinct-colors-among-the-balls/",
    "titulo": "Find the Number of Distinct Colors Among the Balls",
    "enunciado": "You are given an integer \nlimit\n and a 2D array \nqueries\n of size \nn x 2\n.\n\n\nThere are \nlimit + 1\n balls with \ndistinct\n labels in the range \n[0, limit]\n. Initially, all balls are uncolored. For every query in \nqueries\n that is of the form \n[x, y]\n, you mark ball \nx\n with the color \ny\n. After each query, you need to find the number of colors among the balls.\n\n\nReturn an array \nresult\n of length \nn\n, where \nresult[i]\n denotes the number of colors \nafter\n \ni\nth\n query.\n\n\nNote\n that when answering a query, lack of a color \nwill not\n be considered as a color.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nlimit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n\n\nOutput:\n \n[1,2,2,3]\n\n\nExplanation:\n\n\n\n\n\n\nAfter query 0, ball 1 has color 4.\n\n\nAfter query 1, ball 1 has color 4, and ball 2 has color 5.\n\n\nAfter query 2, ball 1 has color 3, and ball 2 has color 5.\n\n\nAfter query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nlimit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n\n\nOutput:\n \n[1,2,2,3,4]\n\n\nExplanation:\n\n\n\n\n\n\nAfter query 0, ball 0 has color 1.\n\n\nAfter query 1, ball 0 has color 1, and ball 1 has color 2.\n\n\nAfter query 2, ball 0 has color 1, and balls 1 and 2 have color 2.\n\n\nAfter query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.\n\n\nAfter query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= limit <= 10\n9\n\n\n1 <= n == queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= queries[i][0] <= limit\n\n\n1 <= queries[i][1] <= 10\n9",
    "temas": [
      "Array",
      "Hash Table",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3149,
    "slug": "find-the-minimum-cost-array-permutation",
    "url": "https://leetcode.com/problems/find-the-minimum-cost-array-permutation/",
    "titulo": "Find the Minimum Cost Array Permutation",
    "enunciado": "You are given an array \nnums\n which is a \npermutation\n of \n[0, 1, 2, ..., n - 1]\n. The \nscore\n of any permutation of \n[0, 1, 2, ..., n - 1]\n named \nperm\n is defined as:\n\n\nscore(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n\n\nReturn the permutation \nperm\n which has the \nminimum\n possible score. If \nmultiple\n permutations exist with this score, return the one that is \nlexicographically smallest\n among them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,0,2]\n\n\nOutput:\n \n[0,1,2]\n\n\nExplanation:\n\n\n\n\nThe lexicographically smallest permutation with minimum cost is \n[0,1,2]\n. The cost of this permutation is \n|0 - 0| + |1 - 2| + |2 - 1| = 2\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [0,2,1]\n\n\nOutput:\n \n[0,2,1]\n\n\nExplanation:\n\n\n\n\nThe lexicographically smallest permutation with minimum cost is \n[0,2,1]\n. The cost of this permutation is \n|0 - 1| + |2 - 2| + |1 - 0| = 2\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == nums.length <= 14\n\n\nnums\n is a permutation of \n[0, 1, 2, ..., n - 1]\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3143,
    "slug": "maximum-points-inside-the-square",
    "url": "https://leetcode.com/problems/maximum-points-inside-the-square/",
    "titulo": "Maximum Points Inside the Square",
    "enunciado": "You are given a 2D\n \narray \npoints\n and a string \ns\n where, \npoints[i]\n represents the coordinates of point \ni\n, and \ns[i]\n represents the \ntag\n of point \ni\n.\n\n\nA \nvalid\n square is a square centered at the origin \n(0, 0)\n, has edges parallel to the axes, and \ndoes not\n contain two points with the same tag.\n\n\nReturn the \nmaximum\n number of points contained in a \nvalid\n square.\n\n\nNote:\n\n\n\n\nA point is considered to be inside the square if it lies on or within the square's boundaries.\n\n\nThe side length of the square can be zero.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \npoints = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = \"abdca\"\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nThe square of side length 4 covers two points \npoints[0]\n and \npoints[1]\n.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \npoints = [[1,1],[-2,-2],[-2,2]], s = \"abb\"\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe square of side length 2 covers one point, which is \npoints[0]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npoints = [[1,1],[-1,-1],[2,-2]], s = \"ccd\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nIt's impossible to make any valid squares centered at the origin such that it covers only one point among \npoints[0]\n and \npoints[1]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, points.length <= 10\n5\n\n\npoints[i].length == 2\n\n\n-10\n9\n <= points[i][0], points[i][1] <= 10\n9\n\n\ns.length == points.length\n\n\npoints\n consists of distinct coordinates.\n\n\ns\n consists only of lowercase English letters.",
    "temas": [
      "Array",
      "Hash Table",
      "String",
      "Binary Search",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3142,
    "slug": "check-if-grid-satisfies-conditions",
    "url": "https://leetcode.com/problems/check-if-grid-satisfies-conditions/",
    "titulo": "Check if Grid Satisfies Conditions",
    "enunciado": "You are given a 2D matrix \ngrid\n of size \nm x n\n. You need to check if each cell \ngrid[i][j]\n is:\n\n\n\n\nEqual to the cell below it, i.e. \ngrid[i][j] == grid[i + 1][j]\n (if it exists).\n\n\nDifferent from the cell to its right, i.e. \ngrid[i][j] != grid[i][j + 1]\n (if it exists).\n\n\n\n\nReturn \ntrue\n if \nall\n the cells satisfy these conditions, otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,0,2],[1,0,2]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nAll the cells in the grid satisfy the conditions.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,1,1],[0,0,0]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nAll cells in the first row are equal.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1],[2],[3]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nCells in the first column have different values.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 10\n\n\n0 <= grid[i][j] <= 9",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3122,
    "slug": "minimum-number-of-operations-to-satisfy-conditions",
    "url": "https://leetcode.com/problems/minimum-number-of-operations-to-satisfy-conditions/",
    "titulo": "Minimum Number of Operations to Satisfy Conditions",
    "enunciado": "You are given a 2D matrix \ngrid\n of size \nm x n\n. In one \noperation\n, you can change the value of \nany\n cell to \nany\n non-negative number. You need to perform some \noperations\n such that each cell \ngrid[i][j]\n is:\n\n\n\n\nEqual to the cell below it, i.e. \ngrid[i][j] == grid[i + 1][j]\n (if it exists).\n\n\nDifferent from the cell to its right, i.e. \ngrid[i][j] != grid[i][j + 1]\n (if it exists).\n\n\n\n\nReturn the \nminimum\n number of operations needed.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,0,2],[1,0,2]]\n\n\nOutput:\n 0\n\n\nExplanation:\n\n\n\n\nAll the cells in the matrix already satisfy the properties.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1,1,1],[0,0,0]]\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nThe matrix becomes \n[[1,0,1],[1,0,1]]\n which satisfies the properties, by doing these 3 operations:\n\n\n\n\nChange \ngrid[1][0]\n to 1.\n\n\nChange \ngrid[0][1]\n to 0.\n\n\nChange \ngrid[1][2]\n to 1.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid = [[1],[2],[3]]\n\n\nOutput:\n 2\n\n\nExplanation:\n\n\n\n\nThere is a single column. We can change the value to 1 in each cell using 2 operations.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 1000\n\n\n0 <= grid[i][j] <= 9",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3148,
    "slug": "maximum-difference-score-in-a-grid",
    "url": "https://leetcode.com/problems/maximum-difference-score-in-a-grid/",
    "titulo": "Maximum Difference Score in a Grid",
    "enunciado": "You are given an \nm x n\n matrix \ngrid\n consisting of \npositive\n integers. You can move from a cell in the matrix to \nany\n other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value \nc1\n to a cell with the value \nc2\n is \nc2 - c1\n.\n\n\nYou can start at \nany\n cell, and you have to make \nat least\n one move.\n\n\nReturn the \nmaximum\n total score you can achieve.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \ngrid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n\n\nOutput:\n \n9\n\n\nExplanation:\n We start at the cell \n(0, 1)\n, and we perform the following moves:\n\n- Move from the cell \n(0, 1)\n to \n(2, 1)\n with a score of \n7 - 5 = 2\n.\n\n- Move from the cell \n(2, 1)\n to \n(2, 2)\n with a score of \n14 - 7 = 7\n.\n\nThe total score is \n2 + 7 = 9\n.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \ngrid = [[4,3,2],[3,2,1]]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n We start at the cell \n(0, 0)\n, and we perform one move: \n(0, 0)\n to \n(0, 1)\n. The score is \n3 - 4 = -1\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 1000\n\n\n4 <= m * n <= 10\n5\n\n\n1 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3111,
    "slug": "minimum-rectangles-to-cover-points",
    "url": "https://leetcode.com/problems/minimum-rectangles-to-cover-points/",
    "titulo": "Minimum Rectangles to Cover Points",
    "enunciado": "You are given a 2D integer array \npoints\n, where \npoints[i] = [x\ni\n, y\ni\n]\n. You are also given an integer \nw\n. Your task is to \ncover\n \nall\n the given points with rectangles.\n\n\nEach rectangle has its lower end at some point \n(x\n1\n, 0)\n and its upper end at some point \n(x\n2\n, y\n2\n)\n, where \nx\n1\n <= x\n2\n, \ny\n2\n >= 0\n, and the condition \nx\n2\n - x\n1\n <= w\n \nmust\n be satisfied for each rectangle.\n\n\nA point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.\n\n\nReturn an integer denoting the \nminimum\n number of rectangles needed so that each point is covered by \nat least one\n rectangle\n.\n\n\nNote:\n A point may be covered by more than one rectangle.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \npoints = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\n\n\nOutput:\n \n2\n\n\nExplanation: \n\n\nThe image above shows one possible placement of rectangles to cover the points:\n\n\n\n\nA rectangle with a lower end at \n(1, 0)\n and its upper end at \n(2, 8)\n\n\nA rectangle with a lower end at \n(3, 0)\n and its upper end at \n(4, 8)\n\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \npoints = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\n\n\nOutput:\n \n3\n\n\nExplanation: \n\n\nThe image above shows one possible placement of rectangles to cover the points:\n\n\n\n\nA rectangle with a lower end at \n(0, 0)\n and its upper end at \n(2, 2)\n\n\nA rectangle with a lower end at \n(3, 0)\n and its upper end at \n(5, 5)\n\n\nA rectangle with a lower end at \n(6, 0)\n and its upper end at \n(6, 6)\n\n\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n \npoints = [[2,3],[1,2]], w = 0\n\n\nOutput:\n \n2\n\n\nExplanation: \n\n\nThe image above shows one possible placement of rectangles to cover the points:\n\n\n\n\nA rectangle with a lower end at \n(1, 0)\n and its upper end at \n(1, 2)\n\n\nA rectangle with a lower end at \n(2, 0)\n and its upper end at \n(2, 3)\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 10\n5\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n == points[i][0] <= 10\n9\n\n\n0 <= y\ni\n == points[i][1] <= 10\n9\n\n\n0 <= w <= 10\n9\n\n\nAll pairs \n(x\ni\n, y\ni\n)\n are distinct.",
    "temas": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3112,
    "slug": "minimum-time-to-visit-disappearing-nodes",
    "url": "https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes/",
    "titulo": "Minimum Time to Visit Disappearing Nodes",
    "enunciado": "There is an undirected graph of \nn\n nodes. You are given a 2D array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n, length\ni\n]\n describes an edge between node \nu\ni\n and node \nv\ni\n with a traversal time of \nlength\ni\n units.\n\n\nAdditionally, you are given an array \ndisappear\n, where \ndisappear[i]\n denotes the time when the node \ni\n disappears from the graph and you won't be able to visit it.\n\n\nNote\n that the graph might be \ndisconnected\n and might contain \nmultiple edges\n.\n\n\nReturn the array \nanswer\n, with \nanswer[i]\n denoting the \nminimum\n units of time required to reach node \ni\n from node 0. If node \ni\n is \nunreachable\n from node 0 then \nanswer[i]\n is \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\n\n\nOutput:\n \n[0,-1,4]\n\n\nExplanation:\n\n\n\n\nWe are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.\n\n\n\n\nFor node 0, we don't need any time as it is our starting point.\n\n\nFor node 1, we need at least 2 units of time to traverse \nedges[0]\n. Unfortunately, it disappears at that moment, so we won't be able to visit it.\n\n\nFor node 2, we need at least 4 units of time to traverse \nedges[2]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\n\n\nOutput:\n \n[0,2,3]\n\n\nExplanation:\n\n\n\n\nWe are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.\n\n\n\n\nFor node 0, we don't need any time as it is the starting point.\n\n\nFor node 1, we need at least 2 units of time to traverse \nedges[0]\n.\n\n\nFor node 2, we need at least 3 units of time to traverse \nedges[0]\n and \nedges[1]\n.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 2, edges = [[0,1,1]], disappear = [1,1]\n\n\nOutput:\n \n[0,-1]\n\n\nExplanation:\n\n\nExactly when we reach node 1, it disappears.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 5 * 10\n4\n\n\n0 <= edges.length <= 10\n5\n\n\nedges[i] == [u\ni\n, v\ni\n, length\ni\n]\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\n1 <= length\ni\n <= 10\n5\n\n\ndisappear.length == n\n\n\n1 <= disappear[i] <= 10\n5",
    "temas": [
      "Array",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3123,
    "slug": "find-edges-in-shortest-paths",
    "url": "https://leetcode.com/problems/find-edges-in-shortest-paths/",
    "titulo": "Find Edges in Shortest Paths",
    "enunciado": "You are given an undirected weighted graph of \nn\n nodes numbered from 0 to \nn - 1\n. The graph consists of \nm\n edges represented by a 2D array \nedges\n, where \nedges[i] = [a\ni\n, b\ni\n, w\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n with weight \nw\ni\n.\n\n\nConsider all the shortest paths from node 0 to node \nn - 1\n in the graph. You need to find a \nboolean\n array \nanswer\n where \nanswer[i]\n is \ntrue\n if the edge \nedges[i]\n is part of \nat least\n one shortest path. Otherwise, \nanswer[i]\n is \nfalse\n.\n\n\nReturn the array \nanswer\n.\n\n\nNote\n that the graph may not be connected.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nn = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\n\n\nOutput:\n \n[true,true,true,false,true,true,true,false]\n\n\nExplanation:\n\n\nThe following are \nall\n the shortest paths between nodes 0 and 5:\n\n\n\n\nThe path \n0 -> 1 -> 5\n: The sum of weights is \n4 + 1 = 5\n.\n\n\nThe path \n0 -> 2 -> 3 -> 5\n: The sum of weights is \n1 + 1 + 3 = 5\n.\n\n\nThe path \n0 -> 2 -> 3 -> 1 -> 5\n: The sum of weights is \n1 + 1 + 2 + 1 = 5\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nn = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\n\n\nOutput:\n \n[true,false,false,true]\n\n\nExplanation:\n\n\nThere is one shortest path between nodes 0 and 3, which is the path \n0 -> 2 -> 3\n with the sum of weights \n1 + 2 = 3\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\nm == edges.length\n\n\n1 <= m <= min(5 * 10\n4\n, n * (n - 1) / 2)\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\n1 <= w\ni\n <= 10\n5\n\n\nThere are no repeated edges.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 3108,
    "slug": "minimum-cost-walk-in-weighted-graph",
    "url": "https://leetcode.com/problems/minimum-cost-walk-in-weighted-graph/",
    "titulo": "Minimum Cost Walk in Weighted Graph",
    "enunciado": "There is an undirected weighted graph with \nn\n vertices labeled from \n0\n to \nn - 1\n.\n\n\nYou are given the integer \nn\n and an array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n indicates that there is an edge between vertices \nu\ni\n and \nv\ni\n with a weight of \nw\ni\n.\n\n\nA walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It's important to note that a walk may visit the same edge or vertex more than once.\n\n\nThe \ncost\n of a walk starting at node \nu\n and ending at node \nv\n is defined as the bitwise \nAND\n of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is \nw\n0\n, w\n1\n, w\n2\n, ..., w\nk\n, then the cost is calculated as \nw\n0\n & w\n1\n & w\n2\n & ... & w\nk\n, where \n&\n denotes the bitwise \nAND\n operator.\n\n\nYou are also given a 2D array \nquery\n, where \nquery[i] = [s\ni\n, t\ni\n]\n. For each query, you need to find the minimum cost of the walk starting at vertex \ns\ni\n and ending at vertex \nt\ni\n. If there exists no such walk, the answer is \n-1\n.\n\n\nReturn \nthe array \nanswer\n, where \nanswer[i]\n denotes the \nminimum\n cost of a walk for query \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]\n\n\nOutput:\n \n[1,-1]\n\n\nExplanation:\n\n\n\n\nTo achieve the cost of 1 in the first query, we need to move on the following edges: \n0->1\n (weight 7), \n1->2\n (weight 1), \n2->1\n (weight 1), \n1->3\n (weight 7).\n\n\nIn the second query, there is no walk between nodes 3 and 4, so the answer is -1.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nn = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]\n\n\nOutput:\n \n[0]\n\n\nExplanation:\n\n\n\n\nTo achieve the cost of 0 in the first query, we need to move on the following edges: \n1->2\n (weight 1), \n2->1\n (weight 6), \n1->2\n (weight 1).\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n0 <= edges.length <= 10\n5\n\n\nedges[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\nu\ni\n != v\ni\n\n\n0 <= w\ni\n <= 10\n5\n\n\n1 <= query.length <= 10\n5\n\n\nquery[i].length == 2\n\n\n0 <= s\ni\n, t\ni\n <= n - 1\n\n\ns\ni\n != t\ni",
    "temas": [
      "Array",
      "Bit Manipulation",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3070,
    "slug": "count-submatrices-with-top-left-element-and-sum-less-than-k",
    "url": "https://leetcode.com/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/",
    "titulo": "Count Submatrices with Top-Left Element and Sum Less Than k",
    "enunciado": "You are given a \n0-indexed\n integer matrix \ngrid\n and an integer \nk\n.\n\n\nReturn \nthe \nnumber\n of \nsubmatrices\n that contain the top-left element of the\n \ngrid\n, \nand have a sum less than or equal to \nk\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[7,6,3],[6,6,1]], k = 18\n\nOutput:\n 4\n\nExplanation:\n There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\n\nOutput:\n 6\n\nExplanation:\n There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length \n\n\nn == grid[i].length\n\n\n1 <= n, m <= 1000 \n\n\n0 <= grid[i][j] <= 1000\n\n\n1 <= k <= 10\n9",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3100,
    "slug": "water-bottles-ii",
    "url": "https://leetcode.com/problems/water-bottles-ii/",
    "titulo": "Water Bottles II",
    "enunciado": "You are given two integers \nnumBottles\n and \nnumExchange\n.\n\n\nnumBottles\n represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:\n\n\n\n\nDrink any number of full water bottles turning them into empty bottles.\n\n\nExchange \nnumExchange\n empty bottles with one full water bottle. Then, increase \nnumExchange\n by one.\n\n\n\n\nNote that you cannot exchange multiple batches of empty bottles for the same value of \nnumExchange\n. For example, if \nnumBottles == 3\n and \nnumExchange == 1\n, you cannot exchange \n3\n empty water bottles for \n3\n full bottles.\n\n\nReturn \nthe \nmaximum\n number of water bottles you can drink\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n numBottles = 13, numExchange = 6\n\nOutput:\n 15\n\nExplanation:\n The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n numBottles = 10, numExchange = 3\n\nOutput:\n 13\n\nExplanation:\n The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numBottles <= 100 \n\n\n1 <= numExchange <= 100",
    "temas": [
      "Math",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 3071,
    "slug": "minimum-operations-to-write-the-letter-y-on-a-grid",
    "url": "https://leetcode.com/problems/minimum-operations-to-write-the-letter-y-on-a-grid/",
    "titulo": "Minimum Operations to Write the Letter Y on a Grid",
    "enunciado": "You are given a \n0-indexed\n \nn x n\n grid where \nn\n is odd, and \ngrid[r][c]\n is \n0\n, \n1\n, or \n2\n.\n\n\nWe say that a cell belongs to the Letter \nY\n if it belongs to one of the following:\n\n\n\n\nThe diagonal starting at the top-left cell and ending at the center cell of the grid.\n\n\nThe diagonal starting at the top-right cell and ending at the center cell of the grid.\n\n\nThe vertical line starting at the center cell and ending at the bottom border of the grid.\n\n\n\n\nThe Letter \nY\n is written on the grid if and only if:\n\n\n\n\nAll values at cells belonging to the Y are equal.\n\n\nAll values at cells not belonging to the Y are equal.\n\n\nThe values at cells belonging to the Y are different from the values at cells not belonging to the Y.\n\n\n\n\nReturn \nthe \nminimum\n number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to\n \n0\n,\n \n1\n,\n \nor\n \n2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2,2],[1,1,0],[0,1,0]]\n\nOutput:\n 3\n\nExplanation:\n We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 1 while those that do not belong to Y are equal to 0.\nIt can be shown that 3 is the minimum number of operations needed to write Y on the grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\n\nOutput:\n 12\n\nExplanation:\n We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 0 while those that do not belong to Y are equal to 2. \nIt can be shown that 12 is the minimum number of operations needed to write Y on the grid.\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 49 \n\n\nn == grid.length == grid[i].length\n\n\n0 <= grid[i][j] <= 2\n\n\nn\n is odd.",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix",
      "Counting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3033,
    "slug": "modify-the-matrix",
    "url": "https://leetcode.com/problems/modify-the-matrix/",
    "titulo": "Modify the Matrix",
    "enunciado": "Given a \n0-indexed\n \nm x n\n integer matrix \nmatrix\n, create a new \n0-indexed\n matrix called \nanswer\n. Make \nanswer\n equal to \nmatrix\n, then replace each element with the value \n-1\n with the \nmaximum\n element in its respective column.\n\n\nReturn \nthe matrix\n \nanswer\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n\nOutput:\n [[1,2,9],[4,8,6],[7,8,9]]\n\nExplanation:\n The diagram above shows the elements that are changed (in blue).\n- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.\n- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[3,-1],[5,2]]\n\nOutput:\n [[3,2],[5,2]]\n\nExplanation:\n The diagram above shows the elements that are changed (in blue).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n2 <= m, n <= 50\n\n\n-1 <= matrix[i][j] <= 100\n\n\nThe input is generated such that each column contains at least one non-negative integer.",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3067,
    "slug": "count-pairs-of-connectable-servers-in-a-weighted-tree-network",
    "url": "https://leetcode.com/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/",
    "titulo": "Count Pairs of Connectable Servers in a Weighted Tree Network",
    "enunciado": "You are given an unrooted weighted tree with \nn\n vertices representing servers numbered from \n0\n to \nn - 1\n, an array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n, weight\ni\n]\n represents a bidirectional edge between vertices \na\ni\n and \nb\ni\n of weight \nweight\ni\n. You are also given an integer \nsignalSpeed\n.\n\n\nTwo servers \na\n and \nb\n are \nconnectable\n through a server \nc\n if:\n\n\n\n\na < b\n, \na != c\n and \nb != c\n.\n\n\nThe distance from \nc\n to \na\n is divisible by \nsignalSpeed\n.\n\n\nThe distance from \nc\n to \nb\n is divisible by \nsignalSpeed\n.\n\n\nThe path from \nc\n to \nb\n and the path from \nc\n to \na\n do not share any edges.\n\n\n\n\nReturn \nan integer array\n \ncount\n \nof length\n \nn\n \nwhere\n \ncount[i]\n \nis the \nnumber\n of server pairs that are \nconnectable\n through\n \nthe server\n \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n\nOutput:\n [0,4,6,6,4,0]\n\nExplanation:\n Since signalSpeed is 1, count[c] is equal to the number of pairs of paths that start at c and do not share any edges.\nIn the case of the given path graph, count[c] is equal to the number of servers to the left of c multiplied by the servers to the right of c.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n\nOutput:\n [2,0,0,0,0,0,2]\n\nExplanation:\n Through server 0, there are 2 pairs of connectable servers: (4, 5) and (4, 6).\nThrough server 6, there are 2 pairs of connectable servers: (4, 5) and (0, 5).\nIt can be shown that no two servers are connectable through servers other than 0 and 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 1000\n\n\nedges.length == n - 1\n\n\nedges[i].length == 3\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nedges[i] = [a\ni\n, b\ni\n, weight\ni\n]\n\n\n1 <= weight\ni\n <= 10\n6\n\n\n1 <= signalSpeed <= 10\n6\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3047,
    "slug": "find-the-largest-area-of-square-inside-two-rectangles",
    "url": "https://leetcode.com/problems/find-the-largest-area-of-square-inside-two-rectangles/",
    "titulo": "Find the Largest Area of Square Inside Two Rectangles",
    "enunciado": "There exist \nn\n rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays \nbottomLeft\n and \ntopRight\n where \nbottomLeft[i] = [a_i, b_i]\n and \ntopRight[i] = [c_i, d_i]\n represent the \nbottom-left\n and \ntop-right\n coordinates of the \ni\nth\n rectangle, respectively.\n\n\nYou need to find the \nmaximum\n area of a \nsquare\n that can fit inside the intersecting region of at least two rectangles. Return \n0\n if such a square does not exist.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\nA square with side length 1 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 1. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\n\nExample 2:\n\n\n\n\nInput:\n bottomLeft = [[1,1],[1,3],[1,5]], topRight = [[5,5],[5,7],[5,9]]\n\n\nOutput:\n 4\n\n\nExplanation:\n\n\nA square with side length 2 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is \n2 * 2 = 4\n. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\n\nExample 3:\n\n\n \n \n\n\nInput:\n bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\nA square with side length 1 can fit inside the intersecting region of any two rectangles. Also, no larger square can, so the maximum area is 1. Note that the region can be formed by the intersection of more than 2 rectangles.\n\n\nExample 4:\n\n\n \n \n\n\nInput: \nbottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]\n\n\nOutput:\n 0\n\n\nExplanation:\n\n\nNo pair of rectangles intersect, hence, the answer is 0.\n\n\n \n\n\nConstraints:\n\n\n\n\nn == bottomLeft.length == topRight.length\n\n\n2 <= n <= 10\n3\n\n\nbottomLeft[i].length == topRight[i].length == 2\n\n\n1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10\n7\n\n\n1 <= topRight[i][0], topRight[i][1] <= 10\n7\n\n\nbottomLeft[i][0] < topRight[i][0]\n\n\nbottomLeft[i][1] < topRight[i][1]",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3044,
    "slug": "most-frequent-prime",
    "url": "https://leetcode.com/problems/most-frequent-prime/",
    "titulo": "Most Frequent Prime",
    "enunciado": "You are given a \nm x n\n \n0-indexed \n2D\n \nmatrix \nmat\n. From every cell, you can create numbers in the following way:\n\n\n\n\nThere could be at most \n8\n paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.\n\n\nSelect a path from them and append digits in this path to the number being formed by traveling in this direction.\n\n\nNote that numbers are generated at every step, for example, if the digits along the path are \n1, 9, 1\n, then there will be three numbers generated along the way: \n1, 19, 191\n.\n\n\n\n\nReturn \nthe most frequent \nprime number\n \ngreater\n than \n10\n out of all the numbers created by traversing the matrix or \n-1\n if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the \nlargest\n among them.\n\n\nNote:\n It is invalid to change the direction during the move.\n\n\n \n\n\nExample 1:\n\n\n \n\n\n\n\n\nInput:\n mat = [[1,1],[9,9],[1,1]]\n\nOutput:\n 19\n\nExplanation:\n \nFrom cell (0,0) there are 3 possible directions and the numbers greater than 10 which can be created in those directions are:\nEast: [11], South-East: [19], South: [19,191].\nNumbers greater than 10 created from the cell (0,1) in all possible directions are: [19,191,19,11].\nNumbers greater than 10 created from the cell (1,0) in all possible directions are: [99,91,91,91,91].\nNumbers greater than 10 created from the cell (1,1) in all possible directions are: [91,91,99,91,91].\nNumbers greater than 10 created from the cell (2,0) in all possible directions are: [11,19,191,19].\nNumbers greater than 10 created from the cell (2,1) in all possible directions are: [11,19,19,191].\nThe most frequent prime number among all the created numbers is 19.\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[7]]\n\nOutput:\n -1\n\nExplanation:\n The only number which can be formed is 7. It is a prime number however it is not greater than 10, so return -1.\n\n\nExample 3:\n\n\n\n\nInput:\n mat = [[9,7,8],[4,6,5],[2,8,6]]\n\nOutput:\n 97\n\nExplanation:\n \nNumbers greater than 10 created from the cell (0,0) in all possible directions are: [97,978,96,966,94,942].\nNumbers greater than 10 created from the cell (0,1) in all possible directions are: [78,75,76,768,74,79].\nNumbers greater than 10 created from the cell (0,2) in all possible directions are: [85,856,86,862,87,879].\nNumbers greater than 10 created from the cell (1,0) in all possible directions are: [46,465,48,42,49,47].\nNumbers greater than 10 created from the cell (1,1) in all possible directions are: [65,66,68,62,64,69,67,68].\nNumbers greater than 10 created from the cell (1,2) in all possible directions are: [56,58,56,564,57,58].\nNumbers greater than 10 created from the cell (2,0) in all possible directions are: [28,286,24,249,26,268].\nNumbers greater than 10 created from the cell (2,1) in all possible directions are: [86,82,84,86,867,85].\nNumbers greater than 10 created from the cell (2,2) in all possible directions are: [68,682,66,669,65,658].\nThe most frequent prime number among all the created numbers is 97.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 6\n\n\n1 <= mat[i][j] <= 9",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Matrix",
      "Counting",
      "Enumeration",
      "Number Theory"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3017,
    "slug": "count-the-number-of-houses-at-a-certain-distance-ii",
    "url": "https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-ii/",
    "titulo": "Count the Number of Houses at a Certain Distance II",
    "enunciado": "You are given three \npositive\n integers \nn\n, \nx\n, and \ny\n.\n\n\nIn a city, there exist houses numbered \n1\n to \nn\n connected by \nn\n streets. There is a street connecting the house numbered \ni\n with the house numbered \ni + 1\n for all \n1 <= i <= n - 1\n . An additional street connects the house numbered \nx\n with the house numbered \ny\n.\n\n\nFor each \nk\n, such that \n1 <= k <= n\n, you need to find the number of \npairs of houses\n \n(house\n1\n, house\n2\n)\n such that the \nminimum\n number of streets that need to be traveled to reach \nhouse\n2\n from \nhouse\n1\n is \nk\n.\n\n\nReturn \na \n1-indexed\n array \nresult\n of length \nn\n where \nresult[k]\n represents the \ntotal\n number of pairs of houses such that the \nminimum\n streets required to reach one house from the other is \nk\n.\n\n\nNote\n that \nx\n and \ny\n can be \nequal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, x = 1, y = 3\n\nOutput:\n [6,0,0]\n\nExplanation:\n Let's look at each pair of houses:\n- For the pair (1, 2), we can go from house 1 to house 2 directly.\n- For the pair (2, 1), we can go from house 2 to house 1 directly.\n- For the pair (1, 3), we can go from house 1 to house 3 directly.\n- For the pair (3, 1), we can go from house 3 to house 1 directly.\n- For the pair (2, 3), we can go from house 2 to house 3 directly.\n- For the pair (3, 2), we can go from house 3 to house 2 directly.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, x = 2, y = 4\n\nOutput:\n [10,8,2,0,0]\n\nExplanation:\n For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).\n- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).\n- For k == 3, the pairs are (1, 5), and (5, 1).\n- For k == 4 and k == 5, there are no pairs.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 4, x = 1, y = 1\n\nOutput:\n [6,4,2,0]\n\nExplanation:\n For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).\n- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).\n- For k == 3, the pairs are (1, 4), and (4, 1).\n- For k == 4, there are no pairs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n1 <= x, y <= n",
    "temas": [
      "Graph",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 3068,
    "slug": "find-the-maximum-sum-of-node-values",
    "url": "https://leetcode.com/problems/find-the-maximum-sum-of-node-values/",
    "titulo": "Find the Maximum Sum of Node Values",
    "enunciado": "There exists an \nundirected\n tree with \nn\n nodes numbered \n0\n to \nn - 1\n. You are given a \n0-indexed\n 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the tree. You are also given a \npositive\n integer \nk\n, and a \n0-indexed\n array of \nnon-negative\n integers \nnums\n of length \nn\n, where \nnums[i]\n represents the \nvalue\n of the node numbered \ni\n.\n\n\nAlice wants the sum of values of tree nodes to be \nmaximum\n, for which Alice can perform the following operation \nany\n number of times (\nincluding zero\n) on the tree:\n\n\n\n\nChoose any edge \n[u, v]\n connecting the nodes \nu\n and \nv\n, and update their values as follows:\n\n\t\n\n\nnums[u] = nums[u] XOR k\n\n\nnums[v] = nums[v] XOR k\n\n\n\n\n\n\n\n\nReturn \nthe \nmaximum\n possible \nsum\n of the \nvalues\n Alice can achieve by performing the operation \nany\n number of times\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\n\nOutput:\n 6\n\nExplanation:\n Alice can achieve the maximum sum of 6 using a single operation:\n- Choose the edge [0,2]. nums[0] and nums[2] become: 1 XOR 3 = 2, and the array nums becomes: [1,2,1] -> [2,2,2].\nThe total sum of values is 2 + 2 + 2 = 6.\nIt can be shown that 6 is the maximum achievable sum of values.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [2,3], k = 7, edges = [[0,1]]\n\nOutput:\n 9\n\nExplanation:\n Alice can achieve the maximum sum of 9 using a single operation:\n- Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -> [5,4].\nThe total sum of values is 5 + 4 = 9.\nIt can be shown that 9 is the maximum achievable sum of values.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]\n\nOutput:\n 42\n\nExplanation:\n The maximum achievable sum is 42 which can be achieved by Alice performing no operations.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n == nums.length <= 2 * 10\n4\n\n\n1 <= k <= 10\n9\n\n\n0 <= nums[i] <= 10\n9\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= edges[i][0], edges[i][1] <= n - 1\n\n\nThe input is generated such that \nedges\n represent a valid tree.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Bit Manipulation",
      "Tree",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3025,
    "slug": "find-the-number-of-ways-to-place-people-i",
    "url": "https://leetcode.com/problems/find-the-number-of-ways-to-place-people-i/",
    "titulo": "Find the Number of Ways to Place People I",
    "enunciado": "You are given a 2D array \npoints\n of size \nn x 2\n representing integer coordinates of some points on a 2D plane, where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nCount the number of pairs of points \n(A, B)\n, where\n\n\n\n\nA\n is on the \nupper left\n side of \nB\n, and\n\n\nthere are no other points in the rectangle (or line) they make (\nincluding the border\n).\n\n\n\n\nReturn the count.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \npoints = [[1,1],[2,2],[3,3]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\nThere is no way to choose \nA\n and \nB\n so \nA\n is on the upper left side of \nB\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \npoints = [[6,2],[4,4],[2,6]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\nThe left one is the pair \n(points[1], points[0])\n, where \npoints[1]\n is on the upper left side of \npoints[0]\n and the rectangle is empty.\n\n\nThe middle one is the pair \n(points[2], points[1])\n, same as the left one it is a valid pair.\n\n\nThe right one is the pair \n(points[2], points[0])\n, where \npoints[2]\n is on the upper left side of \npoints[0]\n, but \npoints[1]\n is inside the rectangle so it's not a valid pair.\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npoints = [[3,1],[1,3],[1,1]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\n\n\n\nThe left one is the pair \n(points[2], points[0])\n, where \npoints[2]\n is on the upper left side of \npoints[0]\n and there are no other points on the line they form. Note that it is a valid state when the two points form a line.\n\n\nThe middle one is the pair \n(points[1], points[2])\n, it is a valid pair same as the left one.\n\n\nThe right one is the pair \n(points[1], points[0])\n, it is not a valid pair as \npoints[2]\n is on the border of the rectangle.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 50\n\n\npoints[i].length == 2\n\n\n0 <= points[i][0], points[i][1] <= 50\n\n\nAll \npoints[i]\n are distinct.",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Sorting",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3027,
    "slug": "find-the-number-of-ways-to-place-people-ii",
    "url": "https://leetcode.com/problems/find-the-number-of-ways-to-place-people-ii/",
    "titulo": "Find the Number of Ways to Place People II",
    "enunciado": "You are given a 2D array \npoints\n of size \nn x 2\n representing integer coordinates of some points on a 2D-plane, where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nWe define the \nright\n direction as positive x-axis (\nincreasing x-coordinate\n) and the \nleft\n direction as negative x-axis (\ndecreasing x-coordinate\n). Similarly, we define the \nup\n direction as positive y-axis (\nincreasing y-coordinate\n) and the \ndown\n direction as negative y-axis (\ndecreasing y-coordinate\n)\n\n\nYou have to place \nn\n people, including Alice and Bob, at these points such that there is \nexactly one\n person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the \nupper left corner\n and Bob's position as the \nlower right corner\n of the fence (\nNote\n that the fence \nmight not\n enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either \ninside\n the fence or \non\n the fence, Alice will be sad.\n\n\nReturn \nthe number of \npairs of points\n where you can place Alice and Bob, such that Alice \ndoes not\n become sad on building the fence\n.\n\n\nNote\n that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners \n(1, 1)\n, \n(1, 3)\n, \n(3, 1)\n, and \n(3, 3)\n, because:\n\n\n\n\nWith Alice at \n(3, 3)\n and Bob at \n(1, 1)\n, Alice's position is not the upper left corner and Bob's position is not the lower right corner of the fence.\n\n\nWith Alice at \n(1, 3)\n and Bob at \n(1, 1)\n, Bob's position is not the lower right corner of the fence.\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,1],[2,2],[3,3]]\n\nOutput:\n 0\n\nExplanation:\n There is no way to place Alice and Bob such that Alice can build a fence with Alice's position as the upper left corner and Bob's position as the lower right corner. Hence we return 0. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[6,2],[4,4],[2,6]]\n\nOutput:\n 2\n\nExplanation:\n There are two ways to place Alice and Bob such that Alice will not be sad:\n- Place Alice at (4, 4) and Bob at (6, 2).\n- Place Alice at (2, 6) and Bob at (4, 4).\nYou cannot place Alice at (2, 6) and Bob at (6, 2) because the person at (4, 4) will be inside the fence.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n points = [[3,1],[1,3],[1,1]]\n\nOutput:\n 2\n\nExplanation:\n There are two ways to place Alice and Bob such that Alice will not be sad:\n- Place Alice at (1, 1) and Bob at (3, 1).\n- Place Alice at (1, 3) and Bob at (1, 1).\nYou cannot place Alice at (1, 3) and Bob at (3, 1) because the person at (1, 1) will be on the fence.\nNote that it does not matter if the fence encloses any area, the first and second fences in the image are valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 1000\n\n\npoints[i].length == 2\n\n\n-10\n9\n <= points[i][0], points[i][1] <= 10\n9\n\n\nAll \npoints[i]\n are distinct.",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Sorting",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3016,
    "slug": "minimum-number-of-pushes-to-type-word-ii",
    "url": "https://leetcode.com/problems/minimum-number-of-pushes-to-type-word-ii/",
    "titulo": "Minimum Number of Pushes to Type Word II",
    "enunciado": "You are given a string \nword\n containing lowercase English letters.\n\n\nTelephone keypads have keys mapped with \ndistinct\n collections of lowercase English letters, which can be used to form words by pushing them. For example, the key \n2\n is mapped with \n[\"a\",\"b\",\"c\"]\n, we need to push the key one time to type \n\"a\"\n, two times to type \n\"b\"\n, and three times to type \n\"c\"\n \n.\n\n\nIt is allowed to remap the keys numbered \n2\n to \n9\n to \ndistinct\n collections of letters. The keys can be remapped to \nany\n amount of letters, but each letter \nmust\n be mapped to \nexactly\n one key. You need to find the \nminimum\n number of times the keys will be pushed to type the string \nword\n.\n\n\nReturn \nthe \nminimum\n number of pushes needed to type \nword\n \nafter remapping the keys\n.\n\n\nAn example mapping of letters to keys on a telephone keypad is given below. Note that \n1\n, \n*\n, \n#\n, and \n0\n do \nnot\n map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n word = \"abcde\"\n\nOutput:\n 5\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\nTotal cost is 1 + 1 + 1 + 1 + 1 = 5.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n word = \"xyzxyzxyzxyz\"\n\nOutput:\n 12\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"x\" -> one push on key 2\n\"y\" -> one push on key 3\n\"z\" -> one push on key 4\nTotal cost is 1 * 4 + 1 * 4 + 1 * 4 = 12\nIt can be shown that no other mapping can provide a lower cost.\nNote that the key 9 is not mapped to any letter: it is not necessary to map letters to every key, but to map all the letters.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n word = \"aabbccddeeffgghhiiiiii\"\n\nOutput:\n 24\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\n\"f\" -> one push on key 7\n\"g\" -> one push on key 8\n\"h\" -> two pushes on key 9\n\"i\" -> one push on key 9\nTotal cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 10\n5\n\n\nword\n consists of lowercase English letters.",
    "temas": [
      "Hash Table",
      "String",
      "Greedy",
      "Sorting",
      "Counting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 3014,
    "slug": "minimum-number-of-pushes-to-type-word-i",
    "url": "https://leetcode.com/problems/minimum-number-of-pushes-to-type-word-i/",
    "titulo": "Minimum Number of Pushes to Type Word I",
    "enunciado": "You are given a string \nword\n containing \ndistinct\n lowercase English letters.\n\n\nTelephone keypads have keys mapped with \ndistinct\n collections of lowercase English letters, which can be used to form words by pushing them. For example, the key \n2\n is mapped with \n[\"a\",\"b\",\"c\"]\n, we need to push the key one time to type \n\"a\"\n, two times to type \n\"b\"\n, and three times to type \n\"c\"\n \n.\n\n\nIt is allowed to remap the keys numbered \n2\n to \n9\n to \ndistinct\n collections of letters. The keys can be remapped to \nany\n amount of letters, but each letter \nmust\n be mapped to \nexactly\n one key. You need to find the \nminimum\n number of times the keys will be pushed to type the string \nword\n.\n\n\nReturn \nthe \nminimum\n number of pushes needed to type \nword\n \nafter remapping the keys\n.\n\n\nAn example mapping of letters to keys on a telephone keypad is given below. Note that \n1\n, \n*\n, \n#\n, and \n0\n do \nnot\n map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n word = \"abcde\"\n\nOutput:\n 5\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\nTotal cost is 1 + 1 + 1 + 1 + 1 = 5.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n word = \"xycdefghij\"\n\nOutput:\n 12\n\nExplanation:\n The remapped keypad given in the image provides the minimum cost.\n\"x\" -> one push on key 2\n\"y\" -> two pushes on key 2\n\"c\" -> one push on key 3\n\"d\" -> two pushes on key 3\n\"e\" -> one push on key 4\n\"f\" -> one push on key 5\n\"g\" -> one push on key 6\n\"h\" -> one push on key 7\n\"i\" -> one push on key 8\n\"j\" -> one push on key 9\nTotal cost is 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 26\n\n\nword\n consists of lowercase English letters.\n\n\nAll letters in \nword\n are distinct.",
    "temas": [
      "Math",
      "String",
      "Greedy"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 3030,
    "slug": "find-the-grid-of-region-average",
    "url": "https://leetcode.com/problems/find-the-grid-of-region-average/",
    "titulo": "Find the Grid of Region Average",
    "enunciado": "You are given \nm x n\n grid \nimage\n which represents a grayscale image, where \nimage[i][j]\n represents a pixel with intensity in the range \n[0..255]\n. You are also given a \nnon-negative\n integer \nthreshold\n.\n\n\nTwo pixels are \nadjacent\n if they share an edge.\n\n\nA \nregion\n is a \n3 x 3\n subgrid where the \nabsolute difference\n in intensity between any two \nadjacent\n pixels is \nless than or equal to\n \nthreshold\n.\n\n\nAll pixels in a region belong to that region, note that a pixel can belong to \nmultiple\n regions.\n\n\nYou need to calculate a \nm x n\n grid \nresult\n, where \nresult[i][j]\n is the \naverage\n intensity of the regions to which \nimage[i][j]\n belongs, \nrounded down\n to the nearest integer. If \nimage[i][j]\n belongs to multiple regions, \nresult[i][j]\n is the \naverage \nof the\n rounded-down average \nintensities of these regions, \nrounded down\n to the nearest integer. If \nimage[i][j]\n does\n not\n belong to any region, \nresult[i][j]\n is \nequal to\n \nimage[i][j]\n.\n\n\nReturn the grid \nresult\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nimage = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n\n\nOutput:\n \n[[9,9,9,9],[9,9,9,9],[9,9,9,9]]\n\n\nExplanation:\n\n\n\n\nThere are two regions as illustrated above. The average intensity of the first region is 9, while the average intensity of the second region is 9.67 which is rounded down to 9. The average intensity of both of the regions is (9 + 9) / 2 = 9. As all the pixels belong to either region 1, region 2, or both of them, the intensity of every pixel in the result is 9.\n\n\nPlease note that the rounded-down values are used when calculating the average of multiple regions, hence the calculation is done using 9 as the average intensity of region 2, not 9.67.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nimage = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n\n\nOutput:\n \n[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n\n\nExplanation:\n\n\n\n\nThere are two regions as illustrated above. The average intensity of the first region is 25, while the average intensity of the second region is 30. The average intensity of both of the regions is (25 + 30) / 2 = 27.5 which is rounded down to 27.\n\n\nAll the pixels in row 0 of the image belong to region 1, hence all the pixels in row 0 in the result are 25. Similarly, all the pixels in row 3 in the result are 30. The pixels in rows 1 and 2 of the image belong to region 1 and region 2, hence their assigned value is 27 in the result.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nimage = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1\n\n\nOutput:\n \n[[5,6,7],[8,9,10],[11,12,13]]\n\n\nExplanation:\n\n\nThere is only one \n3 x 3\n subgrid, while it does not have the condition on difference of adjacent pixels, for example, the difference between \nimage[0][0]\n and \nimage[1][0]\n is \n|5 - 8| = 3 > threshold = 1\n. None of them belong to any valid regions, so the \nresult\n should be the same as \nimage\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n, m <= 500\n\n\n0 <= image[i][j] <= 255\n\n\n0 <= threshold <= 255",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 3015,
    "slug": "count-the-number-of-houses-at-a-certain-distance-i",
    "url": "https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-i/",
    "titulo": "Count the Number of Houses at a Certain Distance I",
    "enunciado": "You are given three \npositive\n integers \nn\n, \nx\n, and \ny\n.\n\n\nIn a city, there exist houses numbered \n1\n to \nn\n connected by \nn\n streets. There is a street connecting the house numbered \ni\n with the house numbered \ni + 1\n for all \n1 <= i <= n - 1\n . An additional street connects the house numbered \nx\n with the house numbered \ny\n.\n\n\nFor each \nk\n, such that \n1 <= k <= n\n, you need to find the number of \npairs of houses\n \n(house\n1\n, house\n2\n)\n such that the \nminimum\n number of streets that need to be traveled to reach \nhouse\n2\n from \nhouse\n1\n is \nk\n.\n\n\nReturn \na \n1-indexed\n array \nresult\n of length \nn\n where \nresult[k]\n represents the \ntotal\n number of pairs of houses such that the \nminimum\n streets required to reach one house from the other is \nk\n.\n\n\nNote\n that \nx\n and \ny\n can be \nequal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, x = 1, y = 3\n\nOutput:\n [6,0,0]\n\nExplanation:\n Let's look at each pair of houses:\n- For the pair (1, 2), we can go from house 1 to house 2 directly.\n- For the pair (2, 1), we can go from house 2 to house 1 directly.\n- For the pair (1, 3), we can go from house 1 to house 3 directly.\n- For the pair (3, 1), we can go from house 3 to house 1 directly.\n- For the pair (2, 3), we can go from house 2 to house 3 directly.\n- For the pair (3, 2), we can go from house 3 to house 2 directly.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, x = 2, y = 4\n\nOutput:\n [10,8,2,0,0]\n\nExplanation:\n For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).\n- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).\n- For k == 3, the pairs are (1, 5), and (5, 1).\n- For k == 4 and k == 5, there are no pairs.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 4, x = 1, y = 1\n\nOutput:\n [6,4,2,0]\n\nExplanation:\n For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).\n- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).\n- For k == 3, the pairs are (1, 4), and (4, 1).\n- For k == 4, there are no pairs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n1 <= x, y <= n",
    "temas": [
      "Breadth-First Search",
      "Graph",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Breadth-First Search",
    "has_image": true
  },
  {
    "id": 3001,
    "slug": "minimum-moves-to-capture-the-queen",
    "url": "https://leetcode.com/problems/minimum-moves-to-capture-the-queen/",
    "titulo": "Minimum Moves to Capture The Queen",
    "enunciado": "There is a \n1-indexed\n \n8 x 8\n chessboard containing \n3\n pieces.\n\n\nYou are given \n6\n integers \na\n, \nb\n, \nc\n, \nd\n, \ne\n, and \nf\n where:\n\n\n\n\n(a, b)\n denotes the position of the white rook.\n\n\n(c, d)\n denotes the position of the white bishop.\n\n\n(e, f)\n denotes the position of the black queen.\n\n\n\n\nGiven that you can only move the white pieces, return \nthe \nminimum\n number of moves required to capture the black queen\n.\n\n\nNote\n that:\n\n\n\n\nRooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.\n\n\nBishops can move any number of squares diagonally, but cannot jump over other pieces.\n\n\nA rook or a bishop can capture the queen if it is located in a square that they can move to.\n\n\nThe queen does not move.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n a = 1, b = 1, c = 8, d = 8, e = 2, f = 3\n\nOutput:\n 2\n\nExplanation:\n We can capture the black queen in two moves by moving the white rook to (1, 3) then to (2, 3).\nIt is impossible to capture the black queen in less than two moves since it is not being attacked by any of the pieces at the beginning.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n a = 5, b = 3, c = 3, d = 4, e = 5, f = 2\n\nOutput:\n 1\n\nExplanation:\n We can capture the black queen in a single move by doing one of the following: \n- Move the white rook to (5, 2).\n- Move the white bishop to (5, 2).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a, b, c, d, e, f <= 8\n\n\nNo two pieces are on the same square.",
    "temas": [
      "Math",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2975,
    "slug": "maximum-square-area-by-removing-fences-from-a-field",
    "url": "https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/",
    "titulo": "Maximum Square Area by Removing Fences From a Field",
    "enunciado": "There is a large \n(m - 1) x (n - 1)\n rectangular field with corners at \n(1, 1)\n and \n(m, n)\n containing some horizontal and vertical fences given in arrays \nhFences\n and \nvFences\n respectively.\n\n\nHorizontal fences are from the coordinates \n(hFences[i], 1)\n to \n(hFences[i], n)\n and vertical fences are from the coordinates \n(1, vFences[i])\n to \n(m, vFences[i])\n.\n\n\nReturn \nthe \nmaximum\n area of a \nsquare\n field that can be formed by \nremoving\n some fences (\npossibly none\n) or \n-1\n \nif it is impossible to make a square field\n.\n\n\nSince the answer may be large, return it \nmodulo\n \n10\n9 \n+ 7\n.\n\n\nNote: \nThe field is surrounded by two horizontal fences from the coordinates \n(1, 1)\n to \n(1, n)\n and \n(m, 1)\n to \n(m, n)\n and two vertical fences from the coordinates \n(1, 1)\n to \n(m, 1)\n and \n(1, n)\n to \n(m, n)\n. These fences \ncannot\n be removed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 4, n = 3, hFences = [2,3], vFences = [2]\n\nOutput:\n 4\n\nExplanation:\n Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 6, n = 7, hFences = [2], vFences = [4]\n\nOutput:\n -1\n\nExplanation:\n It can be proved that there is no way to create a square field by removing fences.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= m, n <= 10\n9\n\n\n1 <= hF\nences\n.length, vFences.length <= 600\n\n\n1 < hFences[i] < m\n\n\n1 < vFences[i] < n\n\n\nhFences\n and \nvFences\n are unique.",
    "temas": [
      "Array",
      "Hash Table",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2973,
    "slug": "find-number-of-coins-to-place-in-tree-nodes",
    "url": "https://leetcode.com/problems/find-number-of-coins-to-place-in-tree-nodes/",
    "titulo": "Find Number of Coins to Place in Tree Nodes",
    "enunciado": "You are given an \nundirected\n tree with \nn\n nodes labeled from \n0\n to \nn - 1\n, and rooted at node \n0\n. You are given a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nYou are also given a \n0-indexed\n integer array \ncost\n of length \nn\n, where \ncost[i]\n is the \ncost\n assigned to the \ni\nth\n node.\n\n\nYou need to place some coins on every node of the tree. The number of coins to be placed at node \ni\n can be calculated as:\n\n\n\n\nIf size of the subtree of node \ni\n is less than \n3\n, place \n1\n coin.\n\n\nOtherwise, place an amount of coins equal to the \nmaximum\n product of cost values assigned to \n3\n distinct nodes in the subtree of node \ni\n. If this product is \nnegative\n, place \n0\n coins.\n\n\n\n\nReturn \nan array \ncoin\n of size \nn\n such that \ncoin[i]\n is the number of coins placed at node \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\n\nOutput:\n [120,1,1,1,1,1]\n\nExplanation:\n For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\n\nOutput:\n [280,140,32,1,1,1,1,1,1]\n\nExplanation:\n The coins placed on each node are:\n- Place 8 * 7 * 5 = 280 coins on node 0.\n- Place 7 * 5 * 4 = 140 coins on node 1.\n- Place 8 * 2 * 2 = 32 coins on node 2.\n- All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[0,2]], cost = [1,2,-2]\n\nOutput:\n [0,1,1]\n\nExplanation:\n Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 2 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\ncost.length == n\n\n\n1 <= |cost[i]| <= 10\n4\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2959,
    "slug": "number-of-possible-sets-of-closing-branches",
    "url": "https://leetcode.com/problems/number-of-possible-sets-of-closing-branches/",
    "titulo": "Number of Possible Sets of Closing Branches",
    "enunciado": "There is a company with \nn\n branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads.\n\n\nThe company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (\npossibly none\n). However, they want to ensure that the remaining branches have a distance of at most \nmaxDistance\n from each other.\n\n\nThe \ndistance\n between two branches is the \nminimum\n total traveled length needed to reach one branch from another.\n\n\nYou are given integers \nn\n, \nmaxDistance\n, and a \n0-indexed\n 2D array \nroads\n, where \nroads[i] = [u\ni\n, v\ni\n, w\ni\n]\n represents the \nundirected\n road between branches \nu\ni\n and \nv\ni\n with length \nw\ni\n.\n\n\nReturn \nthe number of possible sets of closing branches, so that any branch has a distance of at most \nmaxDistance\n from any other\n.\n\n\nNote\n that, after closing a branch, the company will no longer have access to any roads connected to it.\n\n\nNote\n that, multiple roads are allowed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]\n\nOutput:\n 5\n\nExplanation:\n The possible sets of closing branches are:\n- The set [2], after closing, active branches are [0,1] and they are reachable to each other within distance 2.\n- The set [0,1], after closing, the active branch is [2].\n- The set [1,2], after closing, the active branch is [0].\n- The set [0,2], after closing, the active branch is [1].\n- The set [0,1,2], after closing, there are no active branches.\nIt can be proven, that there are only 5 possible sets of closing branches.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]\n\nOutput:\n 7\n\nExplanation:\n The possible sets of closing branches are:\n- The set [], after closing, active branches are [0,1,2] and they are reachable to each other within distance 4.\n- The set [0], after closing, active branches are [1,2] and they are reachable to each other within distance 2.\n- The set [1], after closing, active branches are [0,2] and they are reachable to each other within distance 2.\n- The set [0,1], after closing, the active branch is [2].\n- The set [1,2], after closing, the active branch is [0].\n- The set [0,2], after closing, the active branch is [1].\n- The set [0,1,2], after closing, there are no active branches.\nIt can be proven, that there are only 7 possible sets of closing branches.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 1, maxDistance = 10, roads = []\n\nOutput:\n 2\n\nExplanation:\n The possible sets of closing branches are:\n- The set [], after closing, the active branch is [0].\n- The set [0], after closing, there are no active branches.\nIt can be proven, that there are only 2 possible sets of closing branches.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n\n\n1 <= maxDistance <= 10\n5\n\n\n0 <= roads.length <= 1000\n\n\nroads[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\nu\ni\n != v\ni\n\n\n1 <= w\ni\n <= 1000\n\n\nAll branches are reachable from each other by traveling some roads.",
    "temas": [
      "Bit Manipulation",
      "Graph",
      "Heap (Priority Queue)",
      "Enumeration",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Bit Manipulation",
    "has_image": true
  },
  {
    "id": 2946,
    "slug": "matrix-similarity-after-cyclic-shifts",
    "url": "https://leetcode.com/problems/matrix-similarity-after-cyclic-shifts/",
    "titulo": "Matrix Similarity After Cyclic Shifts",
    "enunciado": "You are given an \nm x n\n integer matrix \nmat\n and an integer \nk\n. The matrix rows are 0-indexed.\n\n\nThe following proccess happens \nk\n times:\n\n\n\n\nEven-indexed\n rows (0, 2, 4, ...) are cyclically shifted to the left.\n\n\n\n\n\n\n\n\nOdd-indexed\n rows (1, 3, 5, ...) are cyclically shifted to the right.\n\n\n\n\n\n\nReturn \ntrue\n if the final modified matrix after \nk\n steps is identical to the original matrix, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nmat = [[1,2,3],[4,5,6],[7,8,9]], k = 4\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nIn each step left shift is applied to rows 0 and 2 (even indices), and right shift to row 1 (odd index).\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nmat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nmat = [[2,2],[2,2]], k = 3\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nAs all the values are equal in the matrix, even after performing cyclic shifts the matrix will remain the same.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= mat.length <= 25\n\n\n1 <= mat[i].length <= 25\n\n\n1 <= mat[i][j] <= 25\n\n\n1 <= k <= 50",
    "temas": [
      "Array",
      "Math",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2943,
    "slug": "maximize-area-of-square-hole-in-grid",
    "url": "https://leetcode.com/problems/maximize-area-of-square-hole-in-grid/",
    "titulo": "Maximize Area of Square Hole in Grid",
    "enunciado": "You are given the two integers, \nn\n and \nm\n and two integer arrays, \nhBars\n and \nvBars\n. The grid has \nn + 2\n horizontal and \nm + 2\n vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from \n1\n.\n\n\nYou can \nremove\n some of the bars in \nhBars\n from horizontal bars and some of the bars in \nvBars\n from vertical bars. Note that other bars are fixed and cannot be removed.\n\n\nReturn an integer denoting the \nmaximum area\n of a \nsquare-shaped\n hole in the grid, after removing some bars (possibly none).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput: \nn = 2, m = 1, hBars = [2,3], vBars = [2]\n\n\nOutput: \n4\n\n\nExplanation:\n\n\nThe left image shows the initial grid formed by the bars. The horizontal bars are \n[1,2,3,4]\n, and the vertical bars are \n[1,2,3]\n.\n\n\nOne way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput: \nn = 1, m = 1, hBars = [2], vBars = [2]\n\n\nOutput: \n4\n\n\nExplanation:\n\n\nTo get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput: \nn = 2, m = 3, hBars = [2,3], vBars = [2,4]\n\n\nOutput: \n4\n\n\nExplanation:\n\n\nOne way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n9\n\n\n1 <= m <= 10\n9\n\n\n1 <= hBars.length <= 100\n\n\n2 <= hBars[i] <= n + 1\n\n\n1 <= vBars.length <= 100\n\n\n2 <= vBars[i] <= m + 1\n\n\nAll values in \nhBars\n are distinct.\n\n\nAll values in \nvBars\n are distinct.",
    "temas": [
      "Array",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2956,
    "slug": "find-common-elements-between-two-arrays",
    "url": "https://leetcode.com/problems/find-common-elements-between-two-arrays/",
    "titulo": "Find Common Elements Between Two Arrays",
    "enunciado": "You are given two integer arrays \nnums1\n and \nnums2\n of sizes \nn\n and \nm\n, respectively. Calculate the following values:\n\n\n\n\nanswer1\n : the number of indices \ni\n such that \nnums1[i]\n exists in \nnums2\n.\n\n\nanswer2\n : the number of indices \ni\n such that \nnums2[i]\n exists in \nnums1\n.\n\n\n\n\nReturn \n[answer1,answer2]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums1 = [2,3,2], nums2 = [1,2]\n\n\nOutput:\n \n[2,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]\n\n\nOutput:\n \n[3,4]\n\n\nExplanation:\n\n\nThe elements at indices 1, 2, and 3 in \nnums1\n exist in \nnums2\n as well. So \nanswer1\n is 3.\n\n\nThe elements at indices 0, 1, 3, and 4 in \nnums2\n exist in \nnums1\n. So \nanswer2\n is 4.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums1 = [3,4,2,3], nums2 = [1,5]\n\n\nOutput:\n \n[0,0]\n\n\nExplanation:\n\n\nNo numbers are common between \nnums1\n and \nnums2\n, so answer is [0,0].\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums1.length\n\n\nm == nums2.length\n\n\n1 <= n, m <= 100\n\n\n1 <= nums1[i], nums2[i] <= 100",
    "temas": [
      "Array",
      "Hash Table"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2925,
    "slug": "maximum-score-after-applying-operations-on-a-tree",
    "url": "https://leetcode.com/problems/maximum-score-after-applying-operations-on-a-tree/",
    "titulo": "Maximum Score After Applying Operations on a Tree",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n, and rooted at node \n0\n. You are given a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nYou are also given a \n0-indexed\n integer array \nvalues\n of length \nn\n, where \nvalues[i]\n is the \nvalue\n associated with the \ni\nth\n node.\n\n\nYou start with a score of \n0\n. In one operation, you can:\n\n\n\n\nPick any node \ni\n.\n\n\nAdd \nvalues[i]\n to your score.\n\n\nSet \nvalues[i]\n to \n0\n.\n\n\n\n\nA tree is \nhealthy\n if the sum of values on the path from the root to any leaf node is different than zero.\n\n\nReturn \nthe \nmaximum score\n you can obtain after performing these operations on the tree any number of times so that it remains \nhealthy\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]\n\nOutput:\n 11\n\nExplanation:\n We can choose nodes 1, 2, 3, 4, and 5. The value of the root is non-zero. Hence, the sum of values on the path from the root to any leaf is different than zero. Therefore, the tree is healthy and the score is values[1] + values[2] + values[3] + values[4] + values[5] = 11.\nIt can be shown that 11 is the maximum score obtainable after any number of operations on the tree.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]\n\nOutput:\n 40\n\nExplanation:\n We can choose nodes 0, 2, 3, and 4.\n- The sum of values on the path from 0 to 4 is equal to 10.\n- The sum of values on the path from 0 to 3 is equal to 10.\n- The sum of values on the path from 0 to 5 is equal to 3.\n- The sum of values on the path from 0 to 6 is equal to 5.\nTherefore, the tree is healthy and the score is values[0] + values[2] + values[3] + values[4] = 40.\nIt can be shown that 40 is the maximum score obtainable after any number of operations on the tree.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 2 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nvalues.length == n\n\n\n1 <= values[i] <= 10\n9\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2924,
    "slug": "find-champion-ii",
    "url": "https://leetcode.com/problems/find-champion-ii/",
    "titulo": "Find Champion II",
    "enunciado": "There are \nn\n teams numbered from \n0\n to \nn - 1\n in a tournament; each team is also a node in a \nDAG\n.\n\n\nYou are given the integer \nn\n and a \n0-indexed\n 2D integer array \nedges\n of length \nm\n representing the \nDAG\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is a directed edge from team \nu\ni\n to team \nv\ni\n in the graph.\n\n\nA directed edge from \na\n to \nb\n in the graph means that team \na\n is \nstronger\n than team \nb\n and team \nb\n is \nweaker\n than team \na\n.\n\n\nTeam \na\n will be the \nchampion\n of the tournament if there is no team \nb\n that is \nstronger\n than team \na\n.\n\n\nReturn \nthe team that will be the \nchampion\n of the tournament if there is a \nunique\n champion, otherwise, return \n-1\n.\n\n\nNotes\n\n\n\n\nA \ncycle\n is a series of nodes \na\n1\n, a\n2\n, ..., a\nn\n, a\nn+1\n such that node \na\n1\n is the same node as node \na\nn+1\n, the nodes \na\n1\n, a\n2\n, ..., a\nn\n are distinct, and there is a directed edge from the node \na\ni\n to node \na\ni+1\n for every \ni\n in the range \n[1, n]\n.\n\n\nA \nDAG\n is a directed graph that does not have any \ncycle\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2]]\n\nOutput:\n 0\n\nExplanation: \nTeam 1 is weaker than team 0. Team 2 is weaker than team 1. So the champion is team 0.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[0,2],[1,3],[1,2]]\n\nOutput:\n -1\n\nExplanation:\n Team 2 is weaker than team 0 and team 1. Team 3 is weaker than team 1. But team 1 and team 0 are not weaker than any other teams. So the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\nm == edges.length\n\n\n0 <= m <= n * (n - 1) / 2\n\n\nedges[i].length == 2\n\n\n0 <= edge[i][j] <= n - 1\n\n\nedges[i][0] != edges[i][1]\n\n\nThe input is generated such that if team \na\n is stronger than team \nb\n, team \nb\n is not stronger than team \na\n.\n\n\nThe input is generated such that if team \na\n is stronger than team \nb\n and team \nb\n is stronger than team \nc\n, then team \na\n is stronger than team \nc\n.",
    "temas": [
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 2920,
    "slug": "maximum-points-after-collecting-coins-from-all-nodes",
    "url": "https://leetcode.com/problems/maximum-points-after-collecting-coins-from-all-nodes/",
    "titulo": "Maximum Points After Collecting Coins From All Nodes",
    "enunciado": "There exists an undirected tree rooted at node \n0\n with \nn\n nodes labeled from \n0\n to \nn - 1\n. You are given a 2D \ninteger\n array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree. You are also given a \n0-indexed\n array \ncoins\n of size \nn\n where \ncoins[i]\n indicates the number of coins in the vertex \ni\n, and an integer \nk\n.\n\n\nStarting from the root, you have to collect all the coins such that the coins at a node can only be collected if the coins of its ancestors have been already collected.\n\n\nCoins at \nnode\ni\n can be collected in one of the following ways:\n\n\n\n\nCollect all the coins, but you will get \ncoins[i] - k\n points. If \ncoins[i] - k\n is negative then you will lose \nabs(coins[i] - k)\n points.\n\n\nCollect all the coins, but you will get \nfloor(coins[i] / 2)\n points. If this way is used, then for all the \nnode\nj\n present in the subtree of \nnode\ni\n, \ncoins[j]\n will get reduced to \nfloor(coins[j] / 2)\n.\n\n\n\n\nReturn \nthe \nmaximum points\n you can get after collecting the coins from \nall\n the tree nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5\n\nOutput:\n 11                        \n\nExplanation:\n \nCollect all the coins from node 0 using the first way. Total points = 10 - 5 = 5.\nCollect all the coins from node 1 using the first way. Total points = 5 + (10 - 5) = 10.\nCollect all the coins from node 2 using the second way so coins left at node 3 will be floor(3 / 2) = 1. Total points = 10 + floor(3 / 2) = 11.\nCollect all the coins from node 3 using the second way. Total points = 11 + floor(1 / 2) = 11.\nIt can be shown that the maximum points we can get after collecting coins from all the nodes is 11. \n\n\n\nExample 2:\n\n\n \n\n\n\n\nInput:\n edges = [[0,1],[0,2]], coins = [8,4,4], k = 0\n\nOutput:\n 16\n\nExplanation:\n \nCoins will be collected from all the nodes using the first way. Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == coins.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= coins[i] <= 10\n4\n\n\nedges.length == n - 1\n\n\n0 <= edges[i][0], edges[i][1] < n\n\n\n0 <= k <= 10\n4",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Tree",
      "Depth-First Search",
      "Memoization"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2876,
    "slug": "count-visited-nodes-in-a-directed-graph",
    "url": "https://leetcode.com/problems/count-visited-nodes-in-a-directed-graph/",
    "titulo": "Count Visited Nodes in a Directed Graph",
    "enunciado": "There is a \ndirected\n graph consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n and \nn\n directed edges.\n\n\nYou are given a \n0-indexed\n array \nedges\n where \nedges[i]\n indicates that there is an edge from node \ni\n to node \nedges[i]\n.\n\n\nConsider the following process on the graph:\n\n\n\n\nYou start from a node \nx\n and keep visiting other nodes through edges until you reach a node that you have already visited before on this \nsame\n process.\n\n\n\n\nReturn \nan array \nanswer\n where \nanswer[i]\n is the number of \ndifferent\n nodes that you will visit if you perform the process starting from node \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [1,2,0,0]\n\nOutput:\n [3,3,3,4]\n\nExplanation:\n We perform the process starting from each node in the following way:\n- Starting from node 0, we visit the nodes 0 -> 1 -> 2 -> 0. The number of different nodes we visit is 3.\n- Starting from node 1, we visit the nodes 1 -> 2 -> 0 -> 1. The number of different nodes we visit is 3.\n- Starting from node 2, we visit the nodes 2 -> 0 -> 1 -> 2. The number of different nodes we visit is 3.\n- Starting from node 3, we visit the nodes 3 -> 0 -> 1 -> 2 -> 0. The number of different nodes we visit is 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [1,2,3,4,0]\n\nOutput:\n [5,5,5,5,5]\n\nExplanation:\n Starting from any node we can visit every node in the graph in the process.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= edges[i] <= n - 1\n\n\nedges[i] != i",
    "temas": [
      "Dynamic Programming",
      "Graph",
      "Memoization"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2867,
    "slug": "count-valid-paths-in-a-tree",
    "url": "https://leetcode.com/problems/count-valid-paths-in-a-tree/",
    "titulo": "Count Valid Paths in a Tree",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n1\n to \nn\n. You are given the integer \nn\n and a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the tree.\n\n\nReturn \nthe \nnumber of valid paths\n in the tree\n.\n\n\nA path \n(a, b)\n is \nvalid\n if there exists \nexactly one\n prime number among the node labels in the path from \na\n to \nb\n.\n\n\nNote\n that:\n\n\n\n\nThe path \n(a, b)\n is a sequence of \ndistinct\n nodes starting with node \na\n and ending with node \nb\n such that every two adjacent nodes in the sequence share an edge in the tree.\n\n\nPath \n(a, b)\n and path \n(b, a)\n are considered the \nsame\n and counted only \nonce\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]\n\nOutput:\n 4\n\nExplanation:\n The pairs with exactly one prime number on the path between them are: \n- (1, 2) since the path from 1 to 2 contains prime number 2. \n- (1, 3) since the path from 1 to 3 contains prime number 3.\n- (1, 4) since the path from 1 to 4 contains prime number 2.\n- (2, 4) since the path from 2 to 4 contains prime number 2.\nIt can be shown that there are only 4 valid paths.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]\n\nOutput:\n 6\n\nExplanation:\n The pairs with exactly one prime number on the path between them are: \n- (1, 2) since the path from 1 to 2 contains prime number 2.\n- (1, 3) since the path from 1 to 3 contains prime number 3.\n- (1, 4) since the path from 1 to 4 contains prime number 2.\n- (1, 6) since the path from 1 to 6 contains prime number 3.\n- (2, 4) since the path from 2 to 4 contains prime number 2.\n- (3, 6) since the path from 3 to 6 contains prime number 3.\nIt can be shown that there are only 6 valid paths.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nThe input is generated such that \nedges\n represent a valid tree.",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2858,
    "slug": "minimum-edge-reversals-so-every-node-is-reachable",
    "url": "https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/",
    "titulo": "Minimum Edge Reversals So Every Node Is Reachable",
    "enunciado": "There is a \nsimple directed graph\n with \nn\n nodes labeled from \n0\n to \nn - 1\n. The graph would form a \ntree\n if its edges were bi-directional.\n\n\nYou are given an integer \nn\n and a \n2D\n integer array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n]\n represents a \ndirected edge\n going from node \nu\ni\n to node \nv\ni\n.\n\n\nAn \nedge reversal\n changes the direction of an edge, i.e., a directed edge going from node \nu\ni\n to node \nv\ni\n becomes a directed edge going from node \nv\ni\n to node \nu\ni\n.\n\n\nFor every node \ni\n in the range \n[0, n - 1]\n, your task is to \nindependently\n calculate the \nminimum\n number of \nedge reversals\n required so it is possible to reach any other node starting from node \ni\n through a \nsequence\n of \ndirected edges\n.\n\n\nReturn \nan integer array \nanswer\n, where \nanswer[i]\n is the\n \n \nminimum\n number of \nedge reversals\n required so it is possible to reach any other node starting from node \ni\n through a \nsequence\n of \ndirected edges\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[2,0],[2,1],[1,3]]\n\nOutput:\n [1,1,0,2]\n\nExplanation:\n The image above shows the graph formed by the edges.\nFor node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0.\nSo, answer[0] = 1.\nFor node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1.\nSo, answer[1] = 1.\nFor node 2: it is already possible to reach any other node starting from node 2.\nSo, answer[2] = 0.\nFor node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3.\nSo, answer[3] = 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[1,2],[2,0]]\n\nOutput:\n [2,0,1]\n\nExplanation:\n The image above shows the graph formed by the edges.\nFor node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0.\nSo, answer[0] = 2.\nFor node 1: it is already possible to reach any other node starting from node 1.\nSo, answer[1] = 0.\nFor node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2.\nSo, answer[2] = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n == edges[i][0] < n\n\n\n0 <= v\ni\n == edges[i][1] < n\n\n\nu\ni\n != v\ni\n\n\nThe input is generated such that if the edges were bi-directional, the graph would be a tree.",
    "temas": [
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2850,
    "slug": "minimum-moves-to-spread-stones-over-grid",
    "url": "https://leetcode.com/problems/minimum-moves-to-spread-stones-over-grid/",
    "titulo": "Minimum Moves to Spread Stones Over Grid",
    "enunciado": "You are given a \n0-indexed\n 2D integer matrix \ngrid\n of size \n3 * 3\n, representing the number of stones in each cell. The grid contains exactly \n9\n stones, and there can be \nmultiple\n stones in a single cell.\n\n\nIn one move, you can move a single stone from its current cell to any other cell if the two cells share a side.\n\n\nReturn \nthe \nminimum number of moves\n required to place one stone in each cell\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,1,0],[1,1,1],[1,2,1]]\n\nOutput:\n 3\n\nExplanation:\n One possible sequence of moves to place one stone in each cell is: \n1- Move one stone from cell (2,1) to cell (2,2).\n2- Move one stone from cell (2,2) to cell (1,2).\n3- Move one stone from cell (1,2) to cell (0,2).\nIn total, it takes 3 moves to place one stone in each cell of the grid.\nIt can be shown that 3 is the minimum number of moves required to place one stone in each cell.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,3,0],[1,0,0],[1,0,3]]\n\nOutput:\n 4\n\nExplanation:\n One possible sequence of moves to place one stone in each cell is:\n1- Move one stone from cell (0,1) to cell (0,2).\n2- Move one stone from cell (0,1) to cell (1,1).\n3- Move one stone from cell (2,2) to cell (1,2).\n4- Move one stone from cell (2,2) to cell (2,1).\nIn total, it takes 4 moves to place one stone in each cell of the grid.\nIt can be shown that 4 is the minimum number of moves required to place one stone in each cell.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ngrid.length == grid[i].length == 3\n\n\n0 <= grid[i][j] <= 9\n\n\nSum of \ngrid\n is equal to \n9\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2856,
    "slug": "minimum-array-length-after-pair-removals",
    "url": "https://leetcode.com/problems/minimum-array-length-after-pair-removals/",
    "titulo": "Minimum Array Length After Pair Removals",
    "enunciado": "Given an integer array \nnum\n sorted in non-decreasing order.\n\n\nYou can perform the following operation any number of times:\n\n\n\n\nChoose \ntwo\n indices, \ni\n and \nj\n, where \nnums[i] < nums[j]\n.\n\n\nThen, remove the elements at indices \ni\n and \nj\n from \nnums\n. The remaining elements retain their original order, and the array is re-indexed.\n\n\n\n\nReturn the \nminimum\n length of \nnums\n after applying the operation zero or more times.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,2,2,3,3]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1000000000,1000000000]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nSince both numbers are equal, they cannot be removed.\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nnums = [2,3,4,4,4]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n9\n\n\nnums\n is sorted in \nnon-decreasing\n order.",
    "temas": [
      "Array",
      "Hash Table",
      "Two Pointers",
      "Binary Search",
      "Greedy",
      "Counting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2846,
    "slug": "minimum-edge-weight-equilibrium-queries-in-a-tree",
    "url": "https://leetcode.com/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/",
    "titulo": "Minimum Edge Weight Equilibrium Queries in a Tree",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n. You are given the integer \nn\n and a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [u\ni\n, v\ni\n, w\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n with weight \nw\ni\n in the tree.\n\n\nYou are also given a 2D integer array \nqueries\n of length \nm\n, where \nqueries[i] = [a\ni\n, b\ni\n]\n. For each query, find the \nminimum number of operations\n required to make the weight of every edge on the path from \na\ni\n to \nb\ni\n equal. In one operation, you can choose any edge of the tree and change its weight to any value.\n\n\nNote\n that:\n\n\n\n\nQueries are \nindependent\n of each other, meaning that the tree returns to its \ninitial state\n on each new query.\n\n\nThe path from \na\ni\n to \nb\ni\n is a sequence of \ndistinct\n nodes starting with node \na\ni\n and ending with node \nb\ni\n such that every two adjacent nodes in the sequence share an edge in the tree.\n\n\n\n\nReturn \nan array \nanswer\n of length \nm\n where\n \nanswer[i]\n \nis the answer to the\n \ni\nth\n \nquery.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]\n\nOutput:\n [0,0,1,3]\n\nExplanation:\n In the first query, all the edges in the path from 0 to 3 have a weight of 1. Hence, the answer is 0.\nIn the second query, all the edges in the path from 3 to 6 have a weight of 2. Hence, the answer is 0.\nIn the third query, we change the weight of edge [2,3] to 2. After this operation, all the edges in the path from 2 to 6 have a weight of 2. Hence, the answer is 1.\nIn the fourth query, we change the weights of edges [0,1], [1,2] and [2,3] to 2. After these operations, all the edges in the path from 0 to 6 have a weight of 2. Hence, the answer is 3.\nFor each queries[i], it can be shown that answer[i] is the minimum number of operations needed to equalize all the edge weights in the path from a\ni\n to b\ni\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]\n\nOutput:\n [1,2,2,3]\n\nExplanation:\n In the first query, we change the weight of edge [1,3] to 6. After this operation, all the edges in the path from 4 to 6 have a weight of 6. Hence, the answer is 1.\nIn the second query, we change the weight of edges [0,3] and [3,1] to 6. After these operations, all the edges in the path from 0 to 4 have a weight of 6. Hence, the answer is 2.\nIn the third query, we change the weight of edges [1,3] and [5,2] to 6. After these operations, all the edges in the path from 6 to 5 have a weight of 6. Hence, the answer is 2.\nIn the fourth query, we change the weights of edges [0,7], [0,3] and [1,3] to 6. After these operations, all the edges in the path from 7 to 4 have a weight of 6. Hence, the answer is 3.\nFor each queries[i], it can be shown that answer[i] is the minimum number of operations needed to equalize all the edge weights in the path from a\ni\n to b\ni\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\n1 <= w\ni\n <= 26\n\n\nThe input is generated such that \nedges\n represents a valid tree.\n\n\n1 <= queries.length == m <= 2 * 10\n4\n\n\nqueries[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n",
    "temas": [
      "Array",
      "Tree",
      "Graph",
      "Strongly Connected Component"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2872,
    "slug": "maximum-number-of-k-divisible-components",
    "url": "https://leetcode.com/problems/maximum-number-of-k-divisible-components/",
    "titulo": "Maximum Number of K-Divisible Components",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n. You are given the integer \nn\n and a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nYou are also given a \n0-indexed\n integer array \nvalues\n of length \nn\n, where \nvalues[i]\n is the \nvalue\n associated with the \ni\nth\n node, and an integer \nk\n.\n\n\nA \nvalid split\n of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by \nk\n, where the \nvalue of a connected component\n is the sum of the values of its nodes.\n\n\nReturn \nthe \nmaximum number of components\n in any valid split\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6\n\nOutput:\n 2\n\nExplanation:\n We remove the edge connecting node 1 with 2. The resulting split is valid because:\n- The value of the component containing nodes 1 and 3 is values[1] + values[3] = 12.\n- The value of the component containing nodes 0, 2, and 4 is values[0] + values[2] + values[4] = 6.\nIt can be shown that no other valid split has more than 2 connected components.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3\n\nOutput:\n 3\n\nExplanation:\n We remove the edge connecting node 0 with 2, and the edge connecting node 0 with 1. The resulting split is valid because:\n- The value of the component containing node 0 is values[0] = 3.\n- The value of the component containing nodes 2, 5, and 6 is values[2] + values[5] + values[6] = 9.\n- The value of the component containing nodes 1, 3, and 4 is values[1] + values[3] + values[4] = 6.\nIt can be shown that no other valid split has more than 3 connected components.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 3 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\nvalues.length == n\n\n\n0 <= values[i] <= 10\n9\n\n\n1 <= k <= 10\n9\n\n\nSum of \nvalues\n is divisible by \nk\n.\n\n\nThe input is generated such that \nedges\n represents a valid tree.",
    "temas": [
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2849,
    "slug": "determine-if-a-cell-is-reachable-at-a-given-time",
    "url": "https://leetcode.com/problems/determine-if-a-cell-is-reachable-at-a-given-time/",
    "titulo": "Determine if a Cell Is Reachable at a Given Time",
    "enunciado": "You are given four integers \nsx\n, \nsy\n, \nfx\n, \nfy\n, and a \nnon-negative\n integer \nt\n.\n\n\nIn an infinite 2D grid, you start at the cell \n(sx, sy)\n. Each second, you \nmust\n move to any of its adjacent cells.\n\n\nReturn \ntrue\n \nif you can reach cell \n(fx, fy)\n \nafter\n exactly\n \nt\n \nseconds\n, \nor\n \nfalse\n \notherwise\n.\n\n\nA cell's \nadjacent cells\n are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n sx = 2, sy = 4, fx = 7, fy = 7, t = 6\n\nOutput:\n true\n\nExplanation:\n Starting at cell (2, 4), we can reach cell (7, 7) in exactly 6 seconds by going through the cells depicted in the picture above. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n sx = 3, sy = 1, fx = 7, fy = 3, t = 3\n\nOutput:\n false\n\nExplanation:\n Starting at cell (3, 1), it takes at least 4 seconds to reach cell (7, 3) by going through the cells depicted in the picture above. Hence, we cannot reach cell (7, 3) at the third second.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sx, sy, fx, fy <= 10\n9\n\n\n0 <= t <= 10\n9",
    "temas": [
      "Math"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2812,
    "slug": "find-the-safest-path-in-a-grid",
    "url": "https://leetcode.com/problems/find-the-safest-path-in-a-grid/",
    "titulo": "Find the Safest Path in a Grid",
    "enunciado": "You are given a \n0-indexed\n 2D matrix \ngrid\n of size \nn x n\n, where \n(r, c)\n represents:\n\n\n\n\nA cell containing a thief if \ngrid[r][c] = 1\n\n\nAn empty cell if \ngrid[r][c] = 0\n\n\n\n\nYou are initially positioned at cell \n(0, 0)\n. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.\n\n\nThe \nsafeness factor\n of a path on the grid is defined as the \nminimum\n manhattan distance from any cell in the path to any thief in the grid.\n\n\nReturn \nthe \nmaximum safeness factor\n of all paths leading to cell \n(n - 1, n - 1)\n.\n\n\nAn \nadjacent\n cell of cell \n(r, c)\n, is one of the cells \n(r, c + 1)\n, \n(r, c - 1)\n, \n(r + 1, c)\n and \n(r - 1, c)\n if it exists.\n\n\nThe \nManhattan distance\n between two cells \n(a, b)\n and \n(x, y)\n is equal to \n|a - x| + |b - y|\n, where \n|val|\n denotes the absolute value of val.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0],[0,0,0],[0,0,1]]\n\nOutput:\n 0\n\nExplanation:\n All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1],[0,0,0],[0,0,0]]\n\nOutput:\n 2\n\nExplanation:\n The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]\n\nOutput:\n 2\n\nExplanation:\n The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.\n- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= grid.length == n <= 400\n\n\ngrid[i].length == n\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.\n\n\nThere is at least one thief in the \ngrid\n.",
    "temas": [
      "Array",
      "Binary Search",
      "Breadth-First Search",
      "Union Find",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2791,
    "slug": "count-paths-that-can-form-a-palindrome-in-a-tree",
    "url": "https://leetcode.com/problems/count-paths-that-can-form-a-palindrome-in-a-tree/",
    "titulo": "Count Paths That Can Form a Palindrome in a Tree",
    "enunciado": "You are given a \ntree\n (i.e. a connected, undirected graph that has no cycles) \nrooted\n at node \n0\n consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n. The tree is represented by a \n0-indexed\n array \nparent\n of size \nn\n, where \nparent[i]\n is the parent of node \ni\n. Since node \n0\n is the root, \nparent[0] == -1\n.\n\n\nYou are also given a string \ns\n of length \nn\n, where \ns[i]\n is the character assigned to the edge between \ni\n and \nparent[i]\n. \ns[0]\n can be ignored.\n\n\nReturn \nthe number of pairs of nodes \n(u, v)\n such that \nu < v\n and the characters assigned to edges on the path from \nu\n to \nv\n can be \nrearranged\n to form a \npalindrome\n.\n\n\nA string is a \npalindrome\n when it reads the same backwards as forwards.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n parent = [-1,0,0,1,1,2], s = \"acaabc\"\n\nOutput:\n 8\n\nExplanation:\n The valid pairs are:\n- All the pairs (0,1), (0,2), (1,3), (1,4) and (2,5) result in one character which is always a palindrome.\n- The pair (2,3) result in the string \"aca\" which is a palindrome.\n- The pair (1,5) result in the string \"cac\" which is a palindrome.\n- The pair (3,5) result in the string \"acac\" which can be rearranged into the palindrome \"acca\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n parent = [-1,0,0,0,0], s = \"aaaaa\"\n\nOutput:\n 10\n\nExplanation:\n Any pair of nodes (u,v) where u < v is valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parent.length == s.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= parent[i] <= n - 1\n for all \ni >= 1\n\n\nparent[0] == -1\n\n\nparent\n represents a valid tree.\n\n\ns\n consists of only lowercase English letters.",
    "temas": [
      "Dynamic Programming",
      "Bit Manipulation",
      "Tree",
      "Depth-First Search",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2807,
    "slug": "insert-greatest-common-divisors-in-linked-list",
    "url": "https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/",
    "titulo": "Insert Greatest Common Divisors in Linked List",
    "enunciado": "Given the head of a linked list \nhead\n, in which each node contains an integer value.\n\n\nBetween every pair of adjacent nodes, insert a new node with a value equal to the \ngreatest common divisor\n of them.\n\n\nReturn \nthe linked list after insertion\n.\n\n\nThe \ngreatest common divisor\n of two numbers is the largest positive integer that evenly divides both numbers.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [18,6,10,3]\n\nOutput:\n [18,6,6,2,10,1,3]\n\nExplanation:\n The 1\nst\n diagram denotes the initial linked list and the 2\nnd\n diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).\n- We insert the greatest common divisor of 18 and 6 = 6 between the 1\nst\n and the 2\nnd\n nodes.\n- We insert the greatest common divisor of 6 and 10 = 2 between the 2\nnd\n and the 3\nrd\n nodes.\n- We insert the greatest common divisor of 10 and 3 = 1 between the 3\nrd\n and the 4\nth\n nodes.\nThere are no more adjacent nodes, so we return the linked list.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [7]\n\nOutput:\n [7]\n\nExplanation:\n The 1\nst\n diagram denotes the initial linked list and the 2\nnd\n diagram denotes the linked list after inserting the new nodes.\nThere are no pairs of adjacent nodes, so we return the initial linked list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 5000]\n.\n\n\n1 <= Node.val <= 1000",
    "temas": [
      "Linked List",
      "Math",
      "Number Theory"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2768,
    "slug": "number-of-black-blocks",
    "url": "https://leetcode.com/problems/number-of-black-blocks/",
    "titulo": "Number of Black Blocks",
    "enunciado": "You are given two integers \nm\n and \nn\n representing the dimensions of a \n0-indexed\n \nm x n\n grid.\n\n\nYou are also given a \n0-indexed\n 2D integer matrix \ncoordinates\n, where \ncoordinates[i] = [x, y]\n indicates that the cell with coordinates \n[x, y]\n is colored \nblack\n. All cells in the grid that do not appear in \ncoordinates\n are \nwhite\n.\n\n\nA block is defined as a \n2 x 2\n submatrix of the grid. More formally, a block with cell \n[x, y]\n as its top-left corner where \n0 <= x < m - 1\n and \n0 <= y < n - 1\n contains the coordinates \n[x, y]\n, \n[x + 1, y]\n, \n[x, y + 1]\n, and \n[x + 1, y + 1]\n.\n\n\nReturn \na \n0-indexed\n integer array\n \narr\n \nof size\n \n5\n \nsuch that\n \narr[i]\n \nis the number of blocks that contains exactly\n \ni\n \nblack\n cells\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n m = 3, n = 3, coordinates = [[0,0]]\n\nOutput:\n [3,1,0,0,0]\n\nExplanation:\n The grid looks like this:\n\n\nThere is only 1 block with one black cell, and it is the block starting with cell [0,0].\nThe other 3 blocks start with cells [0,1], [1,0] and [1,1]. They all have zero black cells. \nThus, we return [3,1,0,0,0]. \n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]\n\nOutput:\n [0,2,2,0,0]\n\nExplanation:\n The grid looks like this:\n\n\nThere are 2 blocks with two black cells (the ones starting with cell coordinates [0,0] and [0,1]).\nThe other 2 blocks have starting cell coordinates of [1,0] and [1,1]. They both have 1 black cell.\nTherefore, we return [0,2,2,0,0].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= m <= 10\n5\n\n\n2 <= n <= 10\n5\n\n\n0 <= coordinates.length <= 10\n4\n\n\ncoordinates[i].length == 2\n\n\n0 <= coordinates[i][0] < m\n\n\n0 <= coordinates[i][1] < n\n\n\nIt is guaranteed that \ncoordinates\n contains pairwise distinct coordinates.",
    "temas": [
      "Array",
      "Hash Table",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2816,
    "slug": "double-a-number-represented-as-a-linked-list",
    "url": "https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/",
    "titulo": "Double a Number Represented as a Linked List",
    "enunciado": "You are given the \nhead\n of a \nnon-empty\n linked list representing a non-negative integer without leading zeroes.\n\n\nReturn \nthe \nhead\n of the linked list after \ndoubling\n it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,8,9]\n\nOutput:\n [3,7,8]\n\nExplanation:\n The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [9,9,9]\n\nOutput:\n [1,9,9,8]\n\nExplanation:\n The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 10\n4\n]\n\n\n0 <= Node.val <= 9\n\n\nThe input is generated such that the list represents a number that does not have leading zeros, except the number \n0\n itself.",
    "temas": [
      "Linked List",
      "Math",
      "Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2751,
    "slug": "robot-collisions",
    "url": "https://leetcode.com/problems/robot-collisions/",
    "titulo": "Robot Collisions",
    "enunciado": "There are \nn\n \n1-indexed\n robots, each having a position on a line, health, and movement direction.\n\n\nYou are given \n0-indexed\n integer arrays \npositions\n, \nhealths\n, and a string \ndirections\n (\ndirections[i]\n is either \n'L'\n for \nleft\n or \n'R'\n for \nright\n). All integers in \npositions\n are \nunique\n.\n\n\nAll robots start moving on the line\n simultaneously\n at the \nsame speed \nin their given directions. If two robots ever share the same position while moving, they will \ncollide\n.\n\n\nIf two robots collide, the robot with \nlower health\n is \nremoved\n from the line, and the health of the other robot \ndecreases\n \nby one\n. The surviving robot continues in the \nsame\n direction it was going. If both robots have the \nsame\n health, they are both\n \nremoved from the line.\n\n\nYour task is to determine the \nhealth\n of the robots that survive the collisions, in the same \norder \nthat the robots were given,\n \ni.e. final health of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\n\n\nReturn \nan array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\n\n\nNote:\n The positions may be unsorted.\n\n\n \n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\n\nOutput:\n [2,17,9,15,10]\n\nExplanation:\n No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\n\nOutput:\n [14]\n\nExplanation:\n There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4's health is smaller, it gets removed, and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\n\nOutput:\n []\n\nExplanation:\n Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= positions.length == healths.length == directions.length == n <= 10\n5\n\n\n1 <= positions[i], healths[i] <= 10\n9\n\n\ndirections[i] == 'L'\n or \ndirections[i] == 'R'\n\n\nAll values in \npositions\n are distinct",
    "temas": [
      "Array",
      "Stack",
      "Sorting",
      "Simulation"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2718,
    "slug": "sum-of-matrix-after-queries",
    "url": "https://leetcode.com/problems/sum-of-matrix-after-queries/",
    "titulo": "Sum of Matrix After Queries",
    "enunciado": "You are given an integer \nn\n and a \n0-indexed\n \n2D array\n \nqueries\n where \nqueries[i] = [type\ni\n, index\ni\n, val\ni\n]\n.\n\n\nInitially, there is a \n0-indexed\n \nn x n\n matrix filled with \n0\n's. For each query, you must apply one of the following changes:\n\n\n\n\nif \ntype\ni\n == 0\n, set the values in the row with \nindex\ni\n to \nval\ni\n, overwriting any previous values.\n\n\nif \ntype\ni\n == 1\n, set the values in the column with \nindex\ni\n to \nval\ni\n, overwriting any previous values.\n\n\n\n\nReturn \nthe sum of integers in the matrix after all queries are applied\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]\n\nOutput:\n 23\n\nExplanation:\n The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]\n\nOutput:\n 17\n\nExplanation:\n The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4\n\n\n1 <= queries.length <= 5 * 10\n4\n\n\nqueries[i].length == 3\n\n\n0 <= type\ni\n <= 1\n\n\n0 <= index\ni\n < n\n\n\n0 <= val\ni\n <= 10\n5",
    "temas": [
      "Array",
      "Hash Table"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2713,
    "slug": "maximum-strictly-increasing-cells-in-a-matrix",
    "url": "https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/",
    "titulo": "Maximum Strictly Increasing Cells in a Matrix",
    "enunciado": "Given a \n1-indexed\n \nm x n\n integer matrix \nmat\n, you can select any cell in the matrix as your \nstarting cell\n.\n\n\nFrom the starting cell, you can move to any other cell \nin the\n \nsame row or column\n, but only if the value of the destination cell is \nstrictly greater\n than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\n\n\nYour task is to find the \nmaximum number of cells\n that you can visit in the matrix by starting from some cell.\n\n\nReturn \nan integer denoting the maximum number of cells that can be visited.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[3,1],[3,4]]\n\nOutput:\n 2\n\nExplanation:\n The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[1,1],[1,1]]\n\nOutput:\n 1\n\nExplanation:\n Since the cells must be strictly increasing, we can only visit one cell in this example. \n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n mat = [[3,1,6],[-9,5,7]]\n\nOutput:\n 4\n\nExplanation:\n The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length \n\n\nn == mat[i].length \n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n-10\n5\n <= mat[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Hash Table",
      "Binary Search",
      "Dynamic Programming",
      "Memoization",
      "Sorting",
      "Matrix",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2699,
    "slug": "modify-graph-edge-weights",
    "url": "https://leetcode.com/problems/modify-graph-edge-weights/",
    "titulo": "Modify Graph Edge Weights",
    "enunciado": "You are given an \nundirected weighted\n \nconnected\n graph containing \nn\n nodes labeled from \n0\n to \nn - 1\n, and an integer array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n, w\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n with weight \nw\ni\n.\n\n\nSome edges have a weight of \n-1\n (\nw\ni\n = -1\n), while others have a \npositive\n weight (\nw\ni\n > 0\n).\n\n\nYour task is to modify \nall edges\n with a weight of \n-1\n by assigning them \npositive integer values \nin the range \n[1, 2 * 10\n9\n]\n so that the \nshortest distance\n between the nodes \nsource\n and \ndestination\n becomes equal to an integer \ntarget\n. If there are \nmultiple\n \nmodifications\n that make the shortest distance between \nsource\n and \ndestination\n equal to \ntarget\n, any of them will be considered correct.\n\n\nReturn \nan array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from \nsource\n to \ndestination\n equal to \ntarget\n, or an \nempty array\n if it's impossible.\n\n\nNote:\n You are not allowed to modify the weights of edges with initial positive weights.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\n\nOutput:\n [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\n\nExplanation:\n The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\n\nOutput:\n []\n\nExplanation:\n The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\n\nOutput:\n [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\n\nExplanation:\n The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n1 <= edges.length <= n * (n - 1) / 2\n\n\nedges[i].length == 3\n\n\n0 <= a\ni\n, b\ni \n< n\n\n\nw\ni\n = -1 \nor \n1 <= w\ni \n<= 10\n7\n\n\na\ni \n!= b\ni\n\n\n0 <= source, destination < n\n\n\nsource != destination\n\n\n1 <= target <= 10\n9\n\n\nThe graph is connected, and there are no self-loops or repeated edges",
    "temas": [
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 2711,
    "slug": "difference-of-number-of-distinct-values-on-diagonals",
    "url": "https://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/",
    "titulo": "Difference of Number of Distinct Values on Diagonals",
    "enunciado": "Given a 2D \ngrid\n of size \nm x n\n, you should find the matrix \nanswer\n of size \nm x n\n.\n\n\nThe cell \nanswer[r][c]\n is calculated by looking at the diagonal values of the cell \ngrid[r][c]\n:\n\n\n\n\nLet \nleftAbove[r][c]\n be the number of \ndistinct\n values on the diagonal to the left and above the cell \ngrid[r][c]\n not including the cell \ngrid[r][c]\n itself.\n\n\nLet \nrightBelow[r][c]\n be the number of \ndistinct\n values on the diagonal to the right and below the cell \ngrid[r][c]\n, not including the cell \ngrid[r][c]\n itself.\n\n\nThen \nanswer[r][c] = |leftAbove[r][c] - rightBelow[r][c]|\n.\n\n\n\n\nA \nmatrix diagonal\n is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.\n\n\n\n\nFor example, in the below diagram the diagonal is highlighted using the cell with indices \n(2, 3)\n colored gray:\n\n\t\n\n\nRed-colored cells are left and above the cell.\n\n\nBlue-colored cells are right and below the cell.\n\n\n\n\n\n\n\n\n\n\nReturn the matrix \nanswer\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ngrid = [[1,2,3],[3,1,5],[3,2,1]]\n\n\nOutput:\n \nOutput: [[1,1,0],[1,0,1],[0,1,1]]\n\n\nExplanation:\n\n\nTo calculate the \nanswer\n cells:\n\n\n\n\n\n\n\n\nanswer\n\n\nleft-above elements\n\n\nleftAbove\n\n\nright-below elements\n\n\nrightBelow\n\n\n|leftAbove - rightBelow|\n\n\n\n\n\n\n\n\n\n\n[0][0]\n\n\n[]\n\n\n0\n\n\n[grid[1][1], grid[2][2]]\n\n\n|{1, 1}| = 1\n\n\n1\n\n\n\n\n\n\n[0][1]\n\n\n[]\n\n\n0\n\n\n[grid[1][2]]\n\n\n|{5}| = 1\n\n\n1\n\n\n\n\n\n\n[0][2]\n\n\n[]\n\n\n0\n\n\n[]\n\n\n0\n\n\n0\n\n\n\n\n\n\n[1][0]\n\n\n[]\n\n\n0\n\n\n[grid[2][1]]\n\n\n|{2}| = 1\n\n\n1\n\n\n\n\n\n\n[1][1]\n\n\n[grid[0][0]]\n\n\n|{1}| = 1\n\n\n[grid[2][2]]\n\n\n|{1}| = 1\n\n\n0\n\n\n\n\n\n\n[1][2]\n\n\n[grid[0][1]]\n\n\n|{2}| = 1\n\n\n[]\n\n\n0\n\n\n1\n\n\n\n\n\n\n[2][0]\n\n\n[]\n\n\n0\n\n\n[]\n\n\n0\n\n\n0\n\n\n\n\n\n\n[2][1]\n\n\n[grid[1][0]]\n\n\n|{3}| = 1\n\n\n[]\n\n\n0\n\n\n1\n\n\n\n\n\n\n[2][2]\n\n\n[grid[0][0], grid[1][1]]\n\n\n|{1, 1}| = 1\n\n\n[]\n\n\n0\n\n\n1\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ngrid = [[1]]\n\n\nOutput:\n \nOutput: [[0]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n, grid[i][j] <= 50",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2684,
    "slug": "maximum-number-of-moves-in-a-grid",
    "url": "https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/",
    "titulo": "Maximum Number of Moves in a Grid",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n matrix \ngrid\n consisting of \npositive\n integers.\n\n\nYou can start at \nany\n cell in the first column of the matrix, and traverse the grid in the following way:\n\n\n\n\nFrom a cell \n(row, col)\n, you can move to any of the cells: \n(row - 1, col + 1)\n, \n(row, col + 1)\n and \n(row + 1, col + 1)\n such that the value of the cell you move to, should be \nstrictly\n bigger than the value of the current cell.\n\n\n\n\nReturn \nthe \nmaximum\n number of \nmoves\n that you can perform.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\n\nOutput:\n 3\n\nExplanation:\n We can start at the cell (0, 0) and make the following moves:\n- (0, 0) -> (0, 1).\n- (0, 1) -> (1, 2).\n- (1, 2) -> (2, 3).\nIt can be shown that it is the maximum number of moves that can be made.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[3,2,4],[2,1,9],[1,1,7]]\n\nOutput:\n 0\n\nExplanation:\n Starting from any cell in the first column we cannot perform any moves.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 1000\n\n\n4 <= m * n <= 10\n5\n\n\n1 <= grid[i][j] <= 10\n6",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2685,
    "slug": "count-the-number-of-complete-components",
    "url": "https://leetcode.com/problems/count-the-number-of-complete-components/",
    "titulo": "Count the Number of Complete Components",
    "enunciado": "You are given an integer \nn\n. There is an \nundirected\n graph with \nn\n vertices, numbered from \n0\n to \nn - 1\n. You are given a 2D integer array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n denotes that there exists an \nundirected\n edge connecting vertices \na\ni\n and \nb\ni\n.\n\n\nReturn \nthe number of \ncomplete connected components\n of the graph\n.\n\n\nA \nconnected component\n is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\n\n\nA connected component is said to be \ncomplete\n if there exists an edge between every pair of its vertices.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\n\nOutput:\n 3\n\nExplanation:\n From the picture above, one can see that all of the components of this graph are complete.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\n\nOutput:\n 1\n\nExplanation:\n The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 50\n\n\n0 <= edges.length <= n * (n - 1) / 2\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni\n\n\nThere are no repeated edges.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2673,
    "slug": "make-costs-of-paths-equal-in-a-binary-tree",
    "url": "https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/",
    "titulo": "Make Costs of Paths Equal in a Binary Tree",
    "enunciado": "You are given an integer \nn\n representing the number of nodes in a \nperfect binary tree\n consisting of nodes numbered from \n1\n to \nn\n. The root of the tree is node \n1\n and each node \ni\n in the tree has two children where the left child is the node \n2 * i\n and the right child is \n2 * i + 1\n.\n\n\nEach node in the tree also has a \ncost\n represented by a given \n0-indexed\n integer array \ncost\n of size \nn\n where \ncost[i]\n is the cost of node \ni + 1\n. You are allowed to \nincrement\n the cost of \nany\n node by \n1\n \nany\n number of times.\n\n\nReturn \nthe \nminimum\n number of increments you need to make the cost of paths from the root to each \nleaf\n node equal\n.\n\n\nNote\n:\n\n\n\n\nA \nperfect binary tree \nis a tree where each node, except the leaf nodes, has exactly 2 children.\n\n\nThe \ncost of a path\n is the sum of costs of nodes in the path.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, cost = [1,5,2,2,3,3,1]\n\nOutput:\n 6\n\nExplanation:\n We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, cost = [5,3,3]\n\nOutput:\n 0\n\nExplanation:\n The two paths already have equal total costs, so no increments are needed.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\nn + 1\n is a power of \n2\n\n\ncost.length == n\n\n\n1 <= cost[i] <= 10\n4",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2658,
    "slug": "maximum-number-of-fish-in-a-grid",
    "url": "https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/",
    "titulo": "Maximum Number of Fish in a Grid",
    "enunciado": "You are given a \n0-indexed\n 2D matrix \ngrid\n of size \nm x n\n, where \n(r, c)\n represents:\n\n\n\n\nA \nland\n cell if \ngrid[r][c] = 0\n, or\n\n\nA \nwater\n cell containing \ngrid[r][c]\n fish, if \ngrid[r][c] > 0\n.\n\n\n\n\nA fisher can start at any \nwater\n cell \n(r, c)\n and can do the following operations any number of times:\n\n\n\n\nCatch all the fish at cell \n(r, c)\n, or\n\n\nMove to any adjacent \nwater\n cell.\n\n\n\n\nReturn \nthe \nmaximum\n number of fish the fisher can catch if he chooses his starting cell optimally, or \n0\n if no water cell exists.\n\n\nAn \nadjacent\n cell of the cell \n(r, c)\n, is one of the cells \n(r, c + 1)\n, \n(r, c - 1)\n, \n(r + 1, c)\n or \n(r - 1, c)\n if it exists.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\n\nOutput:\n 7\n\nExplanation:\n The fisher can start at cell \n(1,3)\n and collect 3 fish, then move to cell \n(2,3)\n and collect 4 fish.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\n\nOutput:\n 1\n\nExplanation:\n The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n\n\n0 <= grid[i][j] <= 10",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2646,
    "slug": "minimize-the-total-price-of-the-trips",
    "url": "https://leetcode.com/problems/minimize-the-total-price-of-the-trips/",
    "titulo": "Minimize the Total Price of the Trips",
    "enunciado": "There exists an undirected and unrooted tree with \nn\n nodes indexed from \n0\n to \nn - 1\n. You are given the integer \nn\n and a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nEach node has an associated price. You are given an integer array \nprice\n, where \nprice[i]\n is the price of the \ni\nth\n node.\n\n\nThe \nprice sum\n of a given path is the sum of the prices of all nodes lying on that path.\n\n\nAdditionally, you are given a 2D integer array \ntrips\n, where \ntrips[i] = [start\ni\n, end\ni\n]\n indicates that you start the \ni\nth\n trip from the node \nstart\ni\n and travel to the node \nend\ni\n by any path you like.\n\n\nBefore performing your first trip, you can choose some \nnon-adjacent\n nodes and halve the prices.\n\n\nReturn \nthe minimum total price sum to perform all the given trips\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\n\nOutput:\n 23\n\nExplanation:\n The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1\nst\n trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2\nnd\n trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3\nrd\n trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\n\nOutput:\n 1\n\nExplanation:\n The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1\nst\n trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 50\n\n\nedges.length == n - 1\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\nedges\n represents a valid tree.\n\n\nprice.length == n\n\n\nprice[i]\n is an even integer.\n\n\n1 <= price[i] <= 1000\n\n\n1 <= trips.length <= 100\n\n\n0 <= start\ni\n, end\ni\n <= n - 1",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2614,
    "slug": "prime-in-diagonal",
    "url": "https://leetcode.com/problems/prime-in-diagonal/",
    "titulo": "Prime In Diagonal",
    "enunciado": "You are given a 0-indexed two-dimensional integer array \nnums\n.\n\n\nReturn \nthe largest \nprime\n number that lies on at least one of the \ndiagonals\n of \nnums\n. In case, no prime is present on any of the diagonals, return\n 0.\n\n\nNote that:\n\n\n\n\nAn integer is \nprime\n if it is greater than \n1\n and has no positive integer divisors other than \n1\n and itself.\n\n\nAn integer \nval\n is on one of the \ndiagonals\n of \nnums\n if there exists an integer \ni\n for which \nnums[i][i] = val\n or an \ni\n for which \nnums[i][nums.length - i - 1] = val\n.\n\n\n\n\n\n\nIn the above diagram, one diagonal is \n[1,5,9]\n and another diagonal is\n [3,5,7]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [[1,2,3],[5,6,7],[9,10,11]]\n\nOutput:\n 11\n\nExplanation:\n The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [[1,2,3],[5,17,7],[9,11,10]]\n\nOutput:\n 17\n\nExplanation:\n The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 300\n\n\nnums.length == nums\ni\n.length\n\n\n1 <= nums\n[i][j]\n <= 4*10\n6",
    "temas": [
      "Array",
      "Math",
      "Matrix",
      "Number Theory"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2603,
    "slug": "collect-coins-in-a-tree",
    "url": "https://leetcode.com/problems/collect-coins-in-a-tree/",
    "titulo": "Collect Coins in a Tree",
    "enunciado": "There exists an undirected and unrooted tree with \nn\n nodes indexed from \n0\n to \nn - 1\n. You are given an integer \nn\n and a 2D integer array edges of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree. You are also given an array \ncoins\n of size \nn\n where \ncoins[i]\n can be either \n0\n or \n1\n, where \n1\n indicates the presence of a coin in the vertex \ni\n.\n\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times: \n\n\n\n\nCollect all the coins that are at a distance of at most \n2\n from the current vertex, or\n\n\nMove to any adjacent vertex in the tree.\n\n\n\n\nFind \nthe minimum number of edges you need to go through to collect all the coins and go back to the initial vertex\n.\n\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\n\nOutput:\n 2\n\nExplanation:\n Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\n\nOutput:\n 2\n\nExplanation:\n Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == coins.length\n\n\n1 <= n <= 3 * 10\n4\n\n\n0 <= coins[i] <= 1\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Tree",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2577,
    "slug": "minimum-time-to-visit-a-cell-in-a-grid",
    "url": "https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/",
    "titulo": "Minimum Time to Visit a Cell In a Grid",
    "enunciado": "You are given a \nm x n\n matrix \ngrid\n consisting of \nnon-negative\n integers where \ngrid[row][col]\n represents the \nminimum\n time required to be able to visit the cell \n(row, col)\n, which means you can visit the cell \n(row, col)\n only when the time you visit it is greater than or equal to \ngrid[row][col]\n.\n\n\nYou are standing in the \ntop-left\n cell of the matrix in the \n0\nth\n second, and you must move to \nany\n adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\n\nReturn \nthe \nminimum\n time required in which you can visit the bottom-right cell of the matrix\n. If you cannot visit the bottom-right cell, then return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n\nOutput:\n 7\n\nExplanation:\n One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,2,4],[3,2,1],[1,0,4]]\n\nOutput:\n -1\n\nExplanation:\n There is no path from the top left to the bottom-right cell.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 1000\n\n\n4 <= m * n <= 10\n5\n\n\n0 <= grid[i][j] <= 10\n5\n\n\ngrid[0][0] == 0",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2617,
    "slug": "minimum-number-of-visited-cells-in-a-grid",
    "url": "https://leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/",
    "titulo": "Minimum Number of Visited Cells in a Grid",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n integer matrix \ngrid\n. Your initial position is at the \ntop-left\n cell \n(0, 0)\n.\n\n\nStarting from the cell \n(i, j)\n, you can move to one of the following cells:\n\n\n\n\nCells \n(i, k)\n with \nj < k <= grid[i][j] + j\n (rightward movement), or\n\n\nCells \n(k, j)\n with \ni < k <= grid[i][j] + i\n (downward movement).\n\n\n\n\nReturn \nthe minimum number of cells you need to visit to reach the \nbottom-right\n cell\n \n(m - 1, n - 1)\n. If there is no valid path, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\n\nOutput:\n 4\n\nExplanation:\n The image above shows one of the paths that visits exactly 4 cells.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\n\nOutput:\n 3\n\nExplanation: \nThe image above shows one of the paths that visits exactly 3 cells.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[2,1,0],[1,0,0]]\n\nOutput:\n -1\n\nExplanation:\n It can be proven that no path exists.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n0 <= grid[i][j] < m * n\n\n\ngrid[m - 1][n - 1] == 0",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Breadth-First Search",
      "Union Find",
      "Heap (Priority Queue)",
      "Matrix",
      "Monotonic Stack"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2661,
    "slug": "first-completely-painted-row-or-column",
    "url": "https://leetcode.com/problems/first-completely-painted-row-or-column/",
    "titulo": "First Completely Painted Row or Column",
    "enunciado": "You are given a \n0-indexed\n integer array \narr\n, and an \nm x n\n integer \nmatrix\n \nmat\n. \narr\n and \nmat\n both contain \nall\n the integers in the range \n[1, m * n]\n.\n\n\nGo through each index \ni\n in \narr\n starting from index \n0\n and paint the cell in \nmat\n containing the integer \narr[i]\n.\n\n\nReturn \nthe smallest index\n \ni\n \nat which either a row or a column will be completely painted in\n \nmat\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n arr = [1,3,4,2], mat = [[1,4],[2,3]]\n\nOutput:\n 2\n\nExplanation:\n The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\n\nOutput:\n 3\n\nExplanation:\n The second column becomes fully painted at arr[3].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn = mat[i].length\n\n\narr.length == m * n\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n1 <= arr[i], mat[r][c] <= m * n\n\n\nAll the integers of \narr\n are \nunique\n.\n\n\nAll the integers of \nmat\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2550,
    "slug": "count-collisions-of-monkeys-on-a-polygon",
    "url": "https://leetcode.com/problems/count-collisions-of-monkeys-on-a-polygon/",
    "titulo": "Count Collisions of Monkeys on a Polygon",
    "enunciado": "There is a regular convex polygon with \nn\n vertices. The vertices are labeled from \n0\n to \nn - 1\n in a clockwise direction, and each vertex has \nexactly one monkey\n. The following figure shows a convex polygon of \n6\n vertices.\n\n\n\n\nSimultaneously, each monkey moves to a neighboring vertex. A \ncollision\n happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.\n\n\nReturn the number of ways the monkeys can move so that at least \none collision\n happens. Since the answer may be very large, return it modulo \n10\n9 \n+ 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 3\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\nThere are 8 total possible movements.\n\nTwo ways such that they collide at some point are:\n\n\n\n\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\n\n\nMonkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 4\n\n\nOutput:\n \n14\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n9",
    "temas": [
      "Math",
      "Recursion"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2642,
    "slug": "design-graph-with-shortest-path-calculator",
    "url": "https://leetcode.com/problems/design-graph-with-shortest-path-calculator/",
    "titulo": "Design Graph With Shortest Path Calculator",
    "enunciado": "There is a \ndirected weighted\n graph that consists of \nn\n nodes numbered from \n0\n to \nn - 1\n. The edges of the graph are initially represented by the given array \nedges\n where \nedges[i] = [from\ni\n, to\ni\n, edgeCost\ni\n]\n meaning that there is an edge from \nfrom\ni\n to \nto\ni\n with the cost \nedgeCost\ni\n.\n\n\nImplement the \nGraph\n class:\n\n\n\n\nGraph(int n, int[][] edges)\n initializes the object with \nn\n nodes and the given edges.\n\n\naddEdge(int[] edge)\n adds an edge to the list of edges where \nedge = [from, to, edgeCost]\n. It is guaranteed that there is no edge between the two nodes before adding this one.\n\n\nint shortestPath(int node1, int node2)\n returns the \nminimum\n cost of a path from \nnode1\n to \nnode2\n. If no path exists, return \n-1\n. The cost of a path is the sum of the costs of the edges in the path.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n\nOutput\n\n[null, 6, -1, null, 6]\n\n\nExplanation\n\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n0 <= edges.length <= n * (n - 1)\n\n\nedges[i].length == edge.length == 3\n\n\n0 <= from\ni\n, to\ni\n, from, to, node1, node2 <= n - 1\n\n\n1 <= edgeCost\ni\n, edgeCost <= 10\n6\n\n\nThere are no repeated edges and no self-loops in the graph at any point.\n\n\nAt most \n100\n calls will be made for \naddEdge\n.\n\n\nAt most \n100\n calls will be made for \nshortestPath\n.",
    "temas": [
      "Graph",
      "Design",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 2641,
    "slug": "cousins-in-binary-tree-ii",
    "url": "https://leetcode.com/problems/cousins-in-binary-tree-ii/",
    "titulo": "Cousins in Binary Tree II",
    "enunciado": "Given the \nroot\n of a binary tree, replace the value of each node in the tree with the \nsum of all its cousins' values\n.\n\n\nTwo nodes of a binary tree are \ncousins\n if they have the same depth with different parents.\n\n\nReturn \nthe \nroot\n of the modified tree\n.\n\n\nNote\n that the depth of a node is the number of edges in the path from the root node to it.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,4,9,1,10,null,7]\n\nOutput:\n [0,0,0,7,7,null,11]\n\nExplanation:\n The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 5 does not have any cousins so its sum is 0.\n- Node with value 4 does not have any cousins so its sum is 0.\n- Node with value 9 does not have any cousins so its sum is 0.\n- Node with value 1 has a cousin with value 7 so its sum is 7.\n- Node with value 10 has a cousin with value 7 so its sum is 7.\n- Node with value 7 has cousins with values 1 and 10 so its sum is 11.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,1,2]\n\nOutput:\n [0,0,0]\n\nExplanation:\n The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 3 does not have any cousins so its sum is 0.\n- Node with value 1 does not have any cousins so its sum is 0.\n- Node with value 2 does not have any cousins so its sum is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n4",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2608,
    "slug": "shortest-cycle-in-a-graph",
    "url": "https://leetcode.com/problems/shortest-cycle-in-a-graph/",
    "titulo": "Shortest Cycle in a Graph",
    "enunciado": "There is a \nbi-directional \ngraph with \nn\n vertices, where each vertex is labeled from \n0\n to \nn - 1\n. The edges in the graph are represented by a given 2D integer array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n]\n denotes an edge between vertex \nu\ni\n and vertex \nv\ni\n. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\n\n\nReturn \nthe length of the \nshortest \ncycle in the graph\n. If no cycle exists, return \n-1\n.\n\n\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\n\nOutput:\n 3\n\nExplanation:\n The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[0,1],[0,2]]\n\nOutput:\n -1\n\nExplanation:\n There are no cycles in this graph.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 1000\n\n\n1 <= edges.length <= 1000\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\nu\ni\n != v\ni\n\n\nThere are no repeated edges.",
    "temas": [
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Breadth-First Search",
    "has_image": true
  },
  {
    "id": 2596,
    "slug": "check-knight-tour-configuration",
    "url": "https://leetcode.com/problems/check-knight-tour-configuration/",
    "titulo": "Check Knight Tour Configuration",
    "enunciado": "There is a knight on an \nn x n\n chessboard. In a valid configuration, the knight starts \nat the top-left cell\n of the board and visits every cell on the board \nexactly once\n.\n\n\nYou are given an \nn x n\n integer matrix \ngrid\n consisting of distinct integers from the range \n[0, n * n - 1]\n where \ngrid[row][col]\n indicates that the cell \n(row, col)\n is the \ngrid[row][col]\nth\n cell that the knight visited. The moves are \n0-indexed\n.\n\n\nReturn \ntrue\n \nif\n \ngrid\n \nrepresents a valid configuration of the knight's movements or\n \nfalse\n \notherwise\n.\n\n\nNote\n that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\n\nOutput:\n true\n\nExplanation:\n The above diagram represents the grid. It can be shown that it is a valid configuration.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,3,6],[5,8,1],[2,7,4]]\n\nOutput:\n false\n\nExplanation:\n The above diagram represents the grid. The 8\nth\n move of the knight is not valid considering its position after the 7\nth\n move.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n3 <= n <= 7\n\n\n0 <= grid[row][col] < n * n\n\n\nAll integers in \ngrid\n are \nunique\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2581,
    "slug": "count-number-of-possible-root-nodes",
    "url": "https://leetcode.com/problems/count-number-of-possible-root-nodes/",
    "titulo": "Count Number of Possible Root Nodes",
    "enunciado": "Alice has an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n. The tree is represented as a 2D integer array \nedges\n of length \nn - 1\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nAlice wants Bob to find the root of the tree. She allows Bob to make several \nguesses\n about her tree. In one guess, he does the following:\n\n\n\n\nChooses two \ndistinct\n integers \nu\n and \nv\n such that there exists an edge \n[u, v]\n in the tree.\n\n\nHe tells Alice that \nu\n is the \nparent\n of \nv\n in the tree.\n\n\n\n\nBob's guesses are represented by a 2D integer array \nguesses\n where \nguesses[j] = [u\nj\n, v\nj\n]\n indicates Bob guessed \nu\nj\n to be the parent of \nv\nj\n.\n\n\nAlice being lazy, does not reply to each of Bob's guesses, but just says that \nat least\n \nk\n of his guesses are \ntrue\n.\n\n\nGiven the 2D integer arrays \nedges\n, \nguesses\n and the integer \nk\n, return \nthe \nnumber of possible nodes\n that can be the root of Alice's tree\n. If there is no such tree, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\n\nOutput:\n 3\n\nExplanation:\n \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\n\nOutput:\n 5\n\nExplanation:\n \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess. \n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nedges.length == n - 1\n\n\n2 <= n <= 10\n5\n\n\n1 <= guesses.length <= 10\n5\n\n\n0 <= a\ni\n, b\ni\n, u\nj\n, v\nj\n <= n - 1\n\n\na\ni\n != b\ni\n\n\nu\nj\n != v\nj\n\n\nedges\n represents a valid tree.\n\n\nguesses[j]\n is an edge of the tree.\n\n\nguesses\n is unique.\n\n\n0 <= k <= guesses.length",
    "temas": [
      "Array",
      "Hash Table",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2579,
    "slug": "count-total-number-of-colored-cells",
    "url": "https://leetcode.com/problems/count-total-number-of-colored-cells/",
    "titulo": "Count Total Number of Colored Cells",
    "enunciado": "There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer \nn\n, indicating that you must do the following routine for \nn\n minutes:\n\n\n\n\nAt the first minute, color \nany\n arbitrary unit cell blue.\n\n\nEvery minute thereafter, color blue \nevery\n uncolored cell that touches a blue cell.\n\n\n\n\nBelow is a pictorial representation of the state of the grid after minutes 1, 2, and 3.\n\n\n\n\nReturn \nthe number of \ncolored cells\n at the end of \nn\n \nminutes\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 1\n\nExplanation:\n After 1 minute, there is only 1 blue cell, so we return 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 5\n\nExplanation:\n After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5",
    "temas": [
      "Math"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2584,
    "slug": "split-the-array-to-make-coprime-products",
    "url": "https://leetcode.com/problems/split-the-array-to-make-coprime-products/",
    "titulo": "Split the Array to Make Coprime Products",
    "enunciado": "You are given a \n0-indexed\n integer array \nnums\n of length \nn\n.\n\n\nA \nsplit\n at an index \ni\n where \n0 <= i <= n - 2\n is called \nvalid\n if the product of the first \ni + 1\n elements and the product of the remaining elements are coprime.\n\n\n\n\nFor example, if \nnums = [2, 3, 3]\n, then a split at the index \ni = 0\n is valid because \n2\n and \n9\n are coprime, while a split at the index \ni = 1\n is not valid because \n6\n and \n3\n are not coprime. A split at the index \ni = 2\n is not valid because \ni == n - 1\n.\n\n\n\n\nReturn \nthe smallest index \ni\n at which the array can be split validly or \n-1\n if there is no such split\n.\n\n\nTwo values \nval1\n and \nval2\n are coprime if \ngcd(val1, val2) == 1\n where \ngcd(val1, val2)\n is the greatest common divisor of \nval1\n and \nval2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [4,7,8,15,3,5]\n\nOutput:\n 2\n\nExplanation:\n The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [4,7,15,8,3,5]\n\nOutput:\n -1\n\nExplanation:\n The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n4\n\n\n1 <= nums[i] <= 10\n6",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2583,
    "slug": "kth-largest-sum-in-a-binary-tree",
    "url": "https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/",
    "titulo": "Kth Largest Sum in a Binary Tree",
    "enunciado": "You are given the \nroot\n of a binary tree and a positive integer \nk\n.\n\n\nThe \nlevel sum\n in the tree is the sum of the values of the nodes that are on the \nsame\n level.\n\n\nReturn\n the \nk\nth\n \nlargest\n level sum in the tree (not necessarily distinct)\n. If there are fewer than \nk\n levels in the tree, return \n-1\n.\n\n\nNote\n that two nodes are on the same level if they have the same distance from the root.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,8,9,2,1,3,7,4,6], k = 2\n\nOutput:\n 13\n\nExplanation:\n The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2\nnd\n largest level sum is 13.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,null,3], k = 1\n\nOutput:\n 3\n\nExplanation:\n The largest level sum is 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n2 <= n <= 10\n5\n\n\n1 <= Node.val <= 10\n6\n\n\n1 <= k <= n",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Sorting",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2532,
    "slug": "time-to-cross-a-bridge",
    "url": "https://leetcode.com/problems/time-to-cross-a-bridge/",
    "titulo": "Time to Cross a Bridge",
    "enunciado": "There are \nk\n workers who want to move \nn\n boxes from the right (old) warehouse to the left (new) warehouse. You are given the two integers \nn\n and \nk\n, and a 2D integer array \ntime\n of size \nk x 4\n where \ntime[i] = [right\ni\n, pick\ni\n, left\ni\n, put\ni\n]\n.\n\n\nThe warehouses are separated by a river and connected by a bridge. Initially, all \nk\n workers are waiting on the left side of the bridge. To move the boxes, the \ni\nth\n worker can do the following:\n\n\n\n\nCross the bridge to the right side in \nright\ni\n minutes.\n\n\nPick a box from the right warehouse in \npick\ni\n minutes.\n\n\nCross the bridge to the left side in \nleft\ni\n minutes.\n\n\nPut the box into the left warehouse in \nput\ni\n minutes.\n\n\n\n\nThe \ni\nth\n worker is \nless efficient\n than the j\nth\n worker if either condition is met:\n\n\n\n\nleft\ni\n + right\ni\n > left\nj\n + right\nj\n\n\nleft\ni\n + right\ni\n == left\nj\n + right\nj\n and \ni > j\n\n\n\n\nThe following rules regulate the movement of the workers through the bridge:\n\n\n\n\nOnly one worker can use the bridge at a time.\n\n\nWhen the bridge is unused prioritize the \nleast efficient\n worker (who have picked up the box) on the right side to cross. If not, prioritize the \nleast efficient\n worker on the left side to cross.\n\n\nIf enough workers have already been dispatched from the left side to pick up all the remaining boxes, \nno more\n workers will be sent from the left side.\n\n\n\n\nReturn the \nelapsed minutes\n at which the last box reaches the \nleft side of the bridge\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\nFrom 0 to 1 minutes: worker 2 crosses the bridge to the right.\nFrom 1 to 2 minutes: worker 2 picks up a box from the right warehouse.\nFrom 2 to 6 minutes: worker 2 crosses the bridge to the left.\nFrom 6 to 7 minutes: worker 2 puts a box at the left warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left side of the bridge.\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 3, k = 2, time =\n [[1,5,1,8],[10,10,10,10]]\n\n\nOutput:\n 37\n\n\nExplanation:\n\n\n\n\n\n\n\n\nThe last box reaches the left side at 37 seconds. Notice, how we \ndo not\n put the last boxes down, as that would take more time, and they are already on the left with the workers.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, k <= 10\n4\n\n\ntime.length == k\n\n\ntime[i].length == 4\n\n\n1 <= left\ni\n, pick\ni\n, right\ni\n, put\ni\n <= 1000",
    "temas": [
      "Array",
      "Heap (Priority Queue)",
      "Simulation"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2556,
    "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
    "url": "https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/",
    "titulo": "Disconnect Path in a Binary Matrix by at Most One Flip",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n \nbinary\n matrix \ngrid\n. You can move from a cell \n(row, col)\n to any of the cells \n(row + 1, col)\n or \n(row, col + 1)\n that has the value \n1\n. The matrix is \ndisconnected\n if there is no path from \n(0, 0)\n to \n(m - 1, n - 1)\n.\n\n\nYou can flip the value of \nat most one\n (possibly none) cell. You \ncannot flip\n the cells \n(0, 0)\n and \n(m - 1, n - 1)\n.\n\n\nReturn \ntrue\n \nif it is possible to make the matrix disconnect or \nfalse\n otherwise\n.\n\n\nNote\n that flipping a cell changes its value from \n0\n to \n1\n or from \n1\n to \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[1,0,0],[1,1,1]]\n\nOutput:\n true\n\nExplanation:\n We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n false\n\nExplanation:\n It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 1000\n\n\n1 <= m * n <= 10\n5\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 1",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2545,
    "slug": "sort-the-students-by-their-kth-score",
    "url": "https://leetcode.com/problems/sort-the-students-by-their-kth-score/",
    "titulo": "Sort the Students by Their Kth Score",
    "enunciado": "There is a class with \nm\n students and \nn\n exams. You are given a \n0-indexed\n \nm x n\n integer matrix \nscore\n, where each row represents one student and \nscore[i][j]\n denotes the score the \ni\nth\n student got in the \nj\nth\n exam. The matrix \nscore\n contains \ndistinct\n integers only.\n\n\nYou are also given an integer \nk\n. Sort the students (i.e., the rows of the matrix) by their scores in the \nk\nth\n (\n0-indexed\n) exam from the highest to the lowest.\n\n\nReturn \nthe matrix after sorting it.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2\n\nOutput:\n [[7,5,11,2],[10,6,9,1],[4,8,3,15]]\n\nExplanation:\n In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.\n- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.\n- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n score = [[3,4],[5,6]], k = 0\n\nOutput:\n [[5,6],[3,4]]\n\nExplanation:\n In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.\n- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == score.length\n\n\nn == score[i].length\n\n\n1 <= m, n <= 250\n\n\n1 <= score[i][j] <= 10\n5\n\n\nscore\n consists of \ndistinct\n integers.\n\n\n0 <= k < n",
    "temas": [
      "Array",
      "Sorting",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2538,
    "slug": "difference-between-maximum-and-minimum-price-sum",
    "url": "https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/",
    "titulo": "Difference Between Maximum and Minimum Price Sum",
    "enunciado": "There exists an undirected and initially unrooted tree with \nn\n nodes indexed from \n0\n to \nn - 1\n. You are given the integer \nn\n and a 2D integer array \nedges\n of length \nn - 1\n, where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nEach node has an associated price. You are given an integer array \nprice\n, where \nprice[i]\n is the price of the \ni\nth\n node.\n\n\nThe \nprice sum\n of a given path is the sum of the prices of all nodes lying on that path.\n\n\nThe tree can be rooted at any node \nroot\n of your choice. The incurred \ncost\n after choosing \nroot\n is the difference between the maximum and minimum \nprice sum\n amongst all paths starting at \nroot\n.\n\n\nReturn \nthe \nmaximum\n possible \ncost\n \namongst all possible root choices\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\n\nOutput:\n 24\n\nExplanation:\n The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.\n- The second path contains the node [2] with the price [7].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\n\nOutput:\n 2\n\nExplanation:\n The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.\n- The second path contains node [0] with a price [1].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\nedges\n represents a valid tree.\n\n\nprice.length == n\n\n\n1 <= price[i] <= 10\n5",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2536,
    "slug": "increment-submatrices-by-one",
    "url": "https://leetcode.com/problems/increment-submatrices-by-one/",
    "titulo": "Increment Submatrices by One",
    "enunciado": "You are given a positive integer \nn\n, indicating that we initially have an \nn x n\n \n0-indexed\n integer matrix \nmat\n filled with zeroes.\n\n\nYou are also given a 2D integer array \nquery\n. For each \nquery[i] = [row1\ni\n, col1\ni\n, row2\ni\n, col2\ni\n]\n, you should do the following operation:\n\n\n\n\nAdd \n1\n to \nevery element\n in the submatrix with the \ntop left\n corner \n(row1\ni\n, col1\ni\n)\n and the \nbottom right\n corner \n(row2\ni\n, col2\ni\n)\n. That is, add \n1\n to \nmat[x][y]\n for all \nrow1\ni\n <= x <= row2\ni\n and \ncol1\ni\n <= y <= col2\ni\n.\n\n\n\n\nReturn\n the matrix\n \nmat\n after performing every query.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, queries = [[1,1,2,2],[0,0,1,1]]\n\nOutput:\n [[1,1,0],[1,2,1],[0,1,1]]\n\nExplanation:\n The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, queries = [[0,0,1,1]]\n\nOutput:\n [[1,1],[1,1]]\n\nExplanation:\n The diagram above shows the initial matrix and the matrix after the first query.\n- In the first query we add 1 to every element in the matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 500\n\n\n1 <= queries.length <= 10\n4\n\n\n0 <= row1\ni\n <= row2\ni\n < n\n\n\n0 <= col1\ni\n <= col2\ni\n < n",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2482,
    "slug": "difference-between-ones-and-zeros-in-row-and-column",
    "url": "https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/",
    "titulo": "Difference Between Ones and Zeros in Row and Column",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n binary matrix \ngrid\n.\n\n\nA \n0-indexed\n \nm x n\n difference matrix \ndiff\n is created with the following procedure:\n\n\n\n\nLet the number of ones in the \ni\nth\n row be \nonesRow\ni\n.\n\n\nLet the number of ones in the \nj\nth\n column be \nonesCol\nj\n.\n\n\nLet the number of zeros in the \ni\nth\n row be \nzerosRow\ni\n.\n\n\nLet the number of zeros in the \nj\nth\n column be \nzerosCol\nj\n.\n\n\ndiff[i][j] = onesRow\ni\n + onesCol\nj\n - zerosRow\ni\n - zerosCol\nj\n\n\n\n\nReturn \nthe difference matrix \ndiff\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1],[1,0,1],[0,0,1]]\n\nOutput:\n [[0,0,4],[0,0,4],[-2,-2,2]]\n\nExplanation:\n\n- diff[0][0] = \nonesRow\n0\n + onesCol\n0\n - zerosRow\n0\n - zerosCol\n0\n = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = \nonesRow\n0\n + onesCol\n1\n - zerosRow\n0\n - zerosCol\n1\n = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = \nonesRow\n0\n + onesCol\n2\n - zerosRow\n0\n - zerosCol\n2\n = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = \nonesRow\n1\n + onesCol\n0\n - zerosRow\n1\n - zerosCol\n0\n = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = \nonesRow\n1\n + onesCol\n1\n - zerosRow\n1\n - zerosCol\n1\n = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = \nonesRow\n1\n + onesCol\n2\n - zerosRow\n1\n - zerosCol\n2\n = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = \nonesRow\n2\n + onesCol\n0\n - zerosRow\n2\n - zerosCol\n0\n = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = \nonesRow\n2\n + onesCol\n1\n - zerosRow\n2\n - zerosCol\n1\n = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = \nonesRow\n2\n + onesCol\n2\n - zerosRow\n2\n - zerosCol\n2\n = 1 + 3 - 2 - 0 = 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[1,1,1]]\n\nOutput:\n [[5,5,5],[5,5,5]]\n\nExplanation:\n\n- diff[0][0] = onesRow\n0\n + onesCol\n0\n - zerosRow\n0\n - zerosCol\n0\n = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow\n0\n + onesCol\n1\n - zerosRow\n0\n - zerosCol\n1\n = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow\n0\n + onesCol\n2\n - zerosRow\n0\n - zerosCol\n2\n = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow\n1\n + onesCol\n0\n - zerosRow\n1\n - zerosCol\n0\n = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow\n1\n + onesCol\n1\n - zerosRow\n1\n - zerosCol\n1\n = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow\n1\n + onesCol\n2\n - zerosRow\n1\n - zerosCol\n2\n = 3 + 2 - 0 - 0 = 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2509,
    "slug": "cycle-length-queries-in-a-tree",
    "url": "https://leetcode.com/problems/cycle-length-queries-in-a-tree/",
    "titulo": "Cycle Length Queries in a Tree",
    "enunciado": "You are given an integer \nn\n. There is a \ncomplete binary tree\n with \n2\nn\n - 1\n nodes. The root of that tree is the node with the value \n1\n, and every node with a value \nval\n in the range \n[1, 2\nn - 1\n - 1]\n has two children where:\n\n\n\n\nThe left node has the value \n2 * val\n, and\n\n\nThe right node has the value \n2 * val + 1\n.\n\n\n\n\nYou are also given a 2D integer array \nqueries\n of length \nm\n, where \nqueries[i] = [a\ni\n, b\ni\n]\n. For each query, solve the following problem:\n\n\n\n\nAdd an edge between the nodes with values \na\ni\n and \nb\ni\n.\n\n\nFind the length of the cycle in the graph.\n\n\nRemove the added edge between nodes with values \na\ni\n and \nb\ni\n.\n\n\n\n\nNote\n that:\n\n\n\n\nA \ncycle\n is a path that starts and ends at the same node, and each edge in the path is visited only once.\n\n\nThe length of a cycle is the number of edges visited in the cycle.\n\n\nThere could be multiple edges between two nodes in the tree after adding the edge of the query.\n\n\n\n\nReturn \nan array \nanswer\n of length \nm\n where\n \nanswer[i]\n \nis the answer to the\n \ni\nth\n \nquery.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, queries = [[5,3],[4,7],[2,3]]\n\nOutput:\n [4,5,3]\n\nExplanation:\n The diagrams above show the tree of 2\n3\n - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, queries = [[1,2]]\n\nOutput:\n [2]\n\nExplanation:\n The diagram above shows the tree of 2\n2\n - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 30\n\n\nm == queries.length\n\n\n1 <= m <= 10\n5\n\n\nqueries[i].length == 2\n\n\n1 <= a\ni\n, b\ni\n <= 2\nn\n - 1\n\n\na\ni\n != b\ni",
    "temas": [
      "Array",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2508,
    "slug": "add-edges-to-make-degrees-of-all-nodes-even",
    "url": "https://leetcode.com/problems/add-edges-to-make-degrees-of-all-nodes-even/",
    "titulo": "Add Edges to Make Degrees of All Nodes Even",
    "enunciado": "There is an \nundirected\n graph consisting of \nn\n nodes numbered from \n1\n to \nn\n. You are given the integer \nn\n and a \n2D\n array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n. The graph can be disconnected.\n\n\nYou can add \nat most\n two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\n\n\nReturn \ntrue\n if it is possible to make the degree of each node in the graph even, otherwise return \nfalse\n.\n\n\nThe degree of a node is the number of edges connected to it.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\n\nOutput:\n true\n\nExplanation:\n The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[1,2],[3,4]]\n\nOutput:\n true\n\nExplanation:\n The above diagram shows a valid way of adding two edges.\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[1,2],[1,3],[1,4]]\n\nOutput:\n false\n\nExplanation:\n It is not possible to obtain a valid graph with adding at most 2 edges.\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\n2 <= edges.length <= 10\n5\n\n\nedges[i].length == 2\n\n\n1 <= a\ni\n, b\ni\n <= n\n\n\na\ni\n != b\ni\n\n\nThere are no repeated edges.",
    "temas": [
      "Hash Table",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2498,
    "slug": "frog-jump-ii",
    "url": "https://leetcode.com/problems/frog-jump-ii/",
    "titulo": "Frog Jump II",
    "enunciado": "You are given a \n0-indexed\n integer array \nstones\n sorted in \nstrictly increasing order\n representing the positions of stones in a river.\n\n\nA frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone \nat most once\n.\n\n\nThe \nlength\n of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\n\n\n\n\nMore formally, if the frog is at \nstones[i]\n and is jumping to \nstones[j]\n, the length of the jump is \n|stones[i] - stones[j]|\n.\n\n\n\n\nThe \ncost\n of a path is the \nmaximum length of a jump\n among all jumps in the path.\n\n\nReturn \nthe \nminimum\n cost of a path for the frog\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n stones = [0,2,5,6,7]\n\nOutput:\n 5\n\nExplanation:\n The above figure represents one of the optimal paths the frog can take.\nThe cost of this path is 5, which is the maximum length of a jump.\nSince it is not possible to achieve a cost of less than 5, we return it.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n stones = [0,3,9]\n\nOutput:\n 9\n\nExplanation:\n \nThe frog can jump directly to the last stone and come back to the first stone. \nIn this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.\nIt can be shown that this is the minimum achievable cost.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= stones.length <= 10\n5\n\n\n0 <= stones[i] <= 10\n9\n\n\nstones[0] == 0\n\n\nstones\n is sorted in a strictly increasing order.",
    "temas": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2497,
    "slug": "maximum-star-sum-of-a-graph",
    "url": "https://leetcode.com/problems/maximum-star-sum-of-a-graph/",
    "titulo": "Maximum Star Sum of a Graph",
    "enunciado": "There is an undirected graph consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n. You are given a \n0-indexed\n integer array \nvals\n of length \nn\n where \nvals[i]\n denotes the value of the \ni\nth\n node.\n\n\nYou are also given a 2D integer array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n denotes that there exists an \nundirected\n edge connecting nodes \na\ni\n and \nb\ni.\n\n\nA \nstar graph\n is a subgraph of the given graph having a center node containing \n0\n or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\n\n\nThe image below shows star graphs with \n3\n and \n4\n neighbors respectively, centered at the blue node.\n\n\n\n\nThe \nstar sum\n is the sum of the values of all the nodes present in the star graph.\n\n\nGiven an integer \nk\n, return \nthe \nmaximum star sum\n of a star graph containing \nat most\n \nk\n edges.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\n\nOutput:\n 16\n\nExplanation:\n The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.\n\n\n\nExample 2:\n\n\n\n\nInput:\n vals = [-5], edges = [], k = 0\n\nOutput:\n -5\n\nExplanation:\n There is only one possible star graph, which is node 0 itself.\nHence, we return -5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == vals.length\n\n\n1 <= n <= 10\n5\n\n\n-10\n4\n <= vals[i] <= 10\n4\n\n\n0 <= edges.length <= min(n * (n - 1) / 2\n, 10\n5\n)\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni\n\n\n0 <= k <= n - 1",
    "temas": [
      "Array",
      "Greedy",
      "Graph",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2503,
    "slug": "maximum-number-of-points-from-grid-queries",
    "url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/",
    "titulo": "Maximum Number of Points From Grid Queries",
    "enunciado": "You are given an \nm x n\n integer matrix \ngrid\n and an array \nqueries\n of size \nk\n.\n\n\nFind an array \nanswer\n of size \nk\n such that for each integer \nqueries[i]\n you start in the \ntop left\n cell of the matrix and repeat the following process:\n\n\n\n\nIf \nqueries[i]\n is \nstrictly\n greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any \nadjacent\n cell in all \n4\n directions: up, down, left, and right.\n\n\nOtherwise, you do not get any points, and you end this process.\n\n\n\n\nAfter the process, \nanswer[i]\n is the \nmaximum\n number of points you can get. \nNote\n that for each query you are allowed to visit the same cell \nmultiple\n times.\n\n\nReturn \nthe resulting array\n \nanswer\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\n\nOutput:\n [5,8,1]\n\nExplanation:\n The diagrams above show which cells we visit to get points for each query.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[5,2,1],[1,1,2]], queries = [3]\n\nOutput:\n [0]\n\nExplanation:\n We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 1000\n\n\n4 <= m * n <= 10\n5\n\n\nk == queries.length\n\n\n1 <= k <= 10\n4\n\n\n1 <= grid[i][j], queries[i] <= 10\n6",
    "temas": [
      "Array",
      "Two Pointers",
      "Breadth-First Search",
      "Union Find",
      "Sorting",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2500,
    "slug": "delete-greatest-value-in-each-row",
    "url": "https://leetcode.com/problems/delete-greatest-value-in-each-row/",
    "titulo": "Delete Greatest Value in Each Row",
    "enunciado": "You are given an \nm x n\n matrix \ngrid\n consisting of positive integers.\n\n\nPerform the following operation until \ngrid\n becomes empty:\n\n\n\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\n\n\nAdd the maximum of deleted elements to the answer.\n\n\n\n\nNote\n that the number of columns decreases by one after each operation.\n\n\nReturn \nthe answer after performing the operations described above\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2,4],[3,3,1]]\n\nOutput:\n 8\n\nExplanation:\n The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[10]]\n\nOutput:\n 10\n\nExplanation:\n The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n1 <= grid[i][j] <= 100",
    "temas": [
      "Array",
      "Sorting",
      "Heap (Priority Queue)",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2493,
    "slug": "divide-nodes-into-the-maximum-number-of-groups",
    "url": "https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/",
    "titulo": "Divide Nodes Into the Maximum Number of Groups",
    "enunciado": "You are given a positive integer \nn\n representing the number of nodes in an \nundirected\n graph. The nodes are labeled from \n1\n to \nn\n.\n\n\nYou are also given a 2D integer array \nedges\n, where \nedges[i] = [a\ni, \nb\ni\n]\n indicates that there is a \nbidirectional\n edge between nodes \na\ni\n and \nb\ni\n. \nNotice\n that the given graph may be disconnected.\n\n\nDivide the nodes of the graph into \nm\n groups (\n1-indexed\n) such that:\n\n\n\n\nEach node in the graph belongs to exactly one group.\n\n\nFor every pair of nodes in the graph that are connected by an edge \n[a\ni, \nb\ni\n]\n, if \na\ni\n belongs to the group with index \nx\n, and \nb\ni\n belongs to the group with index \ny\n, then \n|y - x| = 1\n.\n\n\n\n\nReturn \nthe maximum number of groups (i.e., maximum \nm\n) into which you can divide the nodes\n. Return \n-1\n \nif it is impossible to group the nodes with the given conditions\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\n\nOutput:\n 4\n\nExplanation:\n As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, edges = [[1,2],[2,3],[3,1]]\n\nOutput:\n -1\n\nExplanation:\n If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 500\n\n\n1 <= edges.length <= 10\n4\n\n\nedges[i].length == 2\n\n\n1 <= a\ni\n, b\ni\n <= n\n\n\na\ni\n != b\ni\n\n\nThere is at most one edge between any pair of vertices.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2492,
    "slug": "minimum-score-of-a-path-between-two-cities",
    "url": "https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/",
    "titulo": "Minimum Score of a Path Between Two Cities",
    "enunciado": "You are given a positive integer \nn\n representing \nn\n cities numbered from \n1\n to \nn\n. You are also given a \n2D\n array \nroads\n where \nroads[i] = [a\ni\n, b\ni\n, distance\ni\n]\n indicates that there is a \nbidirectional \nroad between cities \na\ni\n and \nb\ni\n with a distance equal to \ndistance\ni\n. The cities graph is not necessarily connected.\n\n\nThe \nscore\n of a path between two cities is defined as the \nminimum \ndistance of a road in this path.\n\n\nReturn \nthe \nminimum \npossible score of a path between cities \n1\n and \nn\n.\n\n\nNote\n:\n\n\n\n\nA path is a sequence of roads between two cities.\n\n\nIt is allowed for a path to contain the same road \nmultiple\n times, and you can visit cities \n1\n and \nn\n multiple times along the path.\n\n\nThe test cases are generated such that there is \nat least\n one path between \n1\n and \nn\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n\nOutput:\n 5\n\nExplanation:\n The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n\nOutput:\n 2\n\nExplanation:\n The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n1 <= roads.length <= 10\n5\n\n\nroads[i].length == 3\n\n\n1 <= a\ni\n, b\ni\n <= n\n\n\na\ni\n != b\ni\n\n\n1 <= distance\ni\n <= 10\n4\n\n\nThere are no repeated edges.\n\n\nThere is at least one path between \n1\n and \nn\n.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2481,
    "slug": "minimum-cuts-to-divide-a-circle",
    "url": "https://leetcode.com/problems/minimum-cuts-to-divide-a-circle/",
    "titulo": "Minimum Cuts to Divide a Circle",
    "enunciado": "A \nvalid cut\n in a circle can be:\n\n\n\n\nA cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\n\n\nA cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n\n\n\n\nSome valid and invalid cuts are shown in the figures below.\n\n\n\n\nGiven the integer \nn\n, return \nthe \nminimum\n number of cuts needed to divide a circle into \nn\n equal slices\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 2\n\nExplanation:\n \nThe above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n\nAt least 3 cuts are needed to divide the circle into 3 equal slices. \nIt can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\nAlso note that the first cut will not divide the circle into distinct parts.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100",
    "temas": [
      "Math",
      "Geometry"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2487,
    "slug": "remove-nodes-from-linked-list",
    "url": "https://leetcode.com/problems/remove-nodes-from-linked-list/",
    "titulo": "Remove Nodes From Linked List",
    "enunciado": "You are given the \nhead\n of a linked list.\n\n\nRemove every node which has a node with a greater value anywhere to the right side of it.\n\n\nReturn \nthe \nhead\n of the modified linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [5,2,13,3,8]\n\nOutput:\n [13,8]\n\nExplanation:\n The nodes that should be removed are 5, 2 and 3.\n- Node 13 is to the right of node 5.\n- Node 13 is to the right of node 2.\n- Node 8 is to the right of node 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [1,1,1,1]\n\nOutput:\n [1,1,1,1]\n\nExplanation:\n Every node has value 1, so no nodes are removed.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the given list is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5",
    "temas": [
      "Linked List",
      "Stack",
      "Recursion",
      "Monotonic Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2477,
    "slug": "minimum-fuel-cost-to-report-to-the-capital",
    "url": "https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/",
    "titulo": "Minimum Fuel Cost to Report to the Capital",
    "enunciado": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of \nn\n cities numbered from \n0\n to \nn - 1\n and exactly \nn - 1\n roads. The capital city is city \n0\n. You are given a 2D integer array \nroads\n where \nroads[i] = [a\ni\n, b\ni\n]\n denotes that there exists a \nbidirectional road\n connecting cities \na\ni\n and \nb\ni\n.\n\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\n\nThere is a car in each city. You are given an integer \nseats\n that indicates the number of seats in each car.\n\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\n\nReturn \nthe minimum number of liters of fuel to reach the capital city\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n roads = [[0,1],[0,2],[0,3]], seats = 5\n\nOutput:\n 3\n\nExplanation:\n \n- Representative\n1\n goes directly to the capital with 1 liter of fuel.\n- Representative\n2\n goes directly to the capital with 1 liter of fuel.\n- Representative\n3\n goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\n\nOutput:\n 7\n\nExplanation:\n \n- Representative\n2\n goes directly to city 3 with 1 liter of fuel.\n- Representative\n2\n and representative\n3\n go together to city 1 with 1 liter of fuel.\n- Representative\n2\n and representative\n3\n go together to the capital with 1 liter of fuel.\n- Representative\n1\n goes directly to the capital with 1 liter of fuel.\n- Representative\n5\n goes directly to the capital with 1 liter of fuel.\n- Representative\n6\n goes directly to city 4 with 1 liter of fuel.\n- Representative\n4\n and representative\n6\n go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n roads = [], seats = 1\n\nOutput:\n 0\n\nExplanation:\n No representatives need to travel to the capital city.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nroads.length == n - 1\n\n\nroads[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nroads\n represents a valid tree.\n\n\n1 <= seats <= 10\n5",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2476,
    "slug": "closest-nodes-queries-in-a-binary-search-tree",
    "url": "https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/",
    "titulo": "Closest Nodes Queries in a Binary Search Tree",
    "enunciado": "You are given the \nroot\n of a \nbinary search tree \nand an array \nqueries\n of size \nn\n consisting of positive integers.\n\n\nFind a \n2D\n array \nanswer\n of size \nn\n where \nanswer[i] = [min\ni\n, max\ni\n]\n:\n\n\n\n\nmin\ni\n is the \nlargest\n value in the tree that is smaller than or equal to \nqueries[i]\n. If a such value does not exist, add \n-1\n instead.\n\n\nmax\ni\n is the \nsmallest\n value in the tree that is greater than or equal to \nqueries[i]\n. If a such value does not exist, add \n-1\n instead.\n\n\n\n\nReturn \nthe array\n \nanswer\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\n\nOutput:\n [[2,2],[4,6],[15,-1]]\n\nExplanation:\n We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,null,9], queries = [3]\n\nOutput:\n [[-1,4]]\n\nExplanation:\n The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n6\n\n\nn == queries.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= queries[i] <= 10\n6",
    "temas": [
      "Array",
      "Binary Search",
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2467,
    "slug": "most-profitable-path-in-a-tree",
    "url": "https://leetcode.com/problems/most-profitable-path-in-a-tree/",
    "titulo": "Most Profitable Path in a Tree",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n, rooted at node \n0\n. You are given a 2D integer array \nedges\n of length \nn - 1\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nAt every node \ni\n, there is a gate. You are also given an array of even integers \namount\n, where \namount[i]\n represents:\n\n\n\n\nthe price needed to open the gate at node \ni\n, if \namount[i]\n is negative, or,\n\n\nthe cash reward obtained on opening the gate at node \ni\n, otherwise.\n\n\n\n\nThe game goes on as follows:\n\n\n\n\nInitially, Alice is at node \n0\n and Bob is at node \nbob\n.\n\n\nAt every second, Alice and Bob \neach\n move to an adjacent node. Alice moves towards some \nleaf node\n, while Bob moves towards node \n0\n.\n\n\nFor \nevery\n node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n\t\n\n\nIf the gate is \nalready open\n, no price will be required, nor will there be any cash reward.\n\n\nIf Alice and Bob reach the node \nsimultaneously\n, they share the price/reward for opening the gate there. In other words, if the price to open the gate is \nc\n, then both Alice and Bob pay \nc / 2\n each. Similarly, if the reward at the gate is \nc\n, both of them receive \nc / 2\n each.\n\n\n\n\n\n\nIf Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node \n0\n, he stops moving. Note that these events are \nindependent\n of each other.\n\n\n\n\nReturn\n the \nmaximum\n net income Alice can have if she travels towards the optimal leaf node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\n\nOutput:\n 6\n\nExplanation:\n \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n  Since they reach here simultaneously, they open the gate together and share the reward.\n  Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n  Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[0,1]], bob = 1, amount = [-7280,2350]\n\nOutput:\n -7280\n\nExplanation:\n \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nedges\n represents a valid tree.\n\n\n1 <= bob < n\n\n\namount.length == n\n\n\namount[i]\n is an \neven\n integer in the range \n[-10\n4\n, 10\n4\n]\n.",
    "temas": [
      "Array",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2471,
    "slug": "minimum-number-of-operations-to-sort-a-binary-tree-by-level",
    "url": "https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/",
    "titulo": "Minimum Number of Operations to Sort a Binary Tree by Level",
    "enunciado": "You are given the \nroot\n of a binary tree with \nunique values\n.\n\n\nIn one operation, you can choose any two nodes \nat the same level\n and swap their values.\n\n\nReturn \nthe minimum number of operations needed to make the values at each level sorted in a \nstrictly increasing order\n.\n\n\nThe \nlevel\n of a node is the number of edges along the path between it and the root node\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n\nOutput:\n 3\n\nExplanation:\n\n- Swap 4 and 3. The 2\nnd\n level becomes [3,4].\n- Swap 7 and 5. The 3\nrd\n level becomes [5,6,8,7].\n- Swap 8 and 7. The 3\nrd\n level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,3,2,7,6,5,4]\n\nOutput:\n 3\n\nExplanation:\n\n- Swap 3 and 2. The 2\nnd\n level becomes [2,3].\n- Swap 7 and 4. The 3\nrd\n level becomes [4,6,5,7].\n- Swap 6 and 5. The 3\nrd\n level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6]\n\nOutput:\n 0\n\nExplanation:\n Each level is already sorted in increasing order so return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\nAll the values of the tree are \nunique\n.",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2463,
    "slug": "minimum-total-distance-traveled",
    "url": "https://leetcode.com/problems/minimum-total-distance-traveled/",
    "titulo": "Minimum Total Distance Traveled",
    "enunciado": "There are some robots and factories on the X-axis. You are given an integer array \nrobot\n where \nrobot[i]\n is the position of the \ni\nth\n robot. You are also given a 2D integer array \nfactory\n where \nfactory[j] = [position\nj\n, limit\nj\n]\n indicates that \nposition\nj\n is the position of the \nj\nth\n factory and that the \nj\nth\n factory can repair at most \nlimit\nj\n robots.\n\n\nThe positions of each robot are \nunique\n. The positions of each factory are also \nunique\n. Note that a robot can be \nin the same position\n as a factory initially.\n\n\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\n\n\nAt any moment\n, you can set the initial direction of moving for \nsome\n robot. Your target is to minimize the total distance traveled by all the robots.\n\n\nReturn \nthe minimum total distance traveled by all the robots\n. The test cases are generated such that all the robots can be repaired.\n\n\nNote that\n\n\n\n\nAll robots move at the same speed.\n\n\nIf two robots move in the same direction, they will never collide.\n\n\nIf two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n\n\nIf a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n\n\nIf the robot moved from a position \nx\n to a position \ny\n, the distance it moved is \n|y - x|\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n robot = [0,4,6], factory = [[2,2],[6,2]]\n\nOutput:\n 4\n\nExplanation:\n As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n robot = [1,-1], factory = [[-2,1],[2,1]]\n\nOutput:\n 2\n\nExplanation:\n As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= robot.length, factory.length <= 100\n\n\nfactory[j].length == 2\n\n\n-10\n9\n <= robot[i], position\nj\n <= 10\n9\n\n\n0 <= limit\nj\n <= robot.length\n\n\nThe input will be generated such that it is always possible to repair every robot.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2458,
    "slug": "height-of-binary-tree-after-subtree-removal-queries",
    "url": "https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/",
    "titulo": "Height of Binary Tree After Subtree Removal Queries",
    "enunciado": "You are given the \nroot\n of a \nbinary tree\n with \nn\n nodes. Each node is assigned a unique value from \n1\n to \nn\n. You are also given an array \nqueries\n of size \nm\n.\n\n\nYou have to perform \nm\n \nindependent\n queries on the tree where in the \ni\nth\n query you do the following:\n\n\n\n\nRemove\n the subtree rooted at the node with the value \nqueries[i]\n from the tree. It is \nguaranteed\n that \nqueries[i]\n will \nnot\n be equal to the value of the root.\n\n\n\n\nReturn \nan array \nanswer\n of size \nm\n where \nanswer[i]\n is the height of the tree after performing the \ni\nth\n query\n.\n\n\nNote\n:\n\n\n\n\nThe queries are independent, so the tree returns to its \ninitial\n state after each query.\n\n\nThe height of a tree is the \nnumber of edges in the longest simple path\n from the root to some node in the tree.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n\nOutput:\n [2]\n\nExplanation:\n The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -> 3 -> 2).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n\nOutput:\n [3,2,3,2]\n\nExplanation:\n We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n2 <= n <= 10\n5\n\n\n1 <= Node.val <= n\n\n\nAll the values in the tree are \nunique\n.\n\n\nm == queries.length\n\n\n1 <= m <= min(n, 10\n4\n)\n\n\n1 <= queries[i] <= n\n\n\nqueries[i] != root.val",
    "temas": [
      "Array",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2440,
    "slug": "create-components-with-same-value",
    "url": "https://leetcode.com/problems/create-components-with-same-value/",
    "titulo": "Create Components With Same Value",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n.\n\n\nYou are given a \n0-indexed\n integer array \nnums\n of length \nn\n where \nnums[i]\n represents the value of the \ni\nth\n node. You are also given a 2D integer array \nedges\n of length \nn - 1\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nYou are allowed to \ndelete\n some edges, splitting the tree into multiple connected components. Let the \nvalue\n of a component be the sum of \nall\n \nnums[i]\n for which node \ni\n is in the component.\n\n\nReturn\n the \nmaximum\n number of edges you can delete, such that every connected component in the tree has the same value.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \n\nOutput:\n 2 \n\nExplanation:\n The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2], edges = []\n\nOutput:\n 0\n\nExplanation:\n There are no edges to be deleted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n4\n\n\nnums.length == n\n\n\n1 <= nums[i] <= 50\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= edges[i][0], edges[i][1] <= n - 1\n\n\nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Math",
      "Tree",
      "Depth-First Search",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2435,
    "slug": "paths-in-matrix-whose-sum-is-divisible-by-k",
    "url": "https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/",
    "titulo": "Paths in Matrix Whose Sum Is Divisible by K",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n integer matrix \ngrid\n and an integer \nk\n. You are currently at position \n(0, 0)\n and you want to reach position \n(m - 1, n - 1)\n moving only \ndown\n or \nright\n.\n\n\nReturn\n the number of paths where the sum of the elements on the path is divisible by \nk\n. Since the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\n\nOutput:\n 2\n\nExplanation:\n There are two paths where the sum of the elements on the path is divisible by k.\nThe first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\nThe second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0]], k = 5\n\nOutput:\n 1\n\nExplanation:\n The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\n\nOutput:\n 10\n\nExplanation:\n Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 5 * 10\n4\n\n\n1 <= m * n <= 5 * 10\n4\n\n\n0 <= grid[i][j] <= 100\n\n\n1 <= k <= 50",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2428,
    "slug": "maximum-sum-of-an-hourglass",
    "url": "https://leetcode.com/problems/maximum-sum-of-an-hourglass/",
    "titulo": "Maximum Sum of an Hourglass",
    "enunciado": "You are given an \nm x n\n integer matrix \ngrid\n.\n\n\nWe define an \nhourglass\n as a part of the matrix with the following form:\n\n\n\n\nReturn \nthe \nmaximum\n sum of the elements of an hourglass\n.\n\n\nNote\n that an hourglass cannot be rotated and must be entirely contained within the matrix.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\n\nOutput:\n 30\n\nExplanation:\n The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n 35\n\nExplanation:\n There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n3 <= m, n <= 150\n\n\n0 <= grid[i][j] <= 10\n6",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2421,
    "slug": "number-of-good-paths",
    "url": "https://leetcode.com/problems/number-of-good-paths/",
    "titulo": "Number of Good Paths",
    "enunciado": "There is a tree (i.e. a connected, undirected graph with no cycles) consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n and exactly \nn - 1\n edges.\n\n\nYou are given a \n0-indexed\n integer array \nvals\n of length \nn\n where \nvals[i]\n denotes the value of the \ni\nth\n node. You are also given a 2D integer array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n denotes that there exists an \nundirected\n edge connecting nodes \na\ni\n and \nb\ni\n.\n\n\nA \ngood path\n is a simple path that satisfies the following conditions:\n\n\n\n\nThe starting node and the ending node have the \nsame\n value.\n\n\nAll nodes between the starting node and the ending node have values \nless than or equal to\n the starting node (i.e. the starting node's value should be the maximum value along the path).\n\n\n\n\nReturn \nthe number of distinct good paths\n.\n\n\nNote that a path and its reverse are counted as the \nsame\n path. For example, \n0 -> 1\n is considered to be the same as \n1 -> 0\n. A single node is also considered as a valid path.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]\n\nOutput:\n 6\n\nExplanation:\n There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals[2] > vals[0].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]\n\nOutput:\n 7\n\nExplanation:\n There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n vals = [1], edges = []\n\nOutput:\n 1\n\nExplanation:\n The tree consists of only one node, so there is one good path.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == vals.length\n\n\n1 <= n <= 3 * 10\n4\n\n\n0 <= vals[i] <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Union Find",
      "Graph",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2415,
    "slug": "reverse-odd-levels-of-binary-tree",
    "url": "https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/",
    "titulo": "Reverse Odd Levels of Binary Tree",
    "enunciado": "Given the \nroot\n of a \nperfect\n binary tree, reverse the node values at each \nodd\n level of the tree.\n\n\n\n\nFor example, suppose the node values at level 3 are \n[2,1,3,4,7,11,29,18]\n, then it should become \n[18,29,11,7,4,3,1,2]\n.\n\n\n\n\nReturn \nthe root of the reversed tree\n.\n\n\nA binary tree is \nperfect\n if all parent nodes have two children and all leaves are on the same level.\n\n\nThe \nlevel\n of a node is the number of edges along the path between it and the root node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,3,5,8,13,21,34]\n\nOutput:\n [2,5,3,8,13,21,34]\n\nExplanation:\n \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [7,13,11]\n\nOutput:\n [7,11,13]\n\nExplanation:\n \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n\nOutput:\n [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n\nExplanation:\n \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2\n14\n]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\nroot\n is a \nperfect\n binary tree.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2397,
    "slug": "maximum-rows-covered-by-columns",
    "url": "https://leetcode.com/problems/maximum-rows-covered-by-columns/",
    "titulo": "Maximum Rows Covered by Columns",
    "enunciado": "You are given an \nm x n\n binary matrix \nmatrix\n and an integer \nnumSelect\n.\n\n\nYour goal is to select exactly \nnumSelect\n \ndistinct \ncolumns from \nmatrix\n such that you cover as many rows as possible.\n\n\nA row is considered \ncovered\n if all the \n1\n's in that row are also part of a column that you have selected. If a row does not have any \n1\ns, it is also considered covered.\n\n\nMore formally, let us consider \nselected = {c\n1\n, c\n2\n, ...., c\nnumSelect\n}\n as the set of columns selected by you. A row \ni\n is \ncovered\n by \nselected\n if:\n\n\n\n\nFor each cell where \nmatrix[i][j] == 1\n, the column \nj\n is in \nselected\n.\n\n\nOr, no cell in row \ni\n has a value of \n1\n.\n\n\n\n\nReturn the \nmaximum\n number of rows that can be \ncovered\n by a set of \nnumSelect\n columns.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nmatrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nOne possible way to cover 3 rows is shown in the diagram above.\n\nWe choose s = {0, 2}.\n\n- Row 0 is covered because it has no occurrences of 1.\n\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\n\nThus, we can cover three rows.\n\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nmatrix = [[1],[0]], numSelect = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nSelecting the only column will result in both rows being covered since the entire matrix is selected.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 12\n\n\nmatrix[i][j]\n is either \n0\n or \n1\n.\n\n\n1 <= numSelect <= n",
    "temas": [
      "Array",
      "Backtracking",
      "Bit Manipulation",
      "Matrix",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2392,
    "slug": "build-a-matrix-with-conditions",
    "url": "https://leetcode.com/problems/build-a-matrix-with-conditions/",
    "titulo": "Build a Matrix With Conditions",
    "enunciado": "You are given a \npositive\n integer \nk\n. You are also given:\n\n\n\n\na 2D integer array \nrowConditions\n of size \nn\n where \nrowConditions[i] = [above\ni\n, below\ni\n]\n, and\n\n\na 2D integer array \ncolConditions\n of size \nm\n where \ncolConditions[i] = [left\ni\n, right\ni\n]\n.\n\n\n\n\nThe two arrays contain integers from \n1\n to \nk\n.\n\n\nYou have to build a \nk x k\n matrix that contains each of the numbers from \n1\n to \nk\n \nexactly once\n. The remaining cells should have the value \n0\n.\n\n\nThe matrix should also satisfy the following conditions:\n\n\n\n\nThe number \nabove\ni\n should appear in a \nrow\n that is strictly \nabove\n the row at which the number \nbelow\ni\n appears for all \ni\n from \n0\n to \nn - 1\n.\n\n\nThe number \nleft\ni\n should appear in a \ncolumn\n that is strictly \nleft\n of the column at which the number \nright\ni\n appears for all \ni\n from \n0\n to \nm - 1\n.\n\n\n\n\nReturn \nany\n matrix that satisfies the conditions\n. If no answer exists, return an empty matrix.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\n\nOutput:\n [[3,0,0],[0,0,1],[0,2,0]]\n\nExplanation:\n The diagram above shows a valid example of a matrix that satisfies all the conditions.\nThe row conditions are the following:\n- Number 1 is in row \n1\n, and number 2 is in row \n2\n, so 1 is above 2 in the matrix.\n- Number 3 is in row \n0\n, and number 2 is in row \n2\n, so 3 is above 2 in the matrix.\nThe column conditions are the following:\n- Number 2 is in column \n1\n, and number 1 is in column \n2\n, so 2 is left of 1 in the matrix.\n- Number 3 is in column \n0\n, and number 2 is in column \n1\n, so 3 is left of 2 in the matrix.\nNote that there may be multiple correct answers.\n\n\n\nExample 2:\n\n\n\n\nInput:\n k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\n\nOutput:\n []\n\nExplanation:\n From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.\nNo matrix can satisfy all the conditions, so we return the empty matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= k <= 400\n\n\n1 <= rowConditions.length, colConditions.length <= 10\n4\n\n\nrowConditions[i].length == colConditions[i].length == 2\n\n\n1 <= above\ni\n, below\ni\n, left\ni\n, right\ni\n <= k\n\n\nabove\ni\n != below\ni\n\n\nleft\ni\n != right\ni",
    "temas": [
      "Array",
      "Graph",
      "Topological Sort",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2385,
    "slug": "amount-of-time-for-binary-tree-to-be-infected",
    "url": "https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/",
    "titulo": "Amount of Time for Binary Tree to Be Infected",
    "enunciado": "You are given the \nroot\n of a binary tree with \nunique\n values, and an integer \nstart\n. At minute \n0\n, an \ninfection\n starts from the node with value \nstart\n.\n\n\nEach minute, a node becomes infected if:\n\n\n\n\nThe node is currently uninfected.\n\n\nThe node is adjacent to an infected node.\n\n\n\n\nReturn \nthe number of minutes needed for the entire tree to be infected.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,5,3,null,4,10,6,9,2], start = 3\n\nOutput:\n 4\n\nExplanation:\n The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1], start = 1\n\nOutput:\n 0\n\nExplanation:\n At minute 0, the only node in the tree is infected so we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\nEach node has a \nunique\n value.\n\n\nA node with a value of \nstart\n exists in the tree.",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2374,
    "slug": "node-with-highest-edge-score",
    "url": "https://leetcode.com/problems/node-with-highest-edge-score/",
    "titulo": "Node With Highest Edge Score",
    "enunciado": "You are given a directed graph with \nn\n nodes labeled from \n0\n to \nn - 1\n, where each node has \nexactly one\n outgoing edge.\n\n\nThe graph is represented by a given \n0-indexed\n integer array \nedges\n of length \nn\n, where \nedges[i]\n indicates that there is a \ndirected\n edge from node \ni\n to node \nedges[i]\n.\n\n\nThe \nedge score\n of a node \ni\n is defined as the sum of the \nlabels\n of all the nodes that have an edge pointing to \ni\n.\n\n\nReturn \nthe node with the highest \nedge score\n. If multiple nodes have the same \nedge score\n, return the node with the \nsmallest\n index.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [1,0,0,0,0,7,7,5]\n\nOutput:\n 7\n\nExplanation:\n\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [2,0,0,2]\n\nOutput:\n 0\n\nExplanation:\n\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= edges[i] < n\n\n\nedges[i] != i",
    "temas": [
      "Hash Table",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2373,
    "slug": "largest-local-values-in-a-matrix",
    "url": "https://leetcode.com/problems/largest-local-values-in-a-matrix/",
    "titulo": "Largest Local Values in a Matrix",
    "enunciado": "You are given an \nn x n\n integer matrix \ngrid\n.\n\n\nGenerate an integer matrix \nmaxLocal\n of size \n(n - 2) x (n - 2)\n such that:\n\n\n\n\nmaxLocal[i][j]\n is equal to the \nlargest\n value of the \n3 x 3\n matrix in \ngrid\n centered around row \ni + 1\n and column \nj + 1\n.\n\n\n\n\nIn other words, we want to find the largest value in every contiguous \n3 x 3\n matrix in \ngrid\n.\n\n\nReturn \nthe generated matrix\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n\nOutput:\n [[9,9],[8,6]]\n\nExplanation:\n The diagram above shows the original matrix and the generated matrix.\nNotice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n\nOutput:\n [[2,2,2],[2,2,2],[2,2,2]]\n\nExplanation:\n Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n3 <= n <= 100\n\n\n1 <= grid[i][j] <= 100",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2368,
    "slug": "reachable-nodes-with-restrictions",
    "url": "https://leetcode.com/problems/reachable-nodes-with-restrictions/",
    "titulo": "Reachable Nodes With Restrictions",
    "enunciado": "There is an undirected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n and \nn - 1\n edges.\n\n\nYou are given a 2D integer array \nedges\n of length \nn - 1\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree. You are also given an integer array \nrestricted\n which represents \nrestricted\n nodes.\n\n\nReturn \nthe \nmaximum\n number of nodes you can reach from node \n0\n without visiting a restricted node.\n\n\nNote that node \n0\n will \nnot\n be a restricted node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\n\nOutput:\n 4\n\nExplanation:\n The diagram above shows the tree.\nWe have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\n\nOutput:\n 3\n\nExplanation:\n The diagram above shows the tree.\nWe have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nedges\n represents a valid tree.\n\n\n1 <= restricted.length < n\n\n\n1 <= restricted[i] < n\n\n\nAll the values of \nrestricted\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2360,
    "slug": "longest-cycle-in-a-graph",
    "url": "https://leetcode.com/problems/longest-cycle-in-a-graph/",
    "titulo": "Longest Cycle in a Graph",
    "enunciado": "You are given a \ndirected\n graph of \nn\n nodes numbered from \n0\n to \nn - 1\n, where each node has \nat most one\n outgoing edge.\n\n\nThe graph is represented with a given \n0-indexed\n array \nedges\n of size \nn\n, indicating that there is a directed edge from node \ni\n to node \nedges[i]\n. If there is no outgoing edge from node \ni\n, then \nedges[i] == -1\n.\n\n\nReturn \nthe length of the \nlongest\n cycle in the graph\n. If no cycle exists, return \n-1\n.\n\n\nA cycle is a path that starts and ends at the \nsame\n node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [3,3,4,2,3]\n\nOutput:\n 3\n\nExplanation:\n The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [2,-1,3,1]\n\nOutput:\n -1\n\nExplanation:\n There are no cycles in this graph.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n2 <= n <= 10\n5\n\n\n-1 <= edges[i] < n\n\n\nedges[i] != i",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2359,
    "slug": "find-closest-node-to-given-two-nodes",
    "url": "https://leetcode.com/problems/find-closest-node-to-given-two-nodes/",
    "titulo": "Find Closest Node to Given Two Nodes",
    "enunciado": "You are given a \ndirected\n graph of \nn\n nodes numbered from \n0\n to \nn - 1\n, where each node has \nat most one\n outgoing edge.\n\n\nThe graph is represented with a given \n0-indexed\n array \nedges\n of size \nn\n, indicating that there is a directed edge from node \ni\n to node \nedges[i]\n. If there is no outgoing edge from \ni\n, then \nedges[i] == -1\n.\n\n\nYou are also given two integers \nnode1\n and \nnode2\n.\n\n\nReturn \nthe \nindex\n of the node that can be reached from both \nnode1\n and \nnode2\n, such that the \nmaximum\n between the distance from \nnode1\n to that node, and from \nnode2\n to that node is \nminimized\n. If there are multiple answers, return the node with the \nsmallest\n index, and if no possible answer exists, return \n-1\n.\n\n\nNote that \nedges\n may contain cycles.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [2,2,3,-1], node1 = 0, node2 = 1\n\nOutput:\n 2\n\nExplanation:\n The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [1,2,-1], node1 = 0, node2 = 2\n\nOutput:\n 2\n\nExplanation:\n The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n2 <= n <= 10\n5\n\n\n-1 <= edges[i] < n\n\n\nedges[i] != i\n\n\n0 <= node1, node2 < n",
    "temas": [
      "Depth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2352,
    "slug": "equal-row-and-column-pairs",
    "url": "https://leetcode.com/problems/equal-row-and-column-pairs/",
    "titulo": "Equal Row and Column Pairs",
    "enunciado": "Given a \n0-indexed\n \nn x n\n integer matrix \ngrid\n, \nreturn the number of pairs \n(r\ni\n, c\nj\n)\n such that row \nr\ni\n and column \nc\nj\n are equal\n.\n\n\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[3,2,1],[1,7,6],[2,7,7]]\n\nOutput:\n 1\n\nExplanation:\n There is 1 equal row and column pair:\n- (Row 2, Column 1): [2,7,7]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n\nOutput:\n 3\n\nExplanation:\n There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 200\n\n\n1 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2331,
    "slug": "evaluate-boolean-binary-tree",
    "url": "https://leetcode.com/problems/evaluate-boolean-binary-tree/",
    "titulo": "Evaluate Boolean Binary Tree",
    "enunciado": "You are given the \nroot\n of a \nfull binary tree\n with the following properties:\n\n\n\n\nLeaf nodes\n have either the value \n0\n or \n1\n, where \n0\n represents \nFalse\n and \n1\n represents \nTrue\n.\n\n\nNon-leaf nodes\n have either the value \n2\n or \n3\n, where \n2\n represents the boolean \nOR\n and \n3\n represents the boolean \nAND\n.\n\n\n\n\nThe \nevaluation\n of a node is as follows:\n\n\n\n\nIf the node is a leaf node, the evaluation is the \nvalue\n of the node, i.e. \nTrue\n or \nFalse\n.\n\n\nOtherwise, \nevaluate\n the node's two children and \napply\n the boolean operation of its value with the children's evaluations.\n\n\n\n\nReturn\n the boolean result of \nevaluating\n the \nroot\n node.\n\n\nA \nfull binary tree\n is a binary tree where each node has either \n0\n or \n2\n children.\n\n\nA \nleaf node\n is a node that has zero children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3,null,null,0,1]\n\nOutput:\n true\n\nExplanation:\n The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n false\n\nExplanation:\n The root node is a leaf node and it evaluates to false, so we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 3\n\n\nEvery node has either \n0\n or \n2\n children.\n\n\nLeaf nodes have a value of \n0\n or \n1\n.\n\n\nNon-leaf nodes have a value of \n2\n or \n3\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2326,
    "slug": "spiral-matrix-iv",
    "url": "https://leetcode.com/problems/spiral-matrix-iv/",
    "titulo": "Spiral Matrix IV",
    "enunciado": "You are given two integers \nm\n and \nn\n, which represent the dimensions of a matrix.\n\n\nYou are also given the \nhead\n of a linked list of integers.\n\n\nGenerate an \nm x n\n matrix that contains the integers in the linked list presented in \nspiral\n order \n(clockwise)\n, starting from the \ntop-left\n of the matrix. If there are remaining empty spaces, fill them with \n-1\n.\n\n\nReturn \nthe generated matrix\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n\nOutput:\n [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n\nExplanation:\n The diagram above shows how the values are printed in the matrix.\nNote that the remaining spaces in the matrix are filled with -1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 1, n = 4, head = [0,1,2]\n\nOutput:\n [[0,1,2,-1]]\n\nExplanation:\n The diagram above shows how the values are printed from left to right in the matrix.\nThe last space in the matrix is set to -1.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\nThe number of nodes in the list is in the range \n[1, m * n]\n.\n\n\n0 <= Node.val <= 1000",
    "temas": [
      "Array",
      "Linked List",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2328,
    "slug": "number-of-increasing-paths-in-a-grid",
    "url": "https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/",
    "titulo": "Number of Increasing Paths in a Grid",
    "enunciado": "You are given an \nm x n\n integer matrix \ngrid\n, where you can move from a cell to any adjacent cell in all \n4\n directions.\n\n\nReturn \nthe number of \nstrictly\n \nincreasing\n paths in the grid such that you can start from \nany\n cell and end at \nany\n cell. \nSince the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,1],[3,4]]\n\nOutput:\n 8\n\nExplanation:\n The strictly increasing paths are:\n- Paths with length 1: [1], [1], [3], [4].\n- Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].\n- Paths with length 3: [1 -> 3 -> 4].\nThe total number of paths is 4 + 3 + 1 = 8.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1],[2]]\n\nOutput:\n 3\n\nExplanation:\n The strictly increasing paths are:\n- Paths with length 1: [1], [2].\n- Paths with length 2: [1 -> 2].\nThe total number of paths is 2 + 1 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 1000\n\n\n1 <= m * n <= 10\n5\n\n\n1 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2325,
    "slug": "decode-the-message",
    "url": "https://leetcode.com/problems/decode-the-message/",
    "titulo": "Decode the Message",
    "enunciado": "You are given the strings \nkey\n and \nmessage\n, which represent a cipher key and a secret message, respectively. The steps to decode \nmessage\n are as follows:\n\n\n\n\nUse the \nfirst\n appearance of all 26 lowercase English letters in \nkey\n as the \norder\n of the substitution table.\n\n\nAlign the substitution table with the regular English alphabet.\n\n\nEach letter in \nmessage\n is then \nsubstituted\n using the table.\n\n\nSpaces \n' '\n are transformed to themselves.\n\n\n\n\n\n\nFor example, given \nkey = \"\nhap\np\ny\n \nbo\ny\"\n (actual key would have \nat least one\n instance of each letter in the alphabet), we have the partial substitution table of (\n'h' -> 'a'\n, \n'a' -> 'b'\n, \n'p' -> 'c'\n, \n'y' -> 'd'\n, \n'b' -> 'e'\n, \n'o' -> 'f'\n).\n\n\n\n\nReturn \nthe decoded message\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"\n\nOutput:\n \"this is a secret\"\n\nExplanation:\n The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"\nthe\n \nquick\n \nbrown\n \nf\no\nx\n \nj\nu\nmps\n o\nv\ner the \nlazy\n \nd\no\ng\n\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\n\nOutput:\n \"the five boxing wizards jump quickly\"\n\nExplanation:\n The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"\neljuxhpwnyrdgtqkviszcfmabo\n\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n26 <= key.length <= 2000\n\n\nkey\n consists of lowercase English letters and \n' '\n.\n\n\nkey\n contains every letter in the English alphabet (\n'a'\n to \n'z'\n) \nat least once\n.\n\n\n1 <= message.length <= 2000\n\n\nmessage\n consists of lowercase English letters and \n' '\n.",
    "temas": [
      "Hash Table",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2316,
    "slug": "count-unreachable-pairs-of-nodes-in-an-undirected-graph",
    "url": "https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/",
    "titulo": "Count Unreachable Pairs of Nodes in an Undirected Graph",
    "enunciado": "You are given an integer \nn\n. There is an \nundirected\n graph with \nn\n nodes, numbered from \n0\n to \nn - 1\n. You are given a 2D integer array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n denotes that there exists an \nundirected\n edge connecting nodes \na\ni\n and \nb\ni\n.\n\n\nReturn \nthe \nnumber of pairs\n of different nodes that are \nunreachable\n from each other\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[0,2],[1,2]]\n\nOutput:\n 0\n\nExplanation:\n There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]\n\nOutput:\n 14\n\nExplanation:\n There are 14 pairs of nodes that are unreachable from each other:\n[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].\nTherefore, we return 14.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n0 <= edges.length <= 2 * 10\n5\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nThere are no repeated edges.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2322,
    "slug": "minimum-score-after-removals-on-a-tree",
    "url": "https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/",
    "titulo": "Minimum Score After Removals on a Tree",
    "enunciado": "There is an undirected connected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n and \nn - 1\n edges.\n\n\nYou are given a \n0-indexed\n integer array \nnums\n of length \nn\n where \nnums[i]\n represents the value of the \ni\nth\n node. You are also given a 2D integer array \nedges\n of length \nn - 1\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nRemove two \ndistinct\n edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n\n\n\nGet the XOR of all the values of the nodes for \neach\n of the three components respectively.\n\n\nThe \ndifference\n between the \nlargest\n XOR value and the \nsmallest\n XOR value is the \nscore\n of the pair.\n\n\n\n\n\n\nFor example, say the three components have the node values: \n[4,5,7]\n, \n[1,9]\n, and \n[3,3,3]\n. The three XOR values are \n4 ^ 5 ^ 7 = \n6\n, \n1 ^ 9 = \n8\n, and \n3 ^ 3 ^ 3 = \n3\n. The largest XOR value is \n8\n and the smallest XOR value is \n3\n. The score is then \n8 - 3 = 5\n.\n\n\n\n\nReturn \nthe \nminimum\n score of any possible pair of edge removals on the given tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]\n\nOutput:\n 9\n\nExplanation:\n The diagram above shows a way to make a pair of removals.\n- The 1\nst\n component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2\nnd\n component has node [0] with value [1]. Its XOR value is 1 = 1.\n- The 3\nrd\n component has node [2] with value [5]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]\n\nOutput:\n 0\n\nExplanation:\n The diagram above shows a way to make a pair of removals.\n- The 1\nst\n component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.\n- The 2\nnd\n component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.\n- The 3\nrd\n component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n3 <= n <= 1000\n\n\n1 <= nums[i] <= 10\n8\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nedges\n represents a valid tree.",
    "temas": [
      "Array",
      "Bit Manipulation",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2319,
    "slug": "check-if-matrix-is-x-matrix",
    "url": "https://leetcode.com/problems/check-if-matrix-is-x-matrix/",
    "titulo": "Check if Matrix Is X-Matrix",
    "enunciado": "A square matrix is said to be an \nX-Matrix\n if \nboth\n of the following conditions hold:\n\n\n\n\nAll the elements in the diagonals of the matrix are \nnon-zero\n.\n\n\nAll other elements are 0.\n\n\n\n\nGiven a 2D integer array \ngrid\n of size \nn x n\n representing a square matrix, return \ntrue\n if \ngrid\n is an X-Matrix\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n\nOutput:\n true\n\nExplanation:\n Refer to the diagram above. \nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is an X-Matrix.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[5,7,0],[0,3,1],[0,5,0]]\n\nOutput:\n false\n\nExplanation:\n Refer to the diagram above.\nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is not an X-Matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n3 <= n <= 100\n\n\n0 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2320,
    "slug": "count-number-of-ways-to-place-houses",
    "url": "https://leetcode.com/problems/count-number-of-ways-to-place-houses/",
    "titulo": "Count Number of Ways to Place Houses",
    "enunciado": "There is a street with \nn * 2\n \nplots\n, where there are \nn\n plots on each side of the street. The plots on each side are numbered from \n1\n to \nn\n. On each plot, a house can be placed.\n\n\nReturn \nthe number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street\n. Since the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\nNote that if a house is placed on the \ni\nth\n plot on one side of the street, a house can also be placed on the \ni\nth\n plot on the other side of the street.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 4\n\nExplanation:\n \nPossible arrangements:\n1. All plots are empty.\n2. A house is placed on one side of the street.\n3. A house is placed on the other side of the street.\n4. Two houses are placed, one on each side of the street.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 9\n\nExplanation:\n The 9 possible arrangements are shown in the diagram above.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2293,
    "slug": "min-max-game",
    "url": "https://leetcode.com/problems/min-max-game/",
    "titulo": "Min Max Game",
    "enunciado": "You are given a \n0-indexed\n integer array \nnums\n whose length is a power of \n2\n.\n\n\nApply the following algorithm on \nnums\n:\n\n\n\n\nLet \nn\n be the length of \nnums\n. If \nn == 1\n, \nend\n the process. Otherwise, \ncreate\n a new \n0-indexed\n integer array \nnewNums\n of length \nn / 2\n.\n\n\nFor every \neven\n index \ni\n where \n0 <= i < n / 2\n, \nassign\n the value of \nnewNums[i]\n as \nmin(nums[2 * i], nums[2 * i + 1])\n.\n\n\nFor every \nodd\n index \ni\n where \n0 <= i < n / 2\n, \nassign\n the value of \nnewNums[i]\n as \nmax(nums[2 * i], nums[2 * i + 1])\n.\n\n\nReplace\n the array \nnums\n with \nnewNums\n.\n\n\nRepeat\n the entire process starting from step 1.\n\n\n\n\nReturn \nthe last number that remains in \nnums\n after applying the algorithm.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,3,5,2,4,8,2,2]\n\nOutput:\n 1\n\nExplanation:\n The following arrays are the results of applying the algorithm repeatedly.\nFirst: nums = [1,5,4,2]\nSecond: nums = [1,4]\nThird: nums = [1]\n1 is the last remaining number, so we return 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3]\n\nOutput:\n 3\n\nExplanation:\n 3 is already the last remaining number, so we return 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1024\n\n\n1 <= nums[i] <= 10\n9\n\n\nnums.length\n is a power of \n2\n.",
    "temas": [
      "Array",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2236,
    "slug": "root-equals-sum-of-children",
    "url": "https://leetcode.com/problems/root-equals-sum-of-children/",
    "titulo": "Root Equals Sum of Children",
    "enunciado": "You are given the \nroot\n of a \nbinary tree\n that consists of exactly \n3\n nodes: the root, its left child, and its right child.\n\n\nReturn \ntrue\n \nif the value of the root is equal to the \nsum\n of the values of its two children, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,4,6]\n\nOutput:\n true\n\nExplanation:\n The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,1]\n\nOutput:\n false\n\nExplanation:\n The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe tree consists only of the root, its left child, and its right child.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2285,
    "slug": "maximum-total-importance-of-roads",
    "url": "https://leetcode.com/problems/maximum-total-importance-of-roads/",
    "titulo": "Maximum Total Importance of Roads",
    "enunciado": "You are given an integer \nn\n denoting the number of cities in a country. The cities are numbered from \n0\n to \nn - 1\n.\n\n\nYou are also given a 2D integer array \nroads\n where \nroads[i] = [a\ni\n, b\ni\n]\n denotes that there exists a \nbidirectional\n road connecting cities \na\ni\n and \nb\ni\n.\n\n\nYou need to assign each city with an integer value from \n1\n to \nn\n, where each value can only be used \nonce\n. The \nimportance\n of a road is then defined as the \nsum\n of the values of the two cities it connects.\n\n\nReturn \nthe \nmaximum total importance\n of all roads possible after assigning the values optimally.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n\nOutput:\n 43\n\nExplanation:\n The figure above shows the country and the assigned values of [2,4,5,3,1].\n- The road (0,1) has an importance of 2 + 4 = 6.\n- The road (1,2) has an importance of 4 + 5 = 9.\n- The road (2,3) has an importance of 5 + 3 = 8.\n- The road (0,2) has an importance of 2 + 5 = 7.\n- The road (1,3) has an importance of 4 + 3 = 7.\n- The road (2,4) has an importance of 5 + 1 = 6.\nThe total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.\nIt can be shown that we cannot obtain a greater total importance than 43.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, roads = [[0,3],[2,4],[1,3]]\n\nOutput:\n 20\n\nExplanation:\n The figure above shows the country and the assigned values of [4,3,2,5,1].\n- The road (0,3) has an importance of 4 + 5 = 9.\n- The road (2,4) has an importance of 2 + 1 = 3.\n- The road (1,3) has an importance of 3 + 5 = 8.\nThe total importance of all roads is 9 + 3 + 8 = 20.\nIt can be shown that we cannot obtain a greater total importance than 20.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\n1 <= roads.length <= 5 * 10\n4\n\n\nroads[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni\n\n\nThere are no duplicate roads.",
    "temas": [
      "Greedy",
      "Graph",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Greedy",
    "has_image": true
  },
  {
    "id": 2290,
    "slug": "minimum-obstacle-removal-to-reach-corner",
    "url": "https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/",
    "titulo": "Minimum Obstacle Removal to Reach Corner",
    "enunciado": "You are given a \n0-indexed\n 2D integer array \ngrid\n of size \nm x n\n. Each cell has one of two values:\n\n\n\n\n0\n represents an \nempty\n cell,\n\n\n1\n represents an \nobstacle\n that may be removed.\n\n\n\n\nYou can move up, down, left, or right from and to an empty cell.\n\n\nReturn \nthe \nminimum\n number of \nobstacles\n to \nremove\n so you can move from the upper left corner \n(0, 0)\n to the lower right corner \n(m - 1, n - 1)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1],[1,1,0],[1,1,0]]\n\nOutput:\n 2\n\nExplanation:\n We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n\nOutput:\n 0\n\nExplanation:\n We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n5\n\n\n2 <= m * n <= 10\n5\n\n\ngrid[i][j]\n is either \n0\n \nor\n \n1\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2280,
    "slug": "minimum-lines-to-represent-a-line-chart",
    "url": "https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/",
    "titulo": "Minimum Lines to Represent a Line Chart",
    "enunciado": "You are given a 2D integer array \nstockPrices\n where \nstockPrices[i] = [day\ni\n, price\ni\n]\n indicates the price of the stock on day \nday\ni\n is \nprice\ni\n. A \nline chart\n is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\n\n\n\n\nReturn \nthe \nminimum number of lines\n needed to represent the line chart\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]\n\nOutput:\n 3\n\nExplanation:\n\nThe diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n stockPrices = [[3,4],[1,2],[7,8],[2,3]]\n\nOutput:\n 1\n\nExplanation:\n\nAs shown in the diagram above, the line chart can be represented with a single line.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= stockPrices.length <= 10\n5\n\n\nstockPrices[i].length == 2\n\n\n1 <= day\ni\n, price\ni\n <= 10\n9\n\n\nAll \nday\ni\n are \ndistinct\n.",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Sorting",
      "Number Theory"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2246,
    "slug": "longest-path-with-different-adjacent-characters",
    "url": "https://leetcode.com/problems/longest-path-with-different-adjacent-characters/",
    "titulo": "Longest Path With Different Adjacent Characters",
    "enunciado": "You are given a \ntree\n (i.e. a connected, undirected graph that has no cycles) \nrooted\n at node \n0\n consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n. The tree is represented by a \n0-indexed\n array \nparent\n of size \nn\n, where \nparent[i]\n is the parent of node \ni\n. Since node \n0\n is the root, \nparent[0] == -1\n.\n\n\nYou are also given a string \ns\n of length \nn\n, where \ns[i]\n is the character assigned to node \ni\n.\n\n\nReturn \nthe length of the \nlongest path\n in the tree such that no pair of \nadjacent\n nodes on the path have the same character assigned to them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n parent = [-1,0,0,1,1,2], s = \"abacbe\"\n\nOutput:\n 3\n\nExplanation:\n The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n parent = [-1,0,0,0], s = \"aabc\"\n\nOutput:\n 3\n\nExplanation:\n The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parent.length == s.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= parent[i] <= n - 1\n for all \ni >= 1\n\n\nparent[0] == -1\n\n\nparent\n represents a valid tree.\n\n\ns\n consists of only lowercase English letters.",
    "temas": [
      "Array",
      "String",
      "Tree",
      "Depth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2245,
    "slug": "maximum-trailing-zeros-in-a-cornered-path",
    "url": "https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/",
    "titulo": "Maximum Trailing Zeros in a Cornered Path",
    "enunciado": "You are given a 2D integer array \ngrid\n of size \nm x n\n, where each cell contains a positive integer.\n\n\nA \ncornered path\n is defined as a set of adjacent cells with \nat most\n one turn. More specifically, the path should exclusively move either \nhorizontally\n or \nvertically\n up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the \nalternate\n direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\n\n\nThe \nproduct\n of a path is defined as the product of all the values in the path.\n\n\nReturn \nthe \nmaximum\n number of \ntrailing zeros\n in the product of a cornered path found in \ngrid\n.\n\n\nNote:\n\n\n\n\nHorizontal\n movement means moving in either the left or right direction.\n\n\nVertical\n movement means moving in either the up or down direction.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n\nOutput:\n 3\n\nExplanation:\n The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[4,3,2],[7,6,1],[8,8,8]]\n\nOutput:\n 0\n\nExplanation:\n The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n1 <= grid[i][j] <= 1000",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2271,
    "slug": "maximum-white-tiles-covered-by-a-carpet",
    "url": "https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/",
    "titulo": "Maximum White Tiles Covered by a Carpet",
    "enunciado": "You are given a 2D integer array \ntiles\n where \ntiles[i] = [l\ni\n, r\ni\n]\n represents that every tile \nj\n in the range \nl\ni\n <= j <= r\ni\n is colored white.\n\n\nYou are also given an integer \ncarpetLen\n, the length of a single carpet that can be placed \nanywhere\n.\n\n\nReturn \nthe \nmaximum\n number of white tiles that can be covered by the carpet\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10\n\nOutput:\n 9\n\nExplanation:\n Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n tiles = [[10,11],[1,1]], carpetLen = 2\n\nOutput:\n 2\n\nExplanation:\n Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= tiles.length <= 5 * 10\n4\n\n\ntiles[i].length == 2\n\n\n1 <= l\ni\n <= r\ni\n <= 10\n9\n\n\n1 <= carpetLen <= 10\n9\n\n\nThe \ntiles\n are \nnon-overlapping\n.",
    "temas": [
      "Array",
      "Binary Search",
      "Greedy",
      "Sliding Window",
      "Sorting",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2242,
    "slug": "maximum-score-of-a-node-sequence",
    "url": "https://leetcode.com/problems/maximum-score-of-a-node-sequence/",
    "titulo": "Maximum Score of a Node Sequence",
    "enunciado": "There is an \nundirected\n graph with \nn\n nodes, numbered from \n0\n to \nn - 1\n.\n\n\nYou are given a \n0-indexed\n integer array \nscores\n of length \nn\n where \nscores[i]\n denotes the score of node \ni\n. You are also given a 2D integer array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n denotes that there exists an \nundirected\n edge connecting nodes \na\ni\n and \nb\ni\n.\n\n\nA node sequence is \nvalid\n if it meets the following conditions:\n\n\n\n\nThere is an edge connecting every pair of \nadjacent\n nodes in the sequence.\n\n\nNo node appears more than once in the sequence.\n\n\n\n\nThe score of a node sequence is defined as the \nsum\n of the scores of the nodes in the sequence.\n\n\nReturn \nthe \nmaximum score\n of a valid node sequence with a length of \n4\n. \nIf no such sequence exists, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n\nOutput:\n 24\n\nExplanation:\n The figure above shows the graph and the chosen node sequence [0,1,2,3].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.\nThe sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n\nOutput:\n -1\n\nExplanation:\n The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == scores.length\n\n\n4 <= n <= 5 * 10\n4\n\n\n1 <= scores[i] <= 10\n8\n\n\n0 <= edges.length <= 5 * 10\n4\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni\n\n\nThere are no duplicate edges.",
    "temas": [
      "Array",
      "Graph",
      "Sorting",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2267,
    "slug": "check-if-there-is-a-valid-parentheses-string-path",
    "url": "https://leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/",
    "titulo": " Check if There Is a Valid Parentheses String Path",
    "enunciado": "A parentheses string is a \nnon-empty\n string consisting only of \n'('\n and \n')'\n. It is \nvalid\n if \nany\n of the following conditions is \ntrue\n:\n\n\n\n\nIt is \n()\n.\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid parentheses strings.\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid parentheses string.\n\n\n\n\nYou are given an \nm x n\n matrix of parentheses \ngrid\n. A \nvalid parentheses string path\n in the grid is a path satisfying \nall\n of the following conditions:\n\n\n\n\nThe path starts from the upper left cell \n(0, 0)\n.\n\n\nThe path ends at the bottom-right cell \n(m - 1, n - 1)\n.\n\n\nThe path only ever moves \ndown\n or \nright\n.\n\n\nThe resulting parentheses string formed by the path is \nvalid\n.\n\n\n\n\nReturn \ntrue\n \nif there exists a \nvalid parentheses string path\n in the grid.\n Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]\n\nOutput:\n true\n\nExplanation:\n The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string \"()(())\".\nThe second path shown results in the valid parentheses string \"((()))\".\nNote that there may be other valid parentheses string paths.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[\")\",\")\"],[\"(\",\"(\"]]\n\nOutput:\n false\n\nExplanation:\n The two possible paths form the parentheses strings \"))(\" and \")((\". Since neither of them are valid parentheses strings, we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 100\n\n\ngrid[i][j]\n is either \n'('\n or \n')'\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2266,
    "slug": "count-number-of-texts",
    "url": "https://leetcode.com/problems/count-number-of-texts/",
    "titulo": "Count Number of Texts",
    "enunciado": "Alice is texting Bob using her phone. The \nmapping\n of digits to letters is shown in the figure below.\n\n\n\n\nIn order to \nadd\n a letter, Alice has to \npress\n the key of the corresponding digit \ni\n times, where \ni\n is the position of the letter in the key.\n\n\n\n\nFor example, to add the letter \n's'\n, Alice has to press \n'7'\n four times. Similarly, to add the letter \n'k'\n, Alice has to press \n'5'\n twice.\n\n\nNote that the digits \n'0'\n and \n'1'\n do not map to any letters, so Alice \ndoes not\n use them.\n\n\n\n\nHowever, due to an error in transmission, Bob did not receive Alice's text message but received a \nstring of pressed keys\n instead.\n\n\n\n\nFor example, when Alice sent the message \n\"bob\"\n, Bob received the string \n\"2266622\"\n.\n\n\n\n\nGiven a string \npressedKeys\n representing the string received by Bob, return \nthe \ntotal number of possible text messages\n Alice could have sent\n.\n\n\nSince the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n pressedKeys = \"22233\"\n\nOutput:\n 8\n\nExplanation:\n\nThe possible text messages Alice could have sent are:\n\"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\", and \"ce\".\nSince there are 8 possible messages, we return 8.\n\n\n\nExample 2:\n\n\n\n\nInput:\n pressedKeys = \"222222222222222222222222222222222222\"\n\nOutput:\n 82876089\n\nExplanation:\n\nThere are 2082876103 possible text messages Alice could have sent.\nSince we need to return the answer modulo 10\n9\n + 7, we return 2082876103 % (10\n9\n + 7) = 82876089.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= pressedKeys.length <= 10\n5\n\n\npressedKeys\n only consists of digits from \n'2'\n - \n'9'\n.",
    "temas": [
      "Hash Table",
      "Math",
      "String",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2265,
    "slug": "count-nodes-equal-to-average-of-subtree",
    "url": "https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/",
    "titulo": "Count Nodes Equal to Average of Subtree",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe number of nodes where the value of the node is equal to the \naverage\n of the values in its \nsubtree\n.\n\n\nNote:\n\n\n\n\nThe \naverage\n of \nn\n elements is the \nsum\n of the \nn\n elements divided by \nn\n and \nrounded down\n to the nearest integer.\n\n\nA \nsubtree\n of \nroot\n is a tree consisting of \nroot\n and all of its descendants.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,8,5,0,1,null,6]\n\nOutput:\n 5\n\nExplanation:\n \nFor the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\nFor the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\nFor the node with value 0: The average of its subtree is 0 / 1 = 0.\nFor the node with value 1: The average of its subtree is 1 / 1 = 1.\nFor the node with value 6: The average of its subtree is 6 / 1 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 1\n\nExplanation:\n For the node with value 1: The average of its subtree is 1 / 1 = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 2258,
    "slug": "escape-the-spreading-fire",
    "url": "https://leetcode.com/problems/escape-the-spreading-fire/",
    "titulo": "Escape the Spreading Fire",
    "enunciado": "You are given a \n0-indexed\n 2D integer array \ngrid\n of size \nm x n\n which represents a field. Each cell has one of three values:\n\n\n\n\n0\n represents grass,\n\n\n1\n represents fire,\n\n\n2\n represents a wall that you and fire cannot pass through.\n\n\n\n\nYou are situated in the top-left cell, \n(0, 0)\n, and you want to travel to the safehouse at the bottom-right cell, \n(m - 1, n - 1)\n. Every minute, you may move to an \nadjacent\n grass cell. \nAfter\n your move, every fire cell will spread to all \nadjacent\n cells that are not walls.\n\n\nReturn \nthe \nmaximum\n number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse\n. If this is impossible, return \n-1\n. If you can \nalways\n reach the safehouse regardless of the minutes stayed, return \n10\n9\n.\n\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\n\nA cell is \nadjacent\n to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n\nOutput:\n 3\n\nExplanation:\n The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n\nOutput:\n -1\n\nExplanation:\n The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[2,2,0],[1,2,0]]\n\nOutput:\n 1000000000\n\nExplanation:\n The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10\n9\n is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 300\n\n\n4 <= m * n <= 2 * 10\n4\n\n\ngrid[i][j]\n is either \n0\n, \n1\n, or \n2\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "temas": [
      "Array",
      "Binary Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2257,
    "slug": "count-unguarded-cells-in-the-grid",
    "url": "https://leetcode.com/problems/count-unguarded-cells-in-the-grid/",
    "titulo": "Count Unguarded Cells in the Grid",
    "enunciado": "You are given two integers \nm\n and \nn\n representing a \n0-indexed\n \nm x n\n grid. You are also given two 2D integer arrays \nguards\n and \nwalls\n where \nguards[i] = [row\ni\n, col\ni\n]\n and \nwalls[j] = [row\nj\n, col\nj\n]\n represent the positions of the \ni\nth\n guard and \nj\nth\n wall respectively.\n\n\nA guard can see \nevery\n cell in the four cardinal directions (north, east, south, or west) starting from their position unless \nobstructed\n by a wall or another guard. A cell is \nguarded\n if there is \nat least\n one guard that can see it.\n\n\nReturn\n the number of unoccupied cells that are \nnot\n \nguarded\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n\nOutput:\n 7\n\nExplanation:\n The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n\nOutput:\n 4\n\nExplanation:\n The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 10\n5\n\n\n2 <= m * n <= 10\n5\n\n\n1 <= guards.length, walls.length <= 5 * 10\n4\n\n\n2 <= guards.length + walls.length <= m * n\n\n\nguards[i].length == walls[j].length == 2\n\n\n0 <= row\ni\n, row\nj\n < m\n\n\n0 <= col\ni\n, col\nj\n < n\n\n\nAll the positions in \nguards\n and \nwalls\n are \nunique\n.",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2251,
    "slug": "number-of-flowers-in-full-bloom",
    "url": "https://leetcode.com/problems/number-of-flowers-in-full-bloom/",
    "titulo": "Number of Flowers in Full Bloom",
    "enunciado": "You are given a \n0-indexed\n 2D integer array \nflowers\n, where \nflowers[i] = [start\ni\n, end\ni\n]\n means the \ni\nth\n flower will be in \nfull bloom\n from \nstart\ni\n to \nend\ni\n (\ninclusive\n). You are also given a \n0-indexed\n integer array \npeople\n of size \nn\n, where \npeople[i]\n is the time that the \ni\nth\n person will arrive to see the flowers.\n\n\nReturn \nan integer array \nanswer\n of size \nn\n, where \nanswer[i]\n is the \nnumber\n of flowers that are in full bloom when the \ni\nth\n person arrives.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]\n\nOutput:\n [1,2,2,2]\n\nExplanation: \nThe figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n flowers = [[1,10],[3,3]], people = [3,3,2]\n\nOutput:\n [2,2,1]\n\nExplanation:\n The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= flowers.length <= 5 * 10\n4\n\n\nflowers[i].length == 2\n\n\n1 <= start\ni\n <= end\ni\n <= 10\n9\n\n\n1 <= people.length <= 5 * 10\n4\n\n\n1 <= people[i] <= 10\n9",
    "temas": [
      "Array",
      "Hash Table",
      "Binary Search",
      "Sorting",
      "Prefix Sum",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2250,
    "slug": "count-number-of-rectangles-containing-each-point",
    "url": "https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/",
    "titulo": "Count Number of Rectangles Containing Each Point",
    "enunciado": "You are given a 2D integer array \nrectangles\n where \nrectangles[i] = [l\ni\n, h\ni\n]\n indicates that \ni\nth\n rectangle has a length of \nl\ni\n and a height of \nh\ni\n. You are also given a 2D integer array \npoints\n where \npoints[j] = [x\nj\n, y\nj\n]\n is a point with coordinates \n(x\nj\n, y\nj\n)\n.\n\n\nThe \ni\nth\n rectangle has its \nbottom-left corner\n point at the coordinates \n(0, 0)\n and its \ntop-right corner\n point at \n(l\ni\n, h\ni\n)\n.\n\n\nReturn\n an integer array \ncount\n of length \npoints.length\n where \ncount[j]\n is the number of rectangles that \ncontain\n the \nj\nth\n point.\n\n\nThe \ni\nth\n rectangle \ncontains\n the \nj\nth\n point if \n0 <= x\nj\n <= l\ni\n and \n0 <= y\nj\n <= h\ni\n. Note that points that lie on the \nedges\n of a rectangle are also considered to be contained by that rectangle.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n\nOutput:\n [2,1]\n\nExplanation:\n \nThe first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return [2, 1].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n\nOutput:\n [1,3]\n\nExplanation:\n\nThe first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return [1, 3].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rectangles.length, points.length <= 5 * 10\n4\n\n\nrectangles[i].length == points[j].length == 2\n\n\n1 <= l\ni\n, x\nj\n <= 10\n9\n\n\n1 <= h\ni\n, y\nj\n <= 100\n\n\nAll the \nrectangles\n are \nunique\n.\n\n\nAll the \npoints\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Binary Search",
      "Binary Indexed Tree",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2249,
    "slug": "count-lattice-points-inside-a-circle",
    "url": "https://leetcode.com/problems/count-lattice-points-inside-a-circle/",
    "titulo": "Count Lattice Points Inside a Circle",
    "enunciado": "Given a 2D integer array \ncircles\n where \ncircles[i] = [x\ni\n, y\ni\n, r\ni\n]\n represents the center \n(x\ni\n, y\ni\n)\n and radius \nr\ni\n of the \ni\nth\n circle drawn on a grid, return \nthe \nnumber of lattice points\n \nthat are present inside \nat least one\n circle\n.\n\n\nNote:\n\n\n\n\nA \nlattice point\n is a point with integer coordinates.\n\n\nPoints that lie \non the circumference of a circle\n are also considered to be inside it.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n circles = [[2,2,1]]\n\nOutput:\n 5\n\nExplanation:\n\nThe figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n circles = [[2,2,2],[3,4,1]]\n\nOutput:\n 16\n\nExplanation:\n\nThe figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= circles.length <= 200\n\n\ncircles[i].length == 3\n\n\n1 <= x\ni\n, y\ni\n <= 100\n\n\n1 <= r\ni\n <= min(x\ni\n, y\ni\n)",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2221,
    "slug": "find-triangular-sum-of-an-array",
    "url": "https://leetcode.com/problems/find-triangular-sum-of-an-array/",
    "titulo": "Find Triangular Sum of an Array",
    "enunciado": "You are given a \n0-indexed\n integer array \nnums\n, where \nnums[i]\n is a digit between \n0\n and \n9\n (\ninclusive\n).\n\n\nThe \ntriangular sum\n of \nnums\n is the value of the only element present in \nnums\n after the following process terminates:\n\n\n\n\nLet \nnums\n comprise of \nn\n elements. If \nn == 1\n, \nend\n the process. Otherwise, \ncreate\n a new \n0-indexed\n integer array \nnewNums\n of length \nn - 1\n.\n\n\nFor each index \ni\n, where \n0 <= i < n - 1\n, \nassign\n the value of \nnewNums[i]\n as \n(nums[i] + nums[i+1]) % 10\n, where \n%\n denotes modulo operator.\n\n\nReplace\n the array \nnums\n with \nnewNums\n.\n\n\nRepeat\n the entire process starting from step 1.\n\n\n\n\nReturn \nthe triangular sum of\n \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n 8\n\nExplanation:\n\nThe above diagram depicts the process from which we obtain the triangular sum of the array.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5]\n\nOutput:\n 5\n\nExplanation:\n\nSince there is only one element in nums, the triangular sum is the value of that element itself.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n0 <= nums[i] <= 9",
    "temas": [
      "Array",
      "Math",
      "Simulation",
      "Combinatorics"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2203,
    "slug": "minimum-weighted-subgraph-with-the-required-paths",
    "url": "https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/",
    "titulo": "Minimum Weighted Subgraph With the Required Paths",
    "enunciado": "You are given an integer \nn\n denoting the number of nodes of a \nweighted directed\n graph. The nodes are numbered from \n0\n to \nn - 1\n.\n\n\nYou are also given a 2D integer array \nedges\n where \nedges[i] = [from\ni\n, to\ni\n, weight\ni\n]\n denotes that there exists a \ndirected\n edge from \nfrom\ni\n to \nto\ni\n with weight \nweight\ni\n.\n\n\nLastly, you are given three \ndistinct\n integers \nsrc1\n, \nsrc2\n, and \ndest\n denoting three distinct nodes of the graph.\n\n\nReturn \nthe \nminimum weight\n of a subgraph of the graph such that it is \npossible\n to reach\n \ndest\n \nfrom both\n \nsrc1\n \nand\n \nsrc2\n \nvia a set of edges of this subgraph\n. In case such a subgraph does not exist, return \n-1\n.\n\n\nA \nsubgraph\n is a graph whose vertices and edges are subsets of the original graph. The \nweight\n of a subgraph is the sum of weights of its constituent edges.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n\nOutput:\n 9\n\nExplanation:\n\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n\nOutput:\n -1\n\nExplanation:\n\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\n0 <= edges.length <= 10\n5\n\n\nedges[i].length == 3\n\n\n0 <= from\ni\n, to\ni\n, src1, src2, dest <= n - 1\n\n\nfrom\ni\n != to\ni\n\n\nsrc1\n, \nsrc2\n, and \ndest\n are pairwise distinct.\n\n\n1 <= weight[i] <= 10\n5",
    "temas": [
      "Graph",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 2212,
    "slug": "maximum-points-in-an-archery-competition",
    "url": "https://leetcode.com/problems/maximum-points-in-an-archery-competition/",
    "titulo": "Maximum Points in an Archery Competition",
    "enunciado": "Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n\n\n\n\nAlice first shoots \nnumArrows\n arrows and then Bob shoots \nnumArrows\n arrows.\n\n\nThe points are then calculated as follows:\n\t\n\n\nThe target has integer scoring sections ranging from \n0\n to \n11\n \ninclusive\n.\n\n\nFor \neach\n section of the target with score \nk\n (in between \n0\n to \n11\n), say Alice and Bob have shot \na\nk\n and \nb\nk\n arrows on that section respectively. If \na\nk\n >= b\nk\n, then Alice takes \nk\n points. If \na\nk\n < b\nk\n, then Bob takes \nk\n points.\n\n\nHowever, if \na\nk\n == b\nk\n == 0\n, then \nnobody\n takes \nk\n points.\n\n\n\n\n\n\n\n\n\n\n\n\nFor example, if Alice and Bob both shot \n2\n arrows on the section with score \n11\n, then Alice takes \n11\n points. On the other hand, if Alice shot \n0\n arrows on the section with score \n11\n and Bob shot \n2\n arrows on that same section, then Bob takes \n11\n points.\n\n\n\n\n\n\nYou are given the integer \nnumArrows\n and an integer array \naliceArrows\n of size \n12\n, which represents the number of arrows Alice shot on each scoring section from \n0\n to \n11\n. Now, Bob wants to \nmaximize\n the total number of points he can obtain.\n\n\nReturn \nthe array \nbobArrows\n which represents the number of arrows Bob shot on \neach\n scoring section from \n0\n to \n11\n. The sum of the values in \nbobArrows\n should equal \nnumArrows\n.\n\n\nIf there are multiple ways for Bob to earn the maximum total points, return \nany\n one of them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n\nOutput:\n [0,0,0,0,1,1,0,0,1,2,3,1]\n\nExplanation:\n The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n\nOutput:\n [0,0,0,0,0,0,0,0,1,1,1,0]\n\nExplanation:\n The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numArrows <= 10\n5\n\n\naliceArrows.length == bobArrows.length == 12\n\n\n0 <= aliceArrows[i], bobArrows[i] <= numArrows\n\n\nsum(aliceArrows[i]) == numArrows",
    "temas": [
      "Array",
      "Backtracking",
      "Bit Manipulation",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2209,
    "slug": "minimum-white-tiles-after-covering-with-carpets",
    "url": "https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/",
    "titulo": "Minimum White Tiles After Covering With Carpets",
    "enunciado": "You are given a \n0-indexed binary\n string \nfloor\n, which represents the colors of tiles on a floor:\n\n\n\n\nfloor[i] = '0'\n denotes that the \ni\nth\n tile of the floor is colored \nblack\n.\n\n\nOn the other hand, \nfloor[i] = '1'\n denotes that the \ni\nth\n tile of the floor is colored \nwhite\n.\n\n\n\n\nYou are also given \nnumCarpets\n and \ncarpetLen\n. You have \nnumCarpets\n \nblack\n carpets, each of length \ncarpetLen\n tiles. Cover the tiles with the given carpets such that the number of \nwhite\n tiles still visible is \nminimum\n. Carpets may overlap one another.\n\n\nReturn \nthe \nminimum\n number of white tiles still visible.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n floor = \"10110101\", numCarpets = 2, carpetLen = 2\n\nOutput:\n 2\n\nExplanation:\n \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n floor = \"11111\", numCarpets = 2, carpetLen = 3\n\nOutput:\n 0\n\nExplanation:\n \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= carpetLen <= floor.length <= 1000\n\n\nfloor[i]\n is either \n'0'\n or \n'1'\n.\n\n\n1 <= numCarpets <= 1000",
    "temas": [
      "String",
      "Dynamic Programming",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2196,
    "slug": "create-binary-tree-from-descriptions",
    "url": "https://leetcode.com/problems/create-binary-tree-from-descriptions/",
    "titulo": "Create Binary Tree From Descriptions",
    "enunciado": "You are given a 2D integer array \ndescriptions\n where \ndescriptions[i] = [parent\ni\n, child\ni\n, isLeft\ni\n]\n indicates that \nparent\ni\n is the \nparent\n of \nchild\ni\n in a \nbinary\n tree of \nunique\n values. Furthermore,\n\n\n\n\nIf \nisLeft\ni\n == 1\n, then \nchild\ni\n is the left child of \nparent\ni\n.\n\n\nIf \nisLeft\ni\n == 0\n, then \nchild\ni\n is the right child of \nparent\ni\n.\n\n\n\n\nConstruct the binary tree described by \ndescriptions\n and return \nits \nroot\n.\n\n\nThe test cases will be generated such that the binary tree is \nvalid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n\nOutput:\n [50,20,80,15,17,19]\n\nExplanation:\n The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n\nOutput:\n [1,2,null,null,3,4]\n\nExplanation:\n The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= descriptions.length <= 10\n4\n\n\ndescriptions[i].length == 3\n\n\n1 <= parent\ni\n, child\ni\n <= 10\n5\n\n\n0 <= isLeft\ni\n <= 1\n\n\nThe binary tree described by \ndescriptions\n is valid.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2194,
    "slug": "cells-in-a-range-on-an-excel-sheet",
    "url": "https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/",
    "titulo": "Cells in a Range on an Excel Sheet",
    "enunciado": "A cell \n(r, c)\n of an excel sheet is represented as a string \n\"<col><row>\"\n where:\n\n\n\n\n<col>\n denotes the column number \nc\n of the cell. It is represented by \nalphabetical letters\n.\n\n\t\n\n\nFor example, the \n1\nst\n column is denoted by \n'A'\n, the \n2\nnd\n by \n'B'\n, the \n3\nrd\n by \n'C'\n, and so on.\n\n\n\n\n\n\n<row>\n is the row number \nr\n of the cell. The \nr\nth\n row is represented by the \ninteger\n \nr\n.\n\n\n\n\nYou are given a string \ns\n in the format \n\"<col1><row1>:<col2><row2>\"\n, where \n<col1>\n represents the column \nc1\n, \n<row1>\n represents the row \nr1\n, \n<col2>\n represents the column \nc2\n, and \n<row2>\n represents the row \nr2\n, such that \nr1 <= r2\n and \nc1 <= c2\n.\n\n\nReturn \nthe \nlist of cells\n \n(x, y)\n \nsuch that\n \nr1 <= x <= r2\n \nand\n \nc1 <= y <= c2\n. The cells should be represented as \nstrings\n in the format mentioned above and be sorted in \nnon-decreasing\n order first by columns and then by rows.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"K1:L2\"\n\nOutput:\n [\"K1\",\"K2\",\"L1\",\"L2\"]\n\nExplanation:\n\nThe above diagram shows the cells which should be present in the list.\nThe red arrows denote the order in which the cells should be presented.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n s = \"A1:F1\"\n\nOutput:\n [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n\nExplanation:\n\nThe above diagram shows the cells which should be present in the list.\nThe red arrow denotes the order in which the cells should be presented.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ns.length == 5\n\n\n'A' <= s[0] <= s[3] <= 'Z'\n\n\n'1' <= s[1] <= s[4] <= '9'\n\n\ns\n consists of uppercase English letters, digits and \n':'\n.",
    "temas": [
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2181,
    "slug": "merge-nodes-in-between-zeros",
    "url": "https://leetcode.com/problems/merge-nodes-in-between-zeros/",
    "titulo": "Merge Nodes in Between Zeros",
    "enunciado": "You are given the \nhead\n of a linked list, which contains a series of integers \nseparated\n by \n0\n's. The \nbeginning\n and \nend\n of the linked list will have \nNode.val == 0\n.\n\n\nFor \nevery \ntwo consecutive \n0\n's, \nmerge\n all the nodes lying in between them into a single node whose value is the \nsum\n of all the merged nodes. The modified list should not contain any \n0\n's.\n\n\nReturn \nthe\n \nhead\n \nof the modified linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [0,3,1,0,4,5,2,0]\n\nOutput:\n [4,11]\n\nExplanation:\n \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 3 + 1 = 4.\n- The sum of the nodes marked in red: 4 + 5 + 2 = 11.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [0,1,0,3,0,2,2,0]\n\nOutput:\n [1,3,4]\n\nExplanation:\n \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 1 = 1.\n- The sum of the nodes marked in red: 3 = 3.\n- The sum of the nodes marked in yellow: 2 + 2 = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[3, 2 * 10\n5\n]\n.\n\n\n0 <= Node.val <= 1000\n\n\nThere are \nno\n two consecutive nodes with \nNode.val == 0\n.\n\n\nThe \nbeginning\n and \nend\n of the linked list have \nNode.val == 0\n.",
    "temas": [
      "Linked List",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2151,
    "slug": "maximum-good-people-based-on-statements",
    "url": "https://leetcode.com/problems/maximum-good-people-based-on-statements/",
    "titulo": "Maximum Good People Based on Statements",
    "enunciado": "There are two types of persons:\n\n\n\n\nThe \ngood person\n: The person who always tells the truth.\n\n\nThe \nbad person\n: The person who might tell the truth and might lie.\n\n\n\n\nYou are given a \n0-indexed\n 2D integer array \nstatements\n of size \nn x n\n that represents the statements made by \nn\n people about each other. More specifically, \nstatements[i][j]\n could be one of the following:\n\n\n\n\n0\n which represents a statement made by person \ni\n that person \nj\n is a \nbad\n person.\n\n\n1\n which represents a statement made by person \ni\n that person \nj\n is a \ngood\n person.\n\n\n2\n represents that \nno statement\n is made by person \ni\n about person \nj\n.\n\n\n\n\nAdditionally, no person ever makes a statement about themselves. Formally, we have that \nstatements[i][i] = 2\n for all \n0 <= i < n\n.\n\n\nReturn \nthe \nmaximum\n number of people who can be \ngood\n based on the statements made by the \nn\n people\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n statements = [[2,1,2],[1,2,2],[2,0,2]]\n\nOutput:\n 2\n\nExplanation:\n Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet's take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - \nFollowing that person 2 is a good person, there will be only one good person in the group\n.\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - \nFollowing that person 2 is bad but told the truth, there will be no good persons in the group\n.\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - \nFollowing that person 2 is bad and lied, there will be two good persons in the group\n.\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n statements = [[2,0],[0,2]]\n\nOutput:\n 1\n\nExplanation:\n Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet's take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - \nFollowing that person 0 is a good person, there will be only one good person in the group\n.\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - \nFollowing that person 0 is bad but told the truth, there will be no good persons in the group\n.\n        - lying. In this case person 1 is a good person.\n            - \nFollowing that person 0 is bad and lied, there will be only one good person in the group\n.\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == statements.length == statements[i].length\n\n\n2 <= n <= 15\n\n\nstatements[i][j]\n is either \n0\n, \n1\n, or \n2\n.\n\n\nstatements[i][i] == 2",
    "temas": [
      "Array",
      "Backtracking",
      "Bit Manipulation",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2162,
    "slug": "minimum-cost-to-set-cooking-time",
    "url": "https://leetcode.com/problems/minimum-cost-to-set-cooking-time/",
    "titulo": "Minimum Cost to Set Cooking Time",
    "enunciado": "A generic microwave supports cooking times for:\n\n\n\n\nat least \n1\n second.\n\n\nat most \n99\n minutes and \n99\n seconds.\n\n\n\n\nTo set the cooking time, you push \nat most four digits\n. The microwave normalizes what you push as four digits by \nprepending zeroes\n. It interprets the \nfirst\n two digits as the minutes and the \nlast\n two digits as the seconds. It then \nadds\n them up as the cooking time. For example,\n\n\n\n\nYou push \n9\n \n5\n \n4\n (three digits). It is normalized as \n0954\n and interpreted as \n9\n minutes and \n54\n seconds.\n\n\nYou push \n0\n \n0\n \n0\n \n8\n (four digits). It is interpreted as \n0\n minutes and \n8\n seconds.\n\n\nYou push \n8\n \n0\n \n9\n \n0\n. It is interpreted as \n80\n minutes and \n90\n seconds.\n\n\nYou push \n8\n \n1\n \n3\n \n0\n. It is interpreted as \n81\n minutes and \n30\n seconds.\n\n\n\n\nYou are given integers \nstartAt\n, \nmoveCost\n, \npushCost\n, and \ntargetSeconds\n. \nInitially\n, your finger is on the digit \nstartAt\n. Moving the finger above \nany specific digit\n costs \nmoveCost\n units of fatigue. Pushing the digit below the finger \nonce\n costs \npushCost\n units of fatigue.\n\n\nThere can be multiple ways to set the microwave to cook for \ntargetSeconds\n seconds but you are interested in the way with the minimum cost.\n\n\nReturn \nthe \nminimum cost\n to set\n \ntargetSeconds\n \nseconds of cooking time\n.\n\n\nRemember that one minute consists of \n60\n seconds.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n\nOutput:\n 6\n\nExplanation:\n The following are the possible ways to set the cooking time.\n- 1 0 0 0, interpreted as 10 minutes and 0 seconds.\n  The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).\n  The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n  The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n  The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n  The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n  The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n\nOutput:\n 6\n\nExplanation:\n The optimal way is to push two digits: 7 6, interpreted as 76 seconds.\nThe finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\nNote other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= startAt <= 9\n\n\n1 <= moveCost, pushCost <= 10\n5\n\n\n1 <= targetSeconds <= 6039",
    "temas": [
      "Math",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2141,
    "slug": "maximum-running-time-of-n-computers",
    "url": "https://leetcode.com/problems/maximum-running-time-of-n-computers/",
    "titulo": "Maximum Running Time of N Computers",
    "enunciado": "You have \nn\n computers. You are given the integer \nn\n and a \n0-indexed\n integer array \nbatteries\n where the \ni\nth\n battery can \nrun\n a computer for \nbatteries[i]\n minutes. You are interested in running \nall\n \nn\n computers \nsimultaneously\n using the given batteries.\n\n\nInitially, you can insert \nat most one battery\n into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery \nany number of times\n. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\n\nNote that the batteries cannot be recharged.\n\n\nReturn \nthe \nmaximum\n number of minutes you can run all the \nn\n computers simultaneously.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 2, batteries = [3,3,3]\n\nOutput:\n 4\n\nExplanation:\n \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, batteries = [1,1,1,1]\n\nOutput:\n 2\n\nExplanation:\n \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= batteries.length <= 10\n5\n\n\n1 <= batteries[i] <= 10\n9",
    "temas": [
      "Array",
      "Binary Search",
      "Greedy",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2136,
    "slug": "earliest-possible-day-of-full-bloom",
    "url": "https://leetcode.com/problems/earliest-possible-day-of-full-bloom/",
    "titulo": "Earliest Possible Day of Full Bloom",
    "enunciado": "You have \nn\n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two \n0-indexed\n integer arrays \nplantTime\n and \ngrowTime\n, of length \nn\n each:\n\n\n\n\nplantTime[i]\n is the number of \nfull days\n it takes you to \nplant\n the \ni\nth\n seed. Every day, you can work on planting exactly one seed. You \ndo not\n have to work on planting the same seed on consecutive days, but the planting of a seed is not complete \nuntil\n you have worked \nplantTime[i]\n days on planting it in total.\n\n\ngrowTime[i]\n is the number of \nfull days\n it takes the \ni\nth\n seed to grow after being completely planted. \nAfter\n the last day of its growth, the flower \nblooms\n and stays bloomed forever.\n\n\n\n\nFrom the beginning of day \n0\n, you can plant the seeds in \nany\n order.\n\n\nReturn \nthe \nearliest\n possible day where \nall\n seeds are blooming\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n plantTime = [1,4,3], growTime = [2,3,1]\n\nOutput:\n 9\n\nExplanation:\n The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0\nth\n seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1\nst\n seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2\nnd\n seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n plantTime = [1,2,3,2], growTime = [2,1,2,1]\n\nOutput:\n 9\n\nExplanation:\n The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0\nth\n seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1\nst\n seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2\nnd\n seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3\nrd\n seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n\n\nExample 3:\n\n\n\n\nInput:\n plantTime = [1], growTime = [1]\n\nOutput:\n 2\n\nExplanation:\n On day 0, plant the 0\nth\n seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == plantTime.length == growTime.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= plantTime[i], growTime[i] <= 10\n4",
    "temas": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2133,
    "slug": "check-if-every-row-and-column-contains-all-numbers",
    "url": "https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/",
    "titulo": "Check if Every Row and Column Contains All Numbers",
    "enunciado": "An \nn x n\n matrix is \nvalid\n if every row and every column contains \nall\n the integers from \n1\n to \nn\n (\ninclusive\n).\n\n\nGiven an \nn x n\n integer matrix \nmatrix\n, return \ntrue\n \nif the matrix is \nvalid\n.\n Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[3,1,2],[2,3,1]]\n\nOutput:\n true\n\nExplanation:\n In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,1,1],[1,2,3],[1,2,3]]\n\nOutput:\n false\n\nExplanation:\n In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 100\n\n\n1 <= matrix[i][j] <= n",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2147,
    "slug": "number-of-ways-to-divide-a-long-corridor",
    "url": "https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/",
    "titulo": "Number of Ways to Divide a Long Corridor",
    "enunciado": "Along a long library corridor, there is a line of seats and decorative plants. You are given a \n0-indexed\n string \ncorridor\n of length \nn\n consisting of letters \n'S'\n and \n'P'\n where each \n'S'\n represents a seat and each \n'P'\n represents a plant.\n\n\nOne room divider has \nalready\n been installed to the left of index \n0\n, and \nanother\n to the right of index \nn - 1\n. Additional room dividers can be installed. For each position between indices \ni - 1\n and \ni\n (\n1 <= i <= n - 1\n), at most one divider can be installed.\n\n\nDivide the corridor into non-overlapping sections, where each section has \nexactly two seats\n with any number of plants. There may be multiple ways to perform the division. Two ways are \ndifferent\n if there is a position with a room divider installed in the first way but not in the second way.\n\n\nReturn \nthe number of ways to divide the corridor\n. Since the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n. If there is no way, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n corridor = \"SSPPSPS\"\n\nOutput:\n 3\n\nExplanation:\n There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, \neach\n section has exactly \ntwo\n seats.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n corridor = \"PPSPSP\"\n\nOutput:\n 1\n\nExplanation:\n There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n corridor = \"S\"\n\nOutput:\n 0\n\nExplanation:\n There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == corridor.length\n\n\n1 <= n <= 10\n5\n\n\ncorridor[i]\n is either \n'S'\n or \n'P'\n.",
    "temas": [
      "Math",
      "String",
      "Dynamic Programming"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2146,
    "slug": "k-highest-ranked-items-within-a-price-range",
    "url": "https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/",
    "titulo": "K Highest Ranked Items Within a Price Range",
    "enunciado": "You are given a \n0-indexed\n 2D integer array \ngrid\n of size \nm x n\n that represents a map of the items in a shop. The integers in the grid represent the following:\n\n\n\n\n0\n represents a wall that you cannot pass through.\n\n\n1\n represents an empty cell that you can freely move to and from.\n\n\nAll other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\n\n\n\nIt takes \n1\n step to travel between adjacent grid cells.\n\n\nYou are also given integer arrays \npricing\n and \nstart\n where \npricing = [low, high]\n and \nstart = [row, col]\n indicates that you start at the position \n(row, col)\n and are interested only in items with a price in the range of \n[low, high]\n (\ninclusive\n). You are further given an integer \nk\n.\n\n\nYou are interested in the \npositions\n of the \nk\n \nhighest-ranked\n items whose prices are \nwithin\n the given price range. The rank is determined by the \nfirst\n of these criteria that is different:\n\n\n\n\nDistance, defined as the length of the shortest path from the \nstart\n (\nshorter\n distance has a higher rank).\n\n\nPrice (\nlower\n price has a higher rank, but it must be \nin the price range\n).\n\n\nThe row number (\nsmaller\n row number has a higher rank).\n\n\nThe column number (\nsmaller\n column number has a higher rank).\n\n\n\n\nReturn \nthe \nk\n highest-ranked items within the price range \nsorted\n by their rank (highest to lowest)\n. If there are fewer than \nk\n reachable items within the price range, return \nall\n of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\n\nOutput:\n [[0,1],[1,1],[2,1]]\n\nExplanation:\n You start at (0,0).\nWith a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).\nThe ranks of these items are:\n- (0,1) with distance 1\n- (1,1) with distance 2\n- (2,1) with distance 3\n- (2,2) with distance 4\nThus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\n\nOutput:\n [[2,1],[1,2]]\n\nExplanation:\n You start at (2,3).\nWith a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).\nThe ranks of these items are:\n- (2,1) with distance 2, price 2\n- (1,2) with distance 2, price 3\n- (1,1) with distance 3\n- (0,1) with distance 4\nThus, the 2 highest ranked items in the price range are (2,1) and (1,2).\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\n\nOutput:\n [[2,1],[2,0]]\n\nExplanation:\n You start at (0,0).\nWith a price range of [2,3], we can take items from (2,0) and (2,1). \nThe ranks of these items are: \n- (2,1) with distance 5\n- (2,0) with distance 6\nThus, the 2 highest ranked items in the price range are (2,1) and (2,0). \nNote that k = 3 but there are only 2 reachable items within the price range.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n0 <= grid[i][j] <= 10\n5\n\n\npricing.length == 2\n\n\n2 <= low <= high <= 10\n5\n\n\nstart.length == 2\n\n\n0 <= row <= m - 1\n\n\n0 <= col <= n - 1\n\n\ngrid[row][col] > 0\n\n\n1 <= k <= m * n",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Sorting",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2127,
    "slug": "maximum-employees-to-be-invited-to-a-meeting",
    "url": "https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/",
    "titulo": "Maximum Employees to Be Invited to a Meeting",
    "enunciado": "A company is organizing a meeting and has a list of \nn\n employees, waiting to be invited. They have arranged for a large \ncircular\n table, capable of seating \nany number\n of employees.\n\n\nThe employees are numbered from \n0\n to \nn - 1\n. Each employee has a \nfavorite\n person and they will attend the meeting \nonly if\n they can sit next to their favorite person at the table. The favorite person of an employee is \nnot\n themself.\n\n\nGiven a \n0-indexed\n integer array \nfavorite\n, where \nfavorite[i]\n denotes the favorite person of the \ni\nth\n employee, return \nthe \nmaximum number of employees\n that can be invited to the meeting\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n favorite = [2,2,1,2]\n\nOutput:\n 3\n\nExplanation:\n\nThe above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3. \n\n\n\nExample 2:\n\n\n\n\nInput:\n favorite = [1,2,0]\n\nOutput:\n 3\n\nExplanation:\n \nEach employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n favorite = [3,0,1,4,1]\n\nOutput:\n 4\n\nExplanation:\n\nThe above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == favorite.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= favorite[i] <= n - 1\n\n\nfavorite[i] != i",
    "temas": [
      "Depth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 2125,
    "slug": "number-of-laser-beams-in-a-bank",
    "url": "https://leetcode.com/problems/number-of-laser-beams-in-a-bank/",
    "titulo": "Number of Laser Beams in a Bank",
    "enunciado": "Anti-theft security devices are activated inside a bank. You are given a \n0-indexed\n binary string array \nbank\n representing the floor plan of the bank, which is an \nm x n\n 2D matrix. \nbank[i]\n represents the \ni\nth\n row, consisting of \n'0'\ns and \n'1'\ns. \n'0'\n means the cell is empty, while\n'1'\n means the cell has a security device.\n\n\nThere is \none\n laser beam between any \ntwo\n security devices \nif both\n conditions are met:\n\n\n\n\nThe two devices are located on two \ndifferent rows\n: \nr\n1\n and \nr\n2\n, where \nr\n1\n < r\n2\n.\n\n\nFor \neach\n row \ni\n where \nr\n1\n < i < r\n2\n, there are \nno security devices\n in the \ni\nth\n row.\n\n\n\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\n\n\nReturn \nthe total number of laser beams in the bank\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\n\nOutput:\n 8\n\nExplanation:\n Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0\nth\n row with any on the 3\nrd\n row.\nThis is because the 2\nnd\n row contains security devices, which breaks the second condition.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n bank = [\"000\",\"111\",\"000\"]\n\nOutput:\n 0\n\nExplanation:\n There does not exist two devices located on two different rows.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == bank.length\n\n\nn == bank[i].length\n\n\n1 <= m, n <= 500\n\n\nbank[i][j]\n is either \n'0'\n or \n'1'\n.",
    "temas": [
      "Array",
      "Math",
      "String",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2120,
    "slug": "execution-of-all-suffix-instructions-staying-in-a-grid",
    "url": "https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/",
    "titulo": "Execution of All Suffix Instructions Staying in a Grid",
    "enunciado": "There is an \nn x n\n grid, with the top-left cell at \n(0, 0)\n and the bottom-right cell at \n(n - 1, n - 1)\n. You are given the integer \nn\n and an integer array \nstartPos\n where \nstartPos = [start\nrow\n, start\ncol\n]\n indicates that a robot is initially at cell \n(start\nrow\n, start\ncol\n)\n.\n\n\nYou are also given a \n0-indexed\n string \ns\n of length \nm\n where \ns[i]\n is the \ni\nth\n instruction for the robot: \n'L'\n (move left), \n'R'\n (move right), \n'U'\n (move up), and \n'D'\n (move down).\n\n\nThe robot can begin executing from any \ni\nth\n instruction in \ns\n. It executes the instructions one by one towards the end of \ns\n but it stops if either of these conditions is met:\n\n\n\n\nThe next instruction will move the robot off the grid.\n\n\nThere are no more instructions left to execute.\n\n\n\n\nReturn \nan array\n \nanswer\n \nof length\n \nm\n \nwhere\n \nanswer[i]\n \nis \nthe number of instructions\n the robot can execute if the robot \nbegins executing from\n the\n \ni\nth\n \ninstruction in\n \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, startPos = [0,1], s = \"RRDDLU\"\n\nOutput:\n [1,5,4,3,1,0]\n\nExplanation:\n Starting from startPos and beginning execution from the i\nth\n instruction:\n- 0\nth\n: \"\nR\nRDDLU\". Only one instruction \"R\" can be executed before it moves off the grid.\n- 1\nst\n:  \"\nRDDLU\n\". All five instructions can be executed while it stays in the grid and ends at (1, 1).\n- 2\nnd\n:   \"\nDDLU\n\". All four instructions can be executed while it stays in the grid and ends at (1, 0).\n- 3\nrd\n:    \"\nDLU\n\". All three instructions can be executed while it stays in the grid and ends at (0, 0).\n- 4\nth\n:     \"\nL\nU\". Only one instruction \"L\" can be executed before it moves off the grid.\n- 5\nth\n:      \"U\". If moving up, it would move off the grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, startPos = [1,1], s = \"LURD\"\n\nOutput:\n [4,1,0,0]\n\nExplanation:\n\n- 0\nth\n: \"\nLURD\n\".\n- 1\nst\n:  \"\nU\nRD\".\n- 2\nnd\n:   \"RD\".\n- 3\nrd\n:    \"D\".\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 1, startPos = [0,0], s = \"LRUD\"\n\nOutput:\n [0,0,0,0]\n\nExplanation:\n No matter which instruction the robot begins execution from, it would move off the grid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\n1 <= n, m <= 500\n\n\nstartPos.length == 2\n\n\n0 <= start\nrow\n, start\ncol\n < n\n\n\ns\n consists of \n'L'\n, \n'R'\n, \n'U'\n, and \n'D'\n.",
    "temas": [
      "String",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2130,
    "slug": "maximum-twin-sum-of-a-linked-list",
    "url": "https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/",
    "titulo": "Maximum Twin Sum of a Linked List",
    "enunciado": "In a linked list of size \nn\n, where \nn\n is \neven\n, the \ni\nth\n node (\n0-indexed\n) of the linked list is known as the \ntwin\n of the \n(n-1-i)\nth\n node, if \n0 <= i <= (n / 2) - 1\n.\n\n\n\n\nFor example, if \nn = 4\n, then node \n0\n is the twin of node \n3\n, and node \n1\n is the twin of node \n2\n. These are the only nodes with twins for \nn = 4\n.\n\n\n\n\nThe \ntwin sum \nis defined as the sum of a node and its twin.\n\n\nGiven the \nhead\n of a linked list with even length, return \nthe \nmaximum twin sum\n of the linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [5,4,2,1]\n\nOutput:\n 6\n\nExplanation:\n\nNodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\nThere are no other nodes with twins in the linked list.\nThus, the maximum twin sum of the linked list is 6. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [4,2,2,3]\n\nOutput:\n 7\n\nExplanation:\n\nThe nodes with twins present in this linked list are:\n- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\nThus, the maximum twin sum of the linked list is max(7, 4) = 7. \n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1,100000]\n\nOutput:\n 100001\n\nExplanation:\n\nThere is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is an \neven\n integer in the range \n[2, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5",
    "temas": [
      "Linked List",
      "Two Pointers",
      "Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2106,
    "slug": "maximum-fruits-harvested-after-at-most-k-steps",
    "url": "https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/",
    "titulo": "Maximum Fruits Harvested After at Most K Steps",
    "enunciado": "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array \nfruits\n where \nfruits[i] = [position\ni\n, amount\ni\n]\n depicts \namount\ni\n fruits at the position \nposition\ni\n. \nfruits\n is already \nsorted\n by \nposition\ni\n in \nascending order\n, and each \nposition\ni\n is \nunique\n.\n\n\nYou are also given an integer \nstartPos\n and an integer \nk\n. Initially, you are at the position \nstartPos\n. From any position, you can either walk to the \nleft or right\n. It takes \none step\n to move \none unit\n on the x-axis, and you can walk \nat most\n \nk\n steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\n\nReturn \nthe \nmaximum total number\n of fruits you can harvest\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n\nOutput:\n 9\n\nExplanation:\n \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n\nOutput:\n 14\n\nExplanation:\n \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n\nOutput:\n 0\n\nExplanation:\n\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= fruits.length <= 10\n5\n\n\nfruits[i].length == 2\n\n\n0 <= startPos, position\ni\n <= 2 * 10\n5\n\n\nposition\ni-1\n < position\ni\n for any \ni > 0\n (\n0-indexed\n)\n\n\n1 <= amount\ni\n <= 10\n4\n\n\n0 <= k <= 2 * 10\n5",
    "temas": [
      "Array",
      "Binary Search",
      "Sliding Window",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2103,
    "slug": "rings-and-rods",
    "url": "https://leetcode.com/problems/rings-and-rods/",
    "titulo": "Rings and Rods",
    "enunciado": "There are \nn\n rings and each ring is either red, green, or blue. The rings are distributed \nacross ten rods\n labeled from \n0\n to \n9\n.\n\n\nYou are given a string \nrings\n of length \n2n\n that describes the \nn\n rings that are placed onto the rods. Every two characters in \nrings\n forms a \ncolor-position pair\n that is used to describe each ring where:\n\n\n\n\nThe \nfirst\n character of the \ni\nth\n pair denotes the \ni\nth\n ring's \ncolor\n (\n'R'\n, \n'G'\n, \n'B'\n).\n\n\nThe \nsecond\n character of the \ni\nth\n pair denotes the \nrod\n that the \ni\nth\n ring is placed on (\n'0'\n to \n'9'\n).\n\n\n\n\nFor example, \n\"R3G2B1\"\n describes \nn == 3\n rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\n\nReturn \nthe number of rods that have \nall three colors\n of rings on them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n rings = \"B0B6G0R6R0R6G9\"\n\nOutput:\n 1\n\nExplanation:\n \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n rings = \"B0R0G0R9R0B0G0\"\n\nOutput:\n 1\n\nExplanation:\n \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n rings = \"G4\"\n\nOutput:\n 0\n\nExplanation:\n \nOnly one ring is given. Thus, no rods have all three colors.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrings.length == 2 * n\n\n\n1 <= n <= 100\n\n\nrings[i]\n where \ni\n is \neven\n is either \n'R'\n, \n'G'\n, or \n'B'\n (\n0-indexed\n).\n\n\nrings[i]\n where \ni\n is \nodd\n is a digit from \n'0'\n to \n'9'\n (\n0-indexed\n).",
    "temas": [
      "Hash Table",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 2116,
    "slug": "check-if-a-parentheses-string-can-be-valid",
    "url": "https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/",
    "titulo": "Check if a Parentheses String Can Be Valid",
    "enunciado": "A parentheses string is a \nnon-empty\n string consisting only of \n'('\n and \n')'\n. It is valid if \nany\n of the following conditions is \ntrue\n:\n\n\n\n\nIt is \n()\n.\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid parentheses strings.\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid parentheses string.\n\n\n\n\nYou are given a parentheses string \ns\n and a string \nlocked\n, both of length \nn\n. \nlocked\n is a binary string consisting only of \n'0'\ns and \n'1'\ns. For \neach\n index \ni\n of \nlocked\n,\n\n\n\n\nIf \nlocked[i]\n is \n'1'\n, you \ncannot\n change \ns[i]\n.\n\n\nBut if \nlocked[i]\n is \n'0'\n, you \ncan\n change \ns[i]\n to either \n'('\n or \n')'\n.\n\n\n\n\nReturn \ntrue\n \nif you can make \ns\n a valid parentheses string\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"))()))\", locked = \"010100\"\n\nOutput:\n true\n\nExplanation:\n locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].\nWe change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"()()\", locked = \"0000\"\n\nOutput:\n true\n\nExplanation:\n We do not need to make any changes because s is already valid.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \")\", locked = \"0\"\n\nOutput:\n false\n\nExplanation:\n locked permits us to change s[0]. \nChanging s[0] to either '(' or ')' will not make s valid.\n\n\n\nExample 4:\n\n\n\n\nInput:\n s = \"(((())(((())\", locked = \"111111010111\"\n\nOutput:\n true\n\nExplanation:\n locked permits us to change s[6] and s[8]. \nWe change s[6] and s[8] to ')' to make s valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == s.length == locked.length\n\n\n1 <= n <= 10\n5\n\n\ns[i]\n is either \n'('\n or \n')'\n.\n\n\nlocked[i]\n is either \n'0'\n or \n'1'\n.",
    "temas": [
      "String",
      "Stack",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2096,
    "slug": "step-by-step-directions-from-a-binary-tree-node-to-another",
    "url": "https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/",
    "titulo": "Step-By-Step Directions From a Binary Tree Node to Another",
    "enunciado": "You are given the \nroot\n of a \nbinary tree\n with \nn\n nodes. Each node is uniquely assigned a value from \n1\n to \nn\n. You are also given an integer \nstartValue\n representing the value of the start node \ns\n, and a different integer \ndestValue\n representing the value of the destination node \nt\n.\n\n\nFind the \nshortest path\n starting from node \ns\n and ending at node \nt\n. Generate step-by-step directions of such path as a string consisting of only the \nuppercase\n letters \n'L'\n, \n'R'\n, and \n'U'\n. Each letter indicates a specific direction:\n\n\n\n\n'L'\n means to go from a node to its \nleft child\n node.\n\n\n'R'\n means to go from a node to its \nright child\n node.\n\n\n'U'\n means to go from a node to its \nparent\n node.\n\n\n\n\nReturn \nthe step-by-step directions of the \nshortest path\n from node \ns\n to node\n \nt\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\n\nOutput:\n \"UURL\"\n\nExplanation:\n The shortest path is: 3 → 1 → 5 → 2 → 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1], startValue = 2, destValue = 1\n\nOutput:\n \"L\"\n\nExplanation:\n The shortest path is: 2 → 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n2 <= n <= 10\n5\n\n\n1 <= Node.val <= n\n\n\nAll the values in the tree are \nunique\n.\n\n\n1 <= startValue, destValue <= n\n\n\nstartValue != destValue",
    "temas": [
      "String",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2095,
    "slug": "delete-the-middle-node-of-a-linked-list",
    "url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/",
    "titulo": "Delete the Middle Node of a Linked List",
    "enunciado": "You are given the \nhead\n of a linked list. \nDelete\n the \nmiddle node\n, and return \nthe\n \nhead\n \nof the modified linked list\n.\n\n\nThe \nmiddle node\n of a linked list of size \nn\n is the \n⌊n / 2⌋\nth\n node from the \nstart\n using \n0-based indexing\n, where \n⌊x⌋\n denotes the largest integer less than or equal to \nx\n.\n\n\n\n\nFor \nn\n = \n1\n, \n2\n, \n3\n, \n4\n, and \n5\n, the middle nodes are \n0\n, \n1\n, \n1\n, \n2\n, and \n2\n, respectively.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,3,4,7,1,2,6]\n\nOutput:\n [1,3,4,1,2,6]\n\nExplanation:\n\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4]\n\nOutput:\n [1,2,4]\n\nExplanation:\n\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [2,1]\n\nOutput:\n [2]\n\nExplanation:\n\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2090,
    "slug": "k-radius-subarray-averages",
    "url": "https://leetcode.com/problems/k-radius-subarray-averages/",
    "titulo": "K Radius Subarray Averages",
    "enunciado": "You are given a \n0-indexed\n array \nnums\n of \nn\n integers, and an integer \nk\n.\n\n\nThe \nk-radius average\n for a subarray of \nnums\n \ncentered\n at some index \ni\n with the \nradius\n \nk\n is the average of \nall\n elements in \nnums\n between the indices \ni - k\n and \ni + k\n (\ninclusive\n). If there are less than \nk\n elements before \nor\n after the index \ni\n, then the \nk-radius average\n is \n-1\n.\n\n\nBuild and return \nan array \navgs\n of length \nn\n where \navgs[i]\n is the \nk-radius average\n for the subarray centered at index \ni\n.\n\n\nThe \naverage\n of \nx\n elements is the sum of the \nx\n elements divided by \nx\n, using \ninteger division\n. The integer division truncates toward zero, which means losing its fractional part.\n\n\n\n\nFor example, the average of four elements \n2\n, \n3\n, \n1\n, and \n5\n is \n(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75\n, which truncates to \n2\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [7,4,3,9,1,8,5,2,6], k = 3\n\nOutput:\n [-1,-1,-1,5,4,4,-1,-1,-1]\n\nExplanation:\n\n- avg[0], avg[1], and avg[2] are -1 because there are less than k elements \nbefore\n each index.\n- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.\n  Using \ninteger division\n, avg[3] = 37 / 7 = 5.\n- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.\n- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.\n- avg[6], avg[7], and avg[8] are -1 because there are less than k elements \nafter\n each index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [100000], k = 0\n\nOutput:\n [100000]\n\nExplanation:\n\n- The sum of the subarray centered at index 0 with radius 0 is: 100000.\n  avg[0] = 100000 / 1 = 100000.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [8], k = 100000\n\nOutput:\n [-1]\n\nExplanation:\n \n- avg[0] is -1 because there are less than k elements before and after index 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= nums[i], k <= 10\n5",
    "temas": [
      "Array",
      "Sliding Window"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2101,
    "slug": "detonate-the-maximum-bombs",
    "url": "https://leetcode.com/problems/detonate-the-maximum-bombs/",
    "titulo": "Detonate the Maximum Bombs",
    "enunciado": "You are given a list of bombs. The \nrange\n of a bomb is defined as the area where its effect can be felt. This area is in the shape of a \ncircle\n with the center as the location of the bomb.\n\n\nThe bombs are represented by a \n0-indexed\n 2D integer array \nbombs\n where \nbombs[i] = [x\ni\n, y\ni\n, r\ni\n]\n. \nx\ni\n and \ny\ni\n denote the X-coordinate and Y-coordinate of the location of the \ni\nth\n bomb, whereas \nr\ni\n denotes the \nradius\n of its range.\n\n\nYou may choose to detonate a \nsingle\n bomb. When a bomb is detonated, it will detonate \nall bombs\n that lie in its range. These bombs will further detonate the bombs that lie in their ranges.\n\n\nGiven the list of \nbombs\n, return \nthe \nmaximum\n number of bombs that can be detonated if you are allowed to detonate \nonly one\n bomb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n bombs = [[2,1,3],[6,1,4]]\n\nOutput:\n 2\n\nExplanation:\n\nThe above figure shows the positions and ranges of the 2 bombs.\nIf we detonate the left bomb, the right bomb will not be affected.\nBut if we detonate the right bomb, both bombs will be detonated.\nSo the maximum bombs that can be detonated is max(1, 2) = 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n bombs = [[1,1,5],[10,10,5]]\n\nOutput:\n 1\n\nExplanation:\n\nDetonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n\nOutput:\n 5\n\nExplanation:\n\nThe best bomb to detonate is bomb 0 because:\n- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\nThus all 5 bombs are detonated.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= bombs.length <= 100\n\n\nbombs[i].length == 3\n\n\n1 <= x\ni\n, y\ni\n, r\ni\n <= 10\n5",
    "temas": [
      "Array",
      "Math",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Geometry"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2132,
    "slug": "stamping-the-grid",
    "url": "https://leetcode.com/problems/stamping-the-grid/",
    "titulo": "Stamping the Grid",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n where each cell is either \n0\n (empty) or \n1\n (occupied).\n\n\nYou are then given stamps of size \nstampHeight x stampWidth\n. We want to fit the stamps such that they follow the given \nrestrictions\n and \nrequirements\n:\n\n\n\n\nCover all the \nempty\n cells.\n\n\nDo not cover any of the \noccupied\n cells.\n\n\nWe can put as \nmany\n stamps as we want.\n\n\nStamps can \noverlap\n with each other.\n\n\nStamps are not allowed to be \nrotated\n.\n\n\nStamps must stay completely \ninside\n the grid.\n\n\n\n\nReturn \ntrue\n \nif it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return\n \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n\nOutput:\n true\n\nExplanation:\n We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n\nOutput:\n false \n\nExplanation:\n There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[r].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 2 * 10\n5\n\n\ngrid[r][c]\n is either \n0\n or \n1\n.\n\n\n1 <= stampHeight, stampWidth <= 10\n5",
    "temas": [
      "Array",
      "Greedy",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2078,
    "slug": "two-furthest-houses-with-different-colors",
    "url": "https://leetcode.com/problems/two-furthest-houses-with-different-colors/",
    "titulo": "Two Furthest Houses With Different Colors",
    "enunciado": "There are \nn\n houses evenly lined up on the street, and each house is beautifully painted. You are given a \n0-indexed\n integer array \ncolors\n of length \nn\n, where \ncolors[i]\n represents the color of the \ni\nth\n house.\n\n\nReturn \nthe \nmaximum\n distance between \ntwo\n houses with \ndifferent\n colors\n.\n\n\nThe distance between the \ni\nth\n and \nj\nth\n houses is \nabs(i - j)\n, where \nabs(x)\n is the \nabsolute value\n of \nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n colors = [\n1\n,1,1,\n6\n,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n colors = [\n1\n,8,3,8,\n3\n]\n\nOutput:\n 4\n\nExplanation:\n In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n colors = [\n0\n,\n1\n]\n\nOutput:\n 1\n\nExplanation:\n The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == colors.length\n\n\n2 <= n <= 100\n\n\n0 <= colors[i] <= 100\n\n\nTest data are generated such that \nat least\n two houses have different colors.",
    "temas": [
      "Array",
      "Greedy"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2075,
    "slug": "decode-the-slanted-ciphertext",
    "url": "https://leetcode.com/problems/decode-the-slanted-ciphertext/",
    "titulo": "Decode the Slanted Ciphertext",
    "enunciado": "A string \noriginalText\n is encoded using a \nslanted transposition cipher\n to a string \nencodedText\n with the help of a matrix having a \nfixed number of rows\n \nrows\n.\n\n\noriginalText\n is placed first in a top-left to bottom-right manner.\n\n\n\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of \noriginalText\n. The arrow indicates the order in which the cells are filled. All empty cells are filled with \n' '\n. The number of columns is chosen such that the rightmost column will \nnot be empty\n after filling in \noriginalText\n.\n\n\nencodedText\n is then formed by appending all characters of the matrix in a row-wise fashion.\n\n\n\n\nThe characters in the blue cells are appended first to \nencodedText\n, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\n\n\nFor example, if \noriginalText = \"cipher\"\n and \nrows = 3\n, then we encode it in the following manner:\n\n\n\n\nThe blue arrows depict how \noriginalText\n is placed in the matrix, and the red arrows denote the order in which \nencodedText\n is formed. In the above example, \nencodedText = \"ch ie pr\"\n.\n\n\nGiven the encoded string \nencodedText\n and number of rows \nrows\n, return \nthe original string\n \noriginalText\n.\n\n\nNote:\n \noriginalText\n \ndoes not\n have any trailing spaces \n' '\n. The test cases are generated such that there is only one possible \noriginalText\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n encodedText = \"ch   ie   pr\", rows = 3\n\nOutput:\n \"cipher\"\n\nExplanation:\n This is the same example described in the problem description.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n encodedText = \"iveo    eed   l te   olc\", rows = 4\n\nOutput:\n \"i love leetcode\"\n\nExplanation:\n The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n encodedText = \"coding\", rows = 1\n\nOutput:\n \"coding\"\n\nExplanation:\n Since there is only 1 row, both originalText and encodedText are the same.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= encodedText.length <= 10\n6\n\n\nencodedText\n consists of lowercase English letters and \n' '\n only.\n\n\nencodedText\n is a valid encoding of some \noriginalText\n that \ndoes not\n have trailing spaces.\n\n\n1 <= rows <= 1000\n\n\nThe testcases are generated such that there is \nonly one\n possible \noriginalText\n.",
    "temas": [
      "String",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2074,
    "slug": "reverse-nodes-in-even-length-groups",
    "url": "https://leetcode.com/problems/reverse-nodes-in-even-length-groups/",
    "titulo": "Reverse Nodes in Even Length Groups",
    "enunciado": "You are given the \nhead\n of a linked list.\n\n\nThe nodes in the linked list are \nsequentially\n assigned to \nnon-empty\n groups whose lengths form the sequence of the natural numbers (\n1, 2, 3, 4, ...\n). The \nlength\n of a group is the number of nodes assigned to it. In other words,\n\n\n\n\nThe \n1\nst\n node is assigned to the first group.\n\n\nThe \n2\nnd\n and the \n3\nrd\n nodes are assigned to the second group.\n\n\nThe \n4\nth\n, \n5\nth\n, and \n6\nth\n nodes are assigned to the third group, and so on.\n\n\n\n\nNote that the length of the last group may be less than or equal to \n1 + the length of the second to last group\n.\n\n\nReverse\n the nodes in each group with an \neven\n length, and return \nthe\n \nhead\n \nof the modified linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [5,2,6,3,9,1,7,3,8,4]\n\nOutput:\n [5,6,2,3,9,1,4,8,3,7]\n\nExplanation:\n\n- The length of the first group is 1, which is odd, hence no reversal occurs.\n- The length of the second group is 2, which is even, hence the nodes are reversed.\n- The length of the third group is 3, which is odd, hence no reversal occurs.\n- The length of the last group is 4, which is even, hence the nodes are reversed.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,1,0,6]\n\nOutput:\n [1,0,1,6]\n\nExplanation:\n\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 1. No reversal occurs.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1,1,0,6,5]\n\nOutput:\n [1,0,1,5,6]\n\nExplanation:\n\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 2. The nodes are reversed.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 10\n5",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2088,
    "slug": "count-fertile-pyramids-in-a-land",
    "url": "https://leetcode.com/problems/count-fertile-pyramids-in-a-land/",
    "titulo": "Count Fertile Pyramids in a Land",
    "enunciado": "A farmer has a \nrectangular grid\n of land with \nm\n rows and \nn\n columns that can be divided into unit cells. Each cell is either \nfertile\n (represented by a \n1\n) or \nbarren\n (represented by a \n0\n). All cells outside the grid are considered barren.\n\n\nA \npyramidal plot\n of land can be defined as a set of cells with the following criteria:\n\n\n\n\nThe number of cells in the set has to be \ngreater than \n1\n and all cells must be \nfertile\n.\n\n\nThe \napex\n of a pyramid is the \ntopmost\n cell of the pyramid. The \nheight\n of a pyramid is the number of rows it covers. Let \n(r, c)\n be the apex of the pyramid, and its height be \nh\n. Then, the plot comprises of cells \n(i, j)\n where \nr <= i <= r + h - 1\n \nand\n \nc - (i - r) <= j <= c + (i - r)\n.\n\n\n\n\nAn \ninverse pyramidal plot\n of land can be defined as a set of cells with similar criteria:\n\n\n\n\nThe number of cells in the set has to be \ngreater than \n1\n and all cells must be \nfertile\n.\n\n\nThe \napex\n of an inverse pyramid is the \nbottommost\n cell of the inverse pyramid. The \nheight\n of an inverse pyramid is the number of rows it covers. Let \n(r, c)\n be the apex of the pyramid, and its height be \nh\n. Then, the plot comprises of cells \n(i, j)\n where \nr - h + 1 <= i <= r\n \nand\n \nc - (r - i) <= j <= c + (r - i)\n.\n\n\n\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\n\n\n\nGiven a \n0-indexed\n \nm x n\n binary matrix \ngrid\n representing the farmland, return \nthe \ntotal number\n of pyramidal and inverse pyramidal plots that can be found in\n \ngrid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1,0],[1,1,1,1]]\n\nOutput:\n 2\n\nExplanation:\n The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[1,1,1]]\n\nOutput:\n 2\n\nExplanation:\n The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n\nOutput:\n 13\n\nExplanation:\n There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 1000\n\n\n1 <= m * n <= 10\n5\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2087,
    "slug": "minimum-cost-homecoming-of-a-robot-in-a-grid",
    "url": "https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/",
    "titulo": "Minimum Cost Homecoming of a Robot in a Grid",
    "enunciado": "There is an \nm x n\n grid, where \n(0, 0)\n is the top-left cell and \n(m - 1, n - 1)\n is the bottom-right cell. You are given an integer array \nstartPos\n where \nstartPos = [start\nrow\n, start\ncol\n]\n indicates that \ninitially\n, a \nrobot\n is at the cell \n(start\nrow\n, start\ncol\n)\n. You are also given an integer array \nhomePos\n where \nhomePos = [home\nrow\n, home\ncol\n]\n indicates that its \nhome\n is at the cell \n(home\nrow\n, home\ncol\n)\n.\n\n\nThe robot needs to go to its home. It can move one cell in four directions: \nleft\n, \nright\n, \nup\n, or \ndown\n, and it can not move outside the boundary. Every move incurs some cost. You are further given two \n0-indexed\n integer arrays: \nrowCosts\n of length \nm\n and \ncolCosts\n of length \nn\n.\n\n\n\n\nIf the robot moves \nup\n or \ndown\n into a cell whose \nrow\n is \nr\n, then this move costs \nrowCosts[r]\n.\n\n\nIf the robot moves \nleft\n or \nright\n into a cell whose \ncolumn\n is \nc\n, then this move costs \ncolCosts[c]\n.\n\n\n\n\nReturn \nthe \nminimum total cost\n for this robot to return home\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\n\nOutput:\n 18\n\nExplanation:\n One optimal path is that:\nStarting from (1, 0)\n-> It goes down to (\n2\n, 0). This move costs rowCosts[2] = 3.\n-> It goes right to (2, \n1\n). This move costs colCosts[1] = 2.\n-> It goes right to (2, \n2\n). This move costs colCosts[2] = 6.\n-> It goes right to (2, \n3\n). This move costs colCosts[3] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18\n\n\nExample 2:\n\n\n\n\nInput:\n startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\n\nOutput:\n 0\n\nExplanation:\n The robot is already at its home. Since no moves occur, the total cost is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == rowCosts.length\n\n\nn == colCosts.length\n\n\n1 <= m, n <= 10\n5\n\n\n0 <= rowCosts[r], colCosts[c] <= 10\n4\n\n\nstartPos.length == 2\n\n\nhomePos.length == 2\n\n\n0 <= start\nrow\n, home\nrow\n < m\n\n\n0 <= start\ncol\n, home\ncol\n < n",
    "temas": [
      "Array",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2086,
    "slug": "minimum-number-of-food-buckets-to-feed-the-hamsters",
    "url": "https://leetcode.com/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/",
    "titulo": "Minimum Number of Food Buckets to Feed the Hamsters",
    "enunciado": "You are given a \n0-indexed\n string \nhamsters\n where \nhamsters[i]\n is either:\n\n\n\n\n'H'\n indicating that there is a hamster at index \ni\n, or\n\n\n'.'\n indicating that index \ni\n is empty.\n\n\n\n\nYou will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index \ni\n can be fed if you place a food bucket at index \ni - 1\n \nand/or\n at index \ni + 1\n.\n\n\nReturn \nthe minimum number of food buckets you should \nplace at empty indices\n to feed all the hamsters or \n-1\n if it is impossible to feed all of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n hamsters = \"H..H\"\n\nOutput:\n 2\n\nExplanation:\n We place two food buckets at indices 1 and 2.\nIt can be shown that if we place only one food bucket, one of the hamsters will not be fed.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n hamsters = \".H.H.\"\n\nOutput:\n 1\n\nExplanation:\n We place one food bucket at index 2.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n hamsters = \".HHH.\"\n\nOutput:\n -1\n\nExplanation:\n If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= hamsters.length <= 10\n5\n\n\nhamsters[i]\n is either\n'H'\n or \n'.'\n.",
    "temas": [
      "String",
      "Dynamic Programming",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2065,
    "slug": "maximum-path-quality-of-a-graph",
    "url": "https://leetcode.com/problems/maximum-path-quality-of-a-graph/",
    "titulo": "Maximum Path Quality of a Graph",
    "enunciado": "There is an \nundirected\n graph with \nn\n nodes numbered from \n0\n to \nn - 1\n (\ninclusive\n). You are given a \n0-indexed\n integer array \nvalues\n where \nvalues[i]\n is the \nvalue \nof the \ni\nth\n node. You are also given a \n0-indexed\n 2D integer array \nedges\n, where each \nedges[j] = [u\nj\n, v\nj\n, time\nj\n]\n indicates that there is an undirected edge between the nodes \nu\nj\n and \nv\nj\n,\n \nand it takes \ntime\nj\n seconds to travel between the two nodes. Finally, you are given an integer \nmaxTime\n.\n\n\nA \nvalid\n \npath\n in the graph is any path that starts at node \n0\n, ends at node \n0\n, and takes \nat most\n \nmaxTime\n seconds to complete. You may visit the same node multiple times. The \nquality\n of a valid path is the \nsum\n of the values of the \nunique nodes\n visited in the path (each node's value is added \nat most once\n to the sum).\n\n\nReturn \nthe \nmaximum\n quality of a valid path\n.\n\n\nNote:\n There are \nat most four\n edges connected to each node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49\n\nOutput:\n 75\n\nExplanation:\n\nOne possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30\n\nOutput:\n 25\n\nExplanation:\n\nOne possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\nThe nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50\n\nOutput:\n 7\n\nExplanation:\n\nOne possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == values.length\n\n\n1 <= n <= 1000\n\n\n0 <= values[i] <= 10\n8\n\n\n0 <= edges.length <= 2000\n\n\nedges[j].length == 3 \n\n\n0 <= u\nj \n< v\nj\n <= n - 1\n\n\n10 <= time\nj\n, maxTime <= 100\n\n\nAll the pairs \n[u\nj\n, v\nj\n]\n are \nunique\n.\n\n\nThere are \nat most four\n edges connected to each node.\n\n\nThe graph may not be connected.",
    "temas": [
      "Array",
      "Backtracking",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2058,
    "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
    "url": "https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/",
    "titulo": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
    "enunciado": "A \ncritical point\n in a linked list is defined as \neither\n a \nlocal maxima\n or a \nlocal minima\n.\n\n\nA node is a \nlocal maxima\n if the current node has a value \nstrictly greater\n than the previous node and the next node.\n\n\nA node is a \nlocal minima\n if the current node has a value \nstrictly smaller\n than the previous node and the next node.\n\n\nNote that a node can only be a local maxima/minima if there exists \nboth\n a previous node and a next node.\n\n\nGiven a linked list \nhead\n, return \nan array of length 2 containing \n[minDistance, maxDistance]\n where \nminDistance\n is the \nminimum distance\n between \nany two distinct\n critical points and \nmaxDistance\n is the \nmaximum distance\n between \nany two distinct\n critical points. If there are \nfewer\n than two critical points, return \n[-1, -1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [3,1]\n\nOutput:\n [-1,-1]\n\nExplanation:\n There are no critical points in [3,1].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [5,3,1,2,5,1,2]\n\nOutput:\n [1,3]\n\nExplanation:\n There are three critical points:\n- [5,3,\n1\n,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,\n5\n,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,\n1\n,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1,3,2,2,3,2,2,2,7]\n\nOutput:\n [3,3]\n\nExplanation:\n There are two critical points:\n- [1,\n3\n,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,\n3\n,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[2, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n5",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 2069,
    "slug": "walking-robot-simulation-ii",
    "url": "https://leetcode.com/problems/walking-robot-simulation-ii/",
    "titulo": "Walking Robot Simulation II",
    "enunciado": "A \nwidth x height\n grid is on an XY-plane with the \nbottom-left\n cell at \n(0, 0)\n and the \ntop-right\n cell at \n(width - 1, height - 1)\n. The grid is aligned with the four cardinal directions (\n\"North\"\n, \n\"East\"\n, \n\"South\"\n, and \n\"West\"\n). A robot is \ninitially\n at cell \n(0, 0)\n facing direction \n\"East\"\n.\n\n\nThe robot can be instructed to move for a specific number of \nsteps\n. For each step, it does the following.\n\n\n\n\nAttempts to move \nforward one\n cell in the direction it is facing.\n\n\nIf the cell the robot is \nmoving to\n is \nout of bounds\n, the robot instead \nturns\n 90 degrees \ncounterclockwise\n and retries the step.\n\n\n\n\nAfter the robot finishes moving the number of steps required, it stops and awaits the next instruction.\n\n\nImplement the \nRobot\n class:\n\n\n\n\nRobot(int width, int height)\n Initializes the \nwidth x height\n grid with the robot at \n(0, 0)\n facing \n\"East\"\n.\n\n\nvoid step(int num)\n Instructs the robot to move forward \nnum\n steps.\n\n\nint[] getPos()\n Returns the current cell the robot is at, as an array of length 2, \n[x, y]\n.\n\n\nString getDir()\n Returns the current direction of the robot, \n\"North\"\n, \n\"East\"\n, \n\"South\"\n, or \n\"West\"\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n\nOutput\n\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n\n\nExplanation\n\nRobot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East.\nrobot.step(2);  // It moves two steps East to (2, 0), and faces East.\nrobot.step(2);  // It moves two steps East to (4, 0), and faces East.\nrobot.getPos(); // return [4, 0]\nrobot.getDir(); // return \"East\"\nrobot.step(2);  // It moves one step East to (5, 0), and faces East.\n                // Moving the next step East would be out of bounds, so it turns and faces North.\n                // Then, it moves one step North to (5, 1), and faces North.\nrobot.step(1);  // It moves one step North to (5, 2), and faces \nNorth\n (not West).\nrobot.step(4);  // Moving the next step North would be out of bounds, so it turns and faces West.\n                // Then, it moves four steps West to (1, 2), and faces West.\nrobot.getPos(); // return [1, 2]\nrobot.getDir(); // return \"West\"\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= width, height <= 100\n\n\n1 <= num <= 10\n5\n\n\nAt most \n10\n4\n calls \nin total\n will be made to \nstep\n, \ngetPos\n, and \ngetDir\n.",
    "temas": [
      "Design",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Design",
    "has_image": true
  },
  {
    "id": 2050,
    "slug": "parallel-courses-iii",
    "url": "https://leetcode.com/problems/parallel-courses-iii/",
    "titulo": "Parallel Courses III",
    "enunciado": "You are given an integer \nn\n, which indicates that there are \nn\n courses labeled from \n1\n to \nn\n. You are also given a 2D integer array \nrelations\n where \nrelations[j] = [prevCourse\nj\n, nextCourse\nj\n]\n denotes that course \nprevCourse\nj\n has to be completed \nbefore\n course \nnextCourse\nj\n (prerequisite relationship). Furthermore, you are given a \n0-indexed\n integer array \ntime\n where \ntime[i]\n denotes how many \nmonths\n it takes to complete the \n(i+1)\nth\n course.\n\n\nYou must find the \nminimum\n number of months needed to complete all the courses following these rules:\n\n\n\n\nYou may start taking a course at \nany time\n if the prerequisites are met.\n\n\nAny number of courses\n can be taken at the \nsame time\n.\n\n\n\n\nReturn \nthe \nminimum\n number of months needed to complete all the courses\n.\n\n\nNote:\n The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\n\nOutput:\n 8\n\nExplanation:\n The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\n\nOutput:\n 12\n\nExplanation:\n The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 5 * 10\n4\n\n\n0 <= relations.length <= min(n * (n - 1) / 2, 5 * 10\n4\n)\n\n\nrelations[j].length == 2\n\n\n1 <= prevCourse\nj\n, nextCourse\nj\n <= n\n\n\nprevCourse\nj\n != nextCourse\nj\n\n\nAll the pairs \n[prevCourse\nj\n, nextCourse\nj\n]\n are \nunique\n.\n\n\ntime.length == n\n\n\n1 <= time[i] <= 10\n4\n\n\nThe given graph is a directed acyclic graph.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2049,
    "slug": "count-nodes-with-the-highest-score",
    "url": "https://leetcode.com/problems/count-nodes-with-the-highest-score/",
    "titulo": "Count Nodes With the Highest Score",
    "enunciado": "There is a \nbinary\n tree rooted at \n0\n consisting of \nn\n nodes. The nodes are labeled from \n0\n to \nn - 1\n. You are given a \n0-indexed\n integer array \nparents\n representing the tree, where \nparents[i]\n is the parent of node \ni\n. Since node \n0\n is the root, \nparents[0] == -1\n.\n\n\nEach node has a \nscore\n. To find the score of a node, consider if the node and the edges connected to it were \nremoved\n. The tree would become one or more \nnon-empty\n subtrees. The \nsize\n of a subtree is the number of the nodes in it. The \nscore\n of the node is the \nproduct of the sizes\n of all those subtrees.\n\n\nReturn \nthe \nnumber\n of nodes that have the \nhighest score\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n parents = [-1,2,0,2,0]\n\nOutput:\n 3\n\nExplanation:\n\n- The score of node 0 is: 3 * 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 * 1 * 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n parents = [-1,2,0]\n\nOutput:\n 2\n\nExplanation:\n\n- The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 * 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parents.length\n\n\n2 <= n <= 10\n5\n\n\nparents[0] == -1\n\n\n0 <= parents[i] <= n - 1\n for \ni != 0\n\n\nparents\n represents a valid binary tree.",
    "temas": [
      "Array",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2045,
    "slug": "second-minimum-time-to-reach-destination",
    "url": "https://leetcode.com/problems/second-minimum-time-to-reach-destination/",
    "titulo": "Second Minimum Time to Reach Destination",
    "enunciado": "A city is represented as a \nbi-directional connected\n graph with \nn\n vertices where each vertex is labeled from \n1\n to \nn\n (\ninclusive\n). The edges in the graph are represented as a 2D integer array \nedges\n, where each \nedges[i] = [u\ni\n, v\ni\n]\n denotes a bi-directional edge between vertex \nu\ni\n and vertex \nv\ni\n. Every vertex pair is connected by \nat most one\n edge, and no vertex has an edge to itself. The time taken to traverse any edge is \ntime\n minutes.\n\n\nEach vertex has a traffic signal which changes its color from \ngreen\n to \nred\n and vice versa every \nchange\n minutes. All signals change \nat the same time\n. You can enter a vertex at \nany time\n, but can leave a vertex \nonly when the signal is green\n. You \ncannot wait \nat a vertex if the signal is \ngreen\n.\n\n\nThe \nsecond minimum value\n is defined as the smallest value\n strictly larger \nthan the minimum value.\n\n\n\n\nFor example the second minimum value of \n[2, 3, 4]\n is \n3\n, and the second minimum value of \n[2, 2, 4]\n is \n4\n.\n\n\n\n\nGiven \nn\n, \nedges\n, \ntime\n, and \nchange\n, return \nthe \nsecond minimum time\n it will take to go from vertex \n1\n to vertex \nn\n.\n\n\nNotes:\n\n\n\n\nYou can go through any vertex \nany\n number of times, \nincluding\n \n1\n and \nn\n.\n\n\nYou can assume that when the journey \nstarts\n, all signals have just turned \ngreen\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n        \n\n\n\n\nInput:\n n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n\nOutput:\n 13\n\nExplanation:\n\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, edges = [[1,2]], time = 3, change = 2\n\nOutput:\n 11\n\nExplanation:\n\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n4\n\n\nn - 1 <= edges.length <= min(2 * 10\n4\n, n * (n - 1) / 2)\n\n\nedges[i].length == 2\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni\n != v\ni\n\n\nThere are no duplicate edges.\n\n\nEach vertex can be reached directly or indirectly from every other vertex.\n\n\n1 <= time, change <= 10\n3",
    "temas": [
      "Breadth-First Search",
      "Graph",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Breadth-First Search",
    "has_image": true
  },
  {
    "id": 2042,
    "slug": "check-if-numbers-are-ascending-in-a-sentence",
    "url": "https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/",
    "titulo": "Check if Numbers Are Ascending in a Sentence",
    "enunciado": "A sentence is a list of \ntokens\n separated by a \nsingle\n space with no leading or trailing spaces. Every token is either a \npositive number\n consisting of digits \n0-9\n with no leading zeros, or a \nword\n consisting of lowercase English letters.\n\n\n\n\nFor example, \n\"a puppy has 2 eyes 4 legs\"\n is a sentence with seven tokens: \n\"2\"\n and \n\"4\"\n are numbers and the other tokens such as \n\"puppy\"\n are words.\n\n\n\n\nGiven a string \ns\n representing a sentence, you need to check if \nall\n the numbers in \ns\n are \nstrictly increasing\n from left to right (i.e., other than the last number, \neach\n number is \nstrictly smaller\n than the number on its \nright\n in \ns\n).\n\n\nReturn \ntrue\n if so, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n\nOutput:\n true\n\nExplanation:\n The numbers in s are: 1, 3, 4, 6, 12.\nThey are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"hello world 5 x 5\"\n\nOutput:\n false\n\nExplanation:\n The numbers in s are: \n5\n, \n5\n. They are not strictly increasing.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n\nOutput:\n false\n\nExplanation:\n The numbers in s are: 7, \n51\n, \n50\n, 60. They are not strictly increasing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 200\n\n\ns\n consists of lowercase English letters, spaces, and digits from \n0\n to \n9\n, inclusive.\n\n\nThe number of tokens in \ns\n is between \n2\n and \n100\n, inclusive.\n\n\nThe tokens in \ns\n are separated by a single space.\n\n\nThere are at least \ntwo\n numbers in \ns\n.\n\n\nEach number in \ns\n is a \npositive\n number \nless\n than \n100\n, with no leading zeros.\n\n\ns\n contains no leading or trailing spaces.",
    "temas": [
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2056,
    "slug": "number-of-valid-move-combinations-on-chessboard",
    "url": "https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/",
    "titulo": "Number of Valid Move Combinations On Chessboard",
    "enunciado": "There is an \n8 x 8\n chessboard containing \nn\n pieces (rooks, queens, or bishops). You are given a string array \npieces\n of length \nn\n, where \npieces[i]\n describes the type (rook, queen, or bishop) of the \ni\nth\n piece. In addition, you are given a 2D integer array \npositions\n also of length \nn\n, where \npositions[i] = [r\ni\n, c\ni\n]\n indicates that the \ni\nth\n piece is currently at the \n1-based\n coordinate \n(r\ni\n, c\ni\n)\n on the chessboard.\n\n\nWhen making a \nmove\n for a piece, you choose a \ndestination\n square that the piece will travel toward and stop on.\n\n\n\n\nA rook can only travel \nhorizontally or vertically\n from \n(r, c)\n to the direction of \n(r+1, c)\n, \n(r-1, c)\n, \n(r, c+1)\n, or \n(r, c-1)\n.\n\n\nA queen can only travel \nhorizontally, vertically, or diagonally\n from \n(r, c)\n to the direction of \n(r+1, c)\n, \n(r-1, c)\n, \n(r, c+1)\n, \n(r, c-1)\n, \n(r+1, c+1)\n, \n(r+1, c-1)\n, \n(r-1, c+1)\n, \n(r-1, c-1)\n.\n\n\nA bishop can only travel \ndiagonally\n from \n(r, c)\n to the direction of \n(r+1, c+1)\n, \n(r+1, c-1)\n, \n(r-1, c+1)\n, \n(r-1, c-1)\n.\n\n\n\n\nYou must make a \nmove\n for every piece on the board simultaneously. A \nmove combination\n consists of all the \nmoves\n performed on all the given pieces. Every second, each piece will instantaneously travel \none square\n towards their destination if they are not already at it. All pieces start traveling at the \n0\nth\n second. A move combination is \ninvalid\n if, at a given time, \ntwo or more\n pieces occupy the same square.\n\n\nReturn \nthe number of \nvalid\n move combinations\n​​​​​.\n\n\nNotes:\n\n\n\n\nNo two pieces\n will start in the\n same\n square.\n\n\nYou may choose the square a piece is already on as its \ndestination\n.\n\n\nIf two pieces are \ndirectly adjacent\n to each other, it is valid for them to \nmove past each other\n and swap positions in one second.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n pieces = [\"rook\"], positions = [[1,1]]\n\nOutput:\n 15\n\nExplanation:\n The image above shows the possible squares the piece can move to.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n pieces = [\"queen\"], positions = [[1,1]]\n\nOutput:\n 22\n\nExplanation:\n The image above shows the possible squares the piece can move to.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n pieces = [\"bishop\"], positions = [[4,3]]\n\nOutput:\n 12\n\nExplanation:\n The image above shows the possible squares the piece can move to.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == pieces.length \n\n\nn == positions.length\n\n\n1 <= n <= 4\n\n\npieces\n only contains the strings \n\"rook\"\n, \n\"queen\"\n, and \n\"bishop\"\n.\n\n\nThere will be at most one queen on the chessboard.\n\n\n1 <= r\ni\n, c\ni\n <= 8\n\n\nEach \npositions[i]\n is distinct.",
    "temas": [
      "Array",
      "String",
      "Backtracking",
      "Simulation"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2055,
    "slug": "plates-between-candles",
    "url": "https://leetcode.com/problems/plates-between-candles/",
    "titulo": "Plates Between Candles",
    "enunciado": "There is a long table with a line of plates and candles arranged on top of it. You are given a \n0-indexed\n string \ns\n consisting of characters \n'*'\n and \n'|'\n only, where a \n'*'\n represents a \nplate\n and a \n'|'\n represents a \ncandle\n.\n\n\nYou are also given a \n0-indexed\n 2D integer array \nqueries\n where \nqueries[i] = [left\ni\n, right\ni\n]\n denotes the \nsubstring\n \ns[left\ni\n...right\ni\n]\n (\ninclusive\n). For each query, you need to find the \nnumber\n of plates \nbetween candles\n that are \nin the substring\n. A plate is considered \nbetween candles\n if there is at least one candle to its left \nand\n at least one candle to its right \nin the substring\n.\n\n\n\n\nFor example, \ns = \"||**||**|*\"\n, and a query \n[3, 8]\n denotes the substring \n\"*||\n**\n|\"\n. The number of plates between candles in this substring is \n2\n, as each of the two plates has at least one candle \nin the substring\n to its left \nand\n right.\n\n\n\n\nReturn \nan integer array\n \nanswer\n \nwhere\n \nanswer[i]\n \nis the answer to the\n \ni\nth\n \nquery\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"**|**|***|\", queries = [[2,5],[5,9]]\n\nOutput:\n [2,3]\n\nExplanation:\n\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\n\nOutput:\n [9,0,0,0,0]\n\nExplanation:\n\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 10\n5\n\n\ns\n consists of \n'*'\n and \n'|'\n characters.\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= left\ni\n <= right\ni\n < s.length",
    "temas": [
      "Array",
      "String",
      "Binary Search",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2054,
    "slug": "two-best-non-overlapping-events",
    "url": "https://leetcode.com/problems/two-best-non-overlapping-events/",
    "titulo": "Two Best Non-Overlapping Events",
    "enunciado": "You are given a \n0-indexed\n 2D integer array of \nevents\n where \nevents[i] = [startTime\ni\n, endTime\ni\n, value\ni\n]\n. The \ni\nth\n event starts at \nstartTime\ni\n \nand ends at \nendTime\ni\n, and if you attend this event, you will receive a value of \nvalue\ni\n. You can choose \nat most\n \ntwo\n \nnon-overlapping\n events to attend such that the sum of their values is \nmaximized\n.\n\n\nReturn \nthis \nmaximum\n sum.\n\n\nNote that the start time and end time is \ninclusive\n: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time \nt\n, the next event must start at or after \nt + 1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n events = [[1,3,2],[4,5,2],[2,4,3]]\n\nOutput:\n 4\n\nExplanation: \nChoose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n events = [[1,3,2],[4,5,2],[1,5,5]]\n\nOutput:\n 5\n\nExplanation: \nChoose event 2 for a sum of 5.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n events = [[1,5,3],[1,5,1],[6,6,5]]\n\nOutput:\n 8\n\nExplanation: \nChoose events 0 and 2 for a sum of 3 + 5 = 8.\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= events.length <= 10\n5\n\n\nevents[i].length == 3\n\n\n1 <= startTime\ni\n <= endTime\ni\n <= 10\n9\n\n\n1 <= value\ni\n <= 10\n6",
    "temas": [
      "Array",
      "Binary Search",
      "Dynamic Programming",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2035,
    "slug": "partition-array-into-two-arrays-to-minimize-sum-difference",
    "url": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",
    "titulo": "Partition Array Into Two Arrays to Minimize Sum Difference",
    "enunciado": "You are given an integer array \nnums\n of \n2 * n\n integers. You need to partition \nnums\n into \ntwo\n arrays of length \nn\n to \nminimize the absolute difference\n of the \nsums\n of the arrays. To partition \nnums\n, put each element of \nnums\n into \none\n of the two arrays.\n\n\nReturn \nthe \nminimum\n possible absolute difference\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [3,9,7,3]\n\nOutput:\n 2\n\nExplanation:\n One optimal partition is: [3,9] and [7,3].\nThe absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-36,36]\n\nOutput:\n 72\n\nExplanation:\n One optimal partition is: [-36] and [36].\nThe absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n nums = [2,-1,0,4,-2,-9]\n\nOutput:\n 0\n\nExplanation:\n One optimal partition is: [2,4,-9] and [-1,0,-2].\nThe absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 15\n\n\nnums.length == 2 * n\n\n\n-10\n7\n <= nums[i] <= 10\n7",
    "temas": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Dynamic Programming",
      "Bit Manipulation",
      "Ordered Set",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2033,
    "slug": "minimum-operations-to-make-a-uni-value-grid",
    "url": "https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/",
    "titulo": "Minimum Operations to Make a Uni-Value Grid",
    "enunciado": "You are given a 2D integer \ngrid\n of size \nm x n\n and an integer \nx\n. In one operation, you can \nadd\n \nx\n to or \nsubtract\n \nx\n from any element in the \ngrid\n.\n\n\nA \nuni-value grid\n is a grid where all the elements of it are equal.\n\n\nReturn \nthe \nminimum\n number of operations to make the grid \nuni-value\n. If it is not possible, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,4],[6,8]], x = 2\n\nOutput:\n 4\n\nExplanation:\n We can make every element equal to 4 by doing the following: \n- Add x to 2 once.\n- Subtract x from 6 once.\n- Subtract x from 8 twice.\nA total of 4 operations were used.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,5],[2,3]], x = 1\n\nOutput:\n 5\n\nExplanation:\n We can make every element equal to 3.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,2],[3,4]], x = 2\n\nOutput:\n -1\n\nExplanation:\n It is impossible to make every element equal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n1 <= x, grid[i][j] <= 10\n4",
    "temas": [
      "Array",
      "Math",
      "Sorting",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2030,
    "slug": "smallest-k-length-subsequence-with-occurrences-of-a-letter",
    "url": "https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/",
    "titulo": "Smallest K-Length Subsequence With Occurrences of a Letter",
    "enunciado": "You are given a string \ns\n, an integer \nk\n, a letter \nletter\n, and an integer \nrepetition\n.\n\n\nReturn \nthe \nlexicographically smallest\n subsequence of\n \ns\n of length\n \nk\n \nthat has the letter\n \nletter\n \nappear \nat least\n \nrepetition\n \ntimes\n. The test cases are generated so that the \nletter\n appears in \ns\n \nat least\n \nrepetition\n times.\n\n\nA \nsubsequence\n is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n\nA string \na\n is \nlexicographically smaller\n than a string \nb\n if in the first position where \na\n and \nb\n differ, string \na\n has a letter that appears earlier in the alphabet than the corresponding letter in \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leet\", k = 3, letter = \"e\", repetition = 1\n\nOutput:\n \"eet\"\n\nExplanation:\n There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:\n- \"lee\" (from \"\nlee\nt\")\n- \"let\" (from \"\nle\ne\nt\n\")\n- \"let\" (from \"\nl\ne\net\n\")\n- \"eet\" (from \"l\neet\n\")\nThe lexicographically smallest subsequence among them is \"eet\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n s = \"leetcode\", k = 4, letter = \"e\", repetition = 2\n\nOutput:\n \"ecde\"\n\nExplanation:\n \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"bb\", k = 2, letter = \"b\", repetition = 2\n\nOutput:\n \"bb\"\n\nExplanation:\n \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= repetition <= k <= s.length <= 5 * 10\n4\n\n\ns\n consists of lowercase English letters.\n\n\nletter\n is a lowercase English letter, and appears in \ns\n at least \nrepetition\n times.",
    "temas": [
      "String",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2039,
    "slug": "the-time-when-the-network-becomes-idle",
    "url": "https://leetcode.com/problems/the-time-when-the-network-becomes-idle/",
    "titulo": "The Time When the Network Becomes Idle",
    "enunciado": "There is a network of \nn\n servers, labeled from \n0\n to \nn - 1\n. You are given a 2D integer array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates there is a message channel between servers \nu\ni\n and \nv\ni\n, and they can pass \nany\n number of messages to \neach other\n directly in \none\n second. You are also given a \n0-indexed\n integer array \npatience\n of length \nn\n.\n\n\nAll servers are \nconnected\n, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\n\n\nThe server labeled \n0\n is the \nmaster\n server. The rest are \ndata\n servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers \noptimally\n, so every message takes the \nleast amount of time\n to arrive at the master server. The master server will process all newly arrived messages \ninstantly\n and send a reply to the originating server via the \nreversed path\n the message had gone through.\n\n\nAt the beginning of second \n0\n, each data server sends its message to be processed. Starting from second \n1\n, at the \nbeginning\n of \nevery\n second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n\n\n\n\nIf it has not, it will \nresend\n the message periodically. The data server \ni\n will resend the message every \npatience[i]\n second(s), i.e., the data server \ni\n will resend the message if \npatience[i]\n second(s) have \nelapsed\n since the \nlast\n time the message was sent from this server.\n\n\nOtherwise, \nno more resending\n will occur from this server.\n\n\n\n\nThe network becomes \nidle\n when there are \nno\n messages passing between servers or arriving at servers.\n\n\nReturn \nthe \nearliest second\n starting from which the network becomes \nidle\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[1,2]], patience = [0,2,1]\n\nOutput:\n 8\n\nExplanation:\n\nAt (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\n\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\n\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\n\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\n\nOutput:\n 3\n\nExplanation:\n Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == patience.length\n\n\n2 <= n <= 10\n5\n\n\npatience[0] == 0\n\n\n1 <= patience[i] <= 10\n5\n for \n1 <= i < n\n\n\n1 <= edges.length <= min(10\n5\n, n * (n - 1) / 2)\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n, v\ni\n < n\n\n\nu\ni\n != v\ni\n\n\nThere are no duplicate edges.\n\n\nEach server can directly or indirectly reach another server.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2019,
    "slug": "the-score-of-students-solving-math-expression",
    "url": "https://leetcode.com/problems/the-score-of-students-solving-math-expression/",
    "titulo": "The Score of Students Solving Math Expression",
    "enunciado": "You are given a string \ns\n that contains digits \n0-9\n, addition symbols \n'+'\n, and multiplication symbols \n'*'\n \nonly\n, representing a \nvalid\n math expression of \nsingle digit numbers\n (e.g., \n3+5*2\n). This expression was given to \nn\n elementary school students. The students were instructed to get the answer of the expression by following this \norder of operations\n:\n\n\n\n\nCompute \nmultiplication\n, reading from \nleft to right\n; Then,\n\n\nCompute \naddition\n, reading from \nleft to right\n.\n\n\n\n\nYou are given an integer array \nanswers\n of length \nn\n, which are the submitted answers of the students in no particular order. You are asked to grade the \nanswers\n, by following these \nrules\n:\n\n\n\n\nIf an answer \nequals\n the correct answer of the expression, this student will be rewarded \n5\n points;\n\n\nOtherwise, if the answer \ncould be interpreted\n as if the student applied the operators \nin the wrong order\n but had \ncorrect arithmetic\n, this student will be rewarded \n2\n points;\n\n\nOtherwise, this student will be rewarded \n0\n points.\n\n\n\n\nReturn \nthe sum of the points of the students\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"7+3*1*2\", answers = [20,13,42]\n\nOutput:\n 7\n\nExplanation:\n As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,\n13\n,42]\nA student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [\n20\n,13,42]\nThe points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3+5*2\", answers = [13,0,10,13,13,16,16]\n\nOutput:\n 19\n\nExplanation:\n The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [\n13\n,0,10,\n13\n,\n13\n,16,16]\nA student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,\n16\n,\n16\n]\nThe points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"6+0*1\", answers = [12,9,6,4,8,6]\n\nOutput:\n 10\n\nExplanation:\n The correct answer of the expression is 6.\nIf a student had incorrectly done (6+0)*1, the answer would also be 6.\nBy the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\nThe points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 31\n\n\ns\n represents a valid expression that contains only digits \n0-9\n, \n'+'\n, and \n'*'\n only.\n\n\nAll the integer operands in the expression are in the \ninclusive\n range \n[0, 9]\n.\n\n\n1 <=\n The count of all operators (\n'+'\n and \n'*'\n) in the math expression \n<= 15\n\n\nTest data are generated such that the correct answer of the expression is in the range of \n[0, 1000]\n.\n\n\nn == answers.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= answers[i] <= 1000",
    "temas": [
      "Array",
      "Math",
      "String",
      "Dynamic Programming",
      "Stack",
      "Memoization"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2018,
    "slug": "check-if-word-can-be-placed-in-crossword",
    "url": "https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/",
    "titulo": "Check if Word Can Be Placed In Crossword",
    "enunciado": "You are given an \nm x n\n matrix \nboard\n, representing the\n current \nstate of a crossword puzzle. The crossword contains lowercase English letters (from solved words), \n' '\n to represent any \nempty \ncells, and \n'#'\n to represent any \nblocked\n cells.\n\n\nA word can be placed\n horizontally\n (left to right \nor\n right to left) or \nvertically\n (top to bottom \nor\n bottom to top) in the board if:\n\n\n\n\nIt does not occupy a cell containing the character \n'#'\n.\n\n\nThe cell each letter is placed in must either be \n' '\n (empty) or \nmatch\n the letter already on the \nboard\n.\n\n\nThere must not be any empty cells \n' '\n or other lowercase letters \ndirectly left or right\n \nof the word if the word was placed \nhorizontally\n.\n\n\nThere must not be any empty cells \n' '\n or other lowercase letters \ndirectly above or below\n the word if the word was placed \nvertically\n.\n\n\n\n\nGiven a string \nword\n, return \ntrue\n if \nword\n can be placed in \nboard\n, or \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\n\nOutput:\n true\n\nExplanation:\n The word \"abc\" can be placed as shown above (top to bottom).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"\n\nOutput:\n false\n\nExplanation:\n It is impossible to place the word because there will always be a space/letter above or below it.\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"\n\nOutput:\n true\n\nExplanation:\n The word \"ca\" can be placed as shown above (right to left). \n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m * n <= 2 * 10\n5\n\n\nboard[i][j]\n will be \n' '\n, \n'#'\n, or a lowercase English letter.\n\n\n1 <= word.length <= max(m, n)\n\n\nword\n will contain only lowercase English letters.",
    "temas": [
      "Array",
      "Matrix",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2017,
    "slug": "grid-game",
    "url": "https://leetcode.com/problems/grid-game/",
    "titulo": "Grid Game",
    "enunciado": "You are given a \n0-indexed\n 2D array \ngrid\n of size \n2 x n\n, where \ngrid[r][c]\n represents the number of points at position \n(r, c)\n on the matrix. Two robots are playing a game on this matrix.\n\n\nBoth robots initially start at \n(0, 0)\n and want to reach \n(1, n-1)\n. Each robot may only move to the \nright\n (\n(r, c)\n to \n(r, c + 1)\n) or \ndown \n(\n(r, c)\n to \n(r + 1, c)\n).\n\n\nAt the start of the game, the \nfirst\n robot moves from \n(0, 0)\n to \n(1, n-1)\n, collecting all the points from the cells on its path. For all cells \n(r, c)\n traversed on the path, \ngrid[r][c]\n is set to \n0\n. Then, the \nsecond\n robot moves from \n(0, 0)\n to \n(1, n-1)\n, collecting the points on its path. Note that their paths may intersect with one another.\n\n\nThe \nfirst\n robot wants to \nminimize\n the number of points collected by the \nsecond\n robot. In contrast, the \nsecond \nrobot wants to \nmaximize\n the number of points it collects. If both robots play \noptimally\n, return \nthe \nnumber of points\n collected by the \nsecond\n robot.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,5,4],[1,5,1]]\n\nOutput:\n 4\n\nExplanation:\n The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[3,3,1],[8,5,2]]\n\nOutput:\n 4\n\nExplanation:\n The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,3,1,15],[1,3,3,1]]\n\nOutput:\n 7\n\nExplanation: \nThe optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ngrid.length == 2\n\n\nn == grid[r].length\n\n\n1 <= n <= 5 * 10\n4\n\n\n1 <= grid[r][c] <= 10\n5",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2014,
    "slug": "longest-subsequence-repeated-k-times",
    "url": "https://leetcode.com/problems/longest-subsequence-repeated-k-times/",
    "titulo": "Longest Subsequence Repeated k Times",
    "enunciado": "You are given a string \ns\n of length \nn\n, and an integer \nk\n. You are tasked to find the \nlongest subsequence repeated\n \nk\n times in string \ns\n.\n\n\nA \nsubsequence\n is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n\nA subsequence \nseq\n is \nrepeated\n \nk\n times in the string \ns\n if \nseq * k\n is a subsequence of \ns\n, where \nseq * k\n represents a string constructed by concatenating \nseq\n \nk\n times.\n\n\n\n\nFor example, \n\"bba\"\n is repeated \n2\n times in the string \n\"bababcba\"\n, because the string \n\"bbabba\"\n, constructed by concatenating \n\"bba\"\n \n2\n times, is a subsequence of the string \n\"\nb\na\nbab\nc\nba\n\"\n.\n\n\n\n\nReturn \nthe \nlongest subsequence repeated\n \nk\n times in string \ns\n. If multiple such subsequences are found, return the \nlexicographically largest\n one. If there is no such subsequence, return an \nempty\n string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"letsleetcode\", k = 2\n\nOutput:\n \"let\"\n\nExplanation:\n There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n\"let\" is the lexicographically largest one.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bb\", k = 2\n\nOutput:\n \"b\"\n\nExplanation:\n The longest subsequence repeated 2 times is \"b\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"ab\", k = 2\n\nOutput:\n \"\"\n\nExplanation:\n There is no subsequence repeated 2 times. Empty string is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == s.length\n\n\n2 <= n, k <= 2000\n\n\n2 <= n < k * 8\n\n\ns\n consists of lowercase English letters.",
    "temas": [
      "String",
      "Backtracking",
      "Greedy",
      "Counting",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 2013,
    "slug": "detect-squares",
    "url": "https://leetcode.com/problems/detect-squares/",
    "titulo": "Detect Squares",
    "enunciado": "You are given a stream of points on the X-Y plane. Design an algorithm that:\n\n\n\n\nAdds\n new points from the stream into a data structure. \nDuplicate\n points are allowed and should be treated as different points.\n\n\nGiven a query point, \ncounts\n the number of ways to choose three points from the data structure such that the three points and the query point form an \naxis-aligned square\n with \npositive area\n.\n\n\n\n\nAn \naxis-aligned square\n is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\n\n\nImplement the \nDetectSquares\n class:\n\n\n\n\nDetectSquares()\n Initializes the object with an empty data structure.\n\n\nvoid add(int[] point)\n Adds a new point \npoint = [x, y]\n to the data structure.\n\n\nint count(int[] point)\n Counts the number of ways to form \naxis-aligned squares\n with point \npoint = [x, y]\n as described above.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n\nOutput\n\n[null, null, null, null, 1, 0, null, 2]\n\n\nExplanation\n\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // return 1. You can choose:\n                               //   - The first, second, and third points\ndetectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.\ndetectSquares.add([11, 2]);    // Adding duplicate points is allowed.\ndetectSquares.count([11, 10]); // return 2. You can choose:\n                               //   - The first, second, and third points\n                               //   - The first, third, and fourth points\n\n\n\n \n\n\nConstraints:\n\n\n\n\npoint.length == 2\n\n\n0 <= x, y <= 1000\n\n\nAt most \n3000\n calls \nin total\n will be made to \nadd\n and \ncount\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Design",
      "Counting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2022,
    "slug": "convert-1d-array-into-2d-array",
    "url": "https://leetcode.com/problems/convert-1d-array-into-2d-array/",
    "titulo": "Convert 1D Array Into 2D Array",
    "enunciado": "You are given a \n0-indexed\n 1-dimensional (1D) integer array \noriginal\n, and two integers, \nm\n and \nn\n. You are tasked with creating a 2-dimensional (2D) array with \n m\n rows and \nn\n columns using \nall\n the elements from \noriginal\n.\n\n\nThe elements from indices \n0\n to \nn - 1\n (\ninclusive\n) of \noriginal\n should form the first row of the constructed 2D array, the elements from indices \nn\n to \n2 * n - 1\n (\ninclusive\n) should form the second row of the constructed 2D array, and so on.\n\n\nReturn \nan \nm x n\n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n original = [1,2,3,4], m = 2, n = 2\n\nOutput:\n [[1,2],[3,4]]\n\nExplanation:\n The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\n\n\nExample 2:\n\n\n\n\nInput:\n original = [1,2,3], m = 1, n = 3\n\nOutput:\n [[1,2,3]]\n\nExplanation:\n The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\n\n\nExample 3:\n\n\n\n\nInput:\n original = [1,2], m = 1, n = 1\n\nOutput:\n []\n\nExplanation:\n There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= original.length <= 5 * 10\n4\n\n\n1 <= original[i] <= 10\n5\n\n\n1 <= m, n <= 4 * 10\n4",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2003,
    "slug": "smallest-missing-genetic-value-in-each-subtree",
    "url": "https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/",
    "titulo": "Smallest Missing Genetic Value in Each Subtree",
    "enunciado": "There is a \nfamily tree\n rooted at \n0\n consisting of \nn\n nodes numbered \n0\n to \nn - 1\n. You are given a \n0-indexed\n integer array \nparents\n, where \nparents[i]\n is the parent for node \ni\n. Since node \n0\n is the \nroot\n, \nparents[0] == -1\n.\n\n\nThere are \n10\n5\n genetic values, each represented by an integer in the \ninclusive\n range \n[1, 10\n5\n]\n. You are given a \n0-indexed\n integer array \nnums\n, where \nnums[i]\n is a \ndistinct \ngenetic value for node \ni\n.\n\n\nReturn \nan array \nans\n of length \nn\n where \nans[i]\n is\n \nthe \nsmallest\n genetic value that is \nmissing\n from the subtree rooted at node\n \ni\n.\n\n\nThe \nsubtree\n rooted at a node \nx\n contains node \nx\n and all of its \ndescendant\n nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n parents = [-1,0,0,2], nums = [1,2,3,4]\n\nOutput:\n [5,1,1,1]\n\nExplanation:\n The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.\n- 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.\n- 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.\n- 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n\nOutput:\n [7,1,1,4,2,1]\n\nExplanation:\n The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.\n- 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.\n- 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.\n- 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.\n- 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.\n- 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.\n\n\n\nExample 3:\n\n\n\n\nInput:\n parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n\nOutput:\n [1,1,1,1,1,1,1]\n\nExplanation:\n The value 1 is missing from all the subtrees.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parents.length == nums.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= parents[i] <= n - 1\n for \ni != 0\n\n\nparents[0] == -1\n\n\nparents\n represents a valid tree.\n\n\n1 <= nums[i] <= 10\n5\n\n\nEach \nnums[i]\n is distinct.",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Union Find"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 2002,
    "slug": "maximum-product-of-the-length-of-two-palindromic-subsequences",
    "url": "https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/",
    "titulo": "Maximum Product of the Length of Two Palindromic Subsequences",
    "enunciado": "Given a string \ns\n, find two \ndisjoint palindromic subsequences\n of \ns\n such that the \nproduct\n of their lengths is \nmaximized\n. The two subsequences are \ndisjoint\n if they do not both pick a character at the same index.\n\n\nReturn \nthe \nmaximum\n possible \nproduct\n of the lengths of the two palindromic subsequences\n.\n\n\nA \nsubsequence\n is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is \npalindromic\n if it reads the same forward and backward.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"leetcodecom\"\n\nOutput:\n 9\n\nExplanation\n: An optimal solution is to choose \"ete\" for the 1\nst\n subsequence and \"cdc\" for the 2\nnd\n subsequence.\nThe product of their lengths is: 3 * 3 = 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bb\"\n\nOutput:\n 1\n\nExplanation\n: An optimal solution is to choose \"b\" (the first character) for the 1\nst\n subsequence and \"b\" (the second character) for the 2\nnd\n subsequence.\nThe product of their lengths is: 1 * 1 = 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"accbcaxxcxx\"\n\nOutput:\n 25\n\nExplanation\n: An optimal solution is to choose \"accca\" for the 1\nst\n subsequence and \"xxcxx\" for the 2\nnd\n subsequence.\nThe product of their lengths is: 5 * 5 = 25.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 12\n\n\ns\n consists of lowercase English letters only.",
    "temas": [
      "String",
      "Dynamic Programming",
      "Backtracking",
      "Bit Manipulation",
      "Bitmask"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 1971,
    "slug": "find-if-path-exists-in-graph",
    "url": "https://leetcode.com/problems/find-if-path-exists-in-graph/",
    "titulo": "Find if Path Exists in Graph",
    "enunciado": "There is a \nbi-directional\n graph with \nn\n vertices, where each vertex is labeled from \n0\n to \nn - 1\n (\ninclusive\n). The edges in the graph are represented as a 2D integer array \nedges\n, where each \nedges[i] = [u\ni\n, v\ni\n]\n denotes a bi-directional edge between vertex \nu\ni\n and vertex \nv\ni\n. Every vertex pair is connected by \nat most one\n edge, and no vertex has an edge to itself.\n\n\nYou want to determine if there is a \nvalid path\n that exists from vertex \nsource\n to vertex \ndestination\n.\n\n\nGiven \nedges\n and the integers \nn\n, \nsource\n, and \ndestination\n, return \ntrue\n if there is a \nvalid path\n from \nsource\n to \ndestination\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\n\nOutput:\n true\n\nExplanation:\n There are two paths from vertex 0 to vertex 2:\n- 0 → 1 → 2\n- 0 → 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\n\nOutput:\n false\n\nExplanation:\n There is no path from vertex 0 to vertex 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n5\n\n\n0 <= edges.length <= 2 * 10\n5\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\nu\ni\n != v\ni\n\n\n0 <= source, destination <= n - 1\n\n\nThere are no duplicate edges.\n\n\nThere are no self edges.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1981,
    "slug": "minimize-the-difference-between-target-and-chosen-elements",
    "url": "https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/",
    "titulo": "Minimize the Difference Between Target and Chosen Elements",
    "enunciado": "You are given an \nm x n\n integer matrix \nmat\n and an integer \ntarget\n.\n\n\nChoose one integer from \neach row\n in the matrix such that the \nabsolute difference\n between \ntarget\n and the \nsum\n of the chosen elements is \nminimized\n.\n\n\nReturn \nthe \nminimum absolute difference\n.\n\n\nThe \nabsolute difference\n between two numbers \na\n and \nb\n is the absolute value of \na - b\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\n\nOutput:\n 0\n\nExplanation:\n One possible choice is to:\n- Choose 1 from the first row.\n- Choose 5 from the second row.\n- Choose 7 from the third row.\nThe sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[1],[2],[3]], target = 100\n\nOutput:\n 94\n\nExplanation:\n The best possible choice is to:\n- Choose 1 from the first row.\n- Choose 2 from the second row.\n- Choose 3 from the third row.\nThe sum of the chosen elements is 6, and the absolute difference is 94.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n mat = [[1,2,9,8,7]], target = 6\n\nOutput:\n 1\n\nExplanation:\n The best choice is to choose 7 from the first row.\nThe absolute difference is 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 70\n\n\n1 <= mat[i][j] <= 70\n\n\n1 <= target <= 800",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1993,
    "slug": "operations-on-tree",
    "url": "https://leetcode.com/problems/operations-on-tree/",
    "titulo": "Operations on Tree",
    "enunciado": "You are given a tree with \nn\n nodes numbered from \n0\n to \nn - 1\n in the form of a parent array \nparent\n where \nparent[i]\n is the parent of the \ni\nth\n node. The root of the tree is node \n0\n, so \nparent[0] = -1\n since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.\n\n\nThe data structure should support the following functions:\n\n\n\n\nLock:\n \nLocks\n the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n\n\nUnlock: Unlocks\n the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n\n\nUpgrade\n: Locks\n the given node for the given user and \nunlocks\n all of its descendants \nregardless\n of who locked it. You may only upgrade a node if \nall\n 3 conditions are true:\n\t\n\n\nThe node is unlocked,\n\n\nIt has at least one locked descendant (by \nany\n user), and\n\n\nIt does not have any locked ancestors.\n\n\n\n\n\n\n\n\nImplement the \nLockingTree\n class:\n\n\n\n\nLockingTree(int[] parent)\n initializes the data structure with the parent array.\n\n\nlock(int num, int user)\n returns \ntrue\n if it is possible for the user with id \nuser\n to lock the node \nnum\n, or \nfalse\n otherwise. If it is possible, the node \nnum\n will become\n locked\n by the user with id \nuser\n.\n\n\nunlock(int num, int user)\n returns \ntrue\n if it is possible for the user with id \nuser\n to unlock the node \nnum\n, or \nfalse\n otherwise. If it is possible, the node \nnum\n will become \nunlocked\n.\n\n\nupgrade(int num, int user)\n returns \ntrue\n if it is possible for the user with id \nuser\n to upgrade the node \nnum\n, or \nfalse\n otherwise. If it is possible, the node \nnum\n will be \nupgraded\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n\nOutput\n\n[null, true, false, true, true, true, false]\n\n\nExplanation\n\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                           // Node 2 will now be locked by user 2.\nlockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\nlockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                           // Node 2 will now be unlocked.\nlockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                           // Node 4 will now be locked by user 5.\nlockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\nlockingTree.lock(0, 1);    // return false because node 0 is already locked.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == parent.length\n\n\n2 <= n <= 2000\n\n\n0 <= parent[i] <= n - 1\n for \ni != 0\n\n\nparent[0] == -1\n\n\n0 <= num <= n - 1\n\n\n1 <= user <= 10\n4\n\n\nparent\n represents a valid tree.\n\n\nAt most \n2000\n calls \nin total\n will be made to \nlock\n, \nunlock\n, and \nupgrade\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1992,
    "slug": "find-all-groups-of-farmland",
    "url": "https://leetcode.com/problems/find-all-groups-of-farmland/",
    "titulo": "Find All Groups of Farmland",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n binary matrix \nland\n where a \n0\n represents a hectare of forested land and a \n1\n represents a hectare of farmland.\n\n\nTo keep the land organized, there are designated rectangular areas of hectares that consist \nentirely\n of farmland. These rectangular areas are called \ngroups\n. No two groups are adjacent, meaning farmland in one group is \nnot\n four-directionally adjacent to another farmland in a different group.\n\n\nland\n can be represented by a coordinate system where the top left corner of \nland\n is \n(0, 0)\n and the bottom right corner of \nland\n is \n(m-1, n-1)\n. Find the coordinates of the top left and bottom right corner of each \ngroup\n of farmland. A \ngroup\n of farmland with a top left corner at \n(r\n1\n, c\n1\n)\n and a bottom right corner at \n(r\n2\n, c\n2\n)\n is represented by the 4-length array \n[r\n1\n, c\n1\n, r\n2\n, c\n2\n].\n\n\nReturn \na 2D array containing the 4-length arrays described above for each \ngroup\n of farmland in \nland\n. If there are no groups of farmland, return an empty array. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n land = [[1,0,0],[0,1,1],[0,1,1]]\n\nOutput:\n [[0,0,0,0],[1,1,2,2]]\n\nExplanation:\n\nThe first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\nThe second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n land = [[1,1],[1,1]]\n\nOutput:\n [[0,0,1,1]]\n\nExplanation:\n\nThe first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n land = [[0]]\n\nOutput:\n []\n\nExplanation:\n\nThere are no groups of farmland.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == land.length\n\n\nn == land[i].length\n\n\n1 <= m, n <= 300\n\n\nland\n consists of only \n0\n's and \n1\n's.\n\n\nGroups of farmland are \nrectangular\n in shape.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1970,
    "slug": "last-day-where-you-can-still-cross",
    "url": "https://leetcode.com/problems/last-day-where-you-can-still-cross/",
    "titulo": "Last Day Where You Can Still Cross",
    "enunciado": "There is a \n1-based\n binary matrix where \n0\n represents land and \n1\n represents water. You are given integers \nrow\n and \ncol\n representing the number of rows and columns in the matrix, respectively.\n\n\nInitially on day \n0\n, the \nentire\n matrix is \nland\n. However, each day a new cell becomes flooded with \nwater\n. You are given a \n1-based\n 2D array \ncells\n, where \ncells[i] = [r\ni\n, c\ni\n]\n represents that on the \ni\nth\n day, the cell on the \nr\ni\nth\n row and \nc\ni\nth\n column (\n1-based\n coordinates) will be covered with \nwater\n (i.e., changed to \n1\n).\n\n\nYou want to find the \nlast\n day that it is possible to walk from the \ntop\n to the \nbottom\n by only walking on land cells. You can start from \nany\n cell in the top row and end at \nany\n cell in the bottom row. You can only travel in the\n four\n cardinal directions (left, right, up, and down).\n\n\nReturn \nthe \nlast\n day where it is possible to walk from the \ntop\n to the \nbottom\n by only walking on land cells\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\n\nOutput:\n 2\n\nExplanation:\n The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\n\nOutput:\n 1\n\nExplanation:\n The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\n\nOutput:\n 3\n\nExplanation:\n The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= row, col <= 2 * 10\n4\n\n\n4 <= row * col <= 2 * 10\n4\n\n\ncells.length == row * col\n\n\n1 <= r\ni\n <= row\n\n\n1 <= c\ni\n <= col\n\n\nAll the values of \ncells\n are \nunique\n.",
    "temas": [
      "Array",
      "Binary Search",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1976,
    "slug": "number-of-ways-to-arrive-at-destination",
    "url": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/",
    "titulo": "Number of Ways to Arrive at Destination",
    "enunciado": "You are in a city that consists of \nn\n intersections numbered from \n0\n to \nn - 1\n with \nbi-directional\n roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\n\nYou are given an integer \nn\n and a 2D integer array \nroads\n where \nroads[i] = [u\ni\n, v\ni\n, time\ni\n]\n means that there is a road between intersections \nu\ni\n and \nv\ni\n that takes \ntime\ni\n minutes to travel. You want to know in how many ways you can travel from intersection \n0\n to intersection \nn - 1\n in the \nshortest amount of time\n.\n\n\nReturn \nthe \nnumber of ways\n you can arrive at your destination in the \nshortest amount of time\n. Since the answer may be large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n\nOutput:\n 4\n\nExplanation:\n The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, roads = [[1,0,10]]\n\nOutput:\n 1\n\nExplanation:\n There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn - 1 <= roads.length <= n * (n - 1) / 2\n\n\nroads[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\n1 <= time\ni\n <= 10\n9\n\n\nu\ni \n!= v\ni\n\n\nThere is at most one road connecting any two intersections.\n\n\nYou can reach any intersection from any other intersection.",
    "temas": [
      "Dynamic Programming",
      "Graph",
      "Topological Sort",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1975,
    "slug": "maximum-matrix-sum",
    "url": "https://leetcode.com/problems/maximum-matrix-sum/",
    "titulo": "Maximum Matrix Sum",
    "enunciado": "You are given an \nn x n\n integer \nmatrix\n. You can do the following operation \nany\n number of times:\n\n\n\n\nChoose any two \nadjacent\n elements of \nmatrix\n and \nmultiply\n each of them by \n-1\n.\n\n\n\n\nTwo elements are considered \nadjacent\n if and only if they share a \nborder\n.\n\n\nYour goal is to \nmaximize\n the summation of the matrix's elements. Return \nthe \nmaximum\n sum of the matrix's elements using the operation mentioned above.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,-1],[-1,1]]\n\nOutput:\n 4\n\nExplanation:\n We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\n\nOutput:\n 16\n\nExplanation:\n We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n2 <= n <= 250\n\n\n-10\n5\n <= matrix[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Greedy",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1974,
    "slug": "minimum-time-to-type-word-using-special-typewriter",
    "url": "https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/",
    "titulo": "Minimum Time to Type Word Using Special Typewriter",
    "enunciado": "There is a special typewriter with lowercase English letters \n'a'\n to \n'z'\n arranged in a \ncircle\n with a \npointer\n. A character can \nonly\n be typed if the pointer is pointing to that character. The pointer is \ninitially\n pointing to the character \n'a'\n.\n\n\n\n\nEach second, you may perform one of the following operations:\n\n\n\n\nMove the pointer one character \ncounterclockwise\n or \nclockwise\n.\n\n\nType the character the pointer is \ncurrently\n on.\n\n\n\n\nGiven a string \nword\n, return the\n minimum\n number of seconds to type out the characters in \nword\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"abc\"\n\nOutput:\n 5\n\nExplanation: \n\nThe characters are printed as follows:\n- Type the character 'a' in 1 second since the pointer is initially on 'a'.\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer clockwise to 'c' in 1 second.\n- Type the character 'c' in 1 second.\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"bza\"\n\nOutput:\n 7\n\nExplanation:\n\nThe characters are printed as follows:\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer counterclockwise to 'z' in 2 seconds.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'a' in 1 second.\n- Type the character 'a' in 1 second.\n\n\n\nExample 3:\n\n\n\n\nInput:\n word = \"zjpc\"\n\nOutput:\n 34\n\nExplanation:\n\nThe characters are printed as follows:\n- Move the pointer counterclockwise to 'z' in 1 second.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'j' in 10 seconds.\n- Type the character 'j' in 1 second.\n- Move the pointer clockwise to 'p' in 6 seconds.\n- Type the character 'p' in 1 second.\n- Move the pointer counterclockwise to 'c' in 13 seconds.\n- Type the character 'c' in 1 second.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 100\n\n\nword\n consists of lowercase English letters.",
    "temas": [
      "String",
      "Greedy"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 1958,
    "slug": "check-if-move-is-legal",
    "url": "https://leetcode.com/problems/check-if-move-is-legal/",
    "titulo": "Check if Move is Legal",
    "enunciado": "You are given a \n0-indexed\n \n8 x 8\n grid \nboard\n, where \nboard[r][c]\n represents the cell \n(r, c)\n on a game board. On the board, free cells are represented by \n'.'\n, white cells are represented by \n'W'\n, and black cells are represented by \n'B'\n.\n\n\nEach move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only \nlegal\n if, after changing it, the cell becomes the \nendpoint of a good line\n (horizontal, vertical, or diagonal).\n\n\nA \ngood line\n is a line of \nthree or more cells (including the endpoints)\n where the endpoints of the line are \none color\n, and the remaining cells in the middle are the \nopposite color\n (no cells in the line are free). You can find examples for good lines in the figure below:\n\n\n\n\nGiven two integers \nrMove\n and \ncMove\n and a character \ncolor\n representing the color you are playing as (white or black), return \ntrue\n \nif changing cell \n(rMove, cMove)\n \nto color\n \ncolor\n \nis a \nlegal\n move, or \nfalse\n if it is not legal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n\nOutput:\n true\n\nExplanation:\n '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.\nThe two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n\nOutput:\n false\n\nExplanation:\n While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == board[r].length == 8\n\n\n0 <= rMove, cMove < 8\n\n\nboard[rMove][cMove] == '.'\n\n\ncolor\n is either \n'B'\n or \n'W'\n.",
    "temas": [
      "Array",
      "Matrix",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1948,
    "slug": "delete-duplicate-folders-in-system",
    "url": "https://leetcode.com/problems/delete-duplicate-folders-in-system/",
    "titulo": "Delete Duplicate Folders in System",
    "enunciado": "Due to a bug, there are many duplicate folders in a file system. You are given a 2D array \npaths\n, where \npaths[i]\n is an array representing an absolute path to the \ni\nth\n folder in the file system.\n\n\n\n\nFor example, \n[\"one\", \"two\", \"three\"]\n represents the path \n\"/one/two/three\"\n.\n\n\n\n\nTwo folders (not necessarily on the same level) are \nidentical\n if they contain the \nsame non-empty\n set of identical subfolders and underlying subfolder structure. The folders \ndo not\n need to be at the root level to be identical. If two or more folders are \nidentical\n, then \nmark\n the folders as well as all their subfolders.\n\n\n\n\nFor example, folders \n\"/a\"\n and \n\"/b\"\n in the file structure below are identical. They (as well as their subfolders) should \nall\n be marked:\n\n\t\n\n\n/a\n\n\n/a/x\n\n\n/a/x/y\n\n\n/a/z\n\n\n/b\n\n\n/b/x\n\n\n/b/x/y\n\n\n/b/z\n\n\n\n\n\n\nHowever, if the file structure also included the path \n\"/b/w\"\n, then the folders \n\"/a\"\n and \n\"/b\"\n would not be identical. Note that \n\"/a/x\"\n and \n\"/b/x\"\n would still be considered identical even with the added folder.\n\n\n\n\nOnce all the identical folders and their subfolders have been marked, the file system will \ndelete\n all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.\n\n\nReturn \nthe 2D array \nans\n \ncontaining the paths of the \nremaining\n folders after deleting all the marked folders. The paths may be returned in \nany\n order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n\nOutput:\n [[\"d\"],[\"d\",\"a\"]]\n\nExplanation:\n The file structure is as shown.\nFolders \"/a\" and \"/c\" (and their subfolders) are marked for deletion because they both contain an empty\nfolder named \"b\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n\nOutput:\n [[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n\nExplanation: \nThe file structure is as shown. \nFolders \"/a/b/x\" and \"/w\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"y\".\nNote that folders \"/a\" and \"/c\" are identical after the deletion, but they are not deleted because they were not marked beforehand.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n\nOutput:\n [[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n\nExplanation:\n All folders are unique in the file system.\nNote that the returned array can be in a different order as the order does not matter.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= paths.length <= 2 * 10\n4\n\n\n1 <= paths[i].length <= 500\n\n\n1 <= paths[i][j].length <= 10\n\n\n1 <= sum(paths[i][j].length) <= 2 * 10\n5\n\n\npath[i][j]\n consists of lowercase English letters.\n\n\nNo two paths lead to the same folder.\n\n\nFor any folder not at the root level, its parent folder will also be in the input.",
    "temas": [
      "Array",
      "Hash Table",
      "String",
      "Trie",
      "Hash Function"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1938,
    "slug": "maximum-genetic-difference-query",
    "url": "https://leetcode.com/problems/maximum-genetic-difference-query/",
    "titulo": "Maximum Genetic Difference Query",
    "enunciado": "There is a rooted tree consisting of \nn\n nodes numbered \n0\n to \nn - 1\n. Each node's number denotes its \nunique genetic value\n (i.e. the genetic value of node \nx\n is \nx\n). The \ngenetic difference\n between two genetic values is defined as the \nbitwise-\nXOR\n of their values. You are given the integer array \nparents\n, where \nparents[i]\n is the parent for node \ni\n. If node \nx\n is the \nroot\n of the tree, then \nparents[x] == -1\n.\n\n\nYou are also given the array \nqueries\n where \nqueries[i] = [node\ni\n, val\ni\n]\n. For each query \ni\n, find the \nmaximum genetic difference\n between \nval\ni\n and \np\ni\n, where \np\ni\n is the genetic value of any node that is on the path between \nnode\ni\n and the root (including \nnode\ni\n and the root). More formally, you want to maximize \nval\ni\n XOR p\ni\n.\n\n\nReturn \nan array \nans\n where \nans[i]\n is the answer to the \ni\nth\n query\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n\nOutput:\n [2,3,7]\n\nExplanation: \nThe queries are processed as follows:\n- [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.\n- [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.\n- [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n\nOutput:\n [6,14,7]\n\nExplanation: \nThe queries are processed as follows:\n- [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.\n- [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.\n- [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= parents.length <= 10\n5\n\n\n0 <= parents[i] <= parents.length - 1\n for every node \ni\n that is \nnot\n the root.\n\n\nparents[root] == -1\n\n\n1 <= queries.length <= 3 * 10\n4\n\n\n0 <= node\ni\n <= parents.length - 1\n\n\n0 <= val\ni\n <= 2 * 10\n5",
    "temas": [
      "Array",
      "Hash Table",
      "Bit Manipulation",
      "Depth-First Search",
      "Trie"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1937,
    "slug": "maximum-number-of-points-with-cost",
    "url": "https://leetcode.com/problems/maximum-number-of-points-with-cost/",
    "titulo": "Maximum Number of Points with Cost",
    "enunciado": "You are given an \nm x n\n integer matrix \npoints\n (\n0-indexed\n). Starting with \n0\n points, you want to \nmaximize\n the number of points you can get from the matrix.\n\n\nTo gain points, you must pick one cell in \neach row\n. Picking the cell at coordinates \n(r, c)\n will \nadd\n \npoints[r][c]\n to your score.\n\n\nHowever, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows \nr\n and \nr + 1\n (where \n0 <= r < m - 1\n), picking cells at coordinates \n(r, c\n1\n)\n and \n(r + 1, c\n2\n)\n will \nsubtract\n \nabs(c\n1\n - c\n2\n)\n from your score.\n\n\nReturn \nthe \nmaximum\n number of points you can achieve\n.\n\n\nabs(x)\n is defined as:\n\n\n\n\nx\n for \nx >= 0\n.\n\n\n-x\n for \nx < 0\n.\n\n\n\n\n \n\n\nExample 1:\n \n\n\n\n\n\n\nInput:\n points = [[1,2,3],[1,5,1],[3,1,1]]\n\nOutput:\n 9\n\nExplanation:\n\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[1,5],[2,3],[4,2]]\n\nOutput:\n 11\n\nExplanation:\n\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == points.length\n\n\nn == points[r].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n0 <= points[r][c] <= 10\n5",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1931,
    "slug": "painting-a-grid-with-three-different-colors",
    "url": "https://leetcode.com/problems/painting-a-grid-with-three-different-colors/",
    "titulo": "Painting a Grid With Three Different Colors",
    "enunciado": "You are given two integers \nm\n and \nn\n. Consider an \nm x n\n grid where each cell is initially white. You can paint each cell \nred\n, \ngreen\n, or \nblue\n. All cells \nmust\n be painted.\n\n\nReturn\n the number of ways to color the grid with \nno two adjacent cells having the same color\n. Since the answer can be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 1, n = 1\n\nOutput:\n 3\n\nExplanation:\n The three possible colorings are shown in the image above.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 1, n = 2\n\nOutput:\n 6\n\nExplanation:\n The six possible colorings are shown in the image above.\n\n\n\nExample 3:\n\n\n\n\nInput:\n m = 5, n = 5\n\nOutput:\n 580986\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m <= 5\n\n\n1 <= n <= 1000",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1932,
    "slug": "merge-bsts-to-create-single-bst",
    "url": "https://leetcode.com/problems/merge-bsts-to-create-single-bst/",
    "titulo": "Merge BSTs to Create Single BST",
    "enunciado": "You are given \nn\n \nBST (binary search tree) root nodes\n for \nn\n separate BSTs stored in an array \ntrees\n (\n0-indexed\n). Each BST in \ntrees\n has \nat most 3 nodes\n, and no two roots have the same value. In one operation, you can:\n\n\n\n\nSelect two \ndistinct\n indices \ni\n and \nj\n such that the value stored at one of the \nleaves \nof \ntrees[i]\n is equal to the \nroot value\n of \ntrees[j]\n.\n\n\nReplace the leaf node in \ntrees[i]\n with \ntrees[j]\n.\n\n\nRemove \ntrees[j]\n from \ntrees\n.\n\n\n\n\nReturn\n the \nroot\n of the resulting BST if it is possible to form a valid BST after performing \nn - 1\n operations, or\n \nnull\n \nif it is impossible to create a valid BST\n.\n\n\nA BST (binary search tree) is a binary tree where each node satisfies the following property:\n\n\n\n\nEvery node in the node's left subtree has a value \nstrictly less\n than the node's value.\n\n\nEvery node in the node's right subtree has a value \nstrictly greater\n than the node's value.\n\n\n\n\nA leaf is a node that has no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n trees = [[2,1],[3,2,5],[5,4]]\n\nOutput:\n [3,2,5,1,null,4]\n\nExplanation:\n\nIn the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].\nDelete trees[0], so trees = [[3,2,5,1],[5,4]].\n\n\nIn the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[3,2,5,1,null,4]].\n\n\nThe resulting tree, shown above, is a valid BST, so return its root.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n trees = [[5,3,8],[3,2,6]]\n\nOutput:\n []\n\nExplanation:\n\nPick i=0 and j=1 and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[5,3,8,2,6]].\n\n\nThe resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n trees = [[5,4],[3]]\n\nOutput:\n []\n\nExplanation:\n It is impossible to perform any operations.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == trees.length\n\n\n1 <= n <= 5 * 10\n4\n\n\nThe number of nodes in each tree is in the range \n[1, 3]\n.\n\n\nEach node in the input may have children but no grandchildren.\n\n\nNo two roots of \ntrees\n have the same value.\n\n\nAll the trees in the input are \nvalid BSTs\n.\n\n\n1 <= TreeNode.val <= 5 * 10\n4\n.",
    "temas": [
      "Hash Table",
      "Binary Search",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1943,
    "slug": "describe-the-painting",
    "url": "https://leetcode.com/problems/describe-the-painting/",
    "titulo": "Describe the Painting",
    "enunciado": "There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a \nunique\n color. You are given a 2D integer array \nsegments\n, where \nsegments[i] = [start\ni\n, end\ni\n, color\ni\n]\n represents the \nhalf-closed segment\n \n[start\ni\n, end\ni\n)\n with \ncolor\ni\n as the color.\n\n\nThe colors in the overlapping segments of the painting were \nmixed\n when it was painted. When two or more colors mix, they form a new color that can be represented as a \nset\n of mixed colors.\n\n\n\n\nFor example, if colors \n2\n, \n4\n, and \n6\n are mixed, then the resulting mixed color is \n{2,4,6}\n.\n\n\n\n\nFor the sake of simplicity, you should only output the \nsum\n of the elements in the set rather than the full set.\n\n\nYou want to \ndescribe\n the painting with the \nminimum\n number of non-overlapping \nhalf-closed segments\n of these mixed colors. These segments can be represented by the 2D array \npainting\n where \npainting[j] = [left\nj\n, right\nj\n, mix\nj\n]\n describes a \nhalf-closed segment\n \n[left\nj\n, right\nj\n)\n with the mixed color \nsum\n of \nmix\nj\n.\n\n\n\n\nFor example, the painting created with \nsegments = [[1,4,5],[1,7,7]]\n can be described by \npainting = [[1,4,12],[4,7,7]]\n because:\n\n\t\n\n\n[1,4)\n is colored \n{5,7}\n (with a sum of \n12\n) from both the first and second segments.\n\n\n[4,7)\n is colored \n{7}\n from only the second segment.\n\n\n\n\n\n\n\n\nReturn \nthe 2D array \npainting\n describing the finished painting (excluding any parts that are \nnot \npainted). You may return the segments in \nany order\n.\n\n\nA \nhalf-closed segment\n \n[a, b)\n is the section of the number line between points \na\n and \nb\n \nincluding\n point \na\n and \nnot including\n point \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n segments = [[1,4,5],[4,7,7],[1,7,9]]\n\nOutput:\n [[1,4,14],[4,7,16]]\n\nExplanation: \nThe painting can be described as follows:\n- [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n- [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n segments = [[1,7,9],[6,8,15],[8,10,7]]\n\nOutput:\n [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n\nExplanation: \nThe painting can be described as follows:\n- [1,6) is colored 9 from the first segment.\n- [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n- [7,8) is colored 15 from the second segment.\n- [8,10) is colored 7 from the third segment.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n\nOutput:\n [[1,4,12],[4,7,12]]\n\nExplanation: \nThe painting can be described as follows:\n- [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n- [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\nNote that returning a single segment [1,7) is incorrect because the mixed color sets are different.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= segments.length <= 2 * 10\n4\n\n\nsegments[i].length == 3\n\n\n1 <= start\ni\n < end\ni\n <= 10\n5\n\n\n1 <= color\ni\n <= 10\n9\n\n\nEach \ncolor\ni\n is distinct.",
    "temas": [
      "Array",
      "Hash Table",
      "Sorting",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1901,
    "slug": "find-a-peak-element-ii",
    "url": "https://leetcode.com/problems/find-a-peak-element-ii/",
    "titulo": "Find a Peak Element II",
    "enunciado": "A \npeak\n element in a 2D grid is an element that is \nstrictly greater\n than all of its \nadjacent \nneighbors to the left, right, top, and bottom.\n\n\nGiven a \n0-indexed\n \nm x n\n matrix \nmat\n where \nno two adjacent cells are equal\n, find \nany\n peak element \nmat[i][j]\n and return \nthe length 2 array \n[i,j]\n.\n\n\nYou may assume that the entire matrix is surrounded by an \nouter perimeter\n with the value \n-1\n in each cell.\n\n\nYou must write an algorithm that runs in \nO(m log(n))\n or \nO(n log(m))\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,4],[3,2]]\n\nOutput:\n [0,1]\n\nExplanation:\n Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[10,20,15],[21,30,14],[7,16,32]]\n\nOutput:\n [1,1]\n\nExplanation:\n Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 500\n\n\n1 <= mat[i][j] <= 10\n5\n\n\nNo two adjacent cells are equal.",
    "temas": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1914,
    "slug": "cyclically-rotating-a-grid",
    "url": "https://leetcode.com/problems/cyclically-rotating-a-grid/",
    "titulo": "Cyclically Rotating a Grid",
    "enunciado": "You are given an \nm x n\n integer matrix \ngrid\n​​​, where \nm\n and \nn\n are both \neven\n integers, and an integer \nk\n.\n\n\nThe matrix is composed of several layers, which is shown in the below image, where each color is its own layer:\n\n\n\n\nA cyclic rotation of the matrix is done by cyclically rotating \neach layer\n in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the \ncounter-clockwise\n direction. An example rotation is shown below:\n\n\n\n\nReturn \nthe matrix after applying \nk\n \ncyclic rotations to it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n grid = [[40,10],[30,20]], k = 1\r\n\nOutput:\n [[10,20],[40,30]]\r\n\nExplanation:\n The figures above represent the grid at every state.\r\n\n\n\nExample 2:\n\n\n \n \n\n\n\r\n\nInput:\n grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\r\n\nOutput:\n [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\r\n\nExplanation:\n The figures above represent the grid at every state.\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 50\n\n\nBoth \nm\n and \nn\n are \neven\n integers.\n\n\n1 <= grid[i][j] <=\n \n5000\n\n\n1 <= k <= 10\n9",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1928,
    "slug": "minimum-cost-to-reach-destination-in-time",
    "url": "https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/",
    "titulo": "Minimum Cost to Reach Destination in Time",
    "enunciado": "There is a country of \nn\n cities numbered from \n0\n to \nn - 1\n where \nall the cities are connected\n by bi-directional roads. The roads are represented as a 2D integer array \nedges\n where \nedges[i] = [x\ni\n, y\ni\n, time\ni\n]\n denotes a road between cities \nx\ni\n and \ny\ni\n that takes \ntime\ni\n minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a \n0-indexed\n integer array \npassingFees\n of length \nn\n where \npassingFees[j]\n is the amount of dollars you must pay when you pass through city \nj\n.\n\n\nIn the beginning, you are at city \n0\n and want to reach city \nn - 1\n in \nmaxTime\n minutes or less\n. The \ncost\n of your journey is the \nsummation of passing fees\n for each city that you passed through at some moment of your journey (\nincluding\n the source and destination cities).\n\n\nGiven \nmaxTime\n, \nedges\n, and \npassingFees\n, return \nthe \nminimum cost\n to complete your journey, or \n-1\n if you cannot complete it within \nmaxTime\n minutes\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n\nOutput:\n 11\n\nExplanation:\n The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n\nOutput:\n 48\n\nExplanation:\n The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n\n\nExample 3:\n\n\n\n\nInput:\n maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n\nOutput:\n -1\n\nExplanation:\n There is no way to reach city 5 from city 0 within 25 minutes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= maxTime <= 1000\n\n\nn == passingFees.length\n\n\n2 <= n <= 1000\n\n\nn - 1 <= edges.length <= 1000\n\n\n0 <= x\ni\n, y\ni\n <= n - 1\n\n\n1 <= time\ni\n <= 1000\n\n\n1 <= passingFees[j] <= 1000\n \n\n\nThe graph may contain multiple edges between two nodes.\n\n\nThe graph does not contain self loops.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1926,
    "slug": "nearest-exit-from-entrance-in-maze",
    "url": "https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/",
    "titulo": "Nearest Exit from Entrance in Maze",
    "enunciado": "You are given an \nm x n\n matrix \nmaze\n (\n0-indexed\n) with empty cells (represented as \n'.'\n) and walls (represented as \n'+'\n). You are also given the \nentrance\n of the maze, where \nentrance = [entrance\nrow\n, entrance\ncol\n]\n denotes the row and column of the cell you are initially standing at.\n\n\nIn one step, you can move one cell \nup\n, \ndown\n, \nleft\n, or \nright\n. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the \nnearest exit\n from the \nentrance\n. An \nexit\n is defined as an \nempty cell\n that is at the \nborder\n of the \nmaze\n. The \nentrance\n \ndoes not count\n as an exit.\n\n\nReturn \nthe \nnumber of steps\n in the shortest path from the \nentrance\n to the nearest exit, or \n-1\n if no such path exists\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n\nOutput:\n 1\n\nExplanation:\n There are 3 exits in this maze at [1,0], [0,2], and [2,3].\nInitially, you are at the entrance cell [1,2].\n- You can reach [1,0] by moving 2 steps left.\n- You can reach [0,2] by moving 1 step up.\nIt is impossible to reach [2,3] from the entrance.\nThus, the nearest exit is [0,2], which is 1 step away.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n\nOutput:\n 2\n\nExplanation:\n There is 1 exit in this maze at [1,2].\n[1,0] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell [1,0].\n- You can reach [1,2] by moving 2 steps right.\nThus, the nearest exit is [1,2], which is 2 steps away.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n maze = [[\".\",\"+\"]], entrance = [0,0]\n\nOutput:\n -1\n\nExplanation:\n There are no exits in this maze.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nmaze.length == m\n\n\nmaze[i].length == n\n\n\n1 <= m, n <= 100\n\n\nmaze[i][j]\n is either \n'.'\n or \n'+'\n.\n\n\nentrance.length == 2\n\n\n0 <= entrance\nrow\n < m\n\n\n0 <= entrance\ncol\n < n\n\n\nentrance\n will always be an empty cell.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1905,
    "slug": "count-sub-islands",
    "url": "https://leetcode.com/problems/count-sub-islands/",
    "titulo": "Count Sub Islands",
    "enunciado": "You are given two \nm x n\n binary matrices \ngrid1\n and \ngrid2\n containing only \n0\n's (representing water) and \n1\n's (representing land). An \nisland\n is a group of \n1\n's connected \n4-directionally\n (horizontal or vertical). Any cells outside of the grid are considered water cells.\n\n\nAn island in \ngrid2\n is considered a \nsub-island \nif there is an island in \ngrid1\n that contains \nall\n the cells that make up \nthis\n island in \ngrid2\n.\n\n\nReturn the \nnumber\n of islands in \ngrid2\n \nthat are considered \nsub-islands\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n\nOutput:\n 3\n\nExplanation: \nIn the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n\nOutput:\n 2 \n\nExplanation: \nIn the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid1.length == grid2.length\n\n\nn == grid1[i].length == grid2[i].length\n\n\n1 <= m, n <= 500\n\n\ngrid1[i][j]\n and \ngrid2[i][j]\n are either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1886,
    "slug": "determine-whether-matrix-can-be-obtained-by-rotation",
    "url": "https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
    "titulo": "Determine Whether Matrix Can Be Obtained By Rotation",
    "enunciado": "Given two \nn x n\n binary matrices \nmat\n and \ntarget\n, return \ntrue\n if it is possible to make \nmat\n equal to \ntarget\n by \nrotating\n \nmat\n in \n90-degree increments\n, or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n\nOutput:\n true\n\nExplanation: \nWe can rotate mat 90 degrees clockwise to make mat equal target.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n It is impossible to make mat equal to target by rotating mat.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n\nOutput:\n true\n\nExplanation: \nWe can rotate mat 90 degrees clockwise two times to make mat equal target.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == mat.length == target.length\n\n\nn == mat[i].length == target[i].length\n\n\n1 <= n <= 10\n\n\nmat[i][j]\n and \ntarget[i][j]\n are either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1878,
    "slug": "get-biggest-three-rhombus-sums-in-a-grid",
    "url": "https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/",
    "titulo": "Get Biggest Three Rhombus Sums in a Grid",
    "enunciado": "You are given an \nm x n\n integer matrix \ngrid\n​​​.\n\n\nA \nrhombus sum\n is the sum of the elements that form \nthe\n \nborder\n of a regular rhombus shape in \ngrid\n​​​. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each \nrhombus sum\n:\n\n\n\n\nNote that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.\n\n\nReturn \nthe biggest three \ndistinct rhombus sums\n in the \ngrid\n in \ndescending order\n. If there are less than three distinct values, return all of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n\nOutput:\n [228,216,211]\n\nExplanation:\n The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 20 + 3 + 200 + 5 = 228\n- Red: 200 + 2 + 10 + 4 = 216\n- Green: 5 + 200 + 4 + 2 = 211\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [20,9,8]\n\nExplanation:\n The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 4 + 2 + 6 + 8 = 20\n- Red: 9 (area 0 rhombus in the bottom right corner)\n- Green: 8 (area 0 rhombus in the bottom middle)\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[7,7,7]]\n\nOutput:\n [7]\n\nExplanation:\n All three possible rhombus sums are the same, so return [7].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n1 <= grid[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Math",
      "Sorting",
      "Heap (Priority Queue)",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1857,
    "slug": "largest-color-value-in-a-directed-graph",
    "url": "https://leetcode.com/problems/largest-color-value-in-a-directed-graph/",
    "titulo": "Largest Color Value in a Directed Graph",
    "enunciado": "There is a \ndirected graph\n of \nn\n colored nodes and \nm\n edges. The nodes are numbered from \n0\n to \nn - 1\n.\n\n\nYou are given a string \ncolors\n where \ncolors[i]\n is a lowercase English letter representing the \ncolor\n of the \ni\nth\n node in this graph (\n0-indexed\n). You are also given a 2D array \nedges\n where \nedges[j] = [a\nj\n, b\nj\n]\n indicates that there is a \ndirected edge\n from node \na\nj\n to node \nb\nj\n.\n\n\nA valid \npath\n in the graph is a sequence of nodes \nx\n1\n -> x\n2\n -> x\n3\n -> ... -> x\nk\n such that there is a directed edge from \nx\ni\n to \nx\ni+1\n for every \n1 <= i < k\n. The \ncolor value\n of the path is the number of nodes that are colored the \nmost frequently\n occurring color along that path.\n\n\nReturn \nthe \nlargest color value\n of any valid path in the given graph, or \n-1\n if the graph contains a cycle\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n\nOutput:\n 3\n\nExplanation:\n The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \n\"a\" (red in the above image)\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n colors = \"a\", edges = [[0,0]]\n\nOutput:\n -1\n\nExplanation:\n There is a cycle from 0 to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == colors.length\n\n\nm == edges.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= m <= 10\n5\n\n\ncolors\n consists of lowercase English letters.\n\n\n0 <= a\nj\n, b\nj\n < n",
    "temas": [
      "Hash Table",
      "Dynamic Programming",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Counting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1861,
    "slug": "rotating-the-box",
    "url": "https://leetcode.com/problems/rotating-the-box/",
    "titulo": "Rotating the Box",
    "enunciado": "You are given an \nm x n\n matrix of characters \nboxGrid\n representing a side-view of a box. Each cell of the box is one of the following:\n\n\n\n\nA stone \n'#'\n\n\nA stationary obstacle \n'*'\n\n\nEmpty \n'.'\n\n\n\n\nThe box is rotated \n90 degrees clockwise\n, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity \ndoes not\n affect the obstacles' positions, and the inertia from the box's rotation \ndoes not \naffect the stones' horizontal positions.\n\n\nIt is \nguaranteed\n that each stone in \nboxGrid\n rests on an obstacle, another stone, or the bottom of the box.\n\n\nReturn \nan \nn x m\n matrix representing the box after the rotation described above\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n boxGrid = [[\"#\",\".\",\"#\"]]\n\nOutput:\n [[\".\"],\n         [\"#\"],\n         [\"#\"]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n boxGrid = [[\"#\",\".\",\"*\",\".\"],\n              [\"#\",\"#\",\"*\",\".\"]]\n\nOutput:\n [[\"#\",\".\"],\n         [\"#\",\"#\"],\n         [\"*\",\"*\"],\n         [\".\",\".\"]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n boxGrid = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\n              [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\n              [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\n\nOutput:\n [[\".\",\"#\",\"#\"],\n         [\".\",\"#\",\"#\"],\n         [\"#\",\"#\",\"*\"],\n         [\"#\",\"*\",\".\"],\n         [\"#\",\".\",\"*\"],\n         [\"#\",\".\",\".\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == boxGrid.length\n\n\nn == boxGrid[i].length\n\n\n1 <= m, n <= 500\n\n\nboxGrid[i][j]\n is either \n'#'\n, \n'*'\n, or \n'.'\n.",
    "temas": [
      "Array",
      "Two Pointers",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1840,
    "slug": "maximum-building-height",
    "url": "https://leetcode.com/problems/maximum-building-height/",
    "titulo": "Maximum Building Height",
    "enunciado": "You want to build \nn\n new buildings in a city. The new buildings will be built in a line and are labeled from \n1\n to \nn\n.\n\n\nHowever, there are city restrictions on the heights of the new buildings:\n\n\n\n\nThe height of each building must be a non-negative integer.\n\n\nThe height of the first building \nmust\n be \n0\n.\n\n\nThe height difference between any two adjacent buildings \ncannot exceed\n \n1\n.\n\n\n\n\nAdditionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array \nrestrictions\n where \nrestrictions[i] = [id\ni\n, maxHeight\ni\n]\n indicates that building \nid\ni\n must have a height \nless than or equal to\n \nmaxHeight\ni\n.\n\n\nIt is guaranteed that each building will appear \nat most once\n in \nrestrictions\n, and building \n1\n will \nnot\n be in \nrestrictions\n.\n\n\nReturn \nthe \nmaximum possible height\n of the \ntallest\n building\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, restrictions = [[2,1],[4,1]]\n\nOutput:\n 2\n\nExplanation:\n The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, restrictions = []\n\nOutput:\n 5\n\nExplanation:\n The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]\n\nOutput:\n 5\n\nExplanation:\n The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n9\n\n\n0 <= restrictions.length <= min(n - 1, 10\n5\n)\n\n\n2 <= id\ni\n <= n\n\n\nid\ni\n is \nunique\n.\n\n\n0 <= maxHeight\ni\n <= 10\n9",
    "temas": [
      "Array",
      "Math",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1824,
    "slug": "minimum-sideway-jumps",
    "url": "https://leetcode.com/problems/minimum-sideway-jumps/",
    "titulo": "Minimum Sideway Jumps",
    "enunciado": "There is a \n3 lane road\n of length \nn\n that consists of \nn + 1\n \npoints\n labeled from \n0\n to \nn\n. A frog \nstarts\n at point \n0\n in the \nsecond \nlane\n \nand wants to jump to point \nn\n. However, there could be obstacles along the way.\n\n\nYou are given an array \nobstacles\n of length \nn + 1\n where each \nobstacles[i]\n (\nranging from 0 to 3\n) describes an obstacle on the lane \nobstacles[i]\n at point \ni\n. If \nobstacles[i] == 0\n, there are no obstacles at point \ni\n. There will be \nat most one\n obstacle in the 3 lanes at each point.\n\n\n\n\nFor example, if \nobstacles[2] == 1\n, then there is an obstacle on lane 1 at point 2.\n\n\n\n\nThe frog can only travel from point \ni\n to point \ni + 1\n on the same lane if there is not an obstacle on the lane at point \ni + 1\n. To avoid obstacles, the frog can also perform a \nside jump\n to jump to \nanother\n lane (even if they are not adjacent) at the \nsame\n point if there is no obstacle on the new lane.\n\n\n\n\nFor example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\n\n\n\nReturn\n the \nminimum number of side jumps\n the frog needs to reach \nany lane\n at point n starting from lane \n2\n at point 0.\n\n\nNote:\n There will be no obstacles on points \n0\n and \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n obstacles = [0,1,2,3,0]\n\nOutput:\n 2 \n\nExplanation:\n The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n obstacles = [0,1,1,3,3,0]\n\nOutput:\n 0\n\nExplanation:\n There are no obstacles on lane 2. No side jumps are required.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n obstacles = [0,2,1,0,3,0]\n\nOutput:\n 2\n\nExplanation:\n The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nobstacles.length == n + 1\n\n\n1 <= n <= 5 * 10\n5\n\n\n0 <= obstacles[i] <= 3\n\n\nobstacles[0] == obstacles[n] == 0",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1823,
    "slug": "find-the-winner-of-the-circular-game",
    "url": "https://leetcode.com/problems/find-the-winner-of-the-circular-game/",
    "titulo": "Find the Winner of the Circular Game",
    "enunciado": "There are \nn\n friends that are playing a game. The friends are sitting in a circle and are numbered from \n1\n to \nn\n in \nclockwise order\n. More formally, moving clockwise from the \ni\nth\n friend brings you to the \n(i+1)\nth\n friend for \n1 <= i < n\n, and moving clockwise from the \nn\nth\n friend brings you to the \n1\nst\n friend.\n\n\nThe rules of the game are as follows:\n\n\n\n\nStart\n at the \n1\nst\n friend.\n\n\nCount the next \nk\n friends in the clockwise direction \nincluding\n the friend you started at. The counting wraps around the circle and may count some friends more than once.\n\n\nThe last friend you counted leaves the circle and loses the game.\n\n\nIf there is still more than one friend in the circle, go back to step \n2\n \nstarting\n from the friend \nimmediately clockwise\n of the friend who just lost and repeat.\n\n\nElse, the last friend in the circle wins the game.\n\n\n\n\nGiven the number of friends, \nn\n, and an integer \nk\n, return \nthe winner of the game\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, k = 2\n\nOutput:\n 3\n\nExplanation:\n Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.\n\n\nExample 2:\n\n\n\n\nInput:\n n = 6, k = 5\n\nOutput:\n 1\n\nExplanation:\n The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 500\n\n\n\n\n \n\n\nFollow up:\n\n\nCould you solve this problem in linear time with constant space?",
    "temas": [
      "Array",
      "Math",
      "Recursion",
      "Queue",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1819,
    "slug": "number-of-different-subsequences-gcds",
    "url": "https://leetcode.com/problems/number-of-different-subsequences-gcds/",
    "titulo": "Number of Different Subsequences GCDs",
    "enunciado": "You are given an array \nnums\n that consists of positive integers.\n\n\nThe \nGCD\n of a sequence of numbers is defined as the greatest integer that divides \nall\n the numbers in the sequence evenly.\n\n\n\n\nFor example, the GCD of the sequence \n[4,6,16]\n is \n2\n.\n\n\n\n\nA \nsubsequence\n of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n\n\n\nFor example, \n[2,5,10]\n is a subsequence of \n[1,2,1,\n2\n,4,1,\n5\n,\n10\n]\n.\n\n\n\n\nReturn \nthe \nnumber\n of \ndifferent\n GCDs among all \nnon-empty\n subsequences of\n \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [6,10,3]\n\nOutput:\n 5\n\nExplanation:\n The figure shows all the non-empty subsequences and their GCDs.\nThe different GCDs are 6, 10, 3, 2, and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,15,40,5,6]\n\nOutput:\n 7\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 2 * 10\n5",
    "temas": [
      "Array",
      "Math",
      "Counting",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1828,
    "slug": "queries-on-number-of-points-inside-a-circle",
    "url": "https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/",
    "titulo": "Queries on Number of Points Inside a Circle",
    "enunciado": "You are given an array \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n is the coordinates of the \ni\nth\n point on a 2D plane. Multiple points can have the \nsame\n coordinates.\n\n\nYou are also given an array \nqueries\n where \nqueries[j] = [x\nj\n, y\nj\n, r\nj\n]\n describes a circle centered at \n(x\nj\n, y\nj\n)\n with a radius of \nr\nj\n.\n\n\nFor each query \nqueries[j]\n, compute the number of points \ninside\n the \nj\nth\n circle. Points \non the border\n of the circle are considered \ninside\n.\n\n\nReturn \nan array \nanswer\n, where \nanswer[j]\n is the answer to the \nj\nth\n query\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\n\nOutput:\n [3,2,2]\n\nExplanation: \nThe points and circles are shown above.\nqueries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n\nOutput:\n [2,3,2,4]\n\nExplanation: \nThe points and circles are shown above.\nqueries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 500\n\n\npoints[i].length == 2\n\n\n0 <= x\n​​​​​​i\n, y\n​​​​​​i\n <= 500\n\n\n1 <= queries.length <= 500\n\n\nqueries[j].length == 3\n\n\n0 <= x\nj\n, y\nj\n <= 500\n\n\n1 <= r\nj\n <= 500\n\n\nAll coordinates are integers.\n\n\n\n\n \n\n\nFollow up:\n Could you find the answer for each query in better complexity than \nO(n)\n?",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1801,
    "slug": "number-of-orders-in-the-backlog",
    "url": "https://leetcode.com/problems/number-of-orders-in-the-backlog/",
    "titulo": "Number of Orders in the Backlog",
    "enunciado": "You are given a 2D integer array \norders\n, where each \norders[i] = [price\ni\n, amount\ni\n, orderType\ni\n]\n denotes that \namount\ni\n \norders have been placed of type \norderType\ni\n at the price \nprice\ni\n. The \norderType\ni\n is:\n\n\n\n\n0\n if it is a batch of \nbuy\n orders, or\n\n\n1\n if it is a batch of \nsell\n orders.\n\n\n\n\nNote that \norders[i]\n represents a batch of \namount\ni\n independent orders with the same price and order type. All orders represented by \norders[i]\n will be placed before all orders represented by \norders[i+1]\n for all valid \ni\n.\n\n\nThere is a \nbacklog\n that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:\n\n\n\n\nIf the order is a \nbuy\n order, you look at the \nsell\n order with the \nsmallest\n price in the backlog. If that \nsell\n order's price is \nsmaller than or equal to\n the current \nbuy\n order's price, they will match and be executed, and that \nsell\n order will be removed from the backlog. Else, the \nbuy\n order is added to the backlog.\n\n\nVice versa, if the order is a \nsell\n order, you look at the \nbuy\n order with the \nlargest\n price in the backlog. If that \nbuy\n order's price is \nlarger than or equal to\n the current \nsell\n order's price, they will match and be executed, and that \nbuy\n order will be removed from the backlog. Else, the \nsell\n order is added to the backlog.\n\n\n\n\nReturn \nthe total \namount\n of orders in the backlog after placing all the orders from the input\n. Since this number can be large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\r\n\nOutput:\n 6\r\n\nExplanation:\n Here is what happens with the orders:\r\n- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.\r\n- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.\r\n- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.\r\n- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3\nrd\n order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4\nth\n order is added to the backlog.\r\nFinally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.\r\n\n\n\nExample 2:\n\n\n\n\n\r\n\nInput:\n orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\r\n\nOutput:\n 999999984\r\n\nExplanation:\n Here is what happens with the orders:\r\n- 10\n9\n orders of type sell with price 7 are placed. There are no buy orders, so the 10\n9\n orders are added to the backlog.\r\n- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.\r\n- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.\r\n- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.\r\nFinally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (10\n9\n + 7).\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= orders.length <= 10\n5\n\n\norders[i].length == 3\n\n\n1 <= price\ni\n, amount\ni\n <= 10\n9\n\n\norderType\ni\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Heap (Priority Queue)",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1812,
    "slug": "determine-color-of-a-chessboard-square",
    "url": "https://leetcode.com/problems/determine-color-of-a-chessboard-square/",
    "titulo": "Determine Color of a Chessboard Square",
    "enunciado": "You are given \ncoordinates\n, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\n\n\n\nReturn \ntrue\n if the square is white, and \nfalse\n if the square is black\n.\n\n\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n coordinates = \"a1\"\n\nOutput:\n false\n\nExplanation:\n From the chessboard above, the square with coordinates \"a1\" is black, so return false.\n\n\n\nExample 2:\n\n\n\n\nInput:\n coordinates = \"h3\"\n\nOutput:\n true\n\nExplanation:\n From the chessboard above, the square with coordinates \"h3\" is white, so return true.\n\n\n\nExample 3:\n\n\n\n\nInput:\n coordinates = \"c7\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\ncoordinates.length == 2\n\n\n'a' <= coordinates[0] <= 'h'\n\n\n'1' <= coordinates[1] <= '8'",
    "temas": [
      "Math",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1791,
    "slug": "find-center-of-star-graph",
    "url": "https://leetcode.com/problems/find-center-of-star-graph/",
    "titulo": "Find Center of Star Graph",
    "enunciado": "There is an undirected \nstar\n graph consisting of \nn\n nodes labeled from \n1\n to \nn\n. A star graph is a graph where there is one \ncenter\n node and \nexactly\n \nn - 1\n edges that connect the center node with every other node.\n\n\nYou are given a 2D integer array \nedges\n where each \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an edge between the nodes \nu\ni\n and \nv\ni\n. Return the center of the given star graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[2,3],[4,2]]\n\nOutput:\n 2\n\nExplanation:\n As shown in the figure above, node 2 is connected to every other node, so 2 is the center.\n\n\n\nExample 2:\n\n\n\n\nInput:\n edges = [[1,2],[5,1],[1,3],[1,4]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n1 <= u\ni,\n v\ni\n <= n\n\n\nu\ni\n != v\ni\n\n\nThe given \nedges\n represent a valid star graph.",
    "temas": [
      "Graph"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 1786,
    "slug": "number-of-restricted-paths-from-first-to-last-node",
    "url": "https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/",
    "titulo": "Number of Restricted Paths From First to Last Node",
    "enunciado": "There is an undirected weighted connected graph. You are given a positive integer \nn\n which denotes that the graph has \nn\n nodes labeled from \n1\n to \nn\n, and an array \nedges\n where each \nedges[i] = [u\ni\n, v\ni\n, weight\ni\n]\n denotes that there is an edge between nodes \nu\ni\n and \nv\ni\n with weight equal to \nweight\ni\n.\n\n\nA path from node \nstart\n to node \nend\n is a sequence of nodes \n[z\n0\n, z\n1\n,\n \nz\n2\n, ..., z\nk\n]\n such that \nz\n0 \n= start\n and \nz\nk\n = end\n and there is an edge between \nz\ni\n and \nz\ni+1\n where \n0 <= i <= k-1\n.\n\n\nThe distance of a path is the sum of the weights on the edges of the path. Let \ndistanceToLastNode(x)\n denote the shortest distance of a path between node \nn\n and node \nx\n. A \nrestricted path\n is a path that also satisfies that \ndistanceToLastNode(z\ni\n) > distanceToLastNode(z\ni+1\n)\n where \n0 <= i <= k-1\n.\n\n\nReturn \nthe number of restricted paths from node\n \n1\n \nto node\n \nn\n. Since that number may be too large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]\n\nOutput:\n 3\n\nExplanation:\n Each circle contains the node number in black and its \ndistanceToLastNode value in blue. \nThe three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]\n\nOutput:\n 1\n\nExplanation:\n Each circle contains the node number in black and its \ndistanceToLastNode value in blue. \nThe only restricted path is 1 --> 3 --> 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n4\n\n\nn - 1 <= edges.length <= 4 * 10\n4\n\n\nedges[i].length == 3\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni \n!= v\ni\n\n\n1 <= weight\ni\n <= 10\n5\n\n\nThere is at most one edge between any two nodes.\n\n\nThere is at least one path between any two nodes.",
    "temas": [
      "Dynamic Programming",
      "Graph",
      "Topological Sort",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1797,
    "slug": "design-authentication-manager",
    "url": "https://leetcode.com/problems/design-authentication-manager/",
    "titulo": "Design Authentication Manager",
    "enunciado": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire \ntimeToLive\n seconds after the \ncurrentTime\n. If the token is renewed, the expiry time will be \nextended\n to expire \ntimeToLive\n seconds after the (potentially different) \ncurrentTime\n.\n\n\nImplement the \nAuthenticationManager\n class:\n\n\n\n\nAuthenticationManager(int timeToLive)\n constructs the \nAuthenticationManager\n and sets the \ntimeToLive\n.\n\n\ngenerate(string tokenId, int currentTime)\n generates a new token with the given \ntokenId\n at the given \ncurrentTime\n in seconds.\n\n\nrenew(string tokenId, int currentTime)\n renews the \nunexpired\n token with the given \ntokenId\n at the given \ncurrentTime\n in seconds. If there are no unexpired tokens with the given \ntokenId\n, the request is ignored, and nothing happens.\n\n\ncountUnexpiredTokens(int currentTime)\n returns the number of \nunexpired\n tokens at the given currentTime.\n\n\n\n\nNote that if a token expires at time \nt\n, and another action happens on time \nt\n (\nrenew\n or \ncountUnexpiredTokens\n), the expiration takes place \nbefore\n the other actions.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"AuthenticationManager\", \"\nrenew\n\", \"generate\", \"\ncountUnexpiredTokens\n\", \"generate\", \"\nrenew\n\", \"\nrenew\n\", \"\ncountUnexpiredTokens\n\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\n\nOutput\n\n[null, null, null, 1, null, null, null, 0]\n\n\nExplanation\n\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with \ntimeToLive\n = 5 seconds.\nauthenticationManager.\nrenew\n(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\nauthenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\nauthenticationManager.\ncountUnexpiredTokens\n(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\nauthenticationManager.\nrenew\n(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the \nrenew\n request is ignored, and nothing happens.\nauthenticationManager.\nrenew\n(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the \nrenew\n request is fulfilled and now the token will expire at time 15.\nauthenticationManager.\ncountUnexpiredTokens\n(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= timeToLive <= 10\n8\n\n\n1 <= currentTime <= 10\n8\n\n\n1 <= tokenId.length <= 5\n\n\ntokenId\n consists only of lowercase letters.\n\n\nAll calls to \ngenerate\n will contain unique values of \ntokenId\n.\n\n\nThe values of \ncurrentTime\n across all the function calls will be \nstrictly increasing\n.\n\n\nAt most \n2000\n calls will be made to all functions combined.",
    "temas": [
      "Hash Table",
      "Linked List",
      "Design",
      "Doubly-Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1782,
    "slug": "count-pairs-of-nodes",
    "url": "https://leetcode.com/problems/count-pairs-of-nodes/",
    "titulo": "Count Pairs Of Nodes",
    "enunciado": "You are given an undirected graph defined by an integer \nn\n, the number of nodes, and a 2D integer array \nedges\n, the edges in the graph, where \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an \nundirected\n edge between \nu\ni\n and \nv\ni\n. You are also given an integer array \nqueries\n.\n\n\nLet \nincident(a, b)\n be defined as the \nnumber of edges\n that are connected to \neither\n node \na\n or \nb\n.\n\n\nThe answer to the \nj\nth\n query is the \nnumber of pairs\n of nodes \n(a, b)\n that satisfy \nboth\n of the following conditions:\n\n\n\n\na < b\n\n\nincident(a, b) > queries[j]\n\n\n\n\nReturn \nan array \nanswers\n such that \nanswers.length == queries.length\n and \nanswers[j]\n is the answer of the \nj\nth\n query\n.\n\n\nNote that there can be \nmultiple edges\n between the same two nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]\n\nOutput:\n [6,5]\n\nExplanation:\n The calculations for incident(a, b) are shown in the table above.\nThe answers for each of the queries are as follows:\n- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.\n- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]\n\nOutput:\n [10,10,9,8,6]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 2 * 10\n4\n\n\n1 <= edges.length <= 10\n5\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni \n!= v\ni\n\n\n1 <= queries.length <= 20\n\n\n0 <= queries[j] < edges.length",
    "temas": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Graph",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1761,
    "slug": "minimum-degree-of-a-connected-trio-in-a-graph",
    "url": "https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/",
    "titulo": "Minimum Degree of a Connected Trio in a Graph",
    "enunciado": "You are given an undirected graph. You are given an integer \nn\n which is the number of nodes in the graph and an array \nedges\n, where each \nedges[i] = [u\ni\n, v\ni\n]\n indicates that there is an undirected edge between \nu\ni\n and \nv\ni\n.\n\n\nA \nconnected trio\n is a set of \nthree\n nodes where there is an edge between \nevery\n pair of them.\n\n\nThe \ndegree of a connected trio\n is the number of edges where one endpoint is in the trio, and the other is not.\n\n\nReturn \nthe \nminimum\n degree of a connected trio in the graph, or\n \n-1\n \nif the graph has no connected trios.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n\nOutput:\n 3\n\nExplanation:\n There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n\nOutput:\n 0\n\nExplanation:\n There are exactly three trios:\n1) [1,4,3] with degree 0.\n2) [2,5,6] with degree 2.\n3) [5,6,7] with degree 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 400\n\n\nedges[i].length == 2\n\n\n1 <= edges.length <= n * (n-1) / 2\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni \n!= v\ni\n\n\nThere are no repeated edges.",
    "temas": [
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 1765,
    "slug": "map-of-highest-peak",
    "url": "https://leetcode.com/problems/map-of-highest-peak/",
    "titulo": "Map of Highest Peak",
    "enunciado": "You are given an integer matrix \nisWater\n of size \nm x n\n that represents a map of \nland\n and \nwater\n cells.\n\n\n\n\nIf \nisWater[i][j] == 0\n, cell \n(i, j)\n is a \nland\n cell.\n\n\nIf \nisWater[i][j] == 1\n, cell \n(i, j)\n is a \nwater\n cell.\n\n\n\n\nYou must assign each cell a height in a way that follows these rules:\n\n\n\n\nThe height of each cell must be non-negative.\n\n\nIf the cell is a \nwater\n cell, its height must be \n0\n.\n\n\nAny two adjacent cells must have an absolute height difference of \nat most\n \n1\n. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n\n\n\nFind an assignment of heights such that the maximum height in the matrix is \nmaximized\n.\n\n\nReturn \nan integer matrix \nheight\n of size \nm x n\n where \nheight[i][j]\n is cell \n(i, j)\n's height. If there are multiple solutions, return \nany\n of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isWater = [[0,1],[0,0]]\n\nOutput:\n [[1,0],[2,1]]\n\nExplanation:\n The image shows the assigned heights of each cell.\nThe blue cell is the water cell, and the green cells are the land cells.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isWater = [[0,0,1],[1,0,0],[0,0,0]]\n\nOutput:\n [[1,1,0],[0,1,1],[1,2,2]]\n\nExplanation:\n A height of 2 is the maximum possible height of any assignment.\nAny height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == isWater.length\n\n\nn == isWater[i].length\n\n\n1 <= m, n <= 1000\n\n\nisWater[i][j]\n is \n0\n or \n1\n.\n\n\nThere is at least \none\n water cell.\n\n\n\n\n \n\n\nNote:\n This question is the same as 542: \nhttps://leetcode.com/problems/01-matrix/",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1766,
    "slug": "tree-of-coprimes",
    "url": "https://leetcode.com/problems/tree-of-coprimes/",
    "titulo": "Tree of Coprimes",
    "enunciado": "There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n and exactly \nn - 1\n edges. Each node has a value associated with it, and the \nroot\n of the tree is node \n0\n.\n\n\nTo represent this tree, you are given an integer array \nnums\n and a 2D array \nedges\n. Each \nnums[i]\n represents the \ni\nth\n node's value, and each \nedges[j] = [u\nj\n, v\nj\n]\n represents an edge between nodes \nu\nj\n and \nv\nj\n in the tree.\n\n\nTwo values \nx\n and \ny\n are \ncoprime\n if \ngcd(x, y) == 1\n where \ngcd(x, y)\n is the \ngreatest common divisor\n of \nx\n and \ny\n.\n\n\nAn ancestor of a node \ni\n is any other node on the shortest path from node \ni\n to the \nroot\n. A node is \nnot \nconsidered an ancestor of itself.\n\n\nReturn \nan array \nans\n of size \nn\n, \nwhere \nans[i]\n is the closest ancestor to node \ni\n such that \nnums[i]\n \nand \nnums[ans[i]]\n are \ncoprime\n, or \n-1\n if there is no such ancestor\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\n\nOutput:\n [-1,0,0,1]\n\nExplanation:\n In the above figure, each node's value is in parentheses.\n- Node 0 has no coprime ancestors.\n- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n  closest valid ancestor.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\n\nOutput:\n [-1,0,-1,0,0,0,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums.length == n\n\n\n1 <= nums[i] <= 50\n\n\n1 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[j].length == 2\n\n\n0 <= u\nj\n, v\nj\n < n\n\n\nu\nj\n != v\nj",
    "temas": [
      "Array",
      "Math",
      "Tree",
      "Depth-First Search",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1739,
    "slug": "building-boxes",
    "url": "https://leetcode.com/problems/building-boxes/",
    "titulo": "Building Boxes",
    "enunciado": "You have a cubic storeroom where the width, length, and height of the room are all equal to \nn\n units. You are asked to place \nn\n boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:\n\n\n\n\nYou can place the boxes anywhere on the floor.\n\n\nIf box \nx\n is placed on top of the box \ny\n, then each side of the four vertical sides of the box \ny\n \nmust\n either be adjacent to another box or to a wall.\n\n\n\n\nGiven an integer \nn\n, return\n the \nminimum\n possible number of boxes touching the floor.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n The figure above is for the placement of the three boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 3\n\nExplanation:\n The figure above is for the placement of the four boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 10\n\nOutput:\n 6\n\nExplanation:\n The figure above is for the placement of the ten boxes.\nThese boxes are placed in the corner of the room, where the corner is on the back side.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n9",
    "temas": [
      "Math",
      "Binary Search",
      "Greedy"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1751,
    "slug": "maximum-number-of-events-that-can-be-attended-ii",
    "url": "https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/",
    "titulo": "Maximum Number of Events That Can Be Attended II",
    "enunciado": "You are given an array of \nevents\n where \nevents[i] = [startDay\ni\n, endDay\ni\n, value\ni\n]\n. The \ni\nth\n event starts at \nstartDay\ni\n \nand ends at \nendDay\ni\n, and if you attend this event, you will receive a value of \nvalue\ni\n. You are also given an integer \nk\n which represents the maximum number of events you can attend.\n\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the \nentire\n event. Note that the end day is \ninclusive\n: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\n\nReturn \nthe \nmaximum sum\n of values that you can receive by attending events.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\n\nOutput:\n 7\n\nExplanation: \nChoose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\n\nOutput:\n 10\n\nExplanation:\n Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do \nnot\n have to attend k events.\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\n\nOutput:\n 9\n\nExplanation:\n Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= events.length\n\n\n1 <= k * events.length <= 10\n6\n\n\n1 <= startDay\ni\n <= endDay\ni\n <= 10\n9\n\n\n1 <= value\ni\n <= 10\n6",
    "temas": [
      "Array",
      "Binary Search",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1727,
    "slug": "largest-submatrix-with-rearrangements",
    "url": "https://leetcode.com/problems/largest-submatrix-with-rearrangements/",
    "titulo": "Largest Submatrix With Rearrangements",
    "enunciado": "You are given a binary matrix \nmatrix\n of size \nm x n\n, and you are allowed to rearrange the \ncolumns\n of the \nmatrix\n in any order.\n\n\nReturn \nthe area of the largest submatrix within \nmatrix\n where \nevery\n element of the submatrix is \n1\n after reordering the columns optimally.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[0,0,1],[1,1,1],[1,0,1]]\n\nOutput:\n 4\n\nExplanation:\n You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,0,1,0,1]]\n\nOutput:\n 3\n\nExplanation:\n You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[1,1,0],[1,0,1]]\n\nOutput:\n 2\n\nExplanation:\n Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m * n <= 10\n5\n\n\nmatrix[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Greedy",
      "Sorting",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1719,
    "slug": "number-of-ways-to-reconstruct-a-tree",
    "url": "https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/",
    "titulo": "Number Of Ways To Reconstruct A Tree",
    "enunciado": "You are given an array \npairs\n, where \npairs[i] = [x\ni\n, y\ni\n]\n, and:\n\n\n\n\nThere are no duplicates.\n\n\nx\ni\n < y\ni\n\n\n\n\nLet \nways\n be the number of rooted trees that satisfy the following conditions:\n\n\n\n\nThe tree consists of nodes whose values appeared in \npairs\n.\n\n\nA pair \n[x\ni\n, y\ni\n]\n exists in \npairs\n \nif and only if\n \nx\ni\n is an ancestor of \ny\ni\n or \ny\ni\n is an ancestor of \nx\ni\n.\n\n\nNote:\n the tree does not have to be a binary tree.\n\n\n\n\nTwo ways are considered to be different if there is at least one node that has different parents in both ways.\n\n\nReturn:\n\n\n\n\n0\n if \nways == 0\n\n\n1\n if \nways == 1\n\n\n2\n if \nways > 1\n\n\n\n\nA \nrooted tree\n is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\n\n\nAn \nancestor\n of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n pairs = [[1,2],[2,3]]\n\nOutput:\n 1\n\nExplanation:\n There is exactly one valid rooted tree, which is shown in the above figure.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n pairs = [[1,2],[2,3],[1,3]]\n\nOutput:\n 2\n\nExplanation:\n There are multiple valid rooted trees. Three of them are shown in the above figures.\n\n\n\nExample 3:\n\n\n\n\nInput:\n pairs = [[1,2],[2,3],[2,4],[1,5]]\n\nOutput:\n 0\n\nExplanation:\n There are no valid rooted trees.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= pairs.length <= 10\n5\n\n\n1 <= x\ni \n< y\ni\n <= 500\n\n\nThe elements in \npairs\n are unique.",
    "temas": [
      "Tree",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1697,
    "slug": "checking-existence-of-edge-length-limited-paths",
    "url": "https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/",
    "titulo": "Checking Existence of Edge Length Limited Paths",
    "enunciado": "An undirected graph of \nn\n nodes is defined by \nedgeList\n, where \nedgeList[i] = [u\ni\n, v\ni\n, dis\ni\n]\n denotes an edge between nodes \nu\ni\n and \nv\ni\n with distance \ndis\ni\n. Note that there may be \nmultiple\n edges between two nodes.\n\n\nGiven an array \nqueries\n, where \nqueries[j] = [p\nj\n, q\nj\n, limit\nj\n]\n, your task is to determine for each \nqueries[j]\n whether there is a path between \np\nj\n and \nq\nj\n \nsuch that each edge on the path has a distance \nstrictly less than\n \nlimit\nj\n .\n\n\nReturn \na \nboolean array\n \nanswer\n, where \nanswer.length == queries.length\n \nand the \nj\nth\n \nvalue of \nanswer\n \nis \ntrue\n if there is a path for \nqueries[j]\n is \ntrue\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n\nOutput:\n [false,true]\n\nExplanation:\n The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\nFor the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\nFor the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n\nOutput:\n [true,false]\n\nExplanation:\n The above figure shows the given graph.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\n1 <= edgeList.length, queries.length <= 10\n5\n\n\nedgeList[i].length == 3\n\n\nqueries[j].length == 3\n\n\n0 <= u\ni\n, v\ni\n, p\nj\n, q\nj\n <= n - 1\n\n\nu\ni\n != v\ni\n\n\np\nj\n != q\nj\n\n\n1 <= dis\ni\n, limit\nj\n <= 10\n9\n\n\nThere may be \nmultiple\n edges between two nodes.",
    "temas": [
      "Array",
      "Two Pointers",
      "Union Find",
      "Graph",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1659,
    "slug": "maximize-grid-happiness",
    "url": "https://leetcode.com/problems/maximize-grid-happiness/",
    "titulo": "Maximize Grid Happiness",
    "enunciado": "You are given four integers, \nm\n, \nn\n, \nintrovertsCount\n, and \nextrovertsCount\n. You have an \nm x n\n grid, and there are two types of people: introverts and extroverts. There are \nintrovertsCount\n introverts and \nextrovertsCount\n extroverts.\n\n\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you \ndo not\n have to have all the people living in the grid.\n\n\nThe \nhappiness\n of each person is calculated as follows:\n\n\n\n\nIntroverts \nstart\n with \n120\n happiness and \nlose\n \n30\n happiness for each neighbor (introvert or extrovert).\n\n\nExtroverts \nstart\n with \n40\n happiness and \ngain\n \n20\n happiness for each neighbor (introvert or extrovert).\n\n\n\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n\n\nThe \ngrid happiness\n is the \nsum\n of each person's happiness. Return\n the \nmaximum possible grid happiness\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n\nOutput:\n 240\n\nExplanation:\n Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n\nOutput:\n 260\n\nExplanation:\n Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n\n\n\nExample 3:\n\n\n\n\nInput:\n m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n\nOutput:\n 240\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 5\n\n\n0 <= introvertsCount, extrovertsCount <= min(m * n, 6)",
    "temas": [
      "Dynamic Programming",
      "Bit Manipulation",
      "Memoization",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1656,
    "slug": "design-an-ordered-stream",
    "url": "https://leetcode.com/problems/design-an-ordered-stream/",
    "titulo": "Design an Ordered Stream",
    "enunciado": "There is a stream of \nn\n \n(idKey, value)\n pairs arriving in an \narbitrary\n order, where \nidKey\n is an integer between \n1\n and \nn\n and \nvalue\n is a string. No two pairs have the same \nid\n.\n\n\nDesign a stream that returns the values in \nincreasing order of their IDs\n by returning a \nchunk\n (list) of values after each insertion. The concatenation of all the \nchunks\n should result in a list of the sorted values.\n\n\nImplement the \nOrderedStream\n class:\n\n\n\n\nOrderedStream(int n)\n Constructs the stream to take \nn\n values.\n\n\nString[] insert(int idKey, String value)\n Inserts the pair \n(idKey, value)\n into the stream, then returns the \nlargest possible chunk\n of currently inserted values that appear next in the order.\n\n\n\n\n \n\n\nExample:\n\n\n\n\n\n\nInput\n\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\n\nOutput\n\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\n\nExplanation\n\n// Note that the values ordered by ID is [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"].\nOrderedStream os = new OrderedStream(5);\nos.insert(3, \"ccccc\"); // Inserts (3, \"ccccc\"), returns [].\nos.insert(1, \"aaaaa\"); // Inserts (1, \"aaaaa\"), returns [\"aaaaa\"].\nos.insert(2, \"bbbbb\"); // Inserts (2, \"bbbbb\"), returns [\"bbbbb\", \"ccccc\"].\nos.insert(5, \"eeeee\"); // Inserts (5, \"eeeee\"), returns [].\nos.insert(4, \"ddddd\"); // Inserts (4, \"ddddd\"), returns [\"ddddd\", \"eeeee\"].\n// Concatentating all the chunks returned:\n// [] + [\"aaaaa\"] + [\"bbbbb\", \"ccccc\"] + [] + [\"ddddd\", \"eeeee\"] = [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"]\n// The resulting order is the same as the order above.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n1 <= id <= n\n\n\nvalue.length == 5\n\n\nvalue\n consists only of lowercase letters.\n\n\nEach call to \ninsert\n will have a unique \nid.\n\n\nExactly \nn\n calls will be made to \ninsert\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Design",
      "Data Stream"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1648,
    "slug": "sell-diminishing-valued-colored-balls",
    "url": "https://leetcode.com/problems/sell-diminishing-valued-colored-balls/",
    "titulo": "Sell Diminishing-Valued Colored Balls",
    "enunciado": "You have an \ninventory\n of different colored balls, and there is a customer that wants \norders\n balls of \nany\n color.\n\n\nThe customer weirdly values the colored balls. Each colored ball's value is the number of balls \nof that color \nyou currently have in your \ninventory\n. For example, if you own \n6\n yellow balls, the customer would pay \n6\n for the first yellow ball. After the transaction, there are only \n5\n yellow balls left, so the next yellow ball is then valued at \n5\n (i.e., the value of the balls decreases as you sell more to the customer).\n\n\nYou are given an integer array, \ninventory\n, where \ninventory[i]\n represents the number of balls of the \ni\nth\n color that you initially own. You are also given an integer \norders\n, which represents the total number of balls that the customer wants. You can sell the balls \nin any order\n.\n\n\nReturn \nthe \nmaximum\n total value that you can attain after selling \norders\n colored balls\n. As the answer may be too large, return it \nmodulo \n10\n9 \n+ 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n inventory = [2,5], orders = 4\n\nOutput:\n 14\n\nExplanation:\n Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n\n\n\nExample 2:\n\n\n\n\nInput:\n inventory = [3,5], orders = 6\n\nOutput:\n 19\n\nExplanation: \nSell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= inventory.length <= 10\n5\n\n\n1 <= inventory[i] <= 10\n9\n\n\n1 <= orders <= min(sum(inventory[i]), 10\n9\n)",
    "temas": [
      "Array",
      "Math",
      "Binary Search",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1669,
    "slug": "merge-in-between-linked-lists",
    "url": "https://leetcode.com/problems/merge-in-between-linked-lists/",
    "titulo": "Merge In Between Linked Lists",
    "enunciado": "You are given two linked lists: \nlist1\n and \nlist2\n of sizes \nn\n and \nm\n respectively.\n\n\nRemove \nlist1\n's nodes from the \na\nth\n node to the \nb\nth\n node, and put \nlist2\n in their place.\n\n\nThe blue edges and nodes in the following figure indicate the result:\n\n\n\n\nBuild the result list and return its head.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n\nOutput:\n [10,1,13,1000000,1000001,1000002,5]\n\nExplanation:\n We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n\nOutput:\n [0,1,1000000,1000001,1000002,1000003,1000004,6]\n\nExplanation:\n The blue edges and nodes in the above figure indicate the result.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= list1.length <= 10\n4\n\n\n1 <= a <= b < list1.length - 1\n\n\n1 <= list2.length <= 10\n4",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 1642,
    "slug": "furthest-building-you-can-reach",
    "url": "https://leetcode.com/problems/furthest-building-you-can-reach/",
    "titulo": "Furthest Building You Can Reach",
    "enunciado": "You are given an integer array \nheights\n representing the heights of buildings, some \nbricks\n, and some \nladders\n.\n\n\nYou start your journey from building \n0\n and move to the next building by possibly using bricks or ladders.\n\n\nWhile moving from building \ni\n to building \ni+1\n (\n0-indexed\n),\n\n\n\n\nIf the current building's height is \ngreater than or equal\n to the next building's height, you do \nnot\n need a ladder or bricks.\n\n\nIf the current building's height is \nless than\n the next building's height, you can either use \none ladder\n or \n(h[i+1] - h[i])\n \nbricks\n.\n\n\n\n\nReturn the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n\nOutput:\n 4\n\nExplanation:\n Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n\nOutput:\n 7\n\n\n\nExample 3:\n\n\n\n\nInput:\n heights = [14,3,19,3], bricks = 17, ladders = 0\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n1 <= heights[i] <= 10\n6\n\n\n0 <= bricks <= 10\n9\n\n\n0 <= ladders <= heights.length",
    "temas": [
      "Array",
      "Greedy",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1631,
    "slug": "path-with-minimum-effort",
    "url": "https://leetcode.com/problems/path-with-minimum-effort/",
    "titulo": "Path With Minimum Effort",
    "enunciado": "You are a hiker preparing for an upcoming hike. You are given \nheights\n, a 2D array of size \nrows x columns\n, where \nheights[row][col]\n represents the height of cell \n(row, col)\n. You are situated in the top-left cell, \n(0, 0)\n, and you hope to travel to the bottom-right cell, \n(rows-1, columns-1)\n (i.e., \n0-indexed\n). You can move \nup\n, \ndown\n, \nleft\n, or \nright\n, and you wish to find a route that requires the minimum \neffort\n.\n\n\nA route's \neffort\n is the \nmaximum absolute difference\n \nin heights between two consecutive cells of the route.\n\n\nReturn \nthe minimum \neffort\n required to travel from the top-left cell to the bottom-right cell.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [[1,2,2],[3,8,2],[5,3,5]]\n\nOutput:\n 2\n\nExplanation:\n The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [[1,2,3],[3,8,4],[5,3,5]]\n\nOutput:\n 1\n\nExplanation:\n The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n\nOutput:\n 0\n\nExplanation:\n This route does not require any effort.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == heights.length\n\n\ncolumns == heights[i].length\n\n\n1 <= rows, columns <= 100\n\n\n1 <= heights[i][j] <= 10\n6",
    "temas": [
      "Array",
      "Binary Search",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1637,
    "slug": "widest-vertical-area-between-two-points-containing-no-points",
    "url": "https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/",
    "titulo": "Widest Vertical Area Between Two Points Containing No Points",
    "enunciado": "Given \nn\n \npoints\n on a 2D plane where \npoints[i] = [x\ni\n, y\ni\n]\n, Return\n the \nwidest vertical area\n between two points such that no points are inside the area.\n\n\nA \nvertical area\n is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The \nwidest vertical area\n is the one with the maximum width.\n\n\nNote that points \non the edge\n of a vertical area \nare not\n considered included in the area.\n\n\n \n\n\nExample 1:\n\n\n​\n\n\n\nInput:\n points = [[8,7],[9,9],[7,4],[9,7]]\n\nOutput:\n 1\n\nExplanation:\n Both the red and the blue area are optimal.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == points.length\n\n\n2 <= n <= 10\n5\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 10\n9",
    "temas": [
      "Array",
      "Sorting"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1617,
    "slug": "count-subtrees-with-max-distance-between-cities",
    "url": "https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/",
    "titulo": "Count Subtrees With Max Distance Between Cities",
    "enunciado": "There are \nn\n cities numbered from \n1\n to \nn\n. You are given an array \nedges\n of size \nn-1\n, where \nedges[i] = [u\ni\n, v\ni\n]\n represents a bidirectional edge between cities \nu\ni\n and \nv\ni\n. There exists a unique path between each pair of cities. In other words, the cities form a \ntree\n.\n\n\nA \nsubtree\n is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\n\nFor each \nd\n from \n1\n to \nn-1\n, find the number of subtrees in which the \nmaximum distance\n between any two cities in the subtree is equal to \nd\n.\n\n\nReturn \nan array of size\n \nn-1\n \nwhere the \nd\nth\n \nelement \n(1-indexed)\n is the number of subtrees in which the \nmaximum distance\n between any two cities is equal to \nd\n.\n\n\nNotice\n that the \ndistance\n between the two cities is the number of edges in the path between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n n = 4, edges = [[1,2],[2,3],[2,4]]\r\n\nOutput:\n [3,4,0]\r\n\nExplanation:\r\n\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\r\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\r\nNo subtree has two nodes where the max distance between them is 3.\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n n = 2, edges = [[1,2]]\r\n\nOutput:\n [1]\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n n = 3, edges = [[1,2],[2,3]]\r\n\nOutput:\n [2,1]\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 15\n\n\nedges.length == n-1\n\n\nedges[i].length == 2\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nAll pairs \n(u\ni\n, v\ni\n)\n are distinct.",
    "temas": [
      "Dynamic Programming",
      "Bit Manipulation",
      "Tree",
      "Enumeration",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1615,
    "slug": "maximal-network-rank",
    "url": "https://leetcode.com/problems/maximal-network-rank/",
    "titulo": "Maximal Network Rank",
    "enunciado": "There is an infrastructure of \nn\n cities with some number of \nroads\n connecting these cities. Each \nroads[i] = [a\ni\n, b\ni\n]\n indicates that there is a bidirectional road between cities \na\ni\n and \nb\ni\n.\n\n\nThe \nnetwork rank\n \nof \ntwo different cities\n is defined as the total number of \ndirectly\n connected roads to \neither\n city. If a road is directly connected to both cities, it is only counted \nonce\n.\n\n\nThe \nmaximal network rank \nof the infrastructure is the \nmaximum network rank\n of all pairs of different cities.\n\n\nGiven the integer \nn\n and the array \nroads\n, return \nthe \nmaximal network rank\n of the entire infrastructure\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n\nOutput:\n 4\n\nExplanation:\n The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n\nOutput:\n 5\n\nExplanation:\n There are 5 roads that are connected to cities 1 or 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n\nOutput:\n 5\n\nExplanation:\n The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n0 <= roads.length <= n * (n - 1) / 2\n\n\nroads[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= n-1\n\n\na\ni\n != b\ni\n\n\nEach pair of cities has \nat most one\n road connecting them.",
    "temas": [
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 1610,
    "slug": "maximum-number-of-visible-points",
    "url": "https://leetcode.com/problems/maximum-number-of-visible-points/",
    "titulo": "Maximum Number of Visible Points",
    "enunciado": "You are given an array \npoints\n, an integer \nangle\n, and your \nlocation\n, where \nlocation = [pos\nx\n, pos\ny\n]\n and \npoints[i] = [x\ni\n, y\ni\n]\n both denote \nintegral coordinates\n on the X-Y plane.\n\n\nInitially, you are facing directly east from your position. You \ncannot move\n from your position, but you can \nrotate\n. In other words, \npos\nx\n and \npos\ny\n cannot be changed. Your field of view in \ndegrees\n is represented by \nangle\n, determining how wide you can see from any given view direction. Let \nd\n be the amount in degrees that you rotate counterclockwise. Then, your field of view is the \ninclusive\n range of angles \n[d - angle/2, d + angle/2]\n.\n\n\n\n\nYour browser does not support the video tag or this video format.\n\n\n\n\nYou can \nsee\n some set of points if, for each point, the \nangle\n formed by the point, your position, and the immediate east direction from your position is \nin your field of view\n.\n\n\nThere can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.\n\n\nReturn \nthe maximum number of points you can see\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n\nOutput:\n 3\n\nExplanation:\n The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n\nOutput:\n 4\n\nExplanation:\n All points can be made visible in your field of view, including the one at your location.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n points = [[1,0],[2,1]], angle = 13, location = [1,1]\n\nOutput:\n 1\n\nExplanation:\n You can only see one of the two points, as shown above.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 10\n5\n\n\npoints[i].length == 2\n\n\nlocation.length == 2\n\n\n0 <= angle < 360\n\n\n0 <= pos\nx\n, pos\ny\n, x\ni\n, y\ni\n <= 100",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Sliding Window",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1609,
    "slug": "even-odd-tree",
    "url": "https://leetcode.com/problems/even-odd-tree/",
    "titulo": "Even Odd Tree",
    "enunciado": "A binary tree is named \nEven-Odd\n if it meets the following conditions:\n\n\n\n\nThe root of the binary tree is at level index \n0\n, its children are at level index \n1\n, their children are at level index \n2\n, etc.\n\n\nFor every \neven-indexed\n level, all nodes at the level have \nodd\n integer values in \nstrictly increasing\n order (from left to right).\n\n\nFor every \nodd-indexed\n level, all nodes at the level have \neven\n integer values in \nstrictly decreasing\n order (from left to right).\n\n\n\n\nGiven the \nroot\n of a binary tree, \nreturn \ntrue\n if the binary tree is \nEven-Odd\n, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n\nOutput:\n true\n\nExplanation:\n The node values on each level are:\nLevel 0: [1]\nLevel 1: [10,4]\nLevel 2: [3,7,9]\nLevel 3: [12,8,6,2]\nSince levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,4,2,3,3,7]\n\nOutput:\n false\n\nExplanation:\n The node values on each level are:\nLevel 0: [5]\nLevel 1: [4,2]\nLevel 2: [3,3,7]\nNode values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [5,9,1,3,5,7]\n\nOutput:\n false\n\nExplanation:\n Node values in the level 1 should be even integers.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 10\n6",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1728,
    "slug": "cat-and-mouse-ii",
    "url": "https://leetcode.com/problems/cat-and-mouse-ii/",
    "titulo": "Cat and Mouse II",
    "enunciado": "A game is played by a cat and a mouse named Cat and Mouse.\n\n\nThe environment is represented by a \ngrid\n of size \nrows x cols\n, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n\n\n\nPlayers are represented by the characters \n'C'\n(Cat)\n,'M'\n(Mouse).\n\n\nFloors are represented by the character \n'.'\n and can be walked on.\n\n\nWalls are represented by the character \n'#'\n and cannot be walked on.\n\n\nFood is represented by the character \n'F'\n and can be walked on.\n\n\nThere is only one of each character \n'C'\n, \n'M'\n, and \n'F'\n in \ngrid\n.\n\n\n\n\nMouse and Cat play according to the following rules:\n\n\n\n\nMouse \nmoves first\n, then they take turns to move.\n\n\nDuring each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the \ngrid\n.\n\n\ncatJump, mouseJump\n are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n\n\nStaying in the same position is allowed.\n\n\nMouse can jump over Cat.\n\n\n\n\nThe game can end in 4 ways:\n\n\n\n\nIf Cat occupies the same position as Mouse, Cat wins.\n\n\nIf Cat reaches the food first, Cat wins.\n\n\nIf Mouse reaches the food first, Mouse wins.\n\n\nIf Mouse cannot get to the food within 1000 turns, Cat wins.\n\n\n\n\nGiven a \nrows x cols\n matrix \ngrid\n and two integers \ncatJump\n and \nmouseJump\n, return \ntrue\n if Mouse can win the game if both Cat and Mouse play optimally, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\n\nOutput:\n true\n\nExplanation:\n Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == grid.length\n\n\ncols = grid[i].length\n\n\n1 <= rows, cols <= 8\n\n\ngrid[i][j]\n consist only of characters \n'C'\n, \n'M'\n, \n'F'\n, \n'.'\n, and \n'#'\n.\n\n\nThere is only one of each character \n'C'\n, \n'M'\n, and \n'F'\n in \ngrid\n.\n\n\n1 <= catJump, mouseJump <= 8",
    "temas": [
      "Array",
      "Math",
      "Dynamic Programming",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Matrix",
      "Game Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1620,
    "slug": "coordinate-with-maximum-network-quality",
    "url": "https://leetcode.com/problems/coordinate-with-maximum-network-quality/",
    "titulo": "Coordinate With Maximum Network Quality",
    "enunciado": "You are given an array of network towers \ntowers\n, where \ntowers[i] = [x\ni\n, y\ni\n, q\ni\n]\n denotes the \ni\nth\n network tower with location \n(x\ni\n, y\ni\n)\n and quality factor \nq\ni\n. All the coordinates are \nintegral coordinates\n on the X-Y plane, and the distance between the two coordinates is the \nEuclidean distance\n.\n\n\nYou are also given an integer \nradius\n where a tower is \nreachable\n if the distance is \nless than or equal to\n \nradius\n. Outside that distance, the signal becomes garbled, and the tower is \nnot reachable\n.\n\n\nThe signal quality of the \ni\nth\n tower at a coordinate \n(x, y)\n is calculated with the formula \n⌊q\ni\n / (1 + d)⌋\n, where \nd\n is the distance between the tower and the coordinate. The \nnetwork quality\n at a coordinate is the sum of the signal qualities from all the \nreachable\n towers.\n\n\nReturn \nthe array \n[c\nx\n, c\ny\n]\n representing the \nintegral\n coordinate \n(c\nx\n, c\ny\n)\n where the \nnetwork quality\n is maximum. If there are multiple coordinates with the same \nnetwork quality\n, return the lexicographically minimum \nnon-negative\n coordinate.\n\n\nNote:\n\n\n\n\nA coordinate \n(x1, y1)\n is lexicographically smaller than \n(x2, y2)\n if either:\n\n\t\n\n\nx1 < x2\n, or\n\n\nx1 == x2\n and \ny1 < y2\n.\n\n\n\n\n\n\n⌊val⌋\n is the greatest integer less than or equal to \nval\n (the floor function).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n\nOutput:\n [2,1]\n\nExplanation:\n At coordinate (2, 1) the total quality is 13.\n- Quality of 7 from (2, 1) results in ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n- Quality of 5 from (1, 2) results in ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n- Quality of 9 from (3, 1) results in ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\nNo other coordinate has a higher network quality.\n\n\nExample 2:\n\n\n\n\nInput:\n towers = [[23,11,21]], radius = 9\n\nOutput:\n [23,11]\n\nExplanation:\n Since there is only one tower, the network quality is highest right at the tower's location.\n\n\n\nExample 3:\n\n\n\n\nInput:\n towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n\nOutput:\n [1,2]\n\nExplanation:\n Coordinate (1, 2) has the highest network quality.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= towers.length <= 50\n\n\ntowers[i].length == 3\n\n\n0 <= x\ni\n, y\ni\n, q\ni\n <= 50\n\n\n1 <= radius <= 50",
    "temas": [
      "Array",
      "Enumeration"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1621,
    "slug": "number-of-sets-of-k-non-overlapping-line-segments",
    "url": "https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/",
    "titulo": "Number of Sets of K Non-Overlapping Line Segments",
    "enunciado": "Given \nn\n points on a 1-D plane, where the \ni\nth\n point (from \n0\n to \nn-1\n) is at \nx = i\n, find the number of ways we can draw \nexactly\n \nk\n \nnon-overlapping\n line segments such that each segment covers two or more points. The endpoints of each segment must have \nintegral coordinates\n. The \nk\n line segments \ndo not\n have to cover all \nn\n points, and they are \nallowed\n to share endpoints.\n\n\nReturn \nthe number of ways we can draw \nk\n non-overlapping line segments\n.\n Since this number can be huge, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, k = 2\n\nOutput:\n 5\n\nExplanation:\n The two line segments are shown in red and blue.\nThe image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, k = 1\n\nOutput:\n 3\n\nExplanation:\n The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 30, k = 7\n\nOutput:\n 796297179\n\nExplanation:\n The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 10\n9\n + 7 gives us 796297179.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 1000\n\n\n1 <= k <= n-1",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1601,
    "slug": "maximum-number-of-achievable-transfer-requests",
    "url": "https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/",
    "titulo": "Maximum Number of Achievable Transfer Requests",
    "enunciado": "We have \nn\n buildings numbered from \n0\n to \nn - 1\n. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n\n\nYou are given an array \nrequests\n where \nrequests[i] = [from\ni\n, to\ni\n]\n represents an employee's request to transfer from building \nfrom\ni\n to building \nto\ni\n.\n\n\nAll buildings are full\n, so a list of requests is achievable only if for each building, the \nnet change in employee transfers is zero\n. This means the number of employees \nleaving\n is \nequal\n to the number of employees \nmoving in\n. For example if \nn = 3\n and two employees are leaving building \n0\n, one is leaving building \n1\n, and one is leaving building \n2\n, there should be two employees moving to building \n0\n, one employee moving to building \n1\n, and one employee moving to building \n2\n.\n\n\nReturn \nthe maximum number of achievable requests\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n\nOutput:\n 5\n\nExplantion:\n Let's see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don't have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, requests = [[0,0],[1,2],[2,1]]\n\nOutput:\n 3\n\nExplantion:\n Let's see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests. \n\n\nExample 3:\n\n\n\n\nInput:\n n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 20\n\n\n1 <= requests.length <= 16\n\n\nrequests[i].length == 2\n\n\n0 <= from\ni\n, to\ni\n < n",
    "temas": [
      "Array",
      "Backtracking",
      "Bit Manipulation",
      "Enumeration"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1599,
    "slug": "maximum-profit-of-operating-a-centennial-wheel",
    "url": "https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/",
    "titulo": "Maximum Profit of Operating a Centennial Wheel",
    "enunciado": "You are the operator of a Centennial Wheel that has \nfour gondolas\n, and each gondola has room for \nup\n \nto\n \nfour people\n. You have the ability to rotate the gondolas \ncounterclockwise\n, which costs you \nrunningCost\n dollars.\n\n\nYou are given an array \ncustomers\n of length \nn\n where \ncustomers[i]\n is the number of new customers arriving just before the \ni\nth\n rotation (0-indexed). This means you \nmust rotate the wheel \ni\n times before the \ncustomers[i]\n customers arrive\n. \nYou cannot make customers wait if there is room in the gondola\n. Each customer pays \nboardingCost\n dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\n\n\nYou can stop the wheel at any time, including \nbefore\n \nserving\n \nall\n \ncustomers\n. If you decide to stop serving customers, \nall subsequent rotations are free\n in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait \nfor the next rotation\n.\n\n\nReturn\n the minimum number of rotations you need to perform to maximize your profit.\n If there is \nno scenario\n where the profit is positive, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n customers = [8,3], boardingCost = 5, runningCost = 6\n\nOutput:\n 3\n\nExplanation:\n The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.\n\n\n\nExample 2:\n\n\n\n\nInput:\n customers = [10,9,6], boardingCost = 6, runningCost = 4\n\nOutput:\n 7\n\nExplanation:\n\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n\nOutput:\n -1\n\nExplanation:\n\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == customers.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= customers[i] <= 50\n\n\n1 <= boardingCost, runningCost <= 100",
    "temas": [
      "Array",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1598,
    "slug": "crawler-log-folder",
    "url": "https://leetcode.com/problems/crawler-log-folder/",
    "titulo": "Crawler Log Folder",
    "enunciado": "The Leetcode file system keeps a log each time some user performs a \nchange folder\n operation.\n\n\nThe operations are described below:\n\n\n\n\n\"../\"\n : Move to the parent folder of the current folder. (If you are already in the main folder, \nremain in the same folder\n).\n\n\n\"./\"\n : Remain in the same folder.\n\n\n\"x/\"\n : Move to the child folder named \nx\n (This folder is \nguaranteed to always exist\n).\n\n\n\n\nYou are given a list of strings \nlogs\n where \nlogs[i]\n is the operation performed by the user at the \ni\nth\n step.\n\n\nThe file system starts in the main folder, then the operations in \nlogs\n are performed.\n\n\nReturn \nthe minimum number of operations needed to go back to the main folder after the change folder operations.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n\nOutput:\n 2\n\nExplanation: \nUse this change folder operation \"../\" 2 times and go back to the main folder.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n logs = [\"d1/\",\"../\",\"../\",\"../\"]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= logs.length <= 10\n3\n\n\n2 <= logs[i].length <= 10\n\n\nlogs[i]\n contains lowercase English letters, digits, \n'.'\n, and \n'/'\n.\n\n\nlogs[i]\n follows the format described in the statement.\n\n\nFolder names consist of lowercase English letters and digits.",
    "temas": [
      "Array",
      "String",
      "Stack"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1595,
    "slug": "minimum-cost-to-connect-two-groups-of-points",
    "url": "https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/",
    "titulo": "Minimum Cost to Connect Two Groups of Points",
    "enunciado": "You are given two groups of points where the first group has \nsize\n1\n points, the second group has \nsize\n2\n points, and \nsize\n1\n >= size\n2\n.\n\n\nThe \ncost\n of the connection between any two points are given in an \nsize\n1\n x size\n2\n matrix where \ncost[i][j]\n is the cost of connecting point \ni\n of the first group and point \nj\n of the second group. The groups are connected if \neach point in both groups is connected to one or more points in the opposite group\n. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.\n\n\nReturn \nthe minimum cost it takes to connect the two groups\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n cost = [[15, 96], [36, 2]]\n\nOutput:\n 17\n\nExplanation\n: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n\nOutput:\n 4\n\nExplanation\n: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n\n\n\nExample 3:\n\n\n\n\nInput:\n cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n\nOutput:\n 10\n\n\n\n \n\n\nConstraints:\n\n\n\n\nsize\n1\n == cost.length\n\n\nsize\n2\n == cost[i].length\n\n\n1 <= size\n1\n, size\n2\n <= 12\n\n\nsize\n1\n >= size\n2\n\n\n0 <= cost[i][j] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Matrix",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1594,
    "slug": "maximum-non-negative-product-in-a-matrix",
    "url": "https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/",
    "titulo": "Maximum Non Negative Product in a Matrix",
    "enunciado": "You are given a \nm x n\n matrix \ngrid\n. Initially, you are located at the top-left corner \n(0, 0)\n, and in each step, you can only \nmove right or down\n in the matrix.\n\n\nAmong all possible paths starting from the top-left corner \n(0, 0)\n and ending in the bottom-right corner \n(m - 1, n - 1)\n, find the path with the \nmaximum non-negative product\n. The product of a path is the product of all integers in the grid cells visited along the path.\n\n\nReturn the \nmaximum non-negative product \nmodulo\n \n10\n9\n + 7\n. \nIf the maximum product is \nnegative\n, return \n-1\n.\n\n\nNotice that the modulo is performed after getting the maximum product.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]\n\nOutput:\n -1\n\nExplanation:\n It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,-2,1],[1,-2,1],[3,-4,1]]\n\nOutput:\n 8\n\nExplanation:\n Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8).\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,3],[0,-4]]\n\nOutput:\n 0\n\nExplanation:\n Maximum non-negative product is shown (1 * 0 * -4 = 0).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 15\n\n\n-4 <= grid[i][j] <= 4",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1606,
    "slug": "find-servers-that-handled-most-number-of-requests",
    "url": "https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/",
    "titulo": "Find Servers That Handled Most Number of Requests",
    "enunciado": "You have \nk\n servers numbered from \n0\n to \nk-1\n that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but \ncannot handle more than one request at a time\n. The requests are assigned to servers according to a specific algorithm:\n\n\n\n\nThe \ni\nth\n (0-indexed) request arrives.\n\n\nIf all servers are busy, the request is dropped (not handled at all).\n\n\nIf the \n(i % k)\nth\n server is available, assign the request to that server.\n\n\nOtherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the \ni\nth\n server is busy, try to assign the request to the \n(i+1)\nth\n server, then the \n(i+2)\nth\n server, and so on.\n\n\n\n\nYou are given a \nstrictly increasing\n array \narrival\n of positive integers, where \narrival[i]\n represents the arrival time of the \ni\nth\n request, and another array \nload\n, where \nload[i]\n represents the load of the \ni\nth\n request (the time it takes to complete). Your goal is to find the \nbusiest server(s)\n. A server is considered \nbusiest\n if it handled the most number of requests successfully among all the servers.\n\n\nReturn \na list containing the IDs (0-indexed) of the \nbusiest server(s)\n. You may return the IDs in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n\nOutput:\n [1] \n\nExplanation:\n \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n\n\n\nExample 2:\n\n\n\n\nInput:\n k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n\nOutput:\n [0]\n\nExplanation:\n \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n\n\n\nExample 3:\n\n\n\n\nInput:\n k = 3, arrival = [1,2,3], load = [10,12,11]\n\nOutput:\n [0,1,2]\n\nExplanation:\n Each server handles a single request, so they are all considered the busiest.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= 10\n5\n\n\n1 <= arrival.length, load.length <= 10\n5\n\n\narrival.length == load.length\n\n\n1 <= arrival[i], load[i] <= 10\n9\n\n\narrival\n is \nstrictly increasing\n.",
    "temas": [
      "Array",
      "Greedy",
      "Heap (Priority Queue)",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1584,
    "slug": "min-cost-to-connect-all-points",
    "url": "https://leetcode.com/problems/min-cost-to-connect-all-points/",
    "titulo": "Min Cost to Connect All Points",
    "enunciado": "You are given an array \npoints\n representing integer coordinates of some points on a 2D-plane, where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nThe cost of connecting two points \n[x\ni\n, y\ni\n]\n and \n[x\nj\n, y\nj\n]\n is the \nmanhattan distance\n between them: \n|x\ni\n - x\nj\n| + |y\ni\n - y\nj\n|\n, where \n|val|\n denotes the absolute value of \nval\n.\n\n\nReturn \nthe minimum cost to make all points connected.\n All points are connected if there is \nexactly one\n simple path between any two points.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n\nOutput:\n 20\n\nExplanation:\n \n\n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,12],[-2,5],[-4,1]]\n\nOutput:\n 18\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 1000\n\n\n-10\n6\n <= x\ni\n, y\ni\n <= 10\n6\n\n\nAll pairs \n(x\ni\n, y\ni\n)\n are distinct.",
    "temas": [
      "Array",
      "Union Find",
      "Graph",
      "Minimum Spanning Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1582,
    "slug": "special-positions-in-a-binary-matrix",
    "url": "https://leetcode.com/problems/special-positions-in-a-binary-matrix/",
    "titulo": "Special Positions in a Binary Matrix",
    "enunciado": "Given an \nm x n\n binary matrix \nmat\n, return \nthe number of special positions in \nmat\n.\n\n\nA position \n(i, j)\n is called \nspecial\n if \nmat[i][j] == 1\n and all other elements in row \ni\n and column \nj\n are \n0\n (rows and columns are \n0-indexed\n).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,0,0],[0,0,1],[1,0,0]]\n\nOutput:\n 1\n\nExplanation:\n (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\nExplanation:\n (0, 0), (1, 1) and (2, 2) are special positions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 100\n\n\nmat[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1579,
    "slug": "remove-max-number-of-edges-to-keep-graph-fully-traversable",
    "url": "https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
    "titulo": "Remove Max Number of Edges to Keep Graph Fully Traversable",
    "enunciado": "Alice and Bob have an undirected graph of \nn\n nodes and three types of edges:\n\n\n\n\nType 1: Can be traversed by Alice only.\n\n\nType 2: Can be traversed by Bob only.\n\n\nType 3: Can be traversed by both Alice and Bob.\n\n\n\n\nGiven an array \nedges\n where \nedges[i] = [type\ni\n, u\ni\n, v\ni\n]\n represents a bidirectional edge of type \ntype\ni\n between nodes \nu\ni\n and \nv\ni\n, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n\n\nReturn \nthe maximum number of edges you can remove, or return\n \n-1\n \nif Alice and Bob cannot fully traverse the graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n\nOutput:\n 2\n\nExplanation: \nIf we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n\nOutput:\n 0\n\nExplanation: \nNotice that removing any edge will not make the graph fully traversable by Alice and Bob.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n\nOutput:\n -1\n\nExplanation: \nIn the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n\n\n \n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n1 <= edges.length <= min(10\n5\n, 3 * n * (n - 1) / 2)\n\n\nedges[i].length == 3\n\n\n1 <= type\ni\n <= 3\n\n\n1 <= u\ni\n < v\ni\n <= n\n\n\nAll tuples \n(type\ni\n, u\ni\n, v\ni\n)\n are distinct.",
    "temas": [
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Union Find",
    "has_image": true
  },
  {
    "id": 1578,
    "slug": "minimum-time-to-make-rope-colorful",
    "url": "https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",
    "titulo": "Minimum Time to Make Rope Colorful",
    "enunciado": "Alice has \nn\n balloons arranged on a rope. You are given a \n0-indexed\n string \ncolors\n where \ncolors[i]\n is the color of the \ni\nth\n balloon.\n\n\nAlice wants the rope to be \ncolorful\n. She does not want \ntwo consecutive balloons\n to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it \ncolorful\n. You are given a \n0-indexed\n integer array \nneededTime\n where \nneededTime[i]\n is the time (in seconds) that Bob needs to remove the \ni\nth\n balloon from the rope.\n\n\nReturn \nthe \nminimum time\n Bob needs to make the rope \ncolorful\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n colors = \"abaac\", neededTime = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n colors = \"abc\", neededTime = [1,2,3]\n\nOutput:\n 0\n\nExplanation:\n The rope is already colorful. Bob does not need to remove any balloons from the rope.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n colors = \"aabaa\", neededTime = [1,2,3,4,1]\n\nOutput:\n 2\n\nExplanation:\n Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == colors.length == neededTime.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= neededTime[i] <= 10\n4\n\n\ncolors\n contains only lowercase English letters.",
    "temas": [
      "Array",
      "String",
      "Dynamic Programming",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1591,
    "slug": "strange-printer-ii",
    "url": "https://leetcode.com/problems/strange-printer-ii/",
    "titulo": "Strange Printer II",
    "enunciado": "There is a strange printer with the following two special requirements:\n\n\n\n\nOn each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n\n\nOnce the printer has used a color for the above operation, \nthe same color cannot be used again\n.\n\n\n\n\nYou are given a \nm x n\n matrix \ntargetGrid\n, where \ntargetGrid[row][col]\n is the color in the position \n(row, col)\n of the grid.\n\n\nReturn \ntrue\n if it is possible to print the matrix \ntargetGrid\n,\n otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n\nOutput:\n false\n\nExplanation:\n It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == targetGrid.length\n\n\nn == targetGrid[i].length\n\n\n1 <= m, n <= 60\n\n\n1 <= targetGrid[row][col] <= 60",
    "temas": [
      "Array",
      "Graph",
      "Topological Sort",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1569,
    "slug": "number-of-ways-to-reorder-array-to-get-same-bst",
    "url": "https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/",
    "titulo": "Number of Ways to Reorder Array to Get Same BST",
    "enunciado": "Given an array \nnums\n that represents a permutation of integers from \n1\n to \nn\n. We are going to construct a binary search tree (BST) by inserting the elements of \nnums\n in order into an initially empty BST. Find the number of different ways to reorder \nnums\n so that the constructed BST is identical to that formed from the original array \nnums\n.\n\n\n\n\nFor example, given \nnums = [2,1,3]\n, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array \n[2,3,1]\n also yields the same BST but \n[3,2,1]\n yields a different BST.\n\n\n\n\nReturn \nthe number of ways to reorder\n \nnums\n \nsuch that the BST formed is identical to the original BST formed from\n \nnums\n.\n\n\nSince the answer may be very large, \nreturn it modulo \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [2,1,3]\n\nOutput:\n 1\n\nExplanation:\n We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 5\n\nExplanation:\n The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n 0\n\nExplanation:\n There are no other orderings of nums that will yield the same BST.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n1 <= nums[i] <= nums.length\n\n\nAll integers in \nnums\n are \ndistinct\n.",
    "temas": [
      "Array",
      "Math",
      "Divide and Conquer",
      "Dynamic Programming",
      "Tree",
      "Union Find",
      "Binary Search Tree",
      "Memoization",
      "Combinatorics",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1568,
    "slug": "minimum-number-of-days-to-disconnect-island",
    "url": "https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/",
    "titulo": "Minimum Number of Days to Disconnect Island",
    "enunciado": "You are given an \nm x n\n binary grid \ngrid\n where \n1\n represents land and \n0\n represents water. An \nisland\n is a maximal \n4-directionally\n (horizontal or vertical) connected group of \n1\n's.\n\n\nThe grid is said to be \nconnected\n if we have \nexactly one island\n, otherwise is said \ndisconnected\n.\n\n\nIn one day, we are allowed to change \nany \nsingle land cell \n(1)\n into a water cell \n(0)\n.\n\n\nReturn \nthe minimum number of days to disconnect the grid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n\n\nOutput:\n 2\n\nExplanation:\n We need at least 2 days to get a disconnected grid.\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1]]\n\nOutput:\n 2\n\nExplanation:\n Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 30\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix",
      "Strongly Connected Component"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1560,
    "slug": "most-visited-sector-in-a-circular-track",
    "url": "https://leetcode.com/problems/most-visited-sector-in-a-circular-track/",
    "titulo": "Most Visited Sector in  a Circular Track",
    "enunciado": "Given an integer \nn\n and an integer array \nrounds\n. We have a circular track which consists of \nn\n sectors labeled from \n1\n to \nn\n. A marathon will be held on this track, the marathon consists of \nm\n rounds. The \ni\nth\n round starts at sector \nrounds[i - 1]\n and ends at sector \nrounds[i]\n. For example, round 1 starts at sector \nrounds[0]\n and ends at sector \nrounds[1]\n\n\nReturn \nan array of the most visited sectors\n sorted in \nascending\n order.\n\n\nNotice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, rounds = [1,3,1,2]\n\nOutput:\n [1,2]\n\nExplanation:\n The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, rounds = [2,1,2,1,2,1,2,1,2]\n\nOutput:\n [2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 7, rounds = [1,3,5,7]\n\nOutput:\n [1,2,3,4,5,6,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n1 <= m <= 100\n\n\nrounds.length == m + 1\n\n\n1 <= rounds[i] <= n\n\n\nrounds[i] != rounds[i + 1]\n for \n0 <= i < m",
    "temas": [
      "Array",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1572,
    "slug": "matrix-diagonal-sum",
    "url": "https://leetcode.com/problems/matrix-diagonal-sum/",
    "titulo": "Matrix Diagonal Sum",
    "enunciado": "Given a square matrix \nmat\n, return the sum of the matrix diagonals.\n\n\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[\n1\n,2,\n3\n],\n              [4,\n5\n,6],\n              [\n7\n,8,\n9\n]]\n\nOutput:\n 25\n\nExplanation: \nDiagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat[1][1] = 5 is counted only once.\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[\n1\n,1,1,\n1\n],\n              [1,\n1\n,\n1\n,1],\n              [1,\n1\n,\n1\n,1],\n              [\n1\n,1,1,\n1\n]]\n\nOutput:\n 8\n\n\n\nExample 3:\n\n\n\n\nInput:\n mat = [[\n5\n]]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == mat.length == mat[i].length\n\n\n1 <= n <= 100\n\n\n1 <= mat[i][j] <= 100",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1552,
    "slug": "magnetic-force-between-two-balls",
    "url": "https://leetcode.com/problems/magnetic-force-between-two-balls/",
    "titulo": "Magnetic Force Between Two Balls",
    "enunciado": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has \nn\n empty baskets, the \ni\nth\n basket is at \nposition[i]\n, Morty has \nm\n balls and needs to distribute the balls into the baskets such that the \nminimum magnetic force\n between any two balls is \nmaximum\n.\n\n\nRick stated that magnetic force between two different balls at positions \nx\n and \ny\n is \n|x - y|\n.\n\n\nGiven the integer array \nposition\n and the integer \nm\n. Return \nthe required force\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n position = [1,2,3,4,7], m = 3\n\nOutput:\n 3\n\nExplanation:\n Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n position = [5,4,3,2,1,1000000000], m = 2\n\nOutput:\n 999999999\n\nExplanation:\n We can use baskets 1 and 1000000000.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == position.length\n\n\n2 <= n <= 10\n5\n\n\n1 <= position[i] <= 10\n9\n\n\nAll integers in \nposition\n are \ndistinct\n.\n\n\n2 <= m <= position.length",
    "temas": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1547,
    "slug": "minimum-cost-to-cut-a-stick",
    "url": "https://leetcode.com/problems/minimum-cost-to-cut-a-stick/",
    "titulo": "Minimum Cost to Cut a Stick",
    "enunciado": "Given a wooden stick of length \nn\n units. The stick is labelled from \n0\n to \nn\n. For example, a stick of length \n6\n is labelled as follows:\n\n\n\n\nGiven an integer array \ncuts\n where \ncuts[i]\n denotes a position you should perform a cut at.\n\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\n\nReturn \nthe minimum total cost\n of the cuts.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, cuts = [1,3,4,5]\n\nOutput:\n 16\n\nExplanation:\n Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\n\n\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n\nExample 2:\n\n\n\n\nInput:\n n = 9, cuts = [5,6,1,4,2]\n\nOutput:\n 22\n\nExplanation:\n If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n6\n\n\n1 <= cuts.length <= min(n - 1, 100)\n\n\n1 <= cuts[i] <= n - 1\n\n\nAll the integers in \ncuts\n array are \ndistinct\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1559,
    "slug": "detect-cycles-in-2d-grid",
    "url": "https://leetcode.com/problems/detect-cycles-in-2d-grid/",
    "titulo": "Detect Cycles in 2D Grid",
    "enunciado": "Given a 2D array of characters \ngrid\n of size \nm x n\n, you need to find if there exists any cycle consisting of the \nsame value\n in \ngrid\n.\n\n\nA cycle is a path of \nlength 4 or more\n in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the \nsame value\n of the current cell.\n\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle \n(1, 1) -> (1, 2) -> (1, 1)\n is invalid because from \n(1, 2)\n we visited \n(1, 1)\n which was the last visited cell.\n\n\nReturn \ntrue\n if any cycle of the same value exists in \ngrid\n, otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n\nOutput:\n true\n\nExplanation: \nThere are two valid cycles shown in different colors in the image below:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n\nOutput:\n true\n\nExplanation: \nThere is only one valid cycle highlighted in the image below:\n\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 500\n\n\ngrid\n consists only of lowercase English letters.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1558,
    "slug": "minimum-numbers-of-function-calls-to-make-target-array",
    "url": "https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/",
    "titulo": "Minimum Numbers of Function Calls to Make Target Array",
    "enunciado": "You are given an integer array \nnums\n. You have an integer array \narr\n of the same length with all values set to \n0\n initially. You also have the following \nmodify\n function:\n\n\n\n\nYou want to use the modify function to convert \narr\n to \nnums\n using the minimum number of calls.\n\n\nReturn \nthe minimum number of function calls to make \nnums\n from \narr\n.\n\n\nThe test cases are generated so that the answer fits in a \n32-bit\n signed integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,5]\n\nOutput:\n 5\n\nExplanation:\n Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).\nDouble all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).\nIncrement by 1 (both elements)  [0, 4] -> [1, 4] -> \n[1, 5]\n (2 operations).\nTotal of operations: 1 + 2 + 2 = 5.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2]\n\nOutput:\n 3\n\nExplanation:\n Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).\nDouble all the elements: [1, 1] -> \n[2, 2]\n (1 operation).\nTotal of operations: 2 + 1 = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [4,2,5]\n\nOutput:\n 6\n\nExplanation:\n (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> \n[4,2,5]\n(nums).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n9",
    "temas": [
      "Array",
      "Greedy",
      "Bit Manipulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1557,
    "slug": "minimum-number-of-vertices-to-reach-all-nodes",
    "url": "https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/",
    "titulo": "Minimum Number of Vertices to Reach All Nodes",
    "enunciado": "Given a\n directed acyclic graph\n, with \nn\n vertices numbered from \n0\n to \nn-1\n, and an array \nedges\n where \nedges[i] = [from\ni\n, to\ni\n]\n represents a directed edge from node \nfrom\ni\n to node \nto\ni\n.\n\n\nFind \nthe smallest set of vertices from which all nodes in the graph are reachable\n. It's guaranteed that a unique solution exists.\n\n\nNotice that you can return the vertices in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\n\nOutput:\n [0,3]\n\nExplanation: \nIt's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\n\nOutput:\n [0,2,3]\n\nExplanation: \nNotice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10^5\n\n\n1 <= edges.length <= min(10^5, n * (n - 1) / 2)\n\n\nedges[i].length == 2\n\n\n0 <= from\ni,\n to\ni\n < n\n\n\nAll pairs \n(from\ni\n, to\ni\n)\n are distinct.",
    "temas": [
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 1537,
    "slug": "get-the-maximum-score",
    "url": "https://leetcode.com/problems/get-the-maximum-score/",
    "titulo": "Get the Maximum Score",
    "enunciado": "You are given two \nsorted\n arrays of distinct integers \nnums1\n and \nnums2\n.\n\n\nA \nvalid\n \npath\n is defined as follows:\n\n\n\n\nChoose array \nnums1\n or \nnums2\n to traverse (from index-0).\n\n\nTraverse the current array from left to right.\n\n\nIf you are reading any value that is present in \nnums1\n and \nnums2\n you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\n\n\n\nThe \nscore\n is defined as the sum of unique values in a valid path.\n\n\nReturn \nthe maximum score you can obtain of all possible \nvalid paths\n. Since the answer may be too large, return it modulo \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n\nOutput:\n 30\n\nExplanation:\n Valid paths:\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)\nThe maximum is obtained with the path in green \n[2,4,6,8,10]\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,3,5,7,9], nums2 = [3,5,100]\n\nOutput:\n 109\n\nExplanation:\n Maximum sum is obtained with the path \n[1,3,5,100]\n.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\n\nOutput:\n 40\n\nExplanation:\n There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path [6,7,8,9,10].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 10\n5\n\n\n1 <= nums1[i], nums2[i] <= 10\n7\n\n\nnums1\n and \nnums2\n are strictly increasing.",
    "temas": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Greedy"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1536,
    "slug": "minimum-swaps-to-arrange-a-binary-grid",
    "url": "https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/",
    "titulo": "Minimum Swaps to Arrange a Binary Grid",
    "enunciado": "Given an \nn x n\n binary \ngrid\n, in one step you can choose two \nadjacent rows\n of the grid and swap them.\n\n\nA grid is said to be \nvalid\n if all the cells above the main diagonal are \nzeros\n.\n\n\nReturn \nthe minimum number of steps\n needed to make the grid valid, or \n-1\n if the grid cannot be valid.\n\n\nThe main diagonal of a grid is the diagonal that starts at cell \n(1, 1)\n and ends at cell \n(n, n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1],[1,1,0],[1,0,0]]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n\nOutput:\n -1\n\nExplanation:\n All rows are similar, swaps have no effect on the grid.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0],[1,1,0],[1,1,1]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n \n== grid[i].length\n\n\n1 <= n <= 200\n\n\ngrid[i][j]\n is either \n0\n or \n1",
    "temas": [
      "Array",
      "Greedy",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1530,
    "slug": "number-of-good-leaf-nodes-pairs",
    "url": "https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/",
    "titulo": "Number of Good Leaf Nodes Pairs",
    "enunciado": "You are given the \nroot\n of a binary tree and an integer \ndistance\n. A pair of two different \nleaf\n nodes of a binary tree is said to be good if the length of \nthe shortest path\n between them is less than or equal to \ndistance\n.\n\n\nReturn \nthe number of good leaf node pairs\n in the tree.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4], distance = 3\n\nOutput:\n 1\n\nExplanation:\n The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7], distance = 3\n\nOutput:\n 2\n\nExplanation:\n The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n\nOutput:\n 1\n\nExplanation:\n The only good pair is [2,5].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the \ntree\n is in the range \n[1, 2\n10\n].\n\n\n1 <= Node.val <= 100\n\n\n1 <= distance <= 10",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1528,
    "slug": "shuffle-string",
    "url": "https://leetcode.com/problems/shuffle-string/",
    "titulo": "Shuffle String",
    "enunciado": "You are given a string \ns\n and an integer array \nindices\n of the \nsame length\n. The string \ns\n will be shuffled such that the character at the \ni\nth\n position moves to \nindices[i]\n in the shuffled string.\n\n\nReturn \nthe shuffled string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"codeleet\", \nindices\n = [4,5,6,7,0,2,1,3]\n\nOutput:\n \"leetcode\"\n\nExplanation:\n As shown, \"codeleet\" becomes \"leetcode\" after shuffling.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abc\", \nindices\n = [0,1,2]\n\nOutput:\n \"abc\"\n\nExplanation:\n After shuffling, each character remains in its position.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ns.length == indices.length == n\n\n\n1 <= n <= 100\n\n\ns\n consists of only lowercase English letters.\n\n\n0 <= indices[i] < n\n\n\nAll values of \nindices\n are \nunique\n.",
    "temas": [
      "Array",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1521,
    "slug": "find-a-value-of-a-mysterious-function-closest-to-target",
    "url": "https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/",
    "titulo": "Find a Value of a Mysterious Function Closest to Target",
    "enunciado": "Winston was given the above mysterious function \nfunc\n. He has an integer array \narr\n and an integer \ntarget\n and he wants to find the values \nl\n and \nr\n that make the value \n|func(arr, l, r) - target|\n minimum possible.\n\n\nReturn \nthe minimum possible value\n of \n|func(arr, l, r) - target|\n.\n\n\nNotice that \nfunc\n should be called with the values \nl\n and \nr\n where \n0 <= l, r < arr.length\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [9,12,3,7,15], target = 5\n\nOutput:\n 2\n\nExplanation:\n Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1000000,1000000,1000000], target = 1\n\nOutput:\n 999999\n\nExplanation:\n Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [1,2,4,8,16], target = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 10\n5\n\n\n1 <= arr[i] <= 10\n6\n\n\n0 <= target <= 10\n7",
    "temas": [
      "Array",
      "Binary Search",
      "Bit Manipulation",
      "Segment Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1519,
    "slug": "number-of-nodes-in-the-sub-tree-with-the-same-label",
    "url": "https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/",
    "titulo": "Number of Nodes in the Sub-Tree With the Same Label",
    "enunciado": "You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of \nn\n nodes numbered from \n0\n to \nn - 1\n and exactly \nn - 1\n \nedges\n. The \nroot\n of the tree is the node \n0\n, and each node of the tree has \na label\n which is a lower-case character given in the string \nlabels\n (i.e. The node with the number \ni\n has the label \nlabels[i]\n).\n\n\nThe \nedges\n array is given on the form \nedges[i] = [a\ni\n, b\ni\n]\n, which means there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nReturn \nan array of size \nn\n where \nans[i]\n is the number of nodes in the subtree of the \ni\nth\n node which have the same label as node \ni\n.\n\n\nA subtree of a tree \nT\n is the tree consisting of a node in \nT\n and all of its descendant nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"\n\nOutput:\n [2,1,1,1,1,1,1]\n\nExplanation:\n Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"\n\nOutput:\n [4,2,1,1]\n\nExplanation:\n The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"\n\nOutput:\n [3,2,1,1,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nlabels.length == n\n\n\nlabels\n is consisting of only of lowercase English letters.",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Counting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1518,
    "slug": "water-bottles",
    "url": "https://leetcode.com/problems/water-bottles/",
    "titulo": "Water Bottles",
    "enunciado": "There are \nnumBottles\n water bottles that are initially full of water. You can exchange \nnumExchange\n empty water bottles from the market with one full water bottle.\n\n\nThe operation of drinking a full water bottle turns it into an empty bottle.\n\n\nGiven the two integers \nnumBottles\n and \nnumExchange\n, return \nthe \nmaximum\n number of water bottles you can drink\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n numBottles = 9, numExchange = 3\n\nOutput:\n 13\n\nExplanation:\n You can exchange 3 empty bottles to get 1 full water bottle.\nNumber of water bottles you can drink: 9 + 3 + 1 = 13.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n numBottles = 15, numExchange = 4\n\nOutput:\n 19\n\nExplanation:\n You can exchange 4 empty bottles to get 1 full water bottle. \nNumber of water bottles you can drink: 15 + 3 + 1 = 19.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numBottles <= 100\n\n\n2 <= numExchange <= 100",
    "temas": [
      "Math",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1515,
    "slug": "best-position-for-a-service-centre",
    "url": "https://leetcode.com/problems/best-position-for-a-service-centre/",
    "titulo": "Best Position for a Service Centre",
    "enunciado": "A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that \nthe sum of the euclidean distances to all customers is minimum\n.\n\n\nGiven an array \npositions\n where \npositions[i] = [x\ni\n, y\ni\n]\n is the position of the \nith\n customer on the map, return \nthe minimum sum of the euclidean distances\n to all customers.\n\n\nIn other words, you need to choose the position of the service center \n[x\ncentre\n, y\ncentre\n]\n such that the following formula is minimized:\n\n\n\n\nAnswers within \n10\n-5\n of the actual value will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n positions = [[0,1],[1,0],[1,2],[2,1]]\n\nOutput:\n 4.00000\n\nExplanation:\n As shown, you can see that choosing [x\ncentre\n, y\ncentre\n] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n positions = [[1,1],[3,3]]\n\nOutput:\n 2.82843\n\nExplanation:\n The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= positions.length <= 50\n\n\npositions[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 100",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Randomized"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1505,
    "slug": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
    "url": "https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/",
    "titulo": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
    "enunciado": "You are given a string \nnum\n representing \nthe digits\n of a very large integer and an integer \nk\n. You are allowed to swap any two adjacent digits of the integer \nat most\n \nk\n times.\n\n\nReturn \nthe minimum integer you can obtain also as a string\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n num = \"4321\", k = 4\n\nOutput:\n \"1342\"\n\nExplanation:\n The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = \"100\", k = 1\n\nOutput:\n \"010\"\n\nExplanation:\n It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = \"36789\", k = 1000\n\nOutput:\n \"36789\"\n\nExplanation:\n We can keep the number without any swaps.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num.length <= 3 * 10\n4\n\n\nnum\n consists of only \ndigits\n and does not contain \nleading zeros\n.\n\n\n1 <= k <= 10\n9",
    "temas": [
      "String",
      "Greedy",
      "Binary Indexed Tree",
      "Segment Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 1504,
    "slug": "count-submatrices-with-all-ones",
    "url": "https://leetcode.com/problems/count-submatrices-with-all-ones/",
    "titulo": "Count Submatrices With All Ones",
    "enunciado": "Given an \nm x n\n binary matrix \nmat\n, \nreturn the number of \nsubmatrices\n that have all ones\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,0,1],[1,1,0],[1,1,0]]\n\nOutput:\n 13\n\nExplanation:\n \nThere are 6 rectangles of side 1x1.\nThere are 2 rectangles of side 1x2.\nThere are 3 rectangles of side 2x1.\nThere is 1 rectangle of side 2x2. \nThere is 1 rectangle of side 3x1.\nTotal number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]\n\nOutput:\n 24\n\nExplanation:\n \nThere are 8 rectangles of side 1x1.\nThere are 5 rectangles of side 1x2.\nThere are 2 rectangles of side 1x3. \nThere are 4 rectangles of side 2x1.\nThere are 2 rectangles of side 2x2. \nThere are 2 rectangles of side 3x1. \nThere is 1 rectangle of side 3x2. \nTotal number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 150\n\n\nmat[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Matrix",
      "Monotonic Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1503,
    "slug": "last-moment-before-all-ants-fall-out-of-a-plank",
    "url": "https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/",
    "titulo": "Last Moment Before All Ants Fall Out of a Plank",
    "enunciado": "We have a wooden plank of the length \nn\n \nunits\n. Some ants are walking on the plank, each ant moves with a speed of \n1 unit per second\n. Some of the ants move to the \nleft\n, the other move to the \nright\n.\n\n\nWhen two ants moving in two \ndifferent\n directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n\n\nWhen an ant reaches \none end\n of the plank at a time \nt\n, it falls out of the plank immediately.\n\n\nGiven an integer \nn\n and two integer arrays \nleft\n and \nright\n, the positions of the ants moving to the left and the right, return \nthe moment when the last ant(s) fall out of the plank\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, left = [4,3], right = [0,1]\n\nOutput:\n 4\n\nExplanation:\n In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, left = [], right = [0,1,2,3,4,5,6,7]\n\nOutput:\n 7\n\nExplanation:\n All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 7, left = [0,1,2,3,4,5,6,7], right = []\n\nOutput:\n 7\n\nExplanation:\n All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4\n\n\n0 <= left.length <= n + 1\n\n\n0 <= left[i] <= n\n\n\n0 <= right.length <= n + 1\n\n\n0 <= right[i] <= n\n\n\n1 <= left.length + right.length <= n + 1\n\n\nAll values of \nleft\n and \nright\n are unique, and each value can appear \nonly in one\n of the two arrays.",
    "temas": [
      "Array",
      "Brainteaser",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1496,
    "slug": "path-crossing",
    "url": "https://leetcode.com/problems/path-crossing/",
    "titulo": "Path Crossing",
    "enunciado": "Given a string \npath\n, where \npath[i] = 'N'\n, \n'S'\n, \n'E'\n or \n'W'\n, each representing moving one unit north, south, east, or west, respectively. You start at the origin \n(0, 0)\n on a 2D plane and walk on the path specified by \npath\n.\n\n\nReturn \ntrue\n \nif the path crosses itself at any point, that is, if at any time you are on a location you have previously visited\n. Return \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n path = \"NES\"\n\nOutput:\n false \n\nExplanation:\n Notice that the path doesn't cross any point more than once.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n path = \"NESWW\"\n\nOutput:\n true\n\nExplanation:\n Notice that the path visits the origin twice.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= path.length <= 10\n4\n\n\npath[i]\n is either \n'N'\n, \n'S'\n, \n'E'\n, or \n'W'\n.",
    "temas": [
      "Hash Table",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1489,
    "slug": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
    "url": "https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
    "titulo": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
    "enunciado": "Given a weighted undirected connected graph with \nn\n vertices numbered from \n0\n to \nn - 1\n, and an array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n, weight\ni\n]\n represents a bidirectional and weighted edge between nodes \na\ni\n and \nb\ni\n. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.\n\n\nFind \nall the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST)\n. An MST edge whose deletion from the graph would cause the MST weight to increase is called a \ncritical edge\n. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\n\n\nNote that you can return the indices of the edges in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n\nOutput:\n [[0,1],[2,3,4,5]]\n\nExplanation:\n The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n\n\nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n\nOutput:\n [[],[0,1,2,3]]\n\nExplanation:\n We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n1 <= edges.length <= min(200, n * (n - 1) / 2)\n\n\nedges[i].length == 3\n\n\n0 <= a\ni\n < b\ni\n < n\n\n\n1 <= weight\ni\n <= 1000\n\n\nAll pairs \n(a\ni\n, b\ni\n)\n are \ndistinct\n.",
    "temas": [
      "Union Find",
      "Graph",
      "Sorting",
      "Minimum Spanning Tree",
      "Strongly Connected Component"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Union Find",
    "has_image": true
  },
  {
    "id": 1494,
    "slug": "parallel-courses-ii",
    "url": "https://leetcode.com/problems/parallel-courses-ii/",
    "titulo": "Parallel Courses II",
    "enunciado": "You are given an integer \nn\n, which indicates that there are \nn\n courses labeled from \n1\n to \nn\n. You are also given an array \nrelations\n where \nrelations[i] = [prevCourse\ni\n, nextCourse\ni\n]\n, representing a prerequisite relationship between course \nprevCourse\ni\n and course \nnextCourse\ni\n: course \nprevCourse\ni\n has to be taken before course \nnextCourse\ni\n. Also, you are given the integer \nk\n.\n\n\nIn one semester, you can take \nat most\n \nk\n courses as long as you have taken all the prerequisites in the \nprevious\n semesters for the courses you are taking.\n\n\nReturn \nthe \nminimum\n number of semesters needed to take all courses\n. The testcases will be generated such that it is possible to take every course.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n\nOutput:\n 3\n\nExplanation:\n The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n\nOutput:\n 4\n\nExplanation:\n The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 15\n\n\n1 <= k <= n\n\n\n0 <= relations.length <= n * (n-1) / 2\n\n\nrelations[i].length == 2\n\n\n1 <= prevCourse\ni\n, nextCourse\ni\n <= n\n\n\nprevCourse\ni\n != nextCourse\ni\n\n\nAll the pairs \n[prevCourse\ni\n, nextCourse\ni\n]\n are \nunique\n.\n\n\nThe given graph is a directed acyclic graph.",
    "temas": [
      "Dynamic Programming",
      "Bit Manipulation",
      "Graph",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1466,
    "slug": "reorder-routes-to-make-all-paths-lead-to-the-city-zero",
    "url": "https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",
    "titulo": "Reorder Routes to Make All Paths Lead to the City Zero",
    "enunciado": "There are \nn\n cities numbered from \n0\n to \nn - 1\n and \nn - 1\n roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\n\nRoads are represented by \nconnections\n where \nconnections[i] = [a\ni\n, b\ni\n]\n represents a road from city \na\ni\n to city \nb\ni\n.\n\n\nThis year, there will be a big event in the capital (city \n0\n), and many people want to travel to this city.\n\n\nYour task consists of reorienting some roads such that each city can visit the city \n0\n. Return the \nminimum\n number of edges changed.\n\n\nIt's \nguaranteed\n that each city can reach city \n0\n after reorder.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\n\nOutput:\n 3\n\nExplanation: \nChange the direction of edges show in red such that each node can reach the node 0 (capital).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\n\nOutput:\n 2\n\nExplanation: \nChange the direction of edges show in red such that each node can reach the node 0 (capital).\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3, connections = [[1,0],[2,0]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 5 * 10\n4\n\n\nconnections.length == n - 1\n\n\nconnections[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1465,
    "slug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
    "url": "https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/",
    "titulo": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
    "enunciado": "You are given a rectangular cake of size \nh x w\n and two arrays of integers \nhorizontalCuts\n and \nverticalCuts\n where:\n\n\n\n\nhorizontalCuts[i]\n is the distance from the top of the rectangular cake to the \ni\nth\n horizontal cut and similarly, and\n\n\nverticalCuts[j]\n is the distance from the left of the rectangular cake to the \nj\nth\n vertical cut.\n\n\n\n\nReturn \nthe maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays\n \nhorizontalCuts\n \nand\n \nverticalCuts\n. Since the answer can be a large number, return this \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\n\nOutput:\n 4 \n\nExplanation:\n The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\n\nOutput:\n 6\n\nExplanation:\n The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n\n\n\nExample 3:\n\n\n\n\nInput:\n h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= h, w <= 10\n9\n\n\n1 <= horizontalCuts.length <= min(h - 1, 10\n5\n)\n\n\n1 <= verticalCuts.length <= min(w - 1, 10\n5\n)\n\n\n1 <= horizontalCuts[i] < h\n\n\n1 <= verticalCuts[i] < w\n\n\nAll the elements in \nhorizontalCuts\n are distinct.\n\n\nAll the elements in \nverticalCuts\n are distinct.",
    "temas": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1478,
    "slug": "allocate-mailboxes",
    "url": "https://leetcode.com/problems/allocate-mailboxes/",
    "titulo": "Allocate Mailboxes",
    "enunciado": "Given the array \nhouses\n where \nhouses[i]\n is the location of the \ni\nth\n house along a street and an integer \nk\n, allocate \nk\n mailboxes in the street.\n\n\nReturn \nthe \nminimum\n total distance between each house and its nearest mailbox\n.\n\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n houses = [1,4,8,10,20], k = 3\n\nOutput:\n 5\n\nExplanation:\n Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n houses = [2,3,5,12,18], k = 2\n\nOutput:\n 9\n\nExplanation:\n Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= houses.length <= 100\n\n\n1 <= houses[i] <= 10\n4\n\n\nAll the integers of \nhouses\n are \nunique\n.",
    "temas": [
      "Array",
      "Math",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1457,
    "slug": "pseudo-palindromic-paths-in-a-binary-tree",
    "url": "https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",
    "titulo": "Pseudo-Palindromic Paths in a Binary Tree",
    "enunciado": "Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be \npseudo-palindromic\n if at least one permutation of the node values in the path is a palindrome.\n\n\nReturn the number of \npseudo-palindromic\n paths going from the root node to leaf nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,3,1,3,1,null,1]\n\nOutput:\n 2 \n\nExplanation:\n The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,1,1,3,null,null,null,null,null,1]\n\nOutput:\n 1 \n\nExplanation:\n The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [9]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n1 <= Node.val <= 9",
    "temas": [
      "Bit Manipulation",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Bit Manipulation",
    "has_image": true
  },
  {
    "id": 1453,
    "slug": "maximum-number-of-darts-inside-of-a-circular-dartboard",
    "url": "https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/",
    "titulo": "Maximum Number of Darts Inside of a Circular Dartboard",
    "enunciado": "Alice is throwing \nn\n darts on a very large wall. You are given an array \ndarts\n where \ndarts[i] = [x\ni\n, y\ni\n]\n is the position of the \ni\nth\n dart that Alice threw on the wall.\n\n\nBob knows the positions of the \nn\n darts on the wall. He wants to place a dartboard of radius \nr\n on the wall so that the maximum number of darts that Alice throws lie on the dartboard.\n\n\nGiven the integer \nr\n, return \nthe maximum number of darts that can lie on the dartboard\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n\nOutput:\n 4\n\nExplanation:\n Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n\nOutput:\n 5\n\nExplanation:\n Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= darts.length <= 100\n\n\ndarts[i].length == 2\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4\n\n\nAll the \ndarts\n are unique\n\n\n1 <= r <= 5000",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1463,
    "slug": "cherry-pickup-ii",
    "url": "https://leetcode.com/problems/cherry-pickup-ii/",
    "titulo": "Cherry Pickup II",
    "enunciado": "You are given a \nrows x cols\n matrix \ngrid\n representing a field of cherries where \ngrid[i][j]\n represents the number of cherries that you can collect from the \n(i, j)\n cell.\n\n\nYou have two robots that can collect cherries for you:\n\n\n\n\nRobot #1\n is located at the \ntop-left corner\n \n(0, 0)\n, and\n\n\nRobot #2\n is located at the \ntop-right corner\n \n(0, cols - 1)\n.\n\n\n\n\nReturn \nthe maximum number of cherries collection using both robots by following the rules below\n:\n\n\n\n\nFrom a cell \n(i, j)\n, robots can move to cell \n(i + 1, j - 1)\n, \n(i + 1, j)\n, or \n(i + 1, j + 1)\n.\n\n\nWhen any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n\n\nWhen both robots stay in the same cell, only one takes the cherries.\n\n\nBoth robots cannot move outside of the grid at any moment.\n\n\nBoth robots should reach the bottom row in \ngrid\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n\nOutput:\n 24\n\nExplanation:\n Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n\nOutput:\n 28\n\nExplanation:\n Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == grid.length\n\n\ncols == grid[i].length\n\n\n2 <= rows, cols <= 70\n\n\n0 <= grid[i][j] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1462,
    "slug": "course-schedule-iv",
    "url": "https://leetcode.com/problems/course-schedule-iv/",
    "titulo": "Course Schedule IV",
    "enunciado": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \na\ni\n first if you want to take course \nb\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n indicates that you have to take course \n0\n before you can take course \n1\n.\n\n\n\n\nPrerequisites can also be \nindirect\n. If course \na\n is a prerequisite of course \nb\n, and course \nb\n is a prerequisite of course \nc\n, then course \na\n is a prerequisite of course \nc\n.\n\n\nYou are also given an array \nqueries\n where \nqueries[j] = [u\nj\n, v\nj\n]\n. For the \nj\nth\n query, you should answer whether course \nu\nj\n is a prerequisite of course \nv\nj\n or not.\n\n\nReturn \na boolean array \nanswer\n, where \nanswer[j]\n is the answer to the \nj\nth\n query.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\n\nOutput:\n [false,true]\n\nExplanation:\n The pair [1, 0] indicates that you have to take course 1 before you can take course 0.\nCourse 0 is not a prerequisite of course 1, but the opposite is true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\n\nOutput:\n [false,false]\n\nExplanation:\n There are no prerequisites, and each course is independent.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\n\nOutput:\n [true,true]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= numCourses <= 100\n\n\n0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n <= numCourses - 1\n\n\na\ni\n != b\ni\n\n\nAll the pairs \n[a\ni\n, b\ni\n]\n are \nunique\n.\n\n\nThe prerequisites graph has no cycles.\n\n\n1 <= queries.length <= 10\n4\n\n\n0 <= u\ni\n, v\ni\n <= numCourses - 1\n\n\nu\ni\n != v\ni",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1444,
    "slug": "number-of-ways-of-cutting-a-pizza",
    "url": "https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/",
    "titulo": "Number of Ways of Cutting a Pizza",
    "enunciado": "Given a rectangular pizza represented as a \nrows x cols\n matrix containing the following characters: \n'A'\n (an apple) and \n'.'\n (empty cell) and given the integer \nk\n. You have to cut the pizza into \nk\n pieces using \nk-1\n cuts. \n\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n\nReturn the number of ways of cutting the pizza such that each piece contains \nat least\n one apple. \nSince the answer can be a huge number, return this modulo 10^9 + 7.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n pizza = [\"A..\",\"AAA\",\"...\"], k = 3\n\nOutput:\n 3 \n\nExplanation:\n The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n\n\nExample 2:\n\n\n\n\nInput:\n pizza = [\"A..\",\"AA.\",\"...\"], k = 3\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n pizza = [\"A..\",\"A..\",\"...\"], k = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rows, cols <= 50\n\n\nrows == pizza.length\n\n\ncols == pizza[i].length\n\n\n1 <= k <= 10\n\n\npizza\n consists of characters \n'A'\n and \n'.'\n only.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Memoization",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1443,
    "slug": "minimum-time-to-collect-all-apples-in-a-tree",
    "url": "https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/",
    "titulo": "Minimum Time to Collect All Apples in a Tree",
    "enunciado": "Given an undirected tree consisting of \nn\n vertices numbered from \n0\n to \nn-1\n, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. \nReturn the minimum time in seconds you have to spend to collect all apples in the tree, starting at \nvertex 0\n and coming back to this vertex.\n\n\nThe edges of the undirected tree are given in the array \nedges\n, where \nedges[i] = [a\ni\n, b\ni\n]\n means that exists an edge connecting the vertices \na\ni\n and \nb\ni\n. Additionally, there is a boolean array \nhasApple\n, where \nhasApple[i] = true\n means that vertex \ni\n has an apple; otherwise, it does not have any apple.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n\nOutput:\n 8 \n\nExplanation:\n The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n\nOutput:\n 6\n\nExplanation:\n The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n < b\ni\n <= n - 1\n\n\nhasApple.length == n",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1437,
    "slug": "check-if-all-1s-are-at-least-length-k-places-away",
    "url": "https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/",
    "titulo": "Check If All 1's Are at Least Length K Places Away",
    "enunciado": "Given an binary array \nnums\n and an integer \nk\n, return \ntrue\n if all \n1\n's are at least \nk\n places away from each other, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [1,0,0,0,1,0,0,1], k = 2\n\nOutput:\n true\n\nExplanation:\n Each of the 1s are at least 2 places away from each other.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,0,0,1,0,1], k = 2\n\nOutput:\n false\n\nExplanation:\n The second 1 and third 1 are only one apart from each other.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= k <= nums.length\n\n\nnums[i]\n is \n0\n or \n1",
    "temas": [
      "Array"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1448,
    "slug": "count-good-nodes-in-binary-tree",
    "url": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/",
    "titulo": "Count Good Nodes in Binary Tree",
    "enunciado": "Given a binary tree \nroot\n, a node \nX\n in the tree is named \ngood\n if in the path from root to \nX\n there are no nodes with a value \ngreater than\n X.\n\n\nReturn the number of \ngood\n nodes in the binary tree.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n root = [3,1,4,3,null,1,5]\r\n\nOutput:\n 4\r\n\nExplanation:\n Nodes in blue are \ngood\n.\r\nRoot Node (3) is always a good node.\r\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -> (3,4,5) is the maximum value in the path\r\nNode 3 -> (3,1,3) is the maximum value in the path.\n\n\nExample 2:\n\n\n\n\n\r\n\nInput:\n root = [3,3,null,4,2]\r\n\nOutput:\n 3\r\n\nExplanation:\n Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\n\n\nExample 3:\n\n\n\r\n\nInput:\n root = [1]\r\n\nOutput:\n 1\r\n\nExplanation:\n Root is considered as \ngood\n.\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the binary tree is in the range \n[1, 10^5]\n.\n\n\nEach node's value is between \n[-10^4, 10^4]\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1424,
    "slug": "diagonal-traverse-ii",
    "url": "https://leetcode.com/problems/diagonal-traverse-ii/",
    "titulo": "Diagonal Traverse II",
    "enunciado": "Given a 2D integer array \nnums\n, return \nall elements of \nnums\n in diagonal order as shown in the below images\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,4,2,7,5,3,8,6,9]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n\nOutput:\n [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i].length <= 10\n5\n\n\n1 <= sum(nums[i].length) <= 10\n5\n\n\n1 <= nums[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1420,
    "slug": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons",
    "url": "https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/",
    "titulo": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
    "enunciado": "You are given three integers \nn\n, \nm\n and \nk\n. Consider the following algorithm to find the maximum element of an array of positive integers:\n\n\n\n\nYou should build the array arr which has the following properties:\n\n\n\n\narr\n has exactly \nn\n integers.\n\n\n1 <= arr[i] <= m\n where \n(0 <= i < n)\n.\n\n\nAfter applying the mentioned algorithm to \narr\n, the value \nsearch_cost\n is equal to \nk\n.\n\n\n\n\nReturn \nthe number of ways\n to build the array \narr\n under the mentioned conditions. As the answer may grow large, the answer \nmust be\n computed modulo \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2, m = 3, k = 1\n\nOutput:\n 6\n\nExplanation:\n The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5, m = 2, k = 3\n\nOutput:\n 0\n\nExplanation:\n There are no possible arrays that satisfy the mentioned conditions.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 9, m = 1, k = 1\n\nOutput:\n 1\n\nExplanation:\n The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 50\n\n\n1 <= m <= 100\n\n\n0 <= k <= n",
    "temas": [
      "Dynamic Programming",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1411,
    "slug": "number-of-ways-to-paint-n-3-grid",
    "url": "https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/",
    "titulo": "Number of Ways to Paint N × 3 Grid",
    "enunciado": "You have a \ngrid\n of size \nn x 3\n and you want to paint each cell of the grid with exactly one of the three colors: \nRed\n, \nYellow,\n or \nGreen\n while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\n\nGiven \nn\n the number of rows of the grid, return \nthe number of ways\n you can paint this \ngrid\n. As the answer may grow large, the answer \nmust be\n computed modulo \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 12\n\nExplanation:\n There are 12 possible way to paint the grid as shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5000\n\nOutput:\n 30228214\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\n1 <= n <= 5000",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1391,
    "slug": "check-if-there-is-a-valid-path-in-a-grid",
    "url": "https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/",
    "titulo": "Check if There is a Valid Path in a Grid",
    "enunciado": "You are given an \nm x n\n \ngrid\n. Each cell of \ngrid\n represents a street. The street of \ngrid[i][j]\n can be:\n\n\n\n\n1\n which means a street connecting the left cell and the right cell.\n\n\n2\n which means a street connecting the upper cell and the lower cell.\n\n\n3\n which means a street connecting the left cell and the lower cell.\n\n\n4\n which means a street connecting the right cell and the lower cell.\n\n\n5\n which means a street connecting the left cell and the upper cell.\n\n\n6\n which means a street connecting the right cell and the upper cell.\n\n\n\n\n\n\nYou will initially start at the street of the upper-left cell \n(0, 0)\n. A valid path in the grid is a path that starts from the upper left cell \n(0, 0)\n and ends at the bottom-right cell \n(m - 1, n - 1)\n. \nThe path should only follow the streets\n.\n\n\nNotice\n that you are \nnot allowed\n to change any street.\n\n\nReturn \ntrue\n if there is a valid path in the grid or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,4,3],[6,5,2]]\n\nOutput:\n true\n\nExplanation:\n As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,2,1],[1,2,1]]\n\nOutput:\n false\n\nExplanation:\n As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,1,2]]\n\nOutput:\n false\n\nExplanation:\n You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\n1 <= grid[i][j] <= 6",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1401,
    "slug": "circle-and-rectangle-overlapping",
    "url": "https://leetcode.com/problems/circle-and-rectangle-overlapping/",
    "titulo": "Circle and Rectangle Overlapping",
    "enunciado": "You are given a circle represented as \n(radius, xCenter, yCenter)\n and an axis-aligned rectangle represented as \n(x1, y1, x2, y2)\n, where \n(x1, y1)\n are the coordinates of the bottom-left corner, and \n(x2, y2)\n are the coordinates of the top-right corner of the rectangle.\n\n\nReturn \ntrue\n if the circle and rectangle are overlapped otherwise return \nfalse\n. In other words, check if there is \nany\n point \n(x\ni\n, y\ni\n)\n that belongs to the circle and the rectangle at the same time.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n\nOutput:\n true\n\nExplanation:\n Circle and rectangle share the point (1,0).\n\n\n\nExample 2:\n\n\n\n\nInput:\n radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= radius <= 2000\n\n\n-10\n4\n <= xCenter, yCenter <= 10\n4\n\n\n-10\n4\n <= x1 < x2 <= 10\n4\n\n\n-10\n4\n <= y1 < y2 <= 10\n4",
    "temas": [
      "Math",
      "Geometry"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1379,
    "slug": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
    "url": "https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/",
    "titulo": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
    "enunciado": "Given two binary trees \noriginal\n and \ncloned\n and given a reference to a node \ntarget\n in the original tree.\n\n\nThe \ncloned\n tree is a \ncopy of\n the \noriginal\n tree.\n\n\nReturn \na reference to the same node\n in the \ncloned\n tree.\n\n\nNote\n that you are \nnot allowed\n to change any of the two trees or the \ntarget\n node and the answer \nmust be\n a reference to a node in the \ncloned\n tree.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n tree = [7,4,3,null,null,6,19], target = 3\n\nOutput:\n 3\n\nExplanation:\n In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n tree = [7], target =  7\n\nOutput:\n 7\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the \ntree\n is in the range \n[1, 10\n4\n]\n.\n\n\nThe values of the nodes of the \ntree\n are unique.\n\n\ntarget\n node is a node from the \noriginal\n tree and is not \nnull\n.\n\n\n\n\n \n\n\nFollow up:\n Could you solve the problem if repeated values on the tree are allowed?",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1377,
    "slug": "frog-position-after-t-seconds",
    "url": "https://leetcode.com/problems/frog-position-after-t-seconds/",
    "titulo": "Frog Position After T Seconds",
    "enunciado": "Given an undirected tree consisting of \nn\n vertices numbered from \n1\n to \nn\n. A frog starts jumping from \nvertex 1\n. In one second, the frog jumps from its current vertex to another \nunvisited\n vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n\n\nThe edges of the undirected tree are given in the array \nedges\n, where \nedges[i] = [a\ni\n, b\ni\n]\n means that exists an edge connecting the vertices \na\ni\n and \nb\ni\n.\n\n\nReturn the probability that after \nt\n seconds the frog is on the vertex \ntarget\n. \nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n\nOutput:\n 0.16666666666666666 \n\nExplanation:\n The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after \nsecond 1\n and then jumping with 1/2 probability to vertex 4 after \nsecond 2\n. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n\nOutput:\n 0.3333333333333333\n\nExplanation: \nThe figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after \nsecond 1\n. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n1 <= a\ni\n, b\ni\n <= n\n\n\n1 <= t <= 50\n\n\n1 <= target <= n",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1376,
    "slug": "time-needed-to-inform-all-employees",
    "url": "https://leetcode.com/problems/time-needed-to-inform-all-employees/",
    "titulo": "Time Needed to Inform All Employees",
    "enunciado": "A company has \nn\n employees with a unique ID for each employee from \n0\n to \nn - 1\n. The head of the company is the one with \nheadID\n.\n\n\nEach employee has one direct manager given in the \nmanager\n array where \nmanager[i]\n is the direct manager of the \ni-th\n employee, \nmanager[headID] = -1\n. Also, it is guaranteed that the subordination relationships have a tree structure.\n\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\n\nThe \ni-th\n employee needs \ninformTime[i]\n minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n\n\nReturn \nthe number of minutes\n needed to inform all the employees about the urgent news.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1, headID = 0, manager = [-1], informTime = [0]\n\nOutput:\n 0\n\nExplanation:\n The head of the company is the only employee in the company.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n\nOutput:\n 1\n\nExplanation:\n The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n0 <= headID < n\n\n\nmanager.length == n\n\n\n0 <= manager[i] < n\n\n\nmanager[headID] == -1\n\n\ninformTime.length == n\n\n\n0 <= informTime[i] <= 1000\n\n\ninformTime[i] == 0\n if employee \ni\n has no subordinates.\n\n\nIt is \nguaranteed\n that all the employees can be informed.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1388,
    "slug": "pizza-with-3n-slices",
    "url": "https://leetcode.com/problems/pizza-with-3n-slices/",
    "titulo": "Pizza With 3n Slices",
    "enunciado": "There is a pizza with \n3n\n slices of varying size, you and your friends will take slices of pizza as follows:\n\n\n\n\nYou will pick \nany\n pizza slice.\n\n\nYour friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n\n\nYour friend Bob will pick the next slice in the clockwise direction of your pick.\n\n\nRepeat until there are no more slices of pizzas.\n\n\n\n\nGiven an integer array \nslices\n that represent the sizes of the pizza slices in a clockwise direction, return \nthe maximum possible sum of slice sizes that you can pick\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n slices = [1,2,3,4,5,6]\n\nOutput:\n 10\n\nExplanation:\n Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n slices = [8,9,8,6,1,1]\n\nOutput:\n 16\n\nExplanation:\n Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 * n == slices.length\n\n\n1 <= slices.length <= 500\n\n\n1 <= slices[i] <= 1000",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1386,
    "slug": "cinema-seat-allocation",
    "url": "https://leetcode.com/problems/cinema-seat-allocation/",
    "titulo": "Cinema Seat Allocation",
    "enunciado": "A cinema has \nn\n rows of seats, numbered from 1 to \nn\n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.\n\n\nGiven the array \nreservedSeats\n containing the numbers of seats already reserved, for example, \nreservedSeats[i] = [3,8]\n means the seat located in row \n3\n and labelled with \n8\n is already reserved.\n\n\nReturn the maximum number of four-person groups you can assign on the cinema seats.\n A four-person group occupies four adjacent seats \nin one single row\n. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n\nOutput:\n 4\n\nExplanation:\n The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10^9\n\n\n1 <= reservedSeats.length <= min(10*n, 10^4)\n\n\nreservedSeats[i].length == 2\n\n\n1 <= reservedSeats[i][0] <= n\n\n\n1 <= reservedSeats[i][1] <= 10\n\n\nAll \nreservedSeats[i]\n are distinct.",
    "temas": [
      "Array",
      "Hash Table",
      "Greedy",
      "Bit Manipulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1368,
    "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
    "url": "https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/",
    "titulo": "Minimum Cost to Make at Least One Valid Path in a Grid",
    "enunciado": "Given an \nm x n\n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of \ngrid[i][j]\n can be:\n\n\n\n\n1\n which means go to the cell to the right. (i.e go from \ngrid[i][j]\n to \ngrid[i][j + 1]\n)\n\n\n2\n which means go to the cell to the left. (i.e go from \ngrid[i][j]\n to \ngrid[i][j - 1]\n)\n\n\n3\n which means go to the lower cell. (i.e go from \ngrid[i][j]\n to \ngrid[i + 1][j]\n)\n\n\n4\n which means go to the upper cell. (i.e go from \ngrid[i][j]\n to \ngrid[i - 1][j]\n)\n\n\n\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\n\n\nYou will initially start at the upper left cell \n(0, 0)\n. A valid path in the grid is a path that starts from the upper left cell \n(0, 0)\n and ends at the bottom-right cell \n(m - 1, n - 1)\n following the signs on the grid. The valid path does not have to be the shortest.\n\n\nYou can modify the sign on a cell with \ncost = 1\n. You can modify the sign on a cell \none time only\n.\n\n\nReturn \nthe minimum cost to make the grid have at least one valid path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n\nOutput:\n 3\n\nExplanation:\n You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,3],[3,2,2],[1,1,4]]\n\nOutput:\n 0\n\nExplanation:\n You can follow the path from (0, 0) to (2, 2).\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,2],[4,3]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 100\n\n\n1 <= grid[i][j] <= 4",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1367,
    "slug": "linked-list-in-binary-tree",
    "url": "https://leetcode.com/problems/linked-list-in-binary-tree/",
    "titulo": "Linked List in Binary Tree",
    "enunciado": "Given a binary tree \nroot\n and a linked list with \nhead\n as the first node. \n\n\nReturn True if all the elements in the linked list starting from the \nhead\n correspond to some \ndownward path\n connected in the binary tree otherwise return False.\n\n\nIn this context downward path means a path that starts at some node and goes downwards.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\nOutput:\n true\n\nExplanation:\n Nodes in blue form a subpath in the binary Tree.  \n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\nOutput:\n false\n\nExplanation:\n There is no path in the binary tree that contains all the elements of the linked list from \nhead\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree will be in the range \n[1, 2500]\n.\n\n\nThe number of nodes in the list will be in the range \n[1, 100]\n.\n\n\n1 <= Node.val <= 100\n for each node in the linked list and binary tree.",
    "temas": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 1353,
    "slug": "maximum-number-of-events-that-can-be-attended",
    "url": "https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/",
    "titulo": "Maximum Number of Events That Can Be Attended",
    "enunciado": "You are given an array of \nevents\n where \nevents[i] = [startDay\ni\n, endDay\ni\n]\n. Every event \ni\n starts at \nstartDay\ni\n \nand ends at \nendDay\ni\n.\n\n\nYou can attend an event \ni\n at any day \nd\n where \nstartTime\ni\n <= d <= endTime\ni\n. You can only attend one event at any time \nd\n.\n\n\nReturn \nthe maximum number of events you can attend\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n events = [[1,2],[2,3],[3,4]]\n\nOutput:\n 3\n\nExplanation:\n You can attend all the three events.\nOne way to attend them all is as shown.\nAttend the first event on day 1.\nAttend the second event on day 2.\nAttend the third event on day 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n events= [[1,2],[2,3],[3,4],[1,2]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= events.length <= 10\n5\n\n\nevents[i].length == 2\n\n\n1 <= startDay\ni\n <= endDay\ni\n <= 10\n5",
    "temas": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1373,
    "slug": "maximum-sum-bst-in-binary-tree",
    "url": "https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/",
    "titulo": "Maximum Sum BST in Binary Tree",
    "enunciado": "Given a \nbinary tree\n \nroot\n, return \nthe maximum sum of all keys of \nany\n sub-tree which is also a Binary Search Tree (BST)\n.\n\n\nAssume a BST is defined as follows:\n\n\n\n\nThe left subtree of a node contains only nodes with keys \nless than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \ngreater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n\nOutput:\n 20\n\nExplanation:\n Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,3,null,1,2]\n\nOutput:\n 2\n\nExplanation:\n Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [-4,-2,-5]\n\nOutput:\n 0\n\nExplanation:\n All values are negatives. Return an empty BST.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 4 * 10\n4\n]\n.\n\n\n-4 * 10\n4\n <= Node.val <= 4 * 10\n4",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1372,
    "slug": "longest-zigzag-path-in-a-binary-tree",
    "url": "https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/",
    "titulo": "Longest ZigZag Path in a Binary Tree",
    "enunciado": "You are given the \nroot\n of a binary tree.\n\n\nA ZigZag path for a binary tree is defined as follow:\n\n\n\n\nChoose \nany \nnode in the binary tree and a direction (right or left).\n\n\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n\n\nChange the direction from right to left or from left to right.\n\n\nRepeat the second and third steps until you can't move in the tree.\n\n\n\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\n\nReturn \nthe longest \nZigZag\n path contained in that tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\n\nOutput:\n 3\n\nExplanation:\n Longest ZigZag path in blue nodes (right -> left -> right).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,1,1,null,1,null,null,1,1,null,1]\n\nOutput:\n 4\n\nExplanation:\n Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 5 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 100",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1349,
    "slug": "maximum-students-taking-exam",
    "url": "https://leetcode.com/problems/maximum-students-taking-exam/",
    "titulo": "Maximum Students Taking Exam",
    "enunciado": "Given a \nm * n\n matrix \nseats\n  that represent seats distributions in a classroom. If a seat is broken, it is denoted by \n'#'\n character otherwise it is denoted by a \n'.'\n character.\n\n\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the \nmaximum \nnumber of students that can take the exam together without any cheating being possible.\n\n\nStudents must be placed in seats in good condition.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n                [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n                [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\n\nOutput:\n 4\n\nExplanation:\n Teacher can place 4 students in available seats so they don't cheat on the exam. \n\n\n\nExample 2:\n\n\n\n\nInput:\n seats = [[\".\",\"#\"],\n                [\"#\",\"#\"],\n                [\"#\",\".\"],\n                [\"#\",\"#\"],\n                [\".\",\"#\"]]\n\nOutput:\n 3\n\nExplanation:\n Place all students in available seats. \n\n\n\n\nExample 3:\n\n\n\n\nInput:\n seats = [[\"#\",\".\",\"\n.\n\",\".\",\"#\"],\n                [\"\n.\n\",\"#\",\"\n.\n\",\"#\",\"\n.\n\"],\n                [\"\n.\n\",\".\",\"#\",\".\",\"\n.\n\"],\n                [\"\n.\n\",\"#\",\"\n.\n\",\"#\",\"\n.\n\"],\n                [\"#\",\".\",\"\n.\n\",\".\",\"#\"]]\n\nOutput:\n 10\n\nExplanation:\n Place students in available seats in column 1, 3 and 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nseats\n contains only characters \n'.'\n and\n'#'.\n\n\nm == seats.length\n\n\nn == seats[i].length\n\n\n1 <= m <= 8\n\n\n1 <= n <= 8",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Bit Manipulation",
      "Matrix",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1340,
    "slug": "jump-game-v",
    "url": "https://leetcode.com/problems/jump-game-v/",
    "titulo": "Jump Game V",
    "enunciado": "Given an array of integers \narr\n and an integer \nd\n. In one step you can jump from index \ni\n to index:\n\n\n\n\ni + x\n where: \ni + x < arr.length\n and \n 0 < x <= d\n.\n\n\ni - x\n where: \ni - x >= 0\n and \n 0 < x <= d\n.\n\n\n\n\nIn addition, you can only jump from index \ni\n to index \nj\n if \narr[i] > arr[j]\n and \narr[i] > arr[k]\n for all indices \nk\n between \ni\n and \nj\n (More formally \nmin(i, j) < k < max(i, j)\n).\n\n\nYou can choose any index of the array and start jumping. Return \nthe maximum number of indices\n you can visit.\n\n\nNotice that you can not jump outside of the array at any time.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n\nOutput:\n 4\n\nExplanation:\n You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [3,3,3,3,3], d = 3\n\nOutput:\n 1\n\nExplanation:\n You can start at any index. You always cannot jump to any index.\n\n\n\nExample 3:\n\n\n\n\nInput:\n arr = [7,6,5,4,3,2,1], d = 1\n\nOutput:\n 7\n\nExplanation:\n Start at index 0. You can visit all the indicies. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 1000\n\n\n1 <= arr[i] <= 10\n5\n\n\n1 <= d <= arr.length",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1339,
    "slug": "maximum-product-of-splitted-binary-tree",
    "url": "https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/",
    "titulo": "Maximum Product of Splitted Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\n\n\nReturn \nthe maximum product of the sums of the two subtrees\n. Since the answer may be too large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\nNote\n that you need to maximize the answer before taking the mod and not after taking it.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6]\n\nOutput:\n 110\n\nExplanation:\n Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,null,null,5,6]\n\nOutput:\n 90\n\nExplanation:\n Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 5 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 10\n4",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1335,
    "slug": "minimum-difficulty-of-a-job-schedule",
    "url": "https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/",
    "titulo": "Minimum Difficulty of a Job Schedule",
    "enunciado": "You want to schedule a list of jobs in \nd\n days. Jobs are dependent (i.e To work on the \ni\nth\n job, you have to finish all the jobs \nj\n where \n0 <= j < i\n).\n\n\nYou have to finish \nat least\n one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the \nd\n days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\n\nYou are given an integer array \njobDifficulty\n and an integer \nd\n. The difficulty of the \ni\nth\n job is \njobDifficulty[i]\n.\n\n\nReturn \nthe minimum difficulty of a job schedule\n. If you cannot find a schedule for the jobs return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n jobDifficulty = [6,5,4,3,2,1], d = 2\n\nOutput:\n 7\n\nExplanation:\n First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\n\n\nExample 2:\n\n\n\n\nInput:\n jobDifficulty = [9,9,9], d = 4\n\nOutput:\n -1\n\nExplanation:\n If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\n\n\nExample 3:\n\n\n\n\nInput:\n jobDifficulty = [1,1,1], d = 3\n\nOutput:\n 3\n\nExplanation:\n The schedule is one job per day. total difficulty will be 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= jobDifficulty.length <= 300\n\n\n0 <= jobDifficulty[i] <= 1000\n\n\n1 <= d <= 10",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1334,
    "slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
    "url": "https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
    "titulo": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
    "enunciado": "There are \nn\n cities numbered from \n0\n to \nn-1\n. Given the array \nedges\n where \nedges[i] = [from\ni\n, to\ni\n, weight\ni\n]\n represents a bidirectional and weighted edge between cities \nfrom\ni\n and \nto\ni\n, and given the integer \ndistanceThreshold\n.\n\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is \nat most\n \ndistanceThreshold\n, If there are multiple such cities, return the city with the greatest number.\n\n\nNotice that the distance of a path connecting cities \ni\n and \nj\n is equal to the sum of the edges' weights along that path.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n\nOutput:\n 3\n\nExplanation: \nThe figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> [City 1, City 2] \nCity 1 -> [City 0, City 2, City 3] \nCity 2 -> [City 0, City 1, City 3] \nCity 3 -> [City 1, City 2] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n\nOutput:\n 0\n\nExplanation: \nThe figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> [City 1] \nCity 1 -> [City 0, City 4] \nCity 2 -> [City 3, City 4] \nCity 3 -> [City 2, City 4]\nCity 4 -> [City 1, City 2, City 3] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n1 <= edges.length <= n * (n - 1) / 2\n\n\nedges[i].length == 3\n\n\n0 <= from\ni\n < to\ni\n < n\n\n\n1 <= weight\ni\n, distanceThreshold <= 10^4\n\n\nAll pairs \n(from\ni\n, to\ni\n)\n are distinct.",
    "temas": [
      "Dynamic Programming",
      "Graph",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 1326,
    "slug": "minimum-number-of-taps-to-open-to-water-a-garden",
    "url": "https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/",
    "titulo": "Minimum Number of Taps to Open to Water a Garden",
    "enunciado": "There is a one-dimensional garden on the x-axis. The garden starts at the point \n0\n and ends at the point \nn\n. (i.e., the length of the garden is \nn\n).\n\n\nThere are \nn + 1\n taps located at points \n[0, 1, ..., n]\n in the garden.\n\n\nGiven an integer \nn\n and an integer array \nranges\n of length \nn + 1\n where \nranges[i]\n (0-indexed) means the \ni-th\n tap can water the area \n[i - ranges[i], i + ranges[i]]\n if it was open.\n\n\nReturn \nthe minimum number of taps\n that should be open to water the whole garden, If the garden cannot be watered return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, ranges = [3,4,1,1,0,0]\n\nOutput:\n 1\n\nExplanation:\n The tap at point 0 can cover the interval [-3,3]\nThe tap at point 1 can cover the interval [-3,5]\nThe tap at point 2 can cover the interval [1,3]\nThe tap at point 3 can cover the interval [2,4]\nThe tap at point 4 can cover the interval [4,4]\nThe tap at point 5 can cover the interval [5,5]\nOpening Only the second tap will water the whole garden [0,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, ranges = [0,0,0,0]\n\nOutput:\n -1\n\nExplanation:\n Even if you activate all the four taps you cannot water the whole garden.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4\n\n\nranges.length == n + 1\n\n\n0 <= ranges[i] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1325,
    "slug": "delete-leaves-with-a-given-value",
    "url": "https://leetcode.com/problems/delete-leaves-with-a-given-value/",
    "titulo": "Delete Leaves With a Given Value",
    "enunciado": "Given a binary tree \nroot\n and an integer \ntarget\n, delete all the \nleaf nodes\n with value \ntarget\n.\n\n\nNote that once you delete a leaf node with value \ntarget\n, \nif its parent node becomes a leaf node and has the value \ntarget\n, it should also be deleted (you need to continue doing that until you cannot).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,2,null,2,4], target = 2\n\nOutput:\n [1,null,3,null,4]\n\nExplanation:\n Leaf nodes in green with value (target = 2) are removed (Picture in left). \nAfter removing, new nodes become leaf nodes with value (target = 2) (Picture in center).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,3,3,3,2], target = 3\n\nOutput:\n [1,3,null,null,2]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,null,2,null,2], target = 2\n\nOutput:\n [1]\n\nExplanation:\n Leaf nodes in green with value (target = 2) are removed at each step.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3000]\n.\n\n\n1 <= Node.val, target <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1344,
    "slug": "angle-between-hands-of-a-clock",
    "url": "https://leetcode.com/problems/angle-between-hands-of-a-clock/",
    "titulo": "Angle Between Hands of a Clock",
    "enunciado": "Given two numbers, \nhour\n and \nminutes\n, return \nthe smaller angle (in degrees) formed between the \nhour\n and the \nminute\n hand\n.\n\n\nAnswers within \n10\n-5\n of the actual value will be accepted as correct.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n hour = 12, minutes = 30\n\nOutput:\n 165\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n hour = 3, minutes = 30\n\nOutput:\n 75\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n hour = 3, minutes = 15\n\nOutput:\n 7.5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= hour <= 12\n\n\n0 <= minutes <= 59",
    "temas": [
      "Math"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1320,
    "slug": "minimum-distance-to-type-a-word-using-two-fingers",
    "url": "https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/",
    "titulo": "Minimum Distance to Type a Word Using Two Fingers",
    "enunciado": "You have a keyboard layout as shown above in the \nX-Y\n plane, where each English uppercase letter is located at some coordinate.\n\n\n\n\nFor example, the letter \n'A'\n is located at coordinate \n(0, 0)\n, the letter \n'B'\n is located at coordinate \n(0, 1)\n, the letter \n'P'\n is located at coordinate \n(2, 3)\n and the letter \n'Z'\n is located at coordinate \n(4, 1)\n.\n\n\n\n\nGiven the string \nword\n, return \nthe minimum total \ndistance\n to type such string using only two fingers\n.\n\n\nThe \ndistance\n between coordinates \n(x\n1\n, y\n1\n)\n and \n(x\n2\n, y\n2\n)\n is \n|x\n1\n - x\n2\n| + |y\n1\n - y\n2\n|\n.\n\n\nNote\n that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word = \"CAKE\"\n\nOutput:\n 3\n\nExplanation:\n Using two fingers, one optimal way to type \"CAKE\" is: \nFinger 1 on letter 'C' -> cost = 0 \nFinger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \nFinger 2 on letter 'K' -> cost = 0 \nFinger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \nTotal distance = 3\n\n\n\nExample 2:\n\n\n\n\nInput:\n word = \"HAPPY\"\n\nOutput:\n 6\n\nExplanation:\n Using two fingers, one optimal way to type \"HAPPY\" is:\nFinger 1 on letter 'H' -> cost = 0\nFinger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\nFinger 2 on letter 'P' -> cost = 0\nFinger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\nFinger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\nTotal distance = 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= word.length <= 300\n\n\nword\n consists of uppercase English letters.",
    "temas": [
      "String",
      "Dynamic Programming"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 1319,
    "slug": "number-of-operations-to-make-network-connected",
    "url": "https://leetcode.com/problems/number-of-operations-to-make-network-connected/",
    "titulo": "Number of Operations to Make Network Connected",
    "enunciado": "There are \nn\n computers numbered from \n0\n to \nn - 1\n connected by ethernet cables \nconnections\n forming a network where \nconnections[i] = [a\ni\n, b\ni\n]\n represents a connection between computers \na\ni\n and \nb\ni\n. Any computer can reach any other computer directly or indirectly through the network.\n\n\nYou are given an initial computer network \nconnections\n. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\n\n\nReturn \nthe minimum number of times you need to do this in order to make all the computers connected\n. If it is not possible, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, connections = [[0,1],[0,2],[1,2]]\n\nOutput:\n 1\n\nExplanation:\n Remove cable between computer 1 and 2 and place between computers 1 and 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n\nOutput:\n -1\n\nExplanation:\n There are not enough cables.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n1 <= connections.length <= min(n * (n - 1) / 2, 10\n5\n)\n\n\nconnections[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nThere are no repeated connections.\n\n\nNo two computers are connected by more than one cable.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1318,
    "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
    "url": "https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/",
    "titulo": "Minimum Flips to Make a OR b Equal to c",
    "enunciado": "Given 3 positives numbers \na\n, \nb\n and \nc\n. Return the minimum flips required in some bits of \na\n and \nb\n to make ( \na\n OR \nb\n == \nc\n ). (bitwise OR operation).\n\r\nFlip operation consists of change \nany\n single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n a = 2, b = 6, c = 5\r\n\nOutput:\n 3\r\n\nExplanation: \nAfter flips a = 1 , b = 4 , c = 5 such that (\na\n OR \nb\n == \nc\n)\n\n\nExample 2:\n\n\n\r\n\nInput:\n a = 4, b = 2, c = 7\r\n\nOutput:\n 1\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n a = 1, b = 2, c = 3\r\n\nOutput:\n 0\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a <= 10^9\n\n\n1 <= b <= 10^9\n\n\n1 <= c <= 10^9",
    "temas": [
      "Bit Manipulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Bit Manipulation",
    "has_image": true
  },
  {
    "id": 1311,
    "slug": "get-watched-videos-by-your-friends",
    "url": "https://leetcode.com/problems/get-watched-videos-by-your-friends/",
    "titulo": "Get Watched Videos by Your Friends",
    "enunciado": "There are \nn\n people, each person has a unique \nid\n between \n0\n and \nn-1\n. Given the arrays \nwatchedVideos\n and \nfriends\n, where \nwatchedVideos[i]\n and \nfriends[i]\n contain the list of watched videos and the list of friends respectively for the person with \nid = i\n.\n\n\nLevel \n1\n of videos are all watched videos by your friends, level \n2\n of videos are all watched videos by the friends of your friends and so on. In general, the level \nk\n of videos are all watched videos by people with the shortest path \nexactly\n equal to \nk\n with you. Given your \nid\n and the \nlevel\n of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest. \n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n\nOutput:\n [\"B\",\"C\"] \n\nExplanation:\n \nYou have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\nPerson with id = 1 -> watchedVideos = [\"C\"] \nPerson with id = 2 -> watchedVideos = [\"B\",\"C\"] \nThe frequencies of watchedVideos by your friends are: \nB -> 1 \nC -> 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n\nOutput:\n [\"D\"]\n\nExplanation:\n \nYou have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == watchedVideos.length == friends.length\n\n\n2 <= n <= 100\n\n\n1 <= watchedVideos[i].length <= 100\n\n\n1 <= watchedVideos[i][j].length <= 8\n\n\n0 <= friends[i].length < n\n\n\n0 <= friends[i][j] < n\n\n\n0 <= id < n\n\n\n1 <= level < n\n\n\nif \nfriends[i]\n contains \nj\n, then \nfriends[j]\n contains \ni",
    "temas": [
      "Array",
      "Hash Table",
      "Breadth-First Search",
      "Graph",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2192,
    "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
    "url": "https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
    "titulo": "All Ancestors of a Node in a Directed Acyclic Graph",
    "enunciado": "You are given a positive integer \nn\n representing the number of nodes of a \nDirected Acyclic Graph\n (DAG). The nodes are numbered from \n0\n to \nn - 1\n (\ninclusive\n).\n\n\nYou are also given a 2D integer array \nedges\n, where \nedges[i] = [from\ni\n, to\ni\n]\n denotes that there is a \nunidirectional\n edge from \nfrom\ni\n to \nto\ni\n in the graph.\n\n\nReturn \na list\n \nanswer\n, where \nanswer[i]\n is the \nlist of ancestors\n of the\n \ni\nth\n \nnode, sorted in \nascending order\n.\n\n\nA node \nu\n is an \nancestor\n of another node \nv\n if \nu\n can reach \nv\n via a set of edges.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\n\nOutput:\n [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\n\nExplanation:\n\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n\nOutput:\n [[],[0],[0,1],[0,1,2],[0,1,2,3]]\n\nExplanation:\n\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\n\n\nedges[i].length == 2\n\n\n0 <= from\ni\n, to\ni\n <= n - 1\n\n\nfrom\ni\n != to\ni\n\n\nThere are no duplicate edges.\n\n\nThe graph is \ndirected\n and \nacyclic\n.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1305,
    "slug": "all-elements-in-two-binary-search-trees",
    "url": "https://leetcode.com/problems/all-elements-in-two-binary-search-trees/",
    "titulo": "All Elements in Two Binary Search Trees",
    "enunciado": "Given two binary search trees \nroot1\n and \nroot2\n, return \na list containing all the integers from both trees sorted in \nascending\n order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root1 = [2,1,4], root2 = [1,0,3]\n\nOutput:\n [0,1,1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root1 = [1,null,8], root2 = [8,1]\n\nOutput:\n [1,1,8,8]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each tree is in the range \n[0, 5000]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Sorting",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1293,
    "slug": "shortest-path-in-a-grid-with-obstacles-elimination",
    "url": "https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",
    "titulo": "Shortest Path in a Grid with Obstacles Elimination",
    "enunciado": "You are given an \nm x n\n integer matrix \ngrid\n where each cell is either \n0\n (empty) or \n1\n (obstacle). You can move up, down, left, or right from and to an empty cell in \none step\n.\n\n\nReturn \nthe minimum number of \nsteps\n to walk from the upper left corner \n(0, 0)\n to the lower right corner \n(m - 1, n - 1)\n given that you can eliminate \nat most\n \nk\n obstacles\n. If it is not possible to find such walk return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n\nOutput:\n 6\n\nExplanation:\n \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> \n(3,2)\n -> (4,2).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n\nOutput:\n -1\n\nExplanation:\n We need to eliminate at least two obstacles to find such a walk.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 40\n\n\n1 <= k <= m * n\n\n\ngrid[i][j]\n is either \n0\n \nor\n \n1\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1292,
    "slug": "maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold",
    "url": "https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/",
    "titulo": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
    "enunciado": "Given a \nm x n\n matrix \nmat\n and an integer \nthreshold\n, return \nthe maximum side-length of a square with a sum less than or equal to \nthreshold\n or return \n0\n if there is no such square\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n\nOutput:\n 2\n\nExplanation:\n The maximum side length of square with sum less than 4 is 2 as shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 300\n\n\n0 <= mat[i][j] <= 10\n4\n\n\n0 <= threshold <= 10\n5",
    "temas": [
      "Array",
      "Binary Search",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1290,
    "slug": "convert-binary-number-in-a-linked-list-to-integer",
    "url": "https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/",
    "titulo": "Convert Binary Number in a Linked List to Integer",
    "enunciado": "Given \nhead\n which is a reference node to a singly-linked list. The value of each node in the linked list is either \n0\n or \n1\n. The linked list holds the binary representation of a number.\n\n\nReturn the \ndecimal value\n of the number in the linked list.\n\n\nThe \nmost significant bit\n is at the head of the linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,0,1]\n\nOutput:\n 5\n\nExplanation:\n (101) in base 2 = (5) in base 10\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [0]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe Linked List is not empty.\n\n\nNumber of nodes will not exceed \n30\n.\n\n\nEach node's value is either \n0\n or \n1\n.",
    "temas": [
      "Linked List",
      "Math"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 1284,
    "slug": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix",
    "url": "https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/",
    "titulo": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
    "enunciado": "Given a \nm x n\n binary matrix \nmat\n. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing \n1\n to \n0\n and \n0\n to \n1\n). A pair of cells are called neighbors if they share one edge.\n\n\nReturn the \nminimum number of steps\n required to convert \nmat\n to a zero matrix or \n-1\n if you cannot.\n\n\nA \nbinary matrix\n is a matrix with all cells equal to \n0\n or \n1\n only.\n\n\nA \nzero matrix\n is a matrix with all cells equal to \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[0,0],[0,1]]\n\nOutput:\n 3\n\nExplanation:\n One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[0]]\n\nOutput:\n 0\n\nExplanation:\n Given matrix is a zero matrix. We do not need to change it.\n\n\n\nExample 3:\n\n\n\n\nInput:\n mat = [[1,0,0],[1,0,0]]\n\nOutput:\n -1\n\nExplanation:\n Given matrix cannot be a zero matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 3\n\n\nmat[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Bit Manipulation",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1275,
    "slug": "find-winner-on-a-tic-tac-toe-game",
    "url": "https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/",
    "titulo": "Find Winner on a Tic Tac Toe Game",
    "enunciado": "Tic-tac-toe\n is played by two players \nA\n and \nB\n on a \n3 x 3\n grid. The rules of Tic-Tac-Toe are:\n\n\n\n\nPlayers take turns placing characters into empty squares \n' '\n.\n\n\nThe first player \nA\n always places \n'X'\n characters, while the second player \nB\n always places \n'O'\n characters.\n\n\n'X'\n and \n'O'\n characters are always placed into empty squares, never on filled ones.\n\n\nThe game ends when there are \nthree\n of the same (non-empty) character filling any row, column, or diagonal.\n\n\nThe game also ends if all squares are non-empty.\n\n\nNo more moves can be played if the game is over.\n\n\n\n\nGiven a 2D integer array \nmoves\n where \nmoves[i] = [row\ni\n, col\ni\n]\n indicates that the \ni\nth\n move will be played on \ngrid[row\ni\n][col\ni\n]\n. return \nthe winner of the game if it exists\n (\nA\n or \nB\n). In case the game ends in a draw return \n\"Draw\"\n. If there are still movements to play return \n\"Pending\"\n.\n\n\nYou can assume that \nmoves\n is valid (i.e., it follows the rules of \nTic-Tac-Toe\n), the grid is initially empty, and \nA\n will play first.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\n\nOutput:\n \"A\"\n\nExplanation:\n A wins, they always play first.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\n\nOutput:\n \"B\"\n\nExplanation:\n B wins.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\n\nOutput:\n \"Draw\"\n\nExplanation:\n The game ends in a draw since there are no moves to make.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= moves.length <= 9\n\n\nmoves[i].length == 2\n\n\n0 <= row\ni\n, col\ni\n <= 2\n\n\nThere are no repeated elements on \nmoves\n.\n\n\nmoves\n follow the rules of tic tac toe.",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1267,
    "slug": "count-servers-that-communicate",
    "url": "https://leetcode.com/problems/count-servers-that-communicate/",
    "titulo": "Count Servers that Communicate",
    "enunciado": "You are given a map of a server center, represented as a \nm * n\n integer matrix \ngrid\n, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.\n\n\n\nReturn the number of servers that communicate with any other server.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,0],[0,1]]\n\nOutput:\n 0\n\nExplanation:\n No servers can communicate with others.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,0],[1,1]]\n\nOutput:\n 3\n\nExplanation:\n All three servers can communicate with at least one other server.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\n\nOutput:\n 4\n\nExplanation:\n The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m <= 250\n\n\n1 <= n <= 250\n\n\ngrid[i][j] == 0 or 1",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix",
      "Counting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1266,
    "slug": "minimum-time-visiting-all-points",
    "url": "https://leetcode.com/problems/minimum-time-visiting-all-points/",
    "titulo": "Minimum Time Visiting All Points",
    "enunciado": "On a 2D plane, there are \nn\n points with integer coordinates \npoints[i] = [x\ni\n, y\ni\n]\n. Return \nthe \nminimum time\n in seconds to visit all the points in the order given by \npoints\n.\n\n\nYou can move according to these rules:\n\n\n\n\nIn \n1\n second, you can either:\n\n\t\n\n\nmove vertically by one unit,\n\n\nmove horizontally by one unit, or\n\n\nmove diagonally \nsqrt(2)\n units (in other words, move one unit vertically then one unit horizontally in \n1\n second).\n\n\n\n\n\n\nYou have to visit the points in the same order as they appear in the array.\n\n\nYou are allowed to pass through points that appear later in the order, but these do not count as visits.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,1],[3,4],[-1,0]]\n\nOutput:\n 7\n\nExplanation: \nOne optimal path is \n[1,1]\n -> [2,2] -> [3,3] -> \n[3,4] \n-> [2,3] -> [1,2] -> [0,1] -> \n[-1,0]\n   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,2],[-2,2]]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\npoints.length == n\n\n\n1 <= n <= 100\n\n\npoints[i].length == 2\n\n\n-1000 <= points[i][0], points[i][1] <= 1000",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2304,
    "slug": "minimum-path-cost-in-a-grid",
    "url": "https://leetcode.com/problems/minimum-path-cost-in-a-grid/",
    "titulo": "Minimum Path Cost in a Grid",
    "enunciado": "You are given a \n0-indexed\n \nm x n\n integer matrix \ngrid\n consisting of \ndistinct\n integers from \n0\n to \nm * n - 1\n. You can move in this matrix from a cell to any other cell in the \nnext\n row. That is, if you are in cell \n(x, y)\n such that \nx < m - 1\n, you can move to any of the cells \n(x + 1, 0)\n, \n(x + 1, 1)\n, ..., \n(x + 1, n - 1)\n. \nNote\n that it is not possible to move from cells in the last row.\n\n\nEach possible move has a cost given by a \n0-indexed\n 2D array \nmoveCost\n of size \n(m * n) x n\n, where \nmoveCost[i][j]\n is the cost of moving from a cell with value \ni\n to a cell in column \nj\n of the next row. The cost of moving from cells in the last row of \ngrid\n can be ignored.\n\n\nThe cost of a path in \ngrid\n is the \nsum\n of all values of cells visited plus the \nsum\n of costs of all the moves made. Return \nthe \nminimum\n cost of a path that starts from any cell in the \nfirst\n row and ends at any cell in the \nlast\n row.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n\nOutput:\n 17\n\nExplanation: \nThe path with the minimum possible cost is the path 5 -> 0 -> 1.\n- The sum of the values of cells visited is 5 + 0 + 1 = 6.\n- The cost of moving from 5 to 0 is 3.\n- The cost of moving from 0 to 1 is 8.\nSo the total cost of the path is 6 + 3 + 8 = 17.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n\nOutput:\n 6\n\nExplanation:\n The path with the minimum possible cost is the path 2 -> 3.\n- The sum of the values of cells visited is 2 + 3 = 5.\n- The cost of moving from 2 to 3 is 1.\nSo the total cost of this path is 5 + 1 = 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 50\n\n\ngrid\n consists of distinct integers from \n0\n to \nm * n - 1\n.\n\n\nmoveCost.length == m * n\n\n\nmoveCost[i].length == n\n\n\n1 <= moveCost[i][j] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2218,
    "slug": "maximum-value-of-k-coins-from-piles",
    "url": "https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/",
    "titulo": "Maximum Value of K Coins From Piles",
    "enunciado": "There are \nn\n \npiles\n of coins on a table. Each pile consists of a \npositive number\n of coins of assorted denominations.\n\n\nIn one move, you can choose any coin on \ntop\n of any pile, remove it, and add it to your wallet.\n\n\nGiven a list \npiles\n, where \npiles[i]\n is a list of integers denoting the composition of the \ni\nth\n pile from \ntop to bottom\n, and a positive integer \nk\n, return \nthe \nmaximum total value\n of coins you can have in your wallet if you choose \nexactly\n \nk\n \ncoins optimally\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n piles = [[1,100,3],[7,8,9]], k = 2\n\nOutput:\n 101\n\nExplanation:\n\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\n\nOutput:\n 706\n\nExplanation:\n\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == piles.length\n\n\n1 <= n <= 1000\n\n\n1 <= piles[i][j] <= 10\n5\n\n\n1 <= k <= sum(piles[i].length) <= 2000",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1263,
    "slug": "minimum-moves-to-move-a-box-to-their-target-location",
    "url": "https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/",
    "titulo": "Minimum Moves to Move a Box to Their Target Location",
    "enunciado": "A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\n\n\nThe game is represented by an \nm x n\n grid of characters \ngrid\n where each element is a wall, floor, or box.\n\n\nYour task is to move the box \n'B'\n to the target position \n'T'\n under the following rules:\n\n\n\n\nThe character \n'S'\n represents the player. The player can move up, down, left, right in \ngrid\n if it is a floor (empty cell).\n\n\nThe character \n'.'\n represents the floor which means a free cell to walk.\n\n\nThe character\n \n'#'\n \nrepresents the wall which means an obstacle (impossible to walk there).\n\n\nThere is only one box \n'B'\n and one target cell \n'T'\n in the \ngrid\n.\n\n\nThe box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a \npush\n.\n\n\nThe player cannot walk through the box.\n\n\n\n\nReturn \nthe minimum number of \npushes\n to move the box to the target\n. If there is no way to reach the target, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n\nOutput:\n 3\n\nExplanation:\n We return only the number of times the box is pushed.\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n\nOutput:\n -1\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n\nOutput:\n 5\n\nExplanation:\n push the box down, left, left, up and up.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 20\n\n\ngrid\n contains only characters \n'.'\n, \n'#'\n, \n'S'\n, \n'T'\n, or \n'B'\n.\n\n\nThere is only one character \n'S'\n, \n'B'\n, and \n'T'\n in the \ngrid\n.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1261,
    "slug": "find-elements-in-a-contaminated-binary-tree",
    "url": "https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/",
    "titulo": "Find Elements in a Contaminated Binary Tree",
    "enunciado": "Given a binary tree with the following rules:\n\n\n\n\nroot.val == 0\n\n\nFor any \ntreeNode\n:\n\t\n\n\nIf \ntreeNode.val\n has a value \nx\n and \ntreeNode.left != null\n, then \ntreeNode.left.val == 2 * x + 1\n\n\nIf \ntreeNode.val\n has a value \nx\n and \ntreeNode.right != null\n, then \ntreeNode.right.val == 2 * x + 2\n\n\n\n\n\n\n\n\nNow the binary tree is contaminated, which means all \ntreeNode.val\n have been changed to \n-1\n.\n\n\nImplement the \nFindElements\n class:\n\n\n\n\nFindElements(TreeNode* root)\n Initializes the object with a contaminated binary tree and recovers it.\n\n\nbool find(int target)\n Returns \ntrue\n if the \ntarget\n value exists in the recovered binary tree.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"FindElements\",\"find\",\"find\"]\n[[[-1,null,-1]],[1],[2]]\n\nOutput\n\n[null,false,true]\n\nExplanation\n\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True \n\n\nExample 2:\n\n\n\n\n\n\nInput\n\n[\"FindElements\",\"find\",\"find\",\"find\"]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n\nOutput\n\n[null,true,true,false]\n\nExplanation\n\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False\n\n\nExample 3:\n\n\n\n\n\n\nInput\n\n[\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n\nOutput\n\n[null,true,false,false,true]\n\nExplanation\n\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n\n\n\n \n\n\nConstraints:\n\n\n\n\nTreeNode.val == -1\n\n\nThe height of the binary tree is less than or equal to \n20\n\n\nThe total number of nodes is between \n[1, 10\n4\n]\n\n\nTotal calls of \nfind()\n is between \n[1, 10\n4\n]\n\n\n0 <= target <= 10\n6",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1260,
    "slug": "shift-2d-grid",
    "url": "https://leetcode.com/problems/shift-2d-grid/",
    "titulo": "Shift 2D Grid",
    "enunciado": "Given a 2D \ngrid\n of size \nm x n\n and an integer \nk\n. You need to shift the \ngrid\n \nk\n times.\n\n\nIn one shift operation:\n\n\n\n\nElement at \ngrid[i][j]\n moves to \ngrid[i][j + 1]\n.\n\n\nElement at \ngrid[i][n - 1]\n moves to \ngrid[i + 1][0]\n.\n\n\nElement at \ngrid[m - 1][n - 1]\n moves to \ngrid[0][0]\n.\n\n\n\n\nReturn the \n2D grid\n after applying shift operation \nk\n times.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \ngrid\n = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n\nOutput:\n [[9,1,2],[3,4,5],[6,7,8]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \ngrid\n = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\n\nOutput:\n [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ngrid\n = [[1,2,3],[4,5,6],[7,8,9]], k = 9\n\nOutput:\n [[1,2,3],[4,5,6],[7,8,9]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m <= 50\n\n\n1 <= n <= 50\n\n\n-1000 <= grid[i][j] <= 1000\n\n\n0 <= k <= 100",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1254,
    "slug": "number-of-closed-islands",
    "url": "https://leetcode.com/problems/number-of-closed-islands/",
    "titulo": "Number of Closed Islands",
    "enunciado": "Given a 2D \ngrid\n consists of \n0s\n (land) and \n1s\n (water).  An \nisland\n is a maximal 4-directionally connected group of \n0\ns\n and a \nclosed island\n is an island \ntotally\n (all left, top, right, bottom) surrounded by \n1s.\n\n\nReturn the number of \nclosed islands\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\n\nOutput:\n 2\n\nExplanation:\n \nIslands in gray are closed because they are completely surrounded by water (group of 1s).\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,1,1,1,1,1,1],\n               [1,0,0,0,0,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,1,0,1,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,0,0,0,0,1],\n               [1,1,1,1,1,1,1]]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= grid.length, grid[0].length <= 100\n\n\n0 <= grid[i][j] <=1",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1252,
    "slug": "cells-with-odd-values-in-a-matrix",
    "url": "https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/",
    "titulo": "Cells with Odd Values in a Matrix",
    "enunciado": "There is an \nm x n\n matrix that is initialized to all \n0\n's. There is also a 2D array \nindices\n where each \nindices[i] = [r\ni\n, c\ni\n]\n represents a \n0-indexed location\n to perform some increment operations on the matrix.\n\n\nFor each location \nindices[i]\n, do \nboth\n of the following:\n\n\n\n\nIncrement \nall\n the cells on row \nr\ni\n.\n\n\nIncrement \nall\n the cells on column \nc\ni\n.\n\n\n\n\nGiven \nm\n, \nn\n, and \nindices\n, return \nthe \nnumber of odd-valued cells\n in the matrix after applying the increment to all locations in \nindices\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 2, n = 3, indices = [[0,1],[1,1]]\n\nOutput:\n 6\n\nExplanation:\n Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 2, n = 2, indices = [[1,1],[0,0]]\n\nOutput:\n 0\n\nExplanation:\n Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 50\n\n\n1 <= indices.length <= 100\n\n\n0 <= r\ni\n < m\n\n\n0 <= c\ni\n < n\n\n\n\n\n \n\n\nFollow up:\n Could you solve this in \nO(n + m + indices.length)\n time with only \nO(n + m)\n extra space?",
    "temas": [
      "Array",
      "Math",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2312,
    "slug": "selling-pieces-of-wood",
    "url": "https://leetcode.com/problems/selling-pieces-of-wood/",
    "titulo": "Selling Pieces of Wood",
    "enunciado": "You are given two integers \nm\n and \nn\n that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array \nprices\n, where \nprices[i] = [h\ni\n, w\ni\n, price\ni\n]\n indicates you can sell a rectangular piece of wood of height \nh\ni\n and width \nw\ni\n for \nprice\ni\n dollars.\n\n\nTo cut a piece of wood, you must make a vertical or horizontal cut across the \nentire\n height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to \nprices\n. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you \ncannot\n rotate a piece to swap its height and width.\n\n\nReturn \nthe \nmaximum\n money you can earn after cutting an \nm x n\n piece of wood\n.\n\n\nNote that you can cut the piece of wood as many times as you want.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\n\nOutput:\n 19\n\nExplanation:\n The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\n\nOutput:\n 32\n\nExplanation:\n The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 200\n\n\n1 <= prices.length <= 2 * 10\n4\n\n\nprices[i].length == 3\n\n\n1 <= h\ni\n <= m\n\n\n1 <= w\ni\n <= n\n\n\n1 <= price\ni\n <= 10\n6\n\n\nAll the shapes of wood \n(h\ni\n, w\ni\n)\n are pairwise \ndistinct\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Memoization"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1691,
    "slug": "maximum-height-by-stacking-cuboids",
    "url": "https://leetcode.com/problems/maximum-height-by-stacking-cuboids/",
    "titulo": "Maximum Height by Stacking Cuboids ",
    "enunciado": "Given \nn\n \ncuboids\n where the dimensions of the \ni\nth\n cuboid is \ncuboids[i] = [width\ni\n, length\ni\n, height\ni\n]\n (\n0-indexed\n). Choose a \nsubset\n of \ncuboids\n and place them on each other.\n\n\nYou can place cuboid \ni\n on cuboid \nj\n if \nwidth\ni\n <= width\nj\n and \nlength\ni\n <= length\nj\n and \nheight\ni\n <= height\nj\n. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.\n\n\nReturn \nthe \nmaximum height\n of the stacked\n \ncuboids\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n\nOutput:\n 190\n\nExplanation:\n\nCuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.\nCuboid 0 is placed next with the 45x20 side facing down with height 50.\nCuboid 2 is placed next with the 23x12 side facing down with height 45.\nThe total height is 95 + 50 + 45 = 190.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cuboids = [[38,25,45],[76,35,3]]\n\nOutput:\n 76\n\nExplanation:\n\nYou can't place any of the cuboids on the other.\nWe choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.\n\n\n\nExample 3:\n\n\n\n\nInput:\n cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n\nOutput:\n 102\n\nExplanation:\n\nAfter rearranging the cuboids, you can see that all cuboids have the same dimension.\nYou can place the 11x7 side down on all cuboids so their heights are 17.\nThe maximum height of stacked cuboids is 6 * 17 = 102.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == cuboids.length\n\n\n1 <= n <= 100\n\n\n1 <= width\ni\n, length\ni\n, height\ni\n <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1240,
    "slug": "tiling-a-rectangle-with-the-fewest-squares",
    "url": "https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/",
    "titulo": "Tiling a Rectangle with the Fewest Squares",
    "enunciado": "Given a rectangle of size \nn\n x \nm\n, return \nthe minimum number of integer-sided squares that tile the rectangle\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 2, m = 3\n\nOutput:\n 3\n\nExplanation:\n \n3\n squares are necessary to cover the rectangle.\n\n2\n (squares of \n1x1\n)\n\n1\n (square of \n2x2\n)\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 5, m = 8\n\nOutput:\n 5\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 11, m = 13\n\nOutput:\n 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 13",
    "temas": [
      "Backtracking"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Backtracking",
    "has_image": true
  },
  {
    "id": 1235,
    "slug": "maximum-profit-in-job-scheduling",
    "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/",
    "titulo": "Maximum Profit in Job Scheduling",
    "enunciado": "We have \nn\n jobs, where every job is scheduled to be done from \nstartTime[i]\n to \nendTime[i]\n, obtaining a profit of \nprofit[i]\n.\n\n\nYou're given the \nstartTime\n, \nendTime\n and \nprofit\n arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\n\nIf you choose a job that ends at time \nX\n you will be able to start another job that starts at time \nX\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n\nOutput:\n 120\n\nExplanation:\n The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\n\n\nExample 2:\n\n\n \n\n\n\n\nInput:\n startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n\nOutput:\n 150\n\nExplanation:\n The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n\nOutput:\n 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= startTime.length == endTime.length == profit.length <= 5 * 10\n4\n\n\n1 <= startTime[i] < endTime[i] <= 10\n9\n\n\n1 <= profit[i] <= 10\n4",
    "temas": [
      "Array",
      "Binary Search",
      "Dynamic Programming",
      "Sorting"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1232,
    "slug": "check-if-it-is-a-straight-line",
    "url": "https://leetcode.com/problems/check-if-it-is-a-straight-line/",
    "titulo": "Check If It Is a Straight Line",
    "enunciado": "You are given an array \ncoordinates\n, \ncoordinates[i] = [x, y]\n, where \n[x, y]\n represents the coordinate of a point. Check if these points make a straight line in the XY plane.\n\n\n \n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= coordinates.length <= 1000\n\n\ncoordinates[i].length == 2\n\n\n-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4\n\n\ncoordinates\n contains no duplicate point.",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1222,
    "slug": "queens-that-can-attack-the-king",
    "url": "https://leetcode.com/problems/queens-that-can-attack-the-king/",
    "titulo": "Queens That Can Attack the King",
    "enunciado": "On a \n0-indexed\n \n8 x 8\n chessboard, there can be multiple black queens and one white king.\n\n\nYou are given a 2D integer array \nqueens\n where \nqueens[i] = [xQueen\ni\n, yQueen\ni\n]\n represents the position of the \ni\nth\n black queen on the chessboard. You are also given an integer array \nking\n of length \n2\n where \nking = [xKing, yKing]\n represents the position of the white king.\n\n\nReturn \nthe coordinates of the black queens that can directly attack the king\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]\n\nOutput:\n [[0,1],[1,0],[3,3]]\n\nExplanation:\n The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]\n\nOutput:\n [[2,2],[3,4],[4,4]]\n\nExplanation:\n The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= queens.length < 64\n\n\nqueens[i].length == king.length == 2\n\n\n0 <= xQueen\ni\n, yQueen\ni\n, xKing, yKing < 8\n\n\nAll the given positions are \nunique\n.",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1206,
    "slug": "design-skiplist",
    "url": "https://leetcode.com/problems/design-skiplist/",
    "titulo": "Design Skiplist",
    "enunciado": "Design a \nSkiplist\n without using any built-in libraries.\n\n\nA \nskiplist\n is a data structure that takes \nO(log(n))\n time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.\n\n\nFor example, we have a Skiplist containing \n[30,40,50,60,70,90]\n and we want to add \n80\n and \n45\n into it. The Skiplist works this way:\n\n\n\n\nArtyom Kalinin [CC BY-SA 3.0], via \nWikimedia Commons\n\n\nYou can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than \nO(n)\n. It can be proven that the average time complexity for each operation is \nO(log(n))\n and space complexity is \nO(n)\n.\n\n\nSee more about Skiplist: \nhttps://en.wikipedia.org/wiki/Skip_list\n\n\nImplement the \nSkiplist\n class:\n\n\n\n\nSkiplist()\n Initializes the object of the skiplist.\n\n\nbool search(int target)\n Returns \ntrue\n if the integer \ntarget\n exists in the Skiplist or \nfalse\n otherwise.\n\n\nvoid add(int num)\n Inserts the value \nnum\n into the SkipList.\n\n\nbool erase(int num)\n Removes the value \nnum\n from the Skiplist and returns \ntrue\n. If \nnum\n does not exist in the Skiplist, do nothing and return \nfalse\n. If there exist multiple \nnum\n values, removing any one of them is fine.\n\n\n\n\nNote that duplicates may exist in the Skiplist, your code needs to handle this situation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n\nOutput\n\n[null, null, null, null, false, null, true, false, true, false]\n\n\nExplanation\n\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0); // return False\nskiplist.add(4);\nskiplist.search(1); // return True\nskiplist.erase(0);  // return False, 0 is not in skiplist.\nskiplist.erase(1);  // return True\nskiplist.search(1); // return False, 1 has already been erased.\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num, target <= 2 * 10\n4\n\n\nAt most \n5 * 10\n4\n calls will be made to \nsearch\n, \nadd\n, and \nerase\n.",
    "temas": [
      "Linked List",
      "Design"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 1217,
    "slug": "minimum-cost-to-move-chips-to-the-same-position",
    "url": "https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/",
    "titulo": "Minimum Cost to Move Chips to The Same Position",
    "enunciado": "We have \nn\n chips, where the position of the \ni\nth\n chip is \nposition[i]\n.\n\n\nWe need to move all the chips to \nthe same position\n. In one step, we can change the position of the \ni\nth\n chip from \nposition[i]\n to:\n\n\n\n\nposition[i] + 2\n or \nposition[i] - 2\n with \ncost = 0\n.\n\n\nposition[i] + 1\n or \nposition[i] - 1\n with \ncost = 1\n.\n\n\n\n\nReturn \nthe minimum cost\n needed to move all the chips to the same position.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n position = [1,2,3]\n\nOutput:\n 1\n\nExplanation:\n First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n position = [2,2,2,3,3]\n\nOutput:\n 2\n\nExplanation:\n We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n position = [1,1000000000]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= position.length <= 100\n\n\n1 <= position[i] <= 10^9",
    "temas": [
      "Array",
      "Math",
      "Greedy"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1514,
    "slug": "path-with-maximum-probability",
    "url": "https://leetcode.com/problems/path-with-maximum-probability/",
    "titulo": "Path with Maximum Probability",
    "enunciado": "You are given an undirected weighted graph of \nn\n nodes (0-indexed), represented by an edge list where \nedges[i] = [a, b]\n is an undirected edge connecting the nodes \na\n and \nb\n with a probability of success of traversing that edge \nsuccProb[i]\n.\n\n\nGiven two nodes \nstart\n and \nend\n, find the path with the maximum probability of success to go from \nstart\n to \nend\n and return its success probability.\n\n\nIf there is no path from \nstart\n to \nend\n, \nreturn 0\n. Your answer will be accepted if it differs from the correct answer by at most \n1e-5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n\nOutput:\n 0.25000\n\nExplanation:\n There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n\nOutput:\n 0.30000\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n\nOutput:\n 0.00000\n\nExplanation:\n There is no path between 0 and 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10^4\n\n\n0 <= start, end < n\n\n\nstart != end\n\n\n0 <= a, b < n\n\n\na != b\n\n\n0 <= succProb.length == edges.length <= 2*10^4\n\n\n0 <= succProb[i] <= 1\n\n\nThere is at most one edge between every two nodes.",
    "temas": [
      "Array",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1706,
    "slug": "where-will-the-ball-fall",
    "url": "https://leetcode.com/problems/where-will-the-ball-fall/",
    "titulo": "Where Will the Ball Fall",
    "enunciado": "You have a 2-D \ngrid\n of size \nm x n\n representing a box, and you have \nn\n balls. The box is open on the top and bottom sides.\n\n\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n\n\n\n\nA board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as \n1\n.\n\n\nA board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as \n-1\n.\n\n\n\n\nWe drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n\n\nReturn \nan array \nanswer\n of size \nn\n where \nanswer[i]\n is the column that the ball falls out of at the bottom after dropping the ball from the \ni\nth\n column at the top, or \n-1\n if the ball gets stuck in the box\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n\nOutput:\n [1,-1,-1,-1,-1]\n\nExplanation:\n This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[-1]]\n\nOutput:\n [-1]\n\nExplanation:\n The ball gets stuck against the left wall.\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n\nOutput:\n [0,1,2,3,4,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 100\n\n\ngrid[i][j]\n is \n1\n or \n-1\n.",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1210,
    "slug": "minimum-moves-to-reach-target-with-rotations",
    "url": "https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/",
    "titulo": "Minimum Moves to Reach Target with Rotations",
    "enunciado": "In an \nn*n\n grid, there is a snake that spans 2 cells and starts moving from the top left corner at \n(0, 0)\n and \n(0, 1)\n. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at \n(n-1, n-2)\n and \n(n-1, n-1)\n.\n\n\nIn one move the snake can:\n\n\n\n\nMove one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n\n\nMove down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n\n\nRotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from \n(r, c)\n and \n(r, c+1)\n to \n(r, c)\n and \n(r+1, c)\n.\n\n\n\n\nRotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from \n(r, c)\n and \n(r+1, c)\n to \n(r, c)\n and \n(r, c+1)\n.\n\n\n\n\n\n\nReturn the minimum number of moves to reach the target.\n\n\nIf there is no way to reach the target, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n               [0,0,0,0,1,1],\n               [0,0,1,0,1,0],\n               [0,1,1,0,0,0],\n               [0,1,1,0,0,0]]\n\nOutput:\n 11\n\nExplanation:\n\nOne possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0,0,1,1,1,1],\n               [0,0,0,0,1,1],\n               [1,1,0,0,0,1],\n               [1,1,1,0,0,1],\n               [1,1,1,0,0,1],\n               [1,1,1,0,0,0]]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 100\n\n\n0 <= grid[i][j] <= 1\n\n\nIt is guaranteed that the snake starts at empty cells.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1916,
    "slug": "count-ways-to-build-rooms-in-an-ant-colony",
    "url": "https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/",
    "titulo": "Count Ways to Build Rooms in an Ant Colony",
    "enunciado": "You are an ant tasked with adding \nn\n new rooms numbered \n0\n to \nn-1\n to your colony. You are given the expansion plan as a \n0-indexed\n integer array of length \nn\n, \nprevRoom\n, where \nprevRoom[i]\n indicates that you must build room \nprevRoom[i]\n before building room \ni\n, and these two rooms must be connected \ndirectly\n. Room \n0\n is already built, so \nprevRoom[0] = -1\n. The expansion plan is given such that once all the rooms are built, every room will be reachable from room \n0\n.\n\n\nYou can only build \none room\n at a time, and you can travel freely between rooms you have \nalready built\n only if they are \nconnected\n. You can choose to build \nany room\n as long as its \nprevious room\n is already built.\n\n\nReturn \nthe \nnumber of different orders\n you can build all the rooms in\n. Since the answer may be large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n prevRoom = [-1,0,1]\r\n\nOutput:\n 1\r\n\nExplanation:\n There is only one way to build the additional rooms: 0 → 1 → 2\r\n\n\n\nExample 2:\n\n\n\n\n\r\n\nInput:\n prevRoom = [-1,0,0,1,2]\r\n\nOutput:\n 6\r\n\nExplanation:\r\n\nThe 6 ways are:\r\n0 → 1 → 3 → 2 → 4\r\n0 → 2 → 4 → 1 → 3\r\n0 → 1 → 2 → 3 → 4\r\n0 → 1 → 2 → 4 → 3\r\n0 → 2 → 1 → 3 → 4\r\n0 → 2 → 1 → 4 → 3\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == prevRoom.length\n\n\n2 <= n <= 10\n5\n\n\nprevRoom[0] == -1\n\n\n0 <= prevRoom[i] < n\n for all \n1 <= i < n\n\n\nEvery room is reachable from room \n0\n once all the rooms are built.",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Tree",
      "Graph",
      "Topological Sort",
      "Combinatorics"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 2201,
    "slug": "count-artifacts-that-can-be-extracted",
    "url": "https://leetcode.com/problems/count-artifacts-that-can-be-extracted/",
    "titulo": "Count Artifacts That Can Be Extracted",
    "enunciado": "There is an \nn x n\n \n0-indexed\n grid with some artifacts buried in it. You are given the integer \nn\n and a \n0-indexed \n2D integer array \nartifacts\n describing the positions of the rectangular artifacts where \nartifacts[i] = [r1\ni\n, c1\ni\n, r2\ni\n, c2\ni\n]\n denotes that the \ni\nth\n artifact is buried in the subgrid where:\n\n\n\n\n(r1\ni\n, c1\ni\n)\n is the coordinate of the \ntop-left\n cell of the \ni\nth\n artifact and\n\n\n(r2\ni\n, c2\ni\n)\n is the coordinate of the \nbottom-right\n cell of the \ni\nth\n artifact.\n\n\n\n\nYou will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\n\n\nGiven a \n0-indexed\n 2D integer array \ndig\n where \ndig[i] = [r\ni\n, c\ni\n]\n indicates that you will excavate the cell \n(r\ni\n, c\ni\n)\n, return \nthe number of artifacts that you can extract\n.\n\n\nThe test cases are generated such that:\n\n\n\n\nNo two artifacts overlap.\n\n\nEach artifact only covers at most \n4\n cells.\n\n\nThe entries of \ndig\n are unique.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n\nOutput:\n 1\n\nExplanation:\n \nThe different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.\nThere is 1 artifact that can be extracted, namely the red artifact.\nThe blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.\nThus, we return 1.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n\nOutput:\n 2\n\nExplanation:\n Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000\n\n\n1 <= artifacts.length, dig.length <= min(n\n2\n, 10\n5\n)\n\n\nartifacts[i].length == 4\n\n\ndig[i].length == 2\n\n\n0 <= r1\ni\n, c1\ni\n, r2\ni\n, c2\ni\n, r\ni\n, c\ni\n <= n - 1\n\n\nr1\ni\n <= r2\ni\n\n\nc1\ni\n <= c2\ni\n\n\nNo two artifacts will overlap.\n\n\nThe number of cells covered by an artifact is \nat most\n \n4\n.\n\n\nThe entries of \ndig\n are unique.",
    "temas": [
      "Array",
      "Hash Table",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1895,
    "slug": "largest-magic-square",
    "url": "https://leetcode.com/problems/largest-magic-square/",
    "titulo": "Largest Magic Square",
    "enunciado": "A \nk x k\n \nmagic square\n is a \nk x k\n grid filled with integers such that every row sum, every column sum, and both diagonal sums are \nall equal\n. The integers in the magic square \ndo not have to be distinct\n. Every \n1 x 1\n grid is trivially a \nmagic square\n.\n\n\nGiven an \nm x n\n integer \ngrid\n, return \nthe \nsize\n (i.e., the side length \nk\n) of the \nlargest magic square\n that can be found within this grid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n\nOutput:\n 3\n\nExplanation:\n The largest magic square has a size of 3.\nEvery row sum, column sum, and diagonal sum of this magic square is equal to 12.\n- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12\n- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12\n- Diagonal sums: 5+4+3 = 6+4+2 = 12\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\n1 <= grid[i][j] <= 10\n6",
    "temas": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1203,
    "slug": "sort-items-by-groups-respecting-dependencies",
    "url": "https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/",
    "titulo": "Sort Items by Groups Respecting Dependencies",
    "enunciado": "There are \nn\n items each belonging to zero or one of \nm\n groups where \ngroup[i]\n is the group that the \ni\n-th item belongs to and it's equal to \n-1\n if the \ni\n-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\n\nReturn a sorted list of the items such that:\n\n\n\n\nThe items that belong to the same group are next to each other in the sorted list.\n\n\nThere are some relations between these items where \nbeforeItems[i]\n is a list containing all the items that should come before the \ni\n-th item in the sorted array (to the left of the \ni\n-th item).\n\n\n\n\nReturn any solution if there is more than one solution and return an \nempty list\n if there is no solution.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n\nOutput:\n [6,3,4,1,5,2,0,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n\nOutput:\n []\n\nExplanation:\n This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m <= n <= 3 * 10\n4\n\n\ngroup.length == beforeItems.length == n\n\n\n-1 <= group[i] <= m - 1\n\n\n0 <= beforeItems[i].length <= n - 1\n\n\n0 <= beforeItems[i][j] <= n - 1\n\n\ni != beforeItems[i][j]\n\n\nbeforeItems[i] \ndoes not contain duplicates elements.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1944,
    "slug": "number-of-visible-people-in-a-queue",
    "url": "https://leetcode.com/problems/number-of-visible-people-in-a-queue/",
    "titulo": "Number of Visible People in a Queue",
    "enunciado": "There are \nn\n people standing in a queue, and they numbered from \n0\n to \nn - 1\n in \nleft to right\n order. You are given an array \nheights\n of \ndistinct\n integers where \nheights[i]\n represents the height of the \ni\nth\n person.\n\n\nA person can \nsee\n another person to their right in the queue if everybody in between is \nshorter\n than both of them. More formally, the \ni\nth\n person can see the \nj\nth\n person if \ni < j\n and \nmin(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])\n.\n\n\nReturn \nan array \nanswer\n of length \nn\n where \nanswer[i]\n is the \nnumber of people\n the \ni\nth\n person can \nsee\n to their right in the queue\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [10,6,8,5,11,9]\n\nOutput:\n [3,1,2,1,1,0]\n\nExplanation:\n\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [5,1,2,3,10]\n\nOutput:\n [4,1,1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == heights.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= heights[i] <= 10\n5\n\n\nAll the values of \nheights\n are \nunique\n.",
    "temas": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1192,
    "slug": "critical-connections-in-a-network",
    "url": "https://leetcode.com/problems/critical-connections-in-a-network/",
    "titulo": "Critical Connections in a Network",
    "enunciado": "There are \nn\n servers numbered from \n0\n to \nn - 1\n connected by undirected server-to-server \nconnections\n forming a network where \nconnections[i] = [a\ni\n, b\ni\n]\n represents a connection between servers \na\ni\n and \nb\ni\n. Any server can reach other servers directly or indirectly through the network.\n\n\nA \ncritical connection\n is a connection that, if removed, will make some servers unable to reach some other server.\n\n\nReturn all critical connections in the network in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n\nOutput:\n [[1,3]]\n\nExplanation:\n [[3,1]] is also accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, connections = [[0,1]]\n\nOutput:\n [[0,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nn - 1 <= connections.length <= 10\n5\n\n\n0 <= a\ni\n, b\ni\n <= n - 1\n\n\na\ni\n != b\ni\n\n\nThere are no repeated connections.",
    "temas": [
      "Depth-First Search",
      "Graph",
      "Biconnected Component"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 1189,
    "slug": "maximum-number-of-balloons",
    "url": "https://leetcode.com/problems/maximum-number-of-balloons/",
    "titulo": "Maximum Number of Balloons",
    "enunciado": "Given a string \ntext\n, you want to use the characters of \ntext\n to form as many instances of the word \n\"balloon\"\n as possible.\n\n\nYou can use each character in \ntext\n \nat most once\n. Return the maximum number of instances that can be formed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n text = \"nlaebolko\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n text = \"loonbalxballpoon\"\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n text = \"leetcode\"\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text.length <= 10\n4\n\n\ntext\n consists of lower case English letters only.\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 2287: Rearrange Characters to Make Target String.",
    "temas": [
      "Hash Table",
      "String",
      "Counting"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1483,
    "slug": "kth-ancestor-of-a-tree-node",
    "url": "https://leetcode.com/problems/kth-ancestor-of-a-tree-node/",
    "titulo": "Kth Ancestor of a Tree Node",
    "enunciado": "You are given a tree with \nn\n nodes numbered from \n0\n to \nn - 1\n in the form of a parent array \nparent\n where \nparent[i]\n is the parent of \ni\nth\n node. The root of the tree is node \n0\n. Find the \nk\nth\n ancestor of a given node.\n\n\nThe \nk\nth\n ancestor of a tree node is the \nk\nth\n node in the path from that node to the root node.\n\n\nImplement the \nTreeAncestor\n class:\n\n\n\n\nTreeAncestor(int n, int[] parent)\n Initializes the object with the number of nodes in the tree and the parent array.\n\n\nint getKthAncestor(int node, int k)\n return the \nk\nth\n ancestor of the given node \nnode\n. If there is no such ancestor, return \n-1\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\n\nOutput\n\n[null, 1, 0, -1]\n\n\nExplanation\n\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 5 * 10\n4\n\n\nparent.length == n\n\n\nparent[0] == -1\n\n\n0 <= parent[i] < n\n for all \n0 < i < n\n\n\n0 <= node < n\n\n\nThere will be at most \n5 * 10\n4\n queries.",
    "temas": [
      "Binary Search",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Binary Search",
    "has_image": true
  },
  {
    "id": 1954,
    "slug": "minimum-garden-perimeter-to-collect-enough-apples",
    "url": "https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/",
    "titulo": "Minimum Garden Perimeter to Collect Enough Apples",
    "enunciado": "In a garden represented as an infinite 2D grid, there is an apple tree planted at \nevery\n integer coordinate. The apple tree planted at an integer coordinate \n(i, j)\n has \n|i| + |j|\n apples growing on it.\n\n\nYou will buy an axis-aligned \nsquare plot\n of land that is centered at \n(0, 0)\n.\n\n\nGiven an integer \nneededApples\n, return \nthe \nminimum perimeter\n of a plot such that \nat least\n \nneededApples\n \napples are \ninside or on\n the perimeter of that plot\n.\n\n\nThe value of \n|x|\n is defined as:\n\n\n\n\nx\n if \nx >= 0\n\n\n-x\n if \nx < 0\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n neededApples = 1\n\nOutput:\n 8\n\nExplanation:\n A square plot of side length 1 does not contain any apples.\nHowever, a square plot of side length 2 has 12 apples inside (as depicted in the image above).\nThe perimeter is 2 * 4 = 8.\n\n\n\nExample 2:\n\n\n\n\nInput:\n neededApples = 13\n\nOutput:\n 16\n\n\n\nExample 3:\n\n\n\n\nInput:\n neededApples = 1000000000\n\nOutput:\n 5040\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= neededApples <= 10\n15",
    "temas": [
      "Math",
      "Binary Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1184,
    "slug": "distance-between-bus-stops",
    "url": "https://leetcode.com/problems/distance-between-bus-stops/",
    "titulo": "Distance Between Bus Stops",
    "enunciado": "A bus has \nn\n stops numbered from \n0\n to \nn - 1\n that form a circle. We know the distance between all pairs of neighboring stops where \ndistance[i]\n is the distance between the stops number \ni\n and \n(i + 1) % n\n.\n\n\nThe bus goes along both directions i.e. clockwise and counterclockwise.\n\n\nReturn the shortest distance between the given \nstart\n and \ndestination\n stops.\n\n\n \n\n\nExample 1:\n\n\n\n\n\r\n\nInput:\n distance = [1,2,3,4], start = 0, destination = 1\r\n\nOutput:\n 1\r\n\nExplanation:\n Distance between 0 and 1 is 1 or 9, minimum is 1.\n\n\n \n\n\nExample 2:\n\n\n\n\n\r\n\nInput:\n distance = [1,2,3,4], start = 0, destination = 2\r\n\nOutput:\n 3\r\n\nExplanation:\n Distance between 0 and 2 is 3 or 7, minimum is 3.\r\n\n\n\n \n\n\nExample 3:\n\n\n\n\n\r\n\nInput:\n distance = [1,2,3,4], start = 0, destination = 3\r\n\nOutput:\n 4\r\n\nExplanation:\n Distance between 0 and 3 is 6 or 4, minimum is 4.\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10^4\n\n\ndistance.length == n\n\n\n0 <= start, destination < n\n\n\n0 <= distance[i] <= 10^4",
    "temas": [
      "Array"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1382,
    "slug": "balance-a-binary-search-tree",
    "url": "https://leetcode.com/problems/balance-a-binary-search-tree/",
    "titulo": "Balance a Binary Search Tree",
    "enunciado": "Given the \nroot\n of a binary search tree, return \na \nbalanced\n binary search tree with the same node values\n. If there is more than one answer, return \nany of them\n.\n\n\nA binary search tree is \nbalanced\n if the depth of the two subtrees of every node never differs by more than \n1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,2,null,3,null,4,null,null]\n\nOutput:\n [2,1,3,null,null,null,4]\n\nExplanation:\n This is not the only correct answer, [3,1,4,null,2] is also correct.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n [2,1,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n1 <= Node.val <= 10\n5",
    "temas": [
      "Divide and Conquer",
      "Greedy",
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Divide and Conquer",
    "has_image": true
  },
  {
    "id": 1361,
    "slug": "validate-binary-tree-nodes",
    "url": "https://leetcode.com/problems/validate-binary-tree-nodes/",
    "titulo": "Validate Binary Tree Nodes",
    "enunciado": "You have \nn\n binary tree nodes numbered from \n0\n to \nn - 1\n where node \ni\n has two children \nleftChild[i]\n and \nrightChild[i]\n, return \ntrue\n if and only if \nall\n the given nodes form \nexactly one\n valid binary tree.\n\n\nIf node \ni\n has no left child then \nleftChild[i]\n will equal \n-1\n, similarly for the right child.\n\n\nNote that the nodes have no values and that we only use the node numbers in this problem.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 2, leftChild = [1,0], rightChild = [-1,-1]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == leftChild.length == rightChild.length\n\n\n1 <= n <= 10\n4\n\n\n-1 <= leftChild[i], rightChild[i] <= n - 1",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1632,
    "slug": "rank-transform-of-a-matrix",
    "url": "https://leetcode.com/problems/rank-transform-of-a-matrix/",
    "titulo": "Rank Transform of a Matrix",
    "enunciado": "Given an \nm x n\n \nmatrix\n, return \na new matrix \nanswer\n where \nanswer[row][col]\n is the \nrank\n of \nmatrix[row][col]\n.\n\n\nThe \nrank\n is an \ninteger\n that represents how large an element is compared to other elements. It is calculated using the following rules:\n\n\n\n\nThe rank is an integer starting from \n1\n.\n\n\nIf two elements \np\n and \nq\n are in the \nsame row or column\n, then:\n\t\n\n\nIf \np < q\n then \nrank(p) < rank(q)\n\n\nIf \np == q\n then \nrank(p) == rank(q)\n\n\nIf \np > q\n then \nrank(p) > rank(q)\n\n\n\n\n\n\nThe \nrank\n should be as \nsmall\n as possible.\n\n\n\n\nThe test cases are generated so that \nanswer\n is unique under the given rules.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2],[3,4]]\n\nOutput:\n [[1,2],[2,3]]\n\nExplanation:\n\nThe rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.\nThe rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[7,7],[7,7]]\n\nOutput:\n [[1,1],[1,1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n\nOutput:\n [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 500\n\n\n-10\n9\n <= matrix[row][col] <= 10\n9",
    "temas": [
      "Array",
      "Union Find",
      "Graph",
      "Topological Sort",
      "Sorting",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1302,
    "slug": "deepest-leaves-sum",
    "url": "https://leetcode.com/problems/deepest-leaves-sum/",
    "titulo": "Deepest Leaves Sum",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe sum of values of its deepest leaves\n.\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n\nOutput:\n 15\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n\nOutput:\n 19\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n1 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1329,
    "slug": "sort-the-matrix-diagonally",
    "url": "https://leetcode.com/problems/sort-the-matrix-diagonally/",
    "titulo": "Sort the Matrix Diagonally",
    "enunciado": "A \nmatrix diagonal\n is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the \nmatrix diagonal\n starting from \nmat[2][0]\n, where \nmat\n is a \n6 x 3\n matrix, includes cells \nmat[2][0]\n, \nmat[3][1]\n, and \nmat[4][2]\n.\n\n\nGiven an \nm x n\n matrix \nmat\n of integers, sort each \nmatrix diagonal\n in ascending order and return \nthe resulting matrix\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n\nOutput:\n [[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n\nOutput:\n [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 100\n\n\n1 <= mat[i][j] <= 100",
    "temas": [
      "Array",
      "Sorting",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1145,
    "slug": "binary-tree-coloring-game",
    "url": "https://leetcode.com/problems/binary-tree-coloring-game/",
    "titulo": "Binary Tree Coloring Game",
    "enunciado": "Two players play a turn based game on a binary tree. We are given the \nroot\n of this binary tree, and the number of nodes \nn\n in the tree. \nn\n is odd, and each node has a distinct value from \n1\n to \nn\n.\n\n\nInitially, the first player names a value \nx\n with \n1 <= x <= n\n, and the second player names a value \ny\n with \n1 <= y <= n\n and \ny != x\n. The first player colors the node with value \nx\n red, and the second player colors the node with value \ny\n blue.\n\n\nThen, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an \nuncolored\n neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\n\n\nIf (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\n\n\nYou are the second player. If it is possible to choose such a \ny\n to ensure you win the game, return \ntrue\n. If it is not possible, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n\nOutput:\n true\n\nExplanation: \nThe second player can choose the node with value 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2,3], n = 3, x = 1\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= x <= n <= 100\n\n\nn\n is odd.\n\n\n1 <= Node.val <= n\n\n\nAll the values of the tree are \nunique\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1315,
    "slug": "sum-of-nodes-with-even-valued-grandparent",
    "url": "https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/",
    "titulo": "Sum of Nodes with Even-Valued Grandparent",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe sum of values of nodes with an \neven-valued grandparent\n. If there are no nodes with an \neven-valued grandparent\n, return \n0\n.\n\n\nA \ngrandparent\n of a node is the parent of its parent if it exists.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n\nOutput:\n 18\n\nExplanation:\n The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n1 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1138,
    "slug": "alphabet-board-path",
    "url": "https://leetcode.com/problems/alphabet-board-path/",
    "titulo": "Alphabet Board Path",
    "enunciado": "On an alphabet board, we start at position \n(0, 0)\n, corresponding to character \nboard[0][0]\n.\n\n\nHere, \nboard = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\n, as shown in the diagram below.\n\n\n\n\nWe may make the following moves:\n\n\n\n\n'U'\n moves our position up one row, if the position exists on the board;\n\n\n'D'\n moves our position down one row, if the position exists on the board;\n\n\n'L'\n moves our position left one column, if the position exists on the board;\n\n\n'R'\n moves our position right one column, if the position exists on the board;\n\n\n'!'\n adds the character \nboard[r][c]\n at our current position \n(r, c)\n to the answer.\n\n\n\n\n(Here, the only positions that exist on the board are positions with letters on them.)\n\n\nReturn a sequence of moves that makes our answer equal to \ntarget\n in the minimum number of moves.  You may return any path that does so.\n\n\n \n\n\nExample 1:\n\n\nInput:\n target = \"leet\"\r\n\nOutput:\n \"DDR!UURRR!!DDD!\"\r\n\nExample 2:\n\n\nInput:\n target = \"code\"\r\n\nOutput:\n \"RR!DDRR!UUL!R!\"\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= target.length <= 100\n\n\ntarget\n consists only of English lowercase letters.",
    "temas": [
      "Hash Table",
      "String"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1130,
    "slug": "minimum-cost-tree-from-leaf-values",
    "url": "https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/",
    "titulo": "Minimum Cost Tree From Leaf Values",
    "enunciado": "Given an array \narr\n of positive integers, consider all binary trees such that:\n\n\n\n\nEach node has either \n0\n or \n2\n children;\n\n\nThe values of \narr\n correspond to the values of each \nleaf\n in an in-order traversal of the tree.\n\n\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\n\n\n\nAmong all possible binary trees considered, return \nthe smallest possible sum of the values of each non-leaf node\n. It is guaranteed this sum fits into a \n32-bit\n integer.\n\n\nA node is a \nleaf\n if and only if it has zero children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n arr = [6,2,4]\n\nOutput:\n 32\n\nExplanation:\n There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n arr = [4,11]\n\nOutput:\n 44\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= arr.length <= 40\n\n\n1 <= arr[i] <= 15\n\n\nIt is guaranteed that the answer fits into a \n32-bit\n signed integer (i.e., it is less than 2\n31\n).",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1289,
    "slug": "minimum-falling-path-sum-ii",
    "url": "https://leetcode.com/problems/minimum-falling-path-sum-ii/",
    "titulo": "Minimum Falling Path Sum II",
    "enunciado": "Given an \nn x n\n integer matrix \ngrid\n, return \nthe minimum sum of a \nfalling path with non-zero shifts\n.\n\n\nA \nfalling path with non-zero shifts\n is a choice of exactly one element from each row of \ngrid\n such that no two elements chosen in adjacent rows are in the same column.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n 13\n\nExplanation:\n \nThe possible falling paths are:\n[1,5,9], [1,5,7], [1,6,7], [1,6,8],\n[2,4,8], [2,4,9], [2,6,7], [2,6,8],\n[3,4,8], [3,4,9], [3,5,7], [3,5,9]\nThe falling path with the smallest sum is [1,5,7], so the answer is 13.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[7]]\n\nOutput:\n 7\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 200\n\n\n-99 <= grid[i][j] <= 99",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1627,
    "slug": "graph-connectivity-with-threshold",
    "url": "https://leetcode.com/problems/graph-connectivity-with-threshold/",
    "titulo": "Graph Connectivity With Threshold",
    "enunciado": "We have \nn\n cities labeled from \n1\n to \nn\n. Two different cities with labels \nx\n and \ny\n are directly connected by a bidirectional road if and only if \nx\n and \ny\n share a common divisor \nstrictly greater\n than some \nthreshold\n. More formally, cities with labels \nx\n and \ny\n have a road between them if there exists an integer \nz\n such that all of the following are true:\n\n\n\n\nx % z == 0\n,\n\n\ny % z == 0\n, and\n\n\nz > threshold\n.\n\n\n\n\nGiven the two integers, \nn\n and \nthreshold\n, and an array of \nqueries\n, you must determine for each \nqueries[i] = [a\ni\n, b\ni\n]\n if cities \na\ni\n and \nb\ni\n are connected directly or indirectly. (i.e. there is some path between them).\n\n\nReturn \nan array \nanswer\n, where \nanswer.length == queries.length\n and \nanswer[i]\n is \ntrue\n if for the \ni\nth\n query, there is a path between \na\ni\n and \nb\ni\n, or \nanswer[i]\n is \nfalse\n if there is no path.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]\n\nOutput:\n [false,false,true]\n\nExplanation:\n The divisors for each number:\n1:   1\n2:   1, 2\n3:   1, \n3\n\n4:   1, 2, \n4\n\n5:   1, \n5\n\n6:   1, 2, \n3\n, \n6\n\nUsing the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the\nonly ones directly connected. The result of each query:\n[1,4]   1 is not connected to 4\n[2,5]   2 is not connected to 5\n[3,6]   3 is connected to 6 through path 3--6\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]\n\nOutput:\n [true,true,true,true,true]\n\nExplanation:\n The divisors for each number are the same as the previous example. However, since the threshold is 0,\nall divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]\n\nOutput:\n [false,false,false,false,false]\n\nExplanation:\n Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.\nPlease notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n4\n\n\n0 <= threshold <= n\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n1 <= a\ni\n, b\ni\n <= cities\n\n\na\ni\n != b\ni",
    "temas": [
      "Array",
      "Math",
      "Union Find",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1123,
    "slug": "lowest-common-ancestor-of-deepest-leaves",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/",
    "titulo": "Lowest Common Ancestor of Deepest Leaves",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe lowest common ancestor of its deepest leaves\n.\n\n\nRecall that:\n\n\n\n\nThe node of a binary tree is a leaf if and only if it has no children\n\n\nThe depth of the root of the tree is \n0\n. if the depth of a node is \nd\n, the depth of each of its children is \nd + 1\n.\n\n\nThe lowest common ancestor of a set \nS\n of nodes, is the node \nA\n with the largest depth such that every node in \nS\n is in the subtree with root \nA\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4]\n\nOutput:\n [2,7,4]\n\nExplanation:\n We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [1]\n\nExplanation:\n The root is the deepest node in the tree, and it's the lca of itself.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [0,1,3,null,2]\n\nOutput:\n [2]\n\nExplanation:\n The deepest leaf node in the tree is 2, the lca of one node is itself.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree will be in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 1000\n\n\nThe values of the nodes in the tree are \nunique\n.\n\n\n\n\n \n\n\nNote:\n This question is the same as 865: \nhttps://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 1110,
    "slug": "delete-nodes-and-return-forest",
    "url": "https://leetcode.com/problems/delete-nodes-and-return-forest/",
    "titulo": "Delete Nodes And Return Forest",
    "enunciado": "Given the \nroot\n of a binary tree, each node in the tree has a distinct value.\n\n\nAfter deleting all nodes with a value in \nto_delete\n, we are left with a forest (a disjoint union of trees).\n\n\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7], to_delete = [3,5]\n\nOutput:\n [[1,2,null,4],[6],[7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2,4,null,3], to_delete = [3]\n\nOutput:\n [[1,2,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the given tree is at most \n1000\n.\n\n\nEach node has a distinct value between \n1\n and \n1000\n.\n\n\nto_delete.length <= 1000\n\n\nto_delete\n contains distinct values between \n1\n and \n1000\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1105,
    "slug": "filling-bookcase-shelves",
    "url": "https://leetcode.com/problems/filling-bookcase-shelves/",
    "titulo": "Filling Bookcase Shelves",
    "enunciado": "You are given an array \nbooks\n where \nbooks[i] = [thickness\ni\n, height\ni\n]\n indicates the thickness and height of the \ni\nth\n book. You are also given an integer \nshelfWidth\n.\n\n\nWe want to place these books in order onto bookcase shelves that have a total width \nshelfWidth\n.\n\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to \nshelfWidth\n, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n\n\n\nFor example, if we have an ordered list of \n5\n books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\n\n\n\nReturn \nthe minimum possible height that the total bookshelf can be after placing shelves in this manner\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4\n\nOutput:\n 6\n\nExplanation:\n\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n\n\nExample 2:\n\n\n\n\nInput:\n books = [[1,3],[2,4],[3,2]], shelfWidth = 6\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= books.length <= 1000\n\n\n1 <= thickness\ni\n <= shelfWidth <= 1000\n\n\n1 <= height\ni\n <= 1000",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1104,
    "slug": "path-in-zigzag-labelled-binary-tree",
    "url": "https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/",
    "titulo": "Path In Zigzag Labelled Binary Tree",
    "enunciado": "In an infinite binary tree where every node has two children, the nodes are labelled in row order.\n\n\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\n\n\n\nGiven the \nlabel\n of a node in this tree, return the labels in the path from the root of the tree to the node with that \nlabel\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n label = 14\n\nOutput:\n [1,3,4,14]\n\n\n\nExample 2:\n\n\n\n\nInput:\n label = 26\n\nOutput:\n [1,2,6,10,26]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= label <= 10^6",
    "temas": [
      "Math",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 1091,
    "slug": "shortest-path-in-binary-matrix",
    "url": "https://leetcode.com/problems/shortest-path-in-binary-matrix/",
    "titulo": "Shortest Path in Binary Matrix",
    "enunciado": "Given an \nn x n\n binary matrix \ngrid\n, return \nthe length of the shortest \nclear path\n in the matrix\n. If there is no clear path, return \n-1\n.\n\n\nA \nclear path\n in a binary matrix is a path from the \ntop-left\n cell (i.e., \n(0, 0)\n) to the \nbottom-right\n cell (i.e., \n(n - 1, n - 1)\n) such that:\n\n\n\n\nAll the visited cells of the path are \n0\n.\n\n\nAll the adjacent cells of the path are \n8-directionally\n connected (i.e., they are different and they share an edge or a corner).\n\n\n\n\nThe \nlength of a clear path\n is the number of visited cells of this path.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1],[1,0]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[1,1,0],[1,1,0]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0,0],[1,1,0],[1,1,0]]\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 100\n\n\ngrid[i][j] is 0 or 1",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1080,
    "slug": "insufficient-nodes-in-root-to-leaf-paths",
    "url": "https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/",
    "titulo": "Insufficient Nodes in Root to Leaf Paths",
    "enunciado": "Given the \nroot\n of a binary tree and an integer \nlimit\n, delete all \ninsufficient nodes\n in the tree simultaneously, and return \nthe root of the resulting binary tree\n.\n\n\nA node is \ninsufficient\n if every root to \nleaf\n path intersecting this node has a sum strictly less than \nlimit\n.\n\n\nA \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\n\nOutput:\n [1,2,3,4,null,null,7,8,9,null,14]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\n\nOutput:\n [5,4,8,11,null,17,4,7,null,null,null,5]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,-3,-5,null,4,null], limit = -1\n\nOutput:\n [1,null,-3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 5000]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\n-10\n9\n <= limit <= 10\n9",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1074,
    "slug": "number-of-submatrices-that-sum-to-target",
    "url": "https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/",
    "titulo": "Number of Submatrices That Sum to Target",
    "enunciado": "Given a \nmatrix\n and a \ntarget\n, return the number of non-empty submatrices that sum to \ntarget\n.\n\n\nA submatrix \nx1, y1, x2, y2\n is the set of all cells \nmatrix[x][y]\n with \nx1 <= x <= x2\n and \ny1 <= y <= y2\n.\n\n\nTwo submatrices \n(x1, y1, x2, y2)\n and \n(x1', y1', x2', y2')\n are different if they have some coordinate that is different: for example, if \nx1 != x1'\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n\nOutput:\n 4\n\nExplanation:\n The four 1x1 submatrices that only contain 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[1,-1],[-1,1]], target = 0\n\nOutput:\n 5\n\nExplanation:\n The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[904]], target = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= matrix.length <= 100\n\n\n1 <= matrix[0].length <= 100\n\n\n-1000 <= matrix[i][j] <= 1000\n\n\n-10^8 <= target <= 10^8",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1162,
    "slug": "as-far-from-land-as-possible",
    "url": "https://leetcode.com/problems/as-far-from-land-as-possible/",
    "titulo": "As Far from Land as Possible",
    "enunciado": "Given an \nn x n\n \ngrid\n containing only values \n0\n and \n1\n, where \n0\n represents water and \n1\n represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return \n-1\n.\n\n\nThe distance used in this problem is the Manhattan distance: the distance between two cells \n(x0, y0)\n and \n(x1, y1)\n is \n|x0 - x1| + |y0 - y1|\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,0,1],[0,0,0],[1,0,1]]\n\nOutput:\n 2\n\nExplanation:\n The cell (1, 1) is as far as possible from all the land with distance 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0],[0,0,0],[0,0,0]]\n\nOutput:\n 4\n\nExplanation:\n The cell (2, 2) is as far as possible from all the land with distance 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 100\n\n\ngrid[i][j]\n is \n0\n or \n1",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1161,
    "slug": "maximum-level-sum-of-a-binary-tree",
    "url": "https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/",
    "titulo": "Maximum Level Sum of a Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, the level of its root is \n1\n, the level of its children is \n2\n, and so on.\n\n\nReturn the \nsmallest\n level \nx\n such that the sum of all the values of nodes at level \nx\n is \nmaximal\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,7,0,7,-8,null,null]\n\nOutput:\n 2\n\nExplanation: \n\nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [989,null,10250,98693,-89388,null,null,null,-32127]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1038,
    "slug": "binary-search-tree-to-greater-sum-tree",
    "url": "https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/",
    "titulo": "Binary Search Tree to Greater Sum Tree",
    "enunciado": "Given the \nroot\n of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n\n\nAs a reminder, a \nbinary search tree\n is a tree that satisfies these constraints:\n\n\n\n\nThe left subtree of a node contains only nodes with keys \nless than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \ngreater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n\nOutput:\n [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0,null,1]\n\nOutput:\n [1,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 100\n\n\nAll the values in the tree are \nunique\n.\n\n\n\n\n \n\n\nNote:\n This question is the same as 538: \nhttps://leetcode.com/problems/convert-bst-to-greater-tree/",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1039,
    "slug": "minimum-score-triangulation-of-polygon",
    "url": "https://leetcode.com/problems/minimum-score-triangulation-of-polygon/",
    "titulo": "Minimum Score Triangulation of Polygon",
    "enunciado": "You have a convex \nn\n-sided polygon where each vertex has an integer value. You are given an integer array \nvalues\n where \nvalues[i]\n is the value of the \ni\nth\n vertex in \nclockwise order\n.\n\n\nPolygon\n \ntriangulation\n is a process where you divide a polygon into a set of triangles and the vertices of each triangle must also be vertices of the original polygon. Note that no other shapes other than triangles are allowed in the division. This process will result in \nn - 2\n triangles.\n\n\nYou will \ntriangulate\n the polygon. For each triangle, the \nweight\n of that triangle is the product of the values at its vertices. The total score of the triangulation is the sum of these \nweights\n over all \nn - 2\n triangles.\n\n\nReturn the\n minimum possible score \nthat you can achieve with some\n \ntriangulation\n \nof the polygon.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nvalues = [1,2,3]\n\n\nOutput:\n \n6\n\n\nExplanation:\n The polygon is already triangulated, and the score of the only triangle is 6.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nvalues = [3,7,4,5]\n\n\nOutput:\n \n144\n\n\nExplanation:\n There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\n\nThe minimum score is 144.\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n \nvalues = [1,3,1,4,1,5]\n\n\nOutput:\n \n13\n\n\nExplanation:\n The minimum score triangulation is 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == values.length\n\n\n3 <= n <= 50\n\n\n1 <= values[i] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1035,
    "slug": "uncrossed-lines",
    "url": "https://leetcode.com/problems/uncrossed-lines/",
    "titulo": "Uncrossed Lines",
    "enunciado": "You are given two integer arrays \nnums1\n and \nnums2\n. We write the integers of \nnums1\n and \nnums2\n (in the order they are given) on two separate horizontal lines.\n\n\nWe may draw connecting lines: a straight line connecting two numbers \nnums1[i]\n and \nnums2[j]\n such that:\n\n\n\n\nnums1[i] == nums2[j]\n, and\n\n\nthe line we draw does not intersect any other connecting (non-horizontal) line.\n\n\n\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\n\nReturn \nthe maximum number of connecting lines we can draw in this way\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums1 = [1,4,2], nums2 = [1,2,4]\n\nOutput:\n 2\n\nExplanation:\n We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 500\n\n\n1 <= nums1[i], nums2[j] <= 2000",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1028,
    "slug": "recover-a-tree-from-preorder-traversal",
    "url": "https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/",
    "titulo": "Recover a Tree From Preorder Traversal",
    "enunciado": "We run a preorder depth-first search (DFS) on the \nroot\n of a binary tree.\n\n\nAt each node in this traversal, we output \nD\n dashes (where \nD\n is the depth of this node), then we output the value of this node.  If the depth of a node is \nD\n, the depth of its immediate child is \nD + 1\n.  The depth of the \nroot\n node is \n0\n.\n\n\nIf a node has only one child, that child is guaranteed to be \nthe left child\n.\n\n\nGiven the output \ntraversal\n of this traversal, recover the tree and return \nits\n \nroot\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n traversal = \"1-2--3--4-5--6--7\"\n\nOutput:\n [1,2,5,3,4,6,7]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n traversal = \"1-2--3---4-5--6---7\"\n\nOutput:\n [1,2,5,3,null,6,null,4,null,7]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n traversal = \"1-401--349---90--88\"\n\nOutput:\n [1,401,null,349,88,90]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the original tree is in the range \n[1, 1000]\n.\n\n\n1 <= Node.val <= 10\n9",
    "temas": [
      "String",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 1026,
    "slug": "maximum-difference-between-node-and-ancestor",
    "url": "https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/",
    "titulo": "Maximum Difference Between Node and Ancestor",
    "enunciado": "Given the \nroot\n of a binary tree, find the maximum value \nv\n for which there exist \ndifferent\n nodes \na\n and \nb\n where \nv = |a.val - b.val|\n and \na\n is an ancestor of \nb\n.\n\n\nA node \na\n is an ancestor of \nb\n if either: any child of \na\n is equal to \nb\n or any child of \na\n is an ancestor of \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [8,3,10,1,6,null,14,null,null,4,7,13]\n\nOutput:\n 7\n\nExplanation: \nWe have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,null,0,3]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 5000]\n.\n\n\n0 <= Node.val <= 10\n5",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1022,
    "slug": "sum-of-root-to-leaf-binary-numbers",
    "url": "https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/",
    "titulo": "Sum of Root To Leaf Binary Numbers",
    "enunciado": "You are given the \nroot\n of a binary tree where each node has a value \n0\n or \n1\n. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n\n\n\nFor example, if the path is \n0 -> 1 -> 1 -> 0 -> 1\n, then this could represent \n01101\n in binary, which is \n13\n.\n\n\n\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return \nthe sum of these numbers\n.\n\n\nThe test cases are generated so that the answer fits in a \n32-bits\n integer.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,0,1,0,1,0,1]\n\nOutput:\n 22\n\nExplanation: \n(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\nNode.val\n is \n0\n or \n1\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 1020,
    "slug": "number-of-enclaves",
    "url": "https://leetcode.com/problems/number-of-enclaves/",
    "titulo": "Number of Enclaves",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n, where \n0\n represents a sea cell and \n1\n represents a land cell.\n\n\nA \nmove\n consists of walking from one land cell to another adjacent (\n4-directionally\n) land cell or walking off the boundary of the \ngrid\n.\n\n\nReturn \nthe number of land cells in\n \ngrid\n \nfor which we cannot walk off the boundary of the grid in any number of \nmoves\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n\nOutput:\n 3\n\nExplanation:\n There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n\nOutput:\n 0\n\nExplanation:\n All 1s are either on the boundary or can reach the boundary.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 500\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1019,
    "slug": "next-greater-node-in-linked-list",
    "url": "https://leetcode.com/problems/next-greater-node-in-linked-list/",
    "titulo": "Next Greater Node In Linked List",
    "enunciado": "You are given the \nhead\n of a linked list with \nn\n nodes.\n\n\nFor each node in the list, find the value of the \nnext greater node\n. That is, for each node, find the value of the first node that is next to it and has a \nstrictly larger\n value than it.\n\n\nReturn an integer array \nanswer\n where \nanswer[i]\n is the value of the next greater node of the \ni\nth\n node (\n1-indexed\n). If the \ni\nth\n node does not have a next greater node, set \nanswer[i] = 0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [2,1,5]\n\nOutput:\n [5,5,0]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [2,7,4,3,5]\n\nOutput:\n [7,0,5,5,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= n <= 10\n4\n\n\n1 <= Node.val <= 10\n9",
    "temas": [
      "Array",
      "Linked List",
      "Stack",
      "Monotonic Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1008,
    "slug": "construct-binary-search-tree-from-preorder-traversal",
    "url": "https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/",
    "titulo": "Construct Binary Search Tree from Preorder Traversal",
    "enunciado": "Given an array of integers preorder, which represents the \npreorder traversal\n of a BST (i.e., \nbinary search tree\n), construct the tree and return \nits root\n.\n\n\nIt is \nguaranteed\n that there is always possible to find a binary search tree with the given requirements for the given test cases.\n\n\nA \nbinary search tree\n is a binary tree where for every node, any descendant of \nNode.left\n has a value \nstrictly less than\n \nNode.val\n, and any descendant of \nNode.right\n has a value \nstrictly greater than\n \nNode.val\n.\n\n\nA \npreorder traversal\n of a binary tree displays the value of the node first, then traverses \nNode.left\n, then traverses \nNode.right\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n preorder = [8,5,1,7,10,12]\n\nOutput:\n [8,5,10,1,7,null,12]\n\n\n\nExample 2:\n\n\n\n\nInput:\n preorder = [1,3]\n\nOutput:\n [1,null,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= preorder.length <= 100\n\n\n1 <= preorder[i] <= 1000\n\n\nAll the values of \npreorder\n are \nunique\n.",
    "temas": [
      "Array",
      "Stack",
      "Tree",
      "Binary Search Tree",
      "Monotonic Stack",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1007,
    "slug": "minimum-domino-rotations-for-equal-row",
    "url": "https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/",
    "titulo": "Minimum Domino Rotations For Equal Row",
    "enunciado": "In a row of dominoes, \ntops[i]\n and \nbottoms[i]\n represent the top and bottom halves of the \ni\nth\n domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\n\nWe may rotate the \ni\nth\n domino, so that \ntops[i]\n and \nbottoms[i]\n swap values.\n\n\nReturn the minimum number of rotations so that all the values in \ntops\n are the same, or all the values in \nbottoms\n are the same.\n\n\nIf it cannot be done, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n\nOutput:\n 2\n\nExplanation:\n \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n\n\nExample 2:\n\n\n\n\nInput:\n tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n\nOutput:\n -1\n\nExplanation:\n \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= tops.length <= 2 * 10\n4\n\n\nbottoms.length == tops.length\n\n\n1 <= tops[i], bottoms[i] <= 6",
    "temas": [
      "Array",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1001,
    "slug": "grid-illumination",
    "url": "https://leetcode.com/problems/grid-illumination/",
    "titulo": "Grid Illumination",
    "enunciado": "There is a 2D \ngrid\n of size \nn x n\n where each cell of this grid has a lamp that is initially \nturned off\n.\n\n\nYou are given a 2D array of lamp positions \nlamps\n, where \nlamps[i] = [row\ni\n, col\ni\n]\n indicates that the lamp at \ngrid[row\ni\n][col\ni\n]\n is \nturned on\n. Even if the same lamp is listed more than once, it is turned on.\n\n\nWhen a lamp is turned on, it \nilluminates its cell\n and \nall other cells\n in the same \nrow, column, or diagonal\n.\n\n\nYou are also given another 2D array \nqueries\n, where \nqueries[j] = [row\nj\n, col\nj\n]\n. For the \nj\nth\n query, determine whether \ngrid[row\nj\n][col\nj\n]\n is illuminated or not. After answering the \nj\nth\n query, \nturn off\n the lamp at \ngrid[row\nj\n][col\nj\n]\n and its \n8 adjacent lamps\n if they exist. A lamp is adjacent if its cell shares either a side or corner with \ngrid[row\nj\n][col\nj\n]\n.\n\n\nReturn \nan array of integers \nans\n,\n where \nans[j]\n should be \n1\n if the cell in the \nj\nth\n query was illuminated, or \n0\n if the lamp was not.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\n\nOutput:\n [1,0]\n\nExplanation:\n We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].\nThe 0\nth\n query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.\n\n\nThe 1\nst\n query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\n\nOutput:\n [1,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\n\nOutput:\n [1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n9\n\n\n0 <= lamps.length <= 20000\n\n\n0 <= queries.length <= 20000\n\n\nlamps[i].length == 2\n\n\n0 <= row\ni\n, col\ni\n < n\n\n\nqueries[j].length == 2\n\n\n0 <= row\nj\n, col\nj\n < n",
    "temas": [
      "Array",
      "Hash Table"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 999,
    "slug": "available-captures-for-rook",
    "url": "https://leetcode.com/problems/available-captures-for-rook/",
    "titulo": "Available Captures for Rook",
    "enunciado": "You are given an \n8 x 8\n \nmatrix\n representing a chessboard. There is \nexactly one\n white rook represented by \n'R'\n, some number of white bishops \n'B'\n, and some number of black pawns \n'p'\n. Empty squares are represented by \n'.'\n.\n\n\nA rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece \nor\n the edge of the board. A rook is \nattacking\n a pawn if it can move to the pawn's square in one move.\n\n\nNote: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.\n\n\nReturn the \nnumber of pawns\n the white rook is \nattacking\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n \nboard = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nIn this example, the rook is attacking all the pawns.\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n \nboard = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nThe bishops are blocking the rook from attacking any of the pawns.\n\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n \nboard = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe rook is attacking the pawns at positions b5, d6, and f5.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 8\n\n\nboard[i].length == 8\n\n\nboard[i][j]\n is either \n'R'\n, \n'.'\n, \n'B'\n, or \n'p'\n\n\nThere is exactly one cell with \nboard[i][j] == 'R'",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 998,
    "slug": "maximum-binary-tree-ii",
    "url": "https://leetcode.com/problems/maximum-binary-tree-ii/",
    "titulo": "Maximum Binary Tree II",
    "enunciado": "A \nmaximum tree\n is a tree where every node has a value greater than any other value in its subtree.\n\n\nYou are given the \nroot\n of a maximum binary tree and an integer \nval\n.\n\n\nJust as in the \nprevious problem\n, the given tree was constructed from a list \na\n (\nroot = Construct(a)\n) recursively with the following \nConstruct(a)\n routine:\n\n\n\n\nIf \na\n is empty, return \nnull\n.\n\n\nOtherwise, let \na[i]\n be the largest element of \na\n. Create a \nroot\n node with the value \na[i]\n.\n\n\nThe left child of \nroot\n will be \nConstruct([a[0], a[1], ..., a[i - 1]])\n.\n\n\nThe right child of \nroot\n will be \nConstruct([a[i + 1], a[i + 2], ..., a[a.length - 1]])\n.\n\n\nReturn \nroot\n.\n\n\n\n\nNote that we were not given \na\n directly, only a root node \nroot = Construct(a)\n.\n\n\nSuppose \nb\n is a copy of \na\n with the value \nval\n appended to it. It is guaranteed that \nb\n has unique values.\n\n\nReturn \nConstruct(b)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,1,3,null,null,2], val = 5\n\nOutput:\n [5,4,null,1,3,null,null,2]\n\nExplanation:\n a = [1,4,2,3], b = [1,4,2,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,2,4,null,1], val = 3\n\nOutput:\n [5,2,4,null,1,null,3]\n\nExplanation:\n a = [2,1,5,4], b = [2,1,5,4,3]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [5,2,3,null,1], val = 4\n\nOutput:\n [5,2,4,null,1,3]\n\nExplanation:\n a = [2,1,5,3], b = [2,1,5,3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nAll the values of the tree are \nunique\n.\n\n\n1 <= val <= 100",
    "temas": [
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 994,
    "slug": "rotting-oranges",
    "url": "https://leetcode.com/problems/rotting-oranges/",
    "titulo": "Rotting Oranges",
    "enunciado": "You are given an \nm x n\n \ngrid\n where each cell can have one of three values:\n\n\n\n\n0\n representing an empty cell,\n\n\n1\n representing a fresh orange, or\n\n\n2\n representing a rotten orange.\n\n\n\n\nEvery minute, any fresh orange that is \n4-directionally adjacent\n to a rotten orange becomes rotten.\n\n\nReturn \nthe minimum number of minutes that must elapse until no cell has a fresh orange\n. If \nthis is impossible, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,1,1],[1,1,0],[0,1,1]]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[2,1,1],[0,1,1],[1,0,1]]\n\nOutput:\n -1\n\nExplanation:\n The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[0,2]]\n\nOutput:\n 0\n\nExplanation:\n Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n\n\ngrid[i][j]\n is \n0\n, \n1\n, or \n2\n.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 993,
    "slug": "cousins-in-binary-tree",
    "url": "https://leetcode.com/problems/cousins-in-binary-tree/",
    "titulo": "Cousins in Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree with unique values and the values of two different nodes of the tree \nx\n and \ny\n, return \ntrue\n \nif the nodes corresponding to the values \nx\n and \ny\n in the tree are \ncousins\n, or \nfalse\n otherwise.\n\n\nTwo nodes of a binary tree are \ncousins\n if they have the same depth with different parents.\n\n\nNote that in a binary tree, the root node is at the depth \n0\n, and children of each depth \nk\n node are at the depth \nk + 1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4], x = 4, y = 3\n\nOutput:\n false\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4,null,5], x = 5, y = 4\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4], x = 2, y = 3\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nEach node has a \nunique\n value.\n\n\nx != y\n\n\nx\n and \ny\n are exist in the tree.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 988,
    "slug": "smallest-string-starting-from-leaf",
    "url": "https://leetcode.com/problems/smallest-string-starting-from-leaf/",
    "titulo": "Smallest String Starting From Leaf",
    "enunciado": "You are given the \nroot\n of a binary tree where each node has a value in the range \n[0, 25]\n representing the letters \n'a'\n to \n'z'\n.\n\n\nReturn \nthe \nlexicographically smallest\n string that starts at a leaf of this tree and ends at the root\n.\n\n\nAs a reminder, any shorter prefix of a string is \nlexicographically smaller\n.\n\n\n\n\nFor example, \n\"ab\"\n is lexicographically smaller than \n\"aba\"\n.\n\n\n\n\nA leaf of a node is a node that has no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [0,1,2,3,4,3,4]\n\nOutput:\n \"dba\"\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [25,1,3,1,3,0,2]\n\nOutput:\n \"adz\"\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [2,2,1,null,1,0,null,0]\n\nOutput:\n \"abc\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 8500]\n.\n\n\n0 <= Node.val <= 25",
    "temas": [
      "String",
      "Backtracking",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 987,
    "slug": "vertical-order-traversal-of-a-binary-tree",
    "url": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",
    "titulo": "Vertical Order Traversal of a Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, calculate the \nvertical order traversal\n of the binary tree.\n\n\nFor each node at position \n(row, col)\n, its left and right children will be at positions \n(row + 1, col - 1)\n and \n(row + 1, col + 1)\n respectively. The root of the tree is at \n(0, 0)\n.\n\n\nThe \nvertical order traversal\n of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n\n\nReturn \nthe \nvertical order traversal\n of the binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[9],[3,15],[20],[7]]\n\nExplanation:\n\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7]\n\nOutput:\n [[4],[2],[1,5,6],[3],[7]]\n\nExplanation:\n\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,6,5,7]\n\nOutput:\n [[4],[2],[1,5,6],[3],[7]]\n\nExplanation:\n\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 1000",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Sorting",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 986,
    "slug": "interval-list-intersections",
    "url": "https://leetcode.com/problems/interval-list-intersections/",
    "titulo": "Interval List Intersections",
    "enunciado": "You are given two lists of closed intervals, \nfirstList\n and \nsecondList\n, where \nfirstList[i] = [start\ni\n, end\ni\n]\n and \nsecondList[j] = [start\nj\n, end\nj\n]\n. Each list of intervals is pairwise \ndisjoint\n and in \nsorted order\n.\n\n\nReturn \nthe intersection of these two interval lists\n.\n\n\nA \nclosed interval\n \n[a, b]\n (with \na <= b\n) denotes the set of real numbers \nx\n with \na <= x <= b\n.\n\n\nThe \nintersection\n of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of \n[1, 3]\n and \n[2, 4]\n is \n[2, 3]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n\nOutput:\n [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n firstList = [[1,3],[5,9]], secondList = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= firstList.length, secondList.length <= 1000\n\n\nfirstList.length + secondList.length >= 1\n\n\n0 <= start\ni\n < end\ni\n <= 10\n9\n\n\nend\ni\n < start\ni+1\n\n\n0 <= start\nj\n < end\nj\n <= 10\n9\n \n\n\nend\nj\n < start\nj+1",
    "temas": [
      "Array",
      "Two Pointers",
      "Line Sweep"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 980,
    "slug": "unique-paths-iii",
    "url": "https://leetcode.com/problems/unique-paths-iii/",
    "titulo": "Unique Paths III",
    "enunciado": "You are given an \nm x n\n integer array \ngrid\n where \ngrid[i][j]\n could be:\n\n\n\n\n1\n representing the starting square. There is exactly one starting square.\n\n\n2\n representing the ending square. There is exactly one ending square.\n\n\n0\n representing empty squares we can walk over.\n\n\n-1\n representing obstacles that we cannot walk over.\n\n\n\n\nReturn \nthe number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\n\nOutput:\n 2\n\nExplanation:\n We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\n\nOutput:\n 4\n\nExplanation:\n We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[0,1],[2,0]]\n\nOutput:\n 0\n\nExplanation:\n There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 20\n\n\n1 <= m * n <= 20\n\n\n-1 <= grid[i][j] <= 2\n\n\nThere is exactly one starting cell and one ending cell.",
    "temas": [
      "Array",
      "Backtracking",
      "Bit Manipulation",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 979,
    "slug": "distribute-coins-in-binary-tree",
    "url": "https://leetcode.com/problems/distribute-coins-in-binary-tree/",
    "titulo": "Distribute Coins in Binary Tree",
    "enunciado": "You are given the \nroot\n of a binary tree with \nn\n nodes where each \nnode\n in the tree has \nnode.val\n coins. There are \nn\n coins in total throughout the whole tree.\n\n\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n\n\nReturn \nthe \nminimum\n number of moves required to make every node have \nexactly\n one coin\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,0,0]\n\nOutput:\n 2\n\nExplanation: \nFrom the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [0,3,0]\n\nOutput:\n 3\n\nExplanation: \nFrom the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= n <= 100\n\n\n0 <= Node.val <= n\n\n\nThe sum of all \nNode.val\n is \nn\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 973,
    "slug": "k-closest-points-to-origin",
    "url": "https://leetcode.com/problems/k-closest-points-to-origin/",
    "titulo": "K Closest Points to Origin",
    "enunciado": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane and an integer \nk\n, return the \nk\n closest points to the origin \n(0, 0)\n.\n\n\nThe distance between two points on the \nX-Y\n plane is the Euclidean distance (i.e., \n√(x\n1\n - x\n2\n)\n2\n + (y\n1\n - y\n2\n)\n2\n).\n\n\nYou may return the answer in \nany order\n. The answer is \nguaranteed\n to be \nunique\n (except for the order that it is in).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[-2,2]], k = 1\n\nOutput:\n [[-2,2]]\n\nExplanation:\n\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,3],[5,-1],[-2,4]], k = 2\n\nOutput:\n [[3,3],[-2,4]]\n\nExplanation:\n The answer [[-2,4],[3,3]] would also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= points.length <= 10\n4\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
    "temas": [
      "Array",
      "Math",
      "Divide and Conquer",
      "Geometry",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 971,
    "slug": "flip-binary-tree-to-match-preorder-traversal",
    "url": "https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/",
    "titulo": "Flip Binary Tree To Match Preorder Traversal",
    "enunciado": "You are given the \nroot\n of a binary tree with \nn\n nodes, where each node is uniquely assigned a value from \n1\n to \nn\n. You are also given a sequence of \nn\n values \nvoyage\n, which is the \ndesired\n \npre-order traversal\n of the binary tree.\n\n\nAny node in the binary tree can be \nflipped\n by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\n\n\n\nFlip the \nsmallest\n number of nodes so that the \npre-order traversal\n of the tree \nmatches\n \nvoyage\n.\n\n\nReturn \na list of the values of all \nflipped\n nodes. You may return the answer in \nany order\n. If it is \nimpossible\n to flip the nodes in the tree to make the pre-order traversal match \nvoyage\n, return the list \n[-1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2], voyage = [2,1]\n\nOutput:\n [-1]\n\nExplanation:\n It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3], voyage = [1,3,2]\n\nOutput:\n [1]\n\nExplanation:\n Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3], voyage = [1,2,3]\n\nOutput:\n []\n\nExplanation:\n The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\nn == voyage.length\n\n\n1 <= n <= 100\n\n\n1 <= Node.val, voyage[i] <= n\n\n\nAll the values in the tree are \nunique\n.\n\n\nAll the values in \nvoyage\n are \nunique\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 968,
    "slug": "binary-tree-cameras",
    "url": "https://leetcode.com/problems/binary-tree-cameras/",
    "titulo": "Binary Tree Cameras",
    "enunciado": "You are given the \nroot\n of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\n\nReturn \nthe minimum number of cameras needed to monitor all nodes of the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [0,0,null,0,0]\n\nOutput:\n 1\n\nExplanation:\n One camera is enough to monitor all nodes if placed as shown.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [0,0,null,0,null,0,null,null,0]\n\nOutput:\n 2\n\nExplanation:\n At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\nNode.val == 0",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 965,
    "slug": "univalued-binary-tree",
    "url": "https://leetcode.com/problems/univalued-binary-tree/",
    "titulo": "Univalued Binary Tree",
    "enunciado": "A binary tree is \nuni-valued\n if every node in the tree has the same value.\n\n\nGiven the \nroot\n of a binary tree, return \ntrue\n if the given tree is \nuni-valued\n, or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,1,1,1,1,null,1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,2,2,5,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n0 <= Node.val < 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 963,
    "slug": "minimum-area-rectangle-ii",
    "url": "https://leetcode.com/problems/minimum-area-rectangle-ii/",
    "titulo": "Minimum Area Rectangle II",
    "enunciado": "You are given an array of points in the \nX-Y\n plane \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nReturn \nthe minimum area of any rectangle formed from these points, with sides \nnot necessarily parallel\n to the X and Y axes\n. If there is not any such rectangle, return \n0\n.\n\n\nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,2],[2,1],[1,0],[0,1]]\n\nOutput:\n 2.00000\n\nExplanation:\n The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[0,1],[2,1],[1,1],[1,0],[2,0]]\n\nOutput:\n 1.00000\n\nExplanation:\n The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n points = [[0,3],[1,2],[3,1],[1,3],[2,1]]\n\nOutput:\n 0\n\nExplanation:\n There is no possible rectangle to form from these points.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 50\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 4 * 10\n4\n\n\nAll the given points are \nunique\n.",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 959,
    "slug": "regions-cut-by-slashes",
    "url": "https://leetcode.com/problems/regions-cut-by-slashes/",
    "titulo": "Regions Cut By Slashes",
    "enunciado": "An \nn x n\n grid is composed of \n1 x 1\n squares where each \n1 x 1\n square consists of a \n'/'\n, \n'\\'\n, or blank space \n' '\n. These characters divide the square into contiguous regions.\n\n\nGiven the grid \ngrid\n represented as a string array, return \nthe number of regions\n.\n\n\nNote that backslash characters are escaped, so a \n'\\'\n is represented as \n'\\\\'\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [\" /\",\"/ \"]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [\" /\",\"  \"]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [\"/\\\\\",\"\\\\/\"]\n\nOutput:\n 5\n\nExplanation: \nRecall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 30\n\n\ngrid[i][j]\n is either \n'/'\n, \n'\\'\n, or \n' '\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 958,
    "slug": "check-completeness-of-a-binary-tree",
    "url": "https://leetcode.com/problems/check-completeness-of-a-binary-tree/",
    "titulo": "Check Completeness of a Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, determine if it is a \ncomplete binary tree\n.\n\n\nIn a \ncomplete binary tree\n, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between \n1\n and \n2\nh\n nodes inclusive at the last level \nh\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6]\n\nOutput:\n true\n\nExplanation:\n Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,null,7]\n\nOutput:\n false\n\nExplanation:\n The node with value 7 isn't as far left as possible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n1 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 952,
    "slug": "largest-component-size-by-common-factor",
    "url": "https://leetcode.com/problems/largest-component-size-by-common-factor/",
    "titulo": "Largest Component Size by Common Factor",
    "enunciado": "You are given an integer array of unique positive integers \nnums\n. Consider the following graph:\n\n\n\n\nThere are \nnums.length\n nodes, labeled \nnums[0]\n to \nnums[nums.length - 1]\n,\n\n\nThere is an undirected edge between \nnums[i]\n and \nnums[j]\n if \nnums[i]\n and \nnums[j]\n share a common factor greater than \n1\n.\n\n\n\n\nReturn \nthe size of the largest connected component in the graph\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [4,6,15,35]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [20,50,9,63]\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n nums = [2,3,6,7,4,12,21,39]\n\nOutput:\n 8\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n1 <= nums[i] <= 10\n5\n\n\nAll the values of \nnums\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Union Find",
      "Number Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 951,
    "slug": "flip-equivalent-binary-trees",
    "url": "https://leetcode.com/problems/flip-equivalent-binary-trees/",
    "titulo": "Flip Equivalent Binary Trees",
    "enunciado": "For a binary tree \nT\n, we can define a \nflip operation\n as follows: choose any node, and swap the left and right child subtrees.\n\n\nA binary tree \nX\n is \nflip equivalent\n to a binary tree \nY\n if and only if we can make \nX\n equal to \nY\n after some number of flip operations.\n\n\nGiven the roots of two binary trees \nroot1\n and \nroot2\n, return \ntrue\n if the two trees are flip equivalent or \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n\nOutput:\n true\n\nExplanation: \nWe flipped at nodes with values 1, 3, and 5.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root1 = [], root2 = []\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n root1 = [], root2 = [1]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each tree is in the range \n[0, 100]\n.\n\n\nEach tree will have \nunique node values\n in the range \n[0, 99]\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 941,
    "slug": "valid-mountain-array",
    "url": "https://leetcode.com/problems/valid-mountain-array/",
    "titulo": "Valid Mountain Array",
    "enunciado": "Given an array of integers \narr\n, return \ntrue\n if and only if it is a valid mountain array\n.\n\n\nRecall that arr is a mountain array if and only if:\n\n\n\n\narr.length >= 3\n\n\nThere exists some \ni\n with \n0 < i < arr.length - 1\n such that:\n\t\n\n\narr[0] < arr[1] < ... < arr[i - 1] < arr[i] \n\n\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\n\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n arr = [2,1]\n\nOutput:\n false\n\nExample 2:\n\n\nInput:\n arr = [3,5,5]\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n arr = [0,3,2,1]\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 10\n4\n\n\n0 <= arr[i] <= 10\n4",
    "temas": [
      "Array"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 939,
    "slug": "minimum-area-rectangle",
    "url": "https://leetcode.com/problems/minimum-area-rectangle/",
    "titulo": "Minimum Area Rectangle",
    "enunciado": "You are given an array of points in the \nX-Y\n plane \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nReturn \nthe minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes\n. If there is not any such rectangle, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,1],[1,3],[3,1],[3,3],[2,2]]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 500\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 4 * 10\n4\n\n\nAll the given points are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 938,
    "slug": "range-sum-of-bst",
    "url": "https://leetcode.com/problems/range-sum-of-bst/",
    "titulo": "Range Sum of BST",
    "enunciado": "Given the \nroot\n node of a binary search tree and two integers \nlow\n and \nhigh\n, return \nthe sum of values of all nodes with a value in the \ninclusive\n range \n[low, high]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,null,18], low = 7, high = 15\n\nOutput:\n 32\n\nExplanation:\n Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n\nOutput:\n 23\n\nExplanation:\n Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n1 <= low <= high <= 10\n5\n\n\nAll \nNode.val\n are \nunique\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 935,
    "slug": "knight-dialer",
    "url": "https://leetcode.com/problems/knight-dialer/",
    "titulo": "Knight Dialer",
    "enunciado": "The chess knight has a \nunique movement\n, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an \nL\n). The possible movements of chess knight are shown in this diagram:\n\n\nA chess knight can move as indicated in the chess diagram below:\n\n\n\n\nWe have a chess knight and a phone pad as shown below, the knight \ncan only stand on a numeric cell\n (i.e. blue cell).\n\n\n\n\nGiven an integer \nn\n, return how many distinct phone numbers of length \nn\n we can dial.\n\n\nYou are allowed to place the knight \non any numeric cell\n initially and then you should perform \nn - 1\n jumps to dial a number of length \nn\n. All jumps should be \nvalid\n knight jumps.\n\n\nAs the answer may be very large, \nreturn the answer modulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 10\n\nExplanation:\n We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 20\n\nExplanation:\n All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3131\n\nOutput:\n 136006598\n\nExplanation:\n Please take care of the mod.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 5000",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 931,
    "slug": "minimum-falling-path-sum",
    "url": "https://leetcode.com/problems/minimum-falling-path-sum/",
    "titulo": "Minimum Falling Path Sum",
    "enunciado": "Given an \nn x n\n array of integers \nmatrix\n, return \nthe \nminimum sum\n of any \nfalling path\n through\n \nmatrix\n.\n\n\nA \nfalling path\n starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position \n(row, col)\n will be \n(row + 1, col - 1)\n, \n(row + 1, col)\n, or \n(row + 1, col + 1)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[2,1,3],[6,5,4],[7,8,9]]\n\nOutput:\n 13\n\nExplanation:\n There are two falling paths with a minimum sum as shown.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[-19,57],[-40,-5]]\n\nOutput:\n -59\n\nExplanation:\n The falling path with a minimum sum is shown.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 100\n\n\n-100 <= matrix[i][j] <= 100",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 919,
    "slug": "complete-binary-tree-inserter",
    "url": "https://leetcode.com/problems/complete-binary-tree-inserter/",
    "titulo": "Complete Binary Tree Inserter",
    "enunciado": "A \ncomplete binary tree\n is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\n\n\nDesign an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\n\n\nImplement the \nCBTInserter\n class:\n\n\n\n\nCBTInserter(TreeNode root)\n Initializes the data structure with the \nroot\n of the complete binary tree.\n\n\nint insert(int v)\n Inserts a \nTreeNode\n into the tree with value \nNode.val == val\n so that the tree remains complete, and returns the value of the parent of the inserted \nTreeNode\n.\n\n\nTreeNode get_root()\n Returns the root node of the tree.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\n\nOutput\n\n[null, 1, 2, [1, 2, 3, 4]]\n\n\nExplanation\n\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3);  // return 1\ncBTInserter.insert(4);  // return 2\ncBTInserter.get_root(); // return [1, 2, 3, 4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree will be in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 5000\n\n\nroot\n is a complete binary tree.\n\n\n0 <= val <= 5000\n\n\nAt most \n10\n4\n calls will be made to \ninsert\n and \nget_root\n.",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Design",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 913,
    "slug": "cat-and-mouse",
    "url": "https://leetcode.com/problems/cat-and-mouse/",
    "titulo": "Cat and Mouse",
    "enunciado": "A game on an \nundirected\n graph is played by two players, Mouse and Cat, who alternate turns.\n\n\nThe graph is given as follows: \ngraph[a]\n is a list of all nodes \nb\n such that \nab\n is an edge of the graph.\n\n\nThe mouse starts at node \n1\n and goes first, the cat starts at node \n2\n and goes second, and there is a hole at node \n0\n.\n\n\nDuring each player's turn, they \nmust\n travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it \nmust\n travel to any node in \ngraph[1]\n.\n\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node \n0\n).\n\n\nThen, the game can end in three ways:\n\n\n\n\nIf ever the Cat occupies the same node as the Mouse, the Cat wins.\n\n\nIf ever the Mouse reaches the Hole, the Mouse wins.\n\n\nIf ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\n\n\n\nGiven a \ngraph\n, and assuming both players play optimally, return\n\n\n\n\n1\n if the mouse wins the game,\n\n\n2\n if the cat wins the game, or\n\n\n0\n if the game is a draw.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n\nOutput:\n 0\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[1,3],[0],[3],[0,2]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= graph.length <= 50\n\n\n1 <= graph[i].length < graph.length\n\n\n0 <= graph[i][j] < graph.length\n\n\ngraph[i][j] != i\n\n\ngraph[i]\n is unique.\n\n\nThe mouse and the cat can always move.",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Game Theory"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 909,
    "slug": "snakes-and-ladders",
    "url": "https://leetcode.com/problems/snakes-and-ladders/",
    "titulo": "Snakes and Ladders",
    "enunciado": "You are given an \nn x n\n integer matrix \nboard\n where the cells are labeled from \n1\n to \nn\n2\n in a \nBoustrophedon style\n starting from the bottom left of the board (i.e. \nboard[n - 1][0]\n) and alternating direction each row.\n\n\nYou start on square \n1\n of the board. In each move, starting from square \ncurr\n, do the following:\n\n\n\n\nChoose a destination square \nnext\n with a label in the range \n[curr + 1, min(curr + 6, n\n2\n)]\n.\n\n\t\n\n\nThis choice simulates the result of a standard \n6-sided die roll\n: i.e., there are always at most 6 destinations, regardless of the size of the board.\n\n\n\n\n\n\nIf \nnext\n has a snake or ladder, you \nmust\n move to the destination of that snake or ladder. Otherwise, you move to \nnext\n.\n\n\nThe game ends when you reach the square \nn\n2\n.\n\n\n\n\nA board square on row \nr\n and column \nc\n has a snake or ladder if \nboard[r][c] != -1\n. The destination of that snake or ladder is \nboard[r][c]\n. Squares \n1\n and \nn\n2\n are not the starting points of any snake or ladder.\n\n\nNote that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do \nnot\n follow the subsequent snake or ladder.\n\n\n\n\nFor example, suppose the board is \n[[-1,4],[-1,3]]\n, and on the first move, your destination square is \n2\n. You follow the ladder to square \n3\n, but do \nnot\n follow the subsequent ladder to \n4\n.\n\n\n\n\nReturn \nthe least number of dice rolls required to reach the square \nn\n2\n. If it is not possible to reach the square, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n\nOutput:\n 4\n\nExplanation:\n \nIn the beginning, you start at square 1 (at row 5, column 0).\nYou decide to move to square 2 and must take the ladder to square 15.\nYou then decide to move to square 17 and must take the snake to square 13.\nYou then decide to move to square 14 and must take the ladder to square 35.\nYou then decide to move to square 36, ending the game.\nThis is the lowest possible number of moves to reach the last square, so return 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = [[-1,-1],[-1,3]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == board.length == board[i].length\n\n\n2 <= n <= 20\n\n\nboard[i][j]\n is either \n-1\n or in the range \n[1, n\n2\n]\n.\n\n\nThe squares labeled \n1\n and \nn\n2\n are not the starting points of any snake or ladder.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 897,
    "slug": "increasing-order-search-tree",
    "url": "https://leetcode.com/problems/increasing-order-search-tree/",
    "titulo": "Increasing Order Search Tree",
    "enunciado": "Given the \nroot\n of a binary search tree, rearrange the tree in \nin-order\n so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n\nOutput:\n [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,1,7]\n\nOutput:\n [1,null,5,null,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the given tree will be in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 1000",
    "temas": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 894,
    "slug": "all-possible-full-binary-trees",
    "url": "https://leetcode.com/problems/all-possible-full-binary-trees/",
    "titulo": "All Possible Full Binary Trees",
    "enunciado": "Given an integer \nn\n, return \na list of all possible \nfull binary trees\n with\n \nn\n \nnodes\n. Each node of each tree in the answer must have \nNode.val == 0\n.\n\n\nEach element of the answer is the root node of one possible tree. You may return the final list of trees in \nany order\n.\n\n\nA \nfull binary tree\n is a binary tree where each node has exactly \n0\n or \n2\n children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7\n\nOutput:\n [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n [[0,0,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 20",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Recursion",
      "Memoization",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 892,
    "slug": "surface-area-of-3d-shapes",
    "url": "https://leetcode.com/problems/surface-area-of-3d-shapes/",
    "titulo": "Surface Area of 3D Shapes",
    "enunciado": "You are given an \nn x n\n \ngrid\n where you have placed some \n1 x 1 x 1\n cubes. Each value \nv = grid[i][j]\n represents a tower of \nv\n cubes placed on top of cell \n(i, j)\n.\n\n\nAfter placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.\n\n\nReturn \nthe total surface area of the resulting shapes\n.\n\n\nNote:\n The bottom face of each shape counts toward its surface area.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2],[3,4]]\n\nOutput:\n 34\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n 32\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[2,2,2],[2,1,2],[2,2,2]]\n\nOutput:\n 46\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] <= 50",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 889,
    "slug": "construct-binary-tree-from-preorder-and-postorder-traversal",
    "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",
    "titulo": "Construct Binary Tree from Preorder and Postorder Traversal",
    "enunciado": "Given two integer arrays, \npreorder\n and \npostorder\n where \npreorder\n is the preorder traversal of a binary tree of \ndistinct\n values and \npostorder\n is the postorder traversal of the same tree, reconstruct and return \nthe binary tree\n.\n\n\nIf there exist multiple answers, you can \nreturn any\n of them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n\nOutput:\n [1,2,3,4,5,6,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n preorder = [1], postorder = [1]\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= preorder.length <= 30\n\n\n1 <= preorder[i] <= preorder.length\n\n\nAll the values of \npreorder\n are \nunique\n.\n\n\npostorder.length == preorder.length\n\n\n1 <= postorder[i] <= postorder.length\n\n\nAll the values of \npostorder\n are \nunique\n.\n\n\nIt is guaranteed that \npreorder\n and \npostorder\n are the preorder traversal and postorder traversal of the same binary tree.",
    "temas": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 885,
    "slug": "spiral-matrix-iii",
    "url": "https://leetcode.com/problems/spiral-matrix-iii/",
    "titulo": "Spiral Matrix III",
    "enunciado": "You start at the cell \n(rStart, cStart)\n of an \nrows x cols\n grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\n\n\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all \nrows * cols\n spaces of the grid.\n\n\nReturn \nan array of coordinates representing the positions of the grid in the order you visited them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n rows = 1, cols = 4, rStart = 0, cStart = 0\n\nOutput:\n [[0,0],[0,1],[0,2],[0,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n rows = 5, cols = 6, rStart = 1, cStart = 4\n\nOutput:\n [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rows, cols <= 100\n\n\n0 <= rStart < rows\n\n\n0 <= cStart < cols",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 883,
    "slug": "projection-area-of-3d-shapes",
    "url": "https://leetcode.com/problems/projection-area-of-3d-shapes/",
    "titulo": "Projection Area of 3D Shapes",
    "enunciado": "You are given an \nn x n\n \ngrid\n where we place some \n1 x 1 x 1\n cubes that are axis-aligned with the \nx\n, \ny\n, and \nz\n axes.\n\n\nEach value \nv = grid[i][j]\n represents a tower of \nv\n cubes placed on top of the cell \n(i, j)\n.\n\n\nWe view the projection of these cubes onto the \nxy\n, \nyz\n, and \nzx\n planes.\n\n\nA \nprojection\n is like a shadow, that maps our \n3-dimensional\n figure to a \n2-dimensional\n plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n\n\nReturn \nthe total area of all three projections\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,2],[3,4]]\n\nOutput:\n 17\n\nExplanation:\n Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[2]]\n\nOutput:\n 5\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0],[0,2]]\n\nOutput:\n 8\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] <= 50",
    "temas": [
      "Array",
      "Math",
      "Geometry",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 882,
    "slug": "reachable-nodes-in-subdivided-graph",
    "url": "https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/",
    "titulo": "Reachable Nodes In Subdivided Graph",
    "enunciado": "You are given an undirected graph (the \n\"original graph\"\n) with \nn\n nodes labeled from \n0\n to \nn - 1\n. You decide to \nsubdivide\n each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n\n\nThe graph is given as a 2D array of \nedges\n where \nedges[i] = [u\ni\n, v\ni\n, cnt\ni\n]\n indicates that there is an edge between nodes \nu\ni\n and \nv\ni\n in the original graph, and \ncnt\ni\n is the total number of new nodes that you will \nsubdivide\n the edge into. Note that \ncnt\ni\n == 0\n means you will not subdivide the edge.\n\n\nTo \nsubdivide\n the edge \n[u\ni\n, v\ni\n]\n, replace it with \n(cnt\ni\n + 1)\n new edges and \ncnt\ni\n new nodes. The new nodes are \nx\n1\n, \nx\n2\n, ..., \nx\ncnt\ni\n, and the new edges are \n[u\ni\n, x\n1\n]\n, \n[x\n1\n, x\n2\n]\n, \n[x\n2\n, x\n3\n]\n, ..., \n[x\ncnt\ni\n-1\n, x\ncnt\ni\n]\n, \n[x\ncnt\ni\n, v\ni\n]\n.\n\n\nIn this \nnew graph\n, you want to know how many nodes are \nreachable\n from the node \n0\n, where a node is \nreachable\n if the distance is \nmaxMoves\n or less.\n\n\nGiven the original graph and \nmaxMoves\n, return \nthe number of nodes that are \nreachable\n from node \n0\n in the new graph\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\n\nOutput:\n 13\n\nExplanation:\n The edge subdivisions are shown in the image above.\nThe nodes that are reachable are highlighted in yellow.\n\n\n\nExample 2:\n\n\n\n\nInput:\n edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\n\nOutput:\n 23\n\n\n\nExample 3:\n\n\n\n\nInput:\n edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\n\nOutput:\n 1\n\nExplanation:\n Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= edges.length <= min(n * (n - 1) / 2, 10\n4\n)\n\n\nedges[i].length == 3\n\n\n0 <= u\ni\n < v\ni\n < n\n\n\nThere are \nno multiple edges\n in the graph.\n\n\n0 <= cnt\ni\n <= 10\n4\n\n\n0 <= maxMoves <= 10\n9\n\n\n1 <= n <= 3000",
    "temas": [
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Graph",
    "has_image": true
  },
  {
    "id": 497,
    "slug": "random-point-in-non-overlapping-rectangles",
    "url": "https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/",
    "titulo": "Random Point in Non-overlapping Rectangles",
    "enunciado": "You are given an array of non-overlapping axis-aligned rectangles \nrects\n where \nrects[i] = [a\ni\n, b\ni\n, x\ni\n, y\ni\n]\n indicates that \n(a\ni\n, b\ni\n)\n is the bottom-left corner point of the \ni\nth\n rectangle and \n(x\ni\n, y\ni\n)\n is the top-right corner point of the \ni\nth\n rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.\n\n\nAny integer point inside the space covered by one of the given rectangles should be equally likely to be returned.\n\n\nNote\n that an integer point is a point that has integer coordinates.\n\n\nImplement the \nSolution\n class:\n\n\n\n\nSolution(int[][] rects)\n Initializes the object with the given rectangles \nrects\n.\n\n\nint[] pick()\n Returns a random integer point \n[u, v]\n inside the space covered by one of the given rectangles.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\n\nOutput\n\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\n\nExplanation\n\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // return [1, -2]\nsolution.pick(); // return [1, -1]\nsolution.pick(); // return [-1, -2]\nsolution.pick(); // return [-2, -2]\nsolution.pick(); // return [0, 0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rects.length <= 100\n\n\nrects[i].length == 4\n\n\n-10\n9\n <= a\ni\n < x\ni\n <= 10\n9\n\n\n-10\n9\n <= b\ni\n < y\ni\n <= 10\n9\n\n\nx\ni\n - a\ni\n <= 2000\n\n\ny\ni\n - b\ni\n <= 2000\n\n\nAll the rectangles do not overlap.\n\n\nAt most \n10\n4\n calls will be made to \npick\n.",
    "temas": [
      "Array",
      "Math",
      "Binary Search",
      "Reservoir Sampling",
      "Prefix Sum",
      "Ordered Set",
      "Randomized"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 876,
    "slug": "middle-of-the-linked-list",
    "url": "https://leetcode.com/problems/middle-of-the-linked-list/",
    "titulo": "Middle of the Linked List",
    "enunciado": "Given the \nhead\n of a singly linked list, return \nthe middle node of the linked list\n.\n\n\nIf there are two middle nodes, return \nthe second middle\n node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [3,4,5]\n\nExplanation:\n The middle node of the list is node 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6]\n\nOutput:\n [4,5,6]\n\nExplanation:\n Since the list has two middle nodes with values 3 and 4, we return the second one.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 100]\n.\n\n\n1 <= Node.val <= 100",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 872,
    "slug": "leaf-similar-trees",
    "url": "https://leetcode.com/problems/leaf-similar-trees/",
    "titulo": "Leaf-Similar Trees",
    "enunciado": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a \nleaf value sequence\n.\n\n\n\n\nFor example, in the given tree above, the leaf value sequence is \n(6, 7, 4, 9, 8)\n.\n\n\nTwo binary trees are considered \nleaf-similar\n if their leaf value sequence is the same.\n\n\nReturn \ntrue\n if and only if the two given trees with head nodes \nroot1\n and \nroot2\n are leaf-similar.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root1 = [1,2,3], root2 = [1,3,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each tree will be in the range \n[1, 200]\n.\n\n\nBoth of the given trees will have values in the range \n[0, 200]\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 867,
    "slug": "transpose-matrix",
    "url": "https://leetcode.com/problems/transpose-matrix/",
    "titulo": "Transpose Matrix",
    "enunciado": "Given a 2D integer array \nmatrix\n, return \nthe \ntranspose\n of\n \nmatrix\n.\n\n\nThe \ntranspose\n of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[1,4,7],[2,5,8],[3,6,9]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6]]\n\nOutput:\n [[1,4],[2,5],[3,6]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 1000\n\n\n1 <= m * n <= 10\n5\n\n\n-10\n9\n <= matrix[i][j] <= 10\n9",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 865,
    "slug": "smallest-subtree-with-all-the-deepest-nodes",
    "url": "https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/",
    "titulo": "Smallest Subtree with all the Deepest Nodes",
    "enunciado": "Given the \nroot\n of a binary tree, the depth of each node is \nthe shortest distance to the root\n.\n\n\nReturn \nthe smallest subtree\n such that it contains \nall the deepest nodes\n in the original tree.\n\n\nA node is called \nthe deepest\n if it has the largest depth possible among any node in the entire tree.\n\n\nThe \nsubtree\n of a node is a tree consisting of that node, plus the set of all descendants of that node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4]\n\nOutput:\n [2,7,4]\n\nExplanation:\n We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest nodes of the tree.\nNotice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [1]\n\nExplanation:\n The root is the deepest node in the tree.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [0,1,3,null,2]\n\nOutput:\n [2]\n\nExplanation:\n The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree will be in the range \n[1, 500]\n.\n\n\n0 <= Node.val <= 500\n\n\nThe values of the nodes in the tree are \nunique\n.\n\n\n\n\n \n\n\nNote:\n This question is the same as 1123: \nhttps://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 864,
    "slug": "shortest-path-to-get-all-keys",
    "url": "https://leetcode.com/problems/shortest-path-to-get-all-keys/",
    "titulo": "Shortest Path to Get All Keys",
    "enunciado": "You are given an \nm x n\n grid \ngrid\n where:\n\n\n\n\n'.'\n is an empty cell.\n\n\n'#'\n is a wall.\n\n\n'@'\n is the starting point.\n\n\nLowercase letters represent keys.\n\n\nUppercase letters represent locks.\n\n\n\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\n\nFor some \n1 <= k <= 6\n, there is exactly one lowercase and one uppercase letter of the first \nk\n letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\n\nReturn \nthe lowest number of moves to acquire all keys\n. If it is impossible, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\n\nOutput:\n 8\n\nExplanation:\n Note that the goal is to obtain all the keys not to open all the locks.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [\"@..aA\",\"..B#.\",\"....b\"]\n\nOutput:\n 6\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [\"@Aa\"]\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 30\n\n\ngrid[i][j]\n is either an English letter, \n'.'\n, \n'#'\n, or \n'@'\n. \n\n\nThere is exactly one \n'@'\n in the grid.\n\n\nThe number of keys in the grid is in the range \n[1, 6]\n.\n\n\nEach key in the grid is \nunique\n.\n\n\nEach key in the grid has a matching lock.",
    "temas": [
      "Array",
      "Bit Manipulation",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 863,
    "slug": "all-nodes-distance-k-in-binary-tree",
    "url": "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/",
    "titulo": "All Nodes Distance K in Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, the value of a target node \ntarget\n, and an integer \nk\n, return \nan array of the values of all nodes that have a distance \nk\n from the target node.\n\n\nYou can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n\nOutput:\n [7,4,1]\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1], target = 1, k = 3\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 500]\n.\n\n\n0 <= Node.val <= 500\n\n\nAll the values \nNode.val\n are \nunique\n.\n\n\ntarget\n is the value of one of the nodes in the tree.\n\n\n0 <= k <= 1000",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 861,
    "slug": "score-after-flipping-matrix",
    "url": "https://leetcode.com/problems/score-after-flipping-matrix/",
    "titulo": "Score After Flipping Matrix",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n.\n\n\nA \nmove\n consists of choosing any row or column and toggling each value in that row or column (i.e., changing all \n0\n's to \n1\n's, and all \n1\n's to \n0\n's).\n\n\nEvery row of the matrix is interpreted as a binary number, and the \nscore\n of the matrix is the sum of these numbers.\n\n\nReturn \nthe highest possible \nscore\n after making any number of \nmoves\n (including zero moves)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n\nOutput:\n 39\n\nExplanation:\n 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 20\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Greedy",
      "Bit Manipulation",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 858,
    "slug": "mirror-reflection",
    "url": "https://leetcode.com/problems/mirror-reflection/",
    "titulo": "Mirror Reflection",
    "enunciado": "There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered \n0\n, \n1\n, and \n2\n.\n\n\nThe square room has walls of length \np\n and a laser ray from the southwest corner first meets the east wall at a distance \nq\n from the \n0\nth\n receptor.\n\n\nGiven the two integers \np\n and \nq\n, return \nthe number of the receptor that the ray meets first\n.\n\n\nThe test cases are guaranteed so that the ray will meet a receptor eventually.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n p = 2, q = 1\n\nOutput:\n 2\n\nExplanation:\n The ray meets receptor 2 the first time it gets reflected back to the left wall.\n\n\n\nExample 2:\n\n\n\n\nInput:\n p = 3, q = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= q <= p <= 1000",
    "temas": [
      "Math",
      "Geometry",
      "Number Theory"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 850,
    "slug": "rectangle-area-ii",
    "url": "https://leetcode.com/problems/rectangle-area-ii/",
    "titulo": "Rectangle Area II",
    "enunciado": "You are given a 2D array of axis-aligned \nrectangles\n. Each \nrectangle[i] = [x\ni1\n, y\ni1\n, x\ni2\n, y\ni2\n]\n denotes the \ni\nth\n rectangle where \n(x\ni1\n, y\ni1\n)\n are the coordinates of the \nbottom-left corner\n, and \n(x\ni2\n, y\ni2\n)\n are the coordinates of the \ntop-right corner\n.\n\n\nCalculate the \ntotal area\n covered by all \nrectangles\n in the plane. Any area covered by two or more rectangles should only be counted \nonce\n.\n\n\nReturn \nthe \ntotal area\n. Since the answer may be too large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n\nOutput:\n 6\n\nExplanation:\n A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap.\n\n\n\nExample 2:\n\n\n\n\nInput:\n rectangles = [[0,0,1000000000,1000000000]]\n\nOutput:\n 49\n\nExplanation:\n The answer is 10\n18\n modulo (10\n9\n + 7), which is 49.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rectangles.length <= 200\n\n\nrectanges[i].length == 4\n\n\n0 <= x\ni1\n, y\ni1\n, x\ni2\n, y\ni2\n <= 10\n9\n\n\nx\ni1 <= \nx\ni2\n\n\ny\ni1 <=\n y\ni2\n\n\nAll rectangles have non zero area.",
    "temas": [
      "Array",
      "Segment Tree",
      "Line Sweep",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 849,
    "slug": "maximize-distance-to-closest-person",
    "url": "https://leetcode.com/problems/maximize-distance-to-closest-person/",
    "titulo": "Maximize Distance to Closest Person",
    "enunciado": "You are given an array representing a row of \nseats\n where \nseats[i] = 1\n represents a person sitting in the \ni\nth\n seat, and \nseats[i] = 0\n represents that the \ni\nth\n seat is empty \n(0-indexed)\n.\n\n\nThere is at least one empty seat, and at least one person sitting.\n\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized. \n\n\nReturn \nthat maximum distance to the closest person\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n seats = [1,0,0,0,1,0,1]\n\nOutput:\n 2\n\nExplanation: \n\nIf Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n seats = [1,0,0,0]\n\nOutput:\n 3\n\nExplanation: \n\nIf Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n seats = [0,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= seats.length <= 2 * 10\n4\n\n\nseats[i]\n is \n0\n or \n1\n.\n\n\nAt least one seat is \nempty\n.\n\n\nAt least one seat is \noccupied\n.",
    "temas": [
      "Array"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 847,
    "slug": "shortest-path-visiting-all-nodes",
    "url": "https://leetcode.com/problems/shortest-path-visiting-all-nodes/",
    "titulo": "Shortest Path Visiting All Nodes",
    "enunciado": "You have an undirected, connected graph of \nn\n nodes labeled from \n0\n to \nn - 1\n. You are given an array \ngraph\n where \ngraph[i]\n is a list of all the nodes connected with node \ni\n by an edge.\n\n\nReturn \nthe length of the shortest path that visits every node\n. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2,3],[0],[0],[0]]\n\nOutput:\n 4\n\nExplanation:\n One possible path is [1,0,2,0,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\n\nOutput:\n 4\n\nExplanation:\n One possible path is [0,1,4,2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n1 <= n <= 12\n\n\n0 <= graph[i].length < n\n\n\ngraph[i]\n does not contain \ni\n.\n\n\nIf \ngraph[a]\n contains \nb\n, then \ngraph[b]\n contains \na\n.\n\n\nThe input graph is always connected.",
    "temas": [
      "Dynamic Programming",
      "Bit Manipulation",
      "Breadth-First Search",
      "Graph",
      "Bitmask"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 840,
    "slug": "magic-squares-in-grid",
    "url": "https://leetcode.com/problems/magic-squares-in-grid/",
    "titulo": "Magic Squares In Grid",
    "enunciado": "A \n3 x 3\n \nmagic square\n is a \n3 x 3\n grid filled with distinct numbers \nfrom \n1\n to \n9 such that each row, column, and both diagonals all have the same sum.\n\n\nGiven a \nrow x col\n \ngrid\n of integers, how many \n3 x 3\n magic square subgrids are there?\n\n\nNote: while a magic square can only contain numbers from 1 to 9, \ngrid\n may contain numbers up to 15.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\n\nOutput:\n 1\n\nExplanation: \n\nThe following subgrid is a 3 x 3 magic square:\n\n\nwhile this one is not:\n\n\nIn total, there is only one magic square inside the given grid.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[8]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrow == grid.length\n\n\ncol == grid[i].length\n\n\n1 <= row, col <= 10\n\n\n0 <= grid[i][j] <= 15",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 838,
    "slug": "push-dominoes",
    "url": "https://leetcode.com/problems/push-dominoes/",
    "titulo": "Push Dominoes",
    "enunciado": "There are \nn\n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n\n\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n\n\nYou are given a string \ndominoes\n representing the initial state where:\n\n\n\n\ndominoes[i] = 'L'\n, if the \ni\nth\n domino has been pushed to the left,\n\n\ndominoes[i] = 'R'\n, if the \ni\nth\n domino has been pushed to the right, and\n\n\ndominoes[i] = '.'\n, if the \ni\nth\n domino has not been pushed.\n\n\n\n\nReturn \na string representing the final state\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n dominoes = \"RR.L\"\n\nOutput:\n \"RR.L\"\n\nExplanation:\n The first domino expends no additional force on the second domino.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n dominoes = \".L.R...LR..L..\"\n\nOutput:\n \"LL.RR.LLRRLL..\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == dominoes.length\n\n\n1 <= n <= 10\n5\n\n\ndominoes[i]\n is either \n'L'\n, \n'R'\n, or \n'.'\n.",
    "temas": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Two Pointers",
    "has_image": true
  },
  {
    "id": 835,
    "slug": "image-overlap",
    "url": "https://leetcode.com/problems/image-overlap/",
    "titulo": "Image Overlap",
    "enunciado": "You are given two images, \nimg1\n and \nimg2\n, represented as binary, square matrices of size \nn x n\n. A binary matrix has only \n0\ns and \n1\ns as values.\n\n\nWe \ntranslate\n one image however we choose by sliding all the \n1\n bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the \noverlap\n by counting the number of positions that have a \n1\n in \nboth\n images.\n\n\nNote also that a translation does \nnot\n include any kind of rotation. Any \n1\n bits that are translated outside of the matrix borders are erased.\n\n\nReturn \nthe largest possible overlap\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n\nOutput:\n 3\n\nExplanation:\n We translate img1 to right by 1 unit and down by 1 unit.\n\n\nThe number of positions that have a 1 in both images is 3 (shown in red).\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n img1 = [[1]], img2 = [[1]]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n img1 = [[0]], img2 = [[0]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == img1.length == img1[i].length\n\n\nn == img2.length == img2[i].length\n\n\n1 <= n <= 30\n\n\nimg1[i][j]\n is either \n0\n or \n1\n.\n\n\nimg2[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 834,
    "slug": "sum-of-distances-in-tree",
    "url": "https://leetcode.com/problems/sum-of-distances-in-tree/",
    "titulo": "Sum of Distances in Tree",
    "enunciado": "There is an undirected connected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n and \nn - 1\n edges.\n\n\nYou are given the integer \nn\n and the array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nReturn an array \nanswer\n of length \nn\n where \nanswer[i]\n is the sum of the distances between the \ni\nth\n node in the tree and all other nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n\nOutput:\n [8,12,6,10,10,10]\n\nExplanation:\n The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer[0] = 8, and so on.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 1, edges = []\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 2, edges = [[1,0]]\n\nOutput:\n [1,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 3 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nThe given input represents a valid tree.",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 833,
    "slug": "find-and-replace-in-string",
    "url": "https://leetcode.com/problems/find-and-replace-in-string/",
    "titulo": "Find And Replace in String",
    "enunciado": "You are given a \n0-indexed\n string \ns\n that you must perform \nk\n replacement operations on. The replacement operations are given as three \n0-indexed\n parallel arrays, \nindices\n, \nsources\n, and \ntargets\n, all of length \nk\n.\n\n\nTo complete the \ni\nth\n replacement operation:\n\n\n\n\nCheck if the \nsubstring\n \nsources[i]\n occurs at index \nindices[i]\n in the \noriginal string\n \ns\n.\n\n\nIf it does not occur, \ndo nothing\n.\n\n\nOtherwise if it does occur, \nreplace\n that substring with \ntargets[i]\n.\n\n\n\n\nFor example, if \ns = \"\nab\ncd\"\n, \nindices[i] = 0\n, \nsources[i] = \"ab\"\n, and \ntargets[i] = \"eee\"\n, then the result of this replacement will be \n\"\neee\ncd\"\n.\n\n\nAll replacement operations must occur \nsimultaneously\n, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will \nnot overlap\n.\n\n\n\n\nFor example, a testcase with \ns = \"abc\"\n, \nindices = [0, 1]\n, and \nsources = [\"ab\",\"bc\"]\n will not be generated because the \n\"ab\"\n and \n\"bc\"\n replacements overlap.\n\n\n\n\nReturn \nthe \nresulting string\n after performing all replacement operations on \ns\n.\n\n\nA \nsubstring\n is a contiguous sequence of characters in a string.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s = \"abcd\", indices = [0, 2], sources = [\"a\", \"cd\"], targets = [\"eee\", \"ffff\"]\n\nOutput:\n \"eeebffff\"\n\nExplanation:\n\n\"a\" occurs at index 0 in s, so we replace it with \"eee\".\n\"cd\" occurs at index 2 in s, so we replace it with \"ffff\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n s = \"abcd\", indices = [0, 2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\n\nOutput:\n \"eeecd\"\n\nExplanation:\n\n\"ab\" occurs at index 0 in s, so we replace it with \"eee\".\n\"ec\" does not occur at index 2 in s, so we do nothing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\nk == indices.length == sources.length == targets.length\n\n\n1 <= k <= 100\n\n\n0 <= indexes[i] < s.length\n\n\n1 <= sources[i].length, targets[i].length <= 50\n\n\ns\n consists of only lowercase English letters.\n\n\nsources[i]\n and \ntargets[i]\n consist of only lowercase English letters.",
    "temas": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 817,
    "slug": "linked-list-components",
    "url": "https://leetcode.com/problems/linked-list-components/",
    "titulo": "Linked List Components",
    "enunciado": "You are given the \nhead\n of a linked list containing unique integer values and an integer array \nnums\n that is a subset of the linked list values.\n\n\nReturn \nthe number of connected components in \nnums\n where two values are connected if they appear \nconsecutively\n in the linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [0,1,2,3], nums = [0,1,3]\n\nOutput:\n 2\n\nExplanation:\n 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [0,1,2,3,4], nums = [0,3,1,4]\n\nOutput:\n 2\n\nExplanation:\n 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the linked list is \nn\n.\n\n\n1 <= n <= 10\n4\n\n\n0 <= Node.val < n\n\n\nAll the values \nNode.val\n are \nunique\n.\n\n\n1 <= nums.length <= n\n\n\n0 <= nums[i] < n\n\n\nAll the values of \nnums\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 814,
    "slug": "binary-tree-pruning",
    "url": "https://leetcode.com/problems/binary-tree-pruning/",
    "titulo": "Binary Tree Pruning",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe same tree where every subtree (of the given tree) not containing a \n1\n has been removed\n.\n\n\nA subtree of a node \nnode\n is \nnode\n plus every node that is a descendant of \nnode\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,0,0,1]\n\nOutput:\n [1,null,0,null,1]\n\nExplanation:\n \nOnly the red nodes satisfy the property \"every subtree not containing a 1\".\nThe diagram on the right represents the answer.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,1,0,0,0,1]\n\nOutput:\n [1,null,1,null,1]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,1,0,1,1,0,1,0]\n\nOutput:\n [1,1,0,1,1,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 200]\n.\n\n\nNode.val\n is either \n0\n or \n1\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 812,
    "slug": "largest-triangle-area",
    "url": "https://leetcode.com/problems/largest-triangle-area/",
    "titulo": "Largest Triangle Area",
    "enunciado": "Given an array of points on the \nX-Y\n plane \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n, return \nthe area of the largest triangle that can be formed by any three different points\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n\nOutput:\n 2.00000\n\nExplanation:\n The five points are shown in the above figure. The red triangle is the largest.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[1,0],[0,0],[0,1]]\n\nOutput:\n 0.50000\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= points.length <= 50\n\n\n-50 <= x\ni\n, y\ni\n <= 50\n\n\nAll the given points are \nunique\n.",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 807,
    "slug": "max-increase-to-keep-city-skyline",
    "url": "https://leetcode.com/problems/max-increase-to-keep-city-skyline/",
    "titulo": "Max Increase to Keep City Skyline",
    "enunciado": "There is a city composed of \nn x n\n blocks, where each block contains a single building shaped like a vertical square prism. You are given a \n0-indexed\n \nn x n\n integer matrix \ngrid\n where \ngrid[r][c]\n represents the \nheight\n of the building located in the block at row \nr\n and column \nc\n.\n\n\nA city's \nskyline\n is the outer contour formed by all the building when viewing the side of the city from a distance. The \nskyline\n from each cardinal direction north, east, south, and west may be different.\n\n\nWe are allowed to increase the height of \nany number of buildings by any amount\n (the amount can be different per building). The height of a \n0\n-height building can also be increased. However, increasing the height of a building should \nnot\n affect the city's \nskyline\n from any cardinal direction.\n\n\nReturn \nthe \nmaximum total sum\n that the height of the buildings can be increased by \nwithout\n changing the city's \nskyline\n from any cardinal direction\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n\nOutput:\n 35\n\nExplanation:\n The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0,0,0],[0,0,0],[0,0,0]]\n\nOutput:\n 0\n\nExplanation:\n Increasing the height of any building will result in the skyline changing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[r].length\n\n\n2 <= n <= 50\n\n\n0 <= grid[r][c] <= 100",
    "temas": [
      "Array",
      "Greedy",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 802,
    "slug": "find-eventual-safe-states",
    "url": "https://leetcode.com/problems/find-eventual-safe-states/",
    "titulo": "Find Eventual Safe States",
    "enunciado": "There is a directed graph of \nn\n nodes with each node labeled from \n0\n to \nn - 1\n. The graph is represented by a \n0-indexed\n 2D integer array \ngraph\n where \ngraph[i]\n is an integer array of nodes adjacent to node \ni\n, meaning there is an edge from node \ni\n to each node in \ngraph[i]\n.\n\n\nA node is a \nterminal node\n if there are no outgoing edges. A node is a \nsafe node\n if every possible path starting from that node leads to a \nterminal node\n (or another safe node).\n\n\nReturn \nan array containing all the \nsafe nodes\n of the graph\n. The answer should be sorted in \nascending\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n\nOutput:\n [2,4,5,6]\n\nExplanation:\n The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\n\nExample 2:\n\n\n\n\nInput:\n graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n\nOutput:\n [4]\n\nExplanation:\n\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= graph[i].length <= n\n\n\n0 <= graph[i][j] <= n - 1\n\n\ngraph[i]\n is sorted in a strictly increasing order.\n\n\nThe graph may contain self-loops.\n\n\nThe number of edges in the graph will be in the range \n[1, 4 * 10\n4\n]\n.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 799,
    "slug": "champagne-tower",
    "url": "https://leetcode.com/problems/champagne-tower/",
    "titulo": "Champagne Tower",
    "enunciado": "We stack glasses in a pyramid, where the \nfirst\n row has \n1\n glass, the \nsecond\n row has \n2\n glasses, and so on until the 100\nth\n row.  Each glass holds one cup of champagne.\n\n\nThen, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.)\n\n\nFor example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\n\n\n\nNow after pouring some non-negative integer cups of champagne, return how full the \nj\nth\n glass in the \ni\nth\n row is (both \ni\n and \nj\n are 0-indexed.)\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n poured = 1, query_row = 1, query_glass = 1\r\n\nOutput:\n 0.00000\r\n\nExplanation:\n We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n poured = 2, query_row = 1, query_glass = 1\r\n\nOutput:\n 0.50000\r\n\nExplanation:\n We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n poured = 100000009, query_row = 33, query_glass = 17\r\n\nOutput:\n 1.00000\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= poured <= 10\n9\n\n\n0 <= query_glass <= query_row < 100",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 797,
    "slug": "all-paths-from-source-to-target",
    "url": "https://leetcode.com/problems/all-paths-from-source-to-target/",
    "titulo": "All Paths From Source to Target",
    "enunciado": "Given a directed acyclic graph (\nDAG\n) of \nn\n nodes labeled from \n0\n to \nn - 1\n, find all possible paths from node \n0\n to node \nn - 1\n and return them in \nany order\n.\n\n\nThe graph is given as follows: \ngraph[i]\n is a list of all nodes you can visit from node \ni\n (i.e., there is a directed edge from node \ni\n to node \ngraph[i][j]\n).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2],[3],[3],[]]\n\nOutput:\n [[0,1,3],[0,2,3]]\n\nExplanation:\n There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[4,3,1],[3,2,4],[3],[4],[]]\n\nOutput:\n [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n2 <= n <= 15\n\n\n0 <= graph[i][j] < n\n\n\ngraph[i][j] != i\n (i.e., there will be no self-loops).\n\n\nAll the elements of \ngraph[i]\n are \nunique\n.\n\n\nThe input graph is \nguaranteed\n to be a \nDAG\n.",
    "temas": [
      "Backtracking",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Backtracking",
    "has_image": true
  },
  {
    "id": 794,
    "slug": "valid-tic-tac-toe-state",
    "url": "https://leetcode.com/problems/valid-tic-tac-toe-state/",
    "titulo": "Valid Tic-Tac-Toe State",
    "enunciado": "Given a Tic-Tac-Toe board as a string array \nboard\n, return \ntrue\n if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\n\n\nThe board is a \n3 x 3\n array that consists of characters \n' '\n, \n'X'\n, and \n'O'\n. The \n' '\n character represents an empty square.\n\n\nHere are the rules of Tic-Tac-Toe:\n\n\n\n\nPlayers take turns placing characters into empty squares \n' '\n.\n\n\nThe first player always places \n'X'\n characters, while the second player always places \n'O'\n characters.\n\n\n'X'\n and \n'O'\n characters are always placed into empty squares, never filled ones.\n\n\nThe game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n\n\nThe game also ends if all squares are non-empty.\n\n\nNo more moves can be played if the game is over.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [\"O  \",\"   \",\"   \"]\n\nOutput:\n false\n\nExplanation:\n The first player always plays \"X\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [\"XOX\",\" X \",\"   \"]\n\nOutput:\n false\n\nExplanation:\n Players take turns making moves.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [\"XOX\",\"O O\",\"XOX\"]\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 3\n\n\nboard[i].length == 3\n\n\nboard[i][j]\n is either \n'X'\n, \n'O'\n, or \n' '\n.",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 790,
    "slug": "domino-and-tromino-tiling",
    "url": "https://leetcode.com/problems/domino-and-tromino-tiling/",
    "titulo": "Domino and Tromino Tiling",
    "enunciado": "You have two types of tiles: a \n2 x 1\n domino shape and a tromino shape. You may rotate these shapes.\n\n\n\n\nGiven an integer n, return \nthe number of ways to tile an\n \n2 x n\n \nboard\n. Since the answer may be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 5\n\nExplanation:\n The five different ways are shown above.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 1000",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 787,
    "slug": "cheapest-flights-within-k-stops",
    "url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
    "titulo": "Cheapest Flights Within K Stops",
    "enunciado": "There are \nn\n cities connected by some number of flights. You are given an array \nflights\n where \nflights[i] = [from\ni\n, to\ni\n, price\ni\n]\n indicates that there is a flight from city \nfrom\ni\n to city \nto\ni\n with cost \nprice\ni\n.\n\n\nYou are also given three integers \nsrc\n, \ndst\n, and \nk\n, return \nthe cheapest price\n from \nsrc\n to \ndst\n with at most \nk\n stops. \nIf there is no such route, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\n\nOutput:\n 700\n\nExplanation:\n\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\n\nOutput:\n 200\n\nExplanation:\n\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\n\nOutput:\n 500\n\nExplanation:\n\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n0 <= flights.length <= (n * (n - 1) / 2)\n\n\nflights[i].length == 3\n\n\n0 <= from\ni\n, to\ni\n < n\n\n\nfrom\ni\n != to\ni\n\n\n1 <= price\ni\n <= 10\n4\n\n\nThere will not be any multiple flights between two cities.\n\n\n0 <= src, dst, k < n\n\n\nsrc != dst",
    "temas": [
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 785,
    "slug": "is-graph-bipartite",
    "url": "https://leetcode.com/problems/is-graph-bipartite/",
    "titulo": "Is Graph Bipartite?",
    "enunciado": "There is an \nundirected\n graph with \nn\n nodes, where each node is numbered between \n0\n and \nn - 1\n. You are given a 2D array \ngraph\n, where \ngraph[u]\n is an array of nodes that node \nu\n is adjacent to. More formally, for each \nv\n in \ngraph[u]\n, there is an undirected edge between node \nu\n and node \nv\n. The graph has the following properties:\n\n\n\n\nThere are no self-edges (\ngraph[u]\n does not contain \nu\n).\n\n\nThere are no parallel edges (\ngraph[u]\n does not contain duplicate values).\n\n\nIf \nv\n is in \ngraph[u]\n, then \nu\n is in \ngraph[v]\n (the graph is undirected).\n\n\nThe graph may not be connected, meaning there may be two nodes \nu\n and \nv\n such that there is no path between them.\n\n\n\n\nA graph is \nbipartite\n if the nodes can be partitioned into two independent sets \nA\n and \nB\n such that \nevery\n edge in the graph connects a node in set \nA\n and a node in set \nB\n.\n\n\nReturn \ntrue\n if and only if it is \nbipartite\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n\nOutput:\n false\n\nExplanation:\n There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[1,3],[0,2],[1,3],[0,2]]\n\nOutput:\n true\n\nExplanation:\n We can partition the nodes into two sets: {0, 2} and {1, 3}.\n\n\n \n\n\nConstraints:\n\n\n\n\ngraph.length == n\n\n\n1 <= n <= 100\n\n\n0 <= graph[u].length < n\n\n\n0 <= graph[u][i] <= n - 1\n\n\ngraph[u]\n does not contain \nu\n.\n\n\nAll the values of \ngraph[u]\n are \nunique\n.\n\n\nIf \ngraph[u]\n contains \nv\n, then \ngraph[v]\n contains \nu\n.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 783,
    "slug": "minimum-distance-between-bst-nodes",
    "url": "https://leetcode.com/problems/minimum-distance-between-bst-nodes/",
    "titulo": "Minimum Distance Between BST Nodes",
    "enunciado": "Given the \nroot\n of a Binary Search Tree (BST), return \nthe minimum difference between the values of any two different nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,48,null,null,12,49]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 100]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nNote:\n This question is the same as 530: \nhttps://leetcode.com/problems/minimum-absolute-difference-in-bst/",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 782,
    "slug": "transform-to-chessboard",
    "url": "https://leetcode.com/problems/transform-to-chessboard/",
    "titulo": "Transform to Chessboard",
    "enunciado": "You are given an \nn x n\n binary grid \nboard\n. In each move, you can swap any two rows with each other, or any two columns with each other.\n\n\nReturn \nthe minimum number of moves to transform the board into a \nchessboard board\n. If the task is impossible, return \n-1\n.\n\n\nA \nchessboard board\n is a board where no \n0\n's and no \n1\n's are 4-directionally adjacent.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n\nOutput:\n 2\n\nExplanation:\n One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[0,1],[1,0]]\n\nOutput:\n 0\n\nExplanation:\n Also note that the board with 0 in the top left corner, is also a valid chessboard.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[1,0],[1,0]]\n\nOutput:\n -1\n\nExplanation:\n No matter what sequence of moves you make, you cannot end with a valid chessboard.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == board.length\n\n\nn == board[i].length\n\n\n2 <= n <= 30\n\n\nboard[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Math",
      "Bit Manipulation",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 778,
    "slug": "swim-in-rising-water",
    "url": "https://leetcode.com/problems/swim-in-rising-water/",
    "titulo": "Swim in Rising Water",
    "enunciado": "You are given an \nn x n\n integer matrix \ngrid\n where each value \ngrid[i][j]\n represents the elevation at that point \n(i, j)\n.\n\n\nThe rain starts to fall. At time \nt\n, the depth of the water everywhere is \nt\n. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most \nt\n. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\n\nReturn \nthe least time until you can reach the bottom right square \n(n - 1, n - 1)\n if you start at the top left square \n(0, 0)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2],[1,3]]\n\nOutput:\n 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n\nOutput:\n 16\n\nExplanation:\n The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] < n\n2\n\n\nEach value \ngrid[i][j]\n is \nunique\n.",
    "temas": [
      "Array",
      "Binary Search",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 773,
    "slug": "sliding-puzzle",
    "url": "https://leetcode.com/problems/sliding-puzzle/",
    "titulo": "Sliding Puzzle",
    "enunciado": "On an \n2 x 3\n board, there are five tiles labeled from \n1\n to \n5\n, and an empty square represented by \n0\n. A \nmove\n consists of choosing \n0\n and a 4-directionally adjacent number and swapping it.\n\n\nThe state of the board is solved if and only if the board is \n[[1,2,3],[4,5,0]]\n.\n\n\nGiven the puzzle board \nboard\n, return \nthe least number of moves required so that the state of the board is solved\n. If it is impossible for the state of the board to be solved, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[1,2,3],[4,0,5]]\n\nOutput:\n 1\n\nExplanation:\n Swap the 0 and the 5 in one move.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[1,2,3],[5,4,0]]\n\nOutput:\n -1\n\nExplanation:\n No number of moves will make the board solved.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[4,1,2],[5,0,3]]\n\nOutput:\n 5\n\nExplanation:\n 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 2\n\n\nboard[i].length == 3\n\n\n0 <= board[i][j] <= 5\n\n\nEach value \nboard[i][j]\n is \nunique\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Backtracking",
      "Breadth-First Search",
      "Memoization",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 701,
    "slug": "insert-into-a-binary-search-tree",
    "url": "https://leetcode.com/problems/insert-into-a-binary-search-tree/",
    "titulo": "Insert into a Binary Search Tree",
    "enunciado": "You are given the \nroot\n node of a binary search tree (BST) and a \nvalue\n to insert into the tree. Return \nthe root node of the BST after the insertion\n. It is \nguaranteed\n that the new value does not exist in the original BST.\n\n\nNotice\n that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return \nany of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3], val = 5\n\nOutput:\n [4,2,7,1,3,5]\n\nExplanation:\n Another accepted tree is:\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [40,20,60,10,30,50,70], val = 25\n\nOutput:\n [40,20,60,10,30,50,70,null,null,25]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n\nOutput:\n [4,2,7,1,3,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree will be in the range \n[0, 10\n4\n]\n.\n\n\n-10\n8\n <= Node.val <= 10\n8\n\n\nAll the values \nNode.val\n are \nunique\n.\n\n\n-10\n8\n <= val <= 10\n8\n\n\nIt's \nguaranteed\n that \nval\n does not exist in the original BST.",
    "temas": [
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 700,
    "slug": "search-in-a-binary-search-tree",
    "url": "https://leetcode.com/problems/search-in-a-binary-search-tree/",
    "titulo": "Search in a Binary Search Tree",
    "enunciado": "You are given the \nroot\n of a binary search tree (BST) and an integer \nval\n.\n\n\nFind the node in the BST that the node's value equals \nval\n and return the subtree rooted with that node. If such a node does not exist, return \nnull\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3], val = 2\n\nOutput:\n [2,1,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3], val = 5\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 5000]\n.\n\n\n1 <= Node.val <= 10\n7\n\n\nroot\n is a binary search tree.\n\n\n1 <= val <= 10\n7",
    "temas": [
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 766,
    "slug": "toeplitz-matrix",
    "url": "https://leetcode.com/problems/toeplitz-matrix/",
    "titulo": "Toeplitz Matrix",
    "enunciado": "Given an \nm x n\n \nmatrix\n, return \ntrue\n if the matrix is Toeplitz. Otherwise, return \nfalse\n.\n\n\nA matrix is \nToeplitz\n if every diagonal from top-left to bottom-right has the same elements.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n\nOutput:\n true\n\nExplanation:\n\nIn the above grid, the diagonals are:\n\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\".\nIn each diagonal all elements are the same, so the answer is True.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2],[2,2]]\n\nOutput:\n false\n\nExplanation:\n\nThe diagonal \"[1, 2]\" has different elements.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 20\n\n\n0 <= matrix[i][j] <= 99\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nWhat if the \nmatrix\n is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\n\n\nWhat if the \nmatrix\n is so large that you can only load up a partial row into the memory at once?",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 590,
    "slug": "n-ary-tree-postorder-traversal",
    "url": "https://leetcode.com/problems/n-ary-tree-postorder-traversal/",
    "titulo": "N-ary Tree Postorder Traversal",
    "enunciado": "Given the \nroot\n of an n-ary tree, return \nthe postorder traversal of its nodes' values\n.\n\n\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n [5,6,3,2,4,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4\n\n\nThe height of the n-ary tree is less than or equal to \n1000\n.\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
    "temas": [
      "Stack",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 589,
    "slug": "n-ary-tree-preorder-traversal",
    "url": "https://leetcode.com/problems/n-ary-tree-preorder-traversal/",
    "titulo": "N-ary Tree Preorder Traversal",
    "enunciado": "Given the \nroot\n of an n-ary tree, return \nthe preorder traversal of its nodes' values\n.\n\n\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n [1,3,5,6,2,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4\n\n\nThe height of the n-ary tree is less than or equal to \n1000\n.\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
    "temas": [
      "Stack",
      "Tree",
      "Depth-First Search"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 559,
    "slug": "maximum-depth-of-n-ary-tree",
    "url": "https://leetcode.com/problems/maximum-depth-of-n-ary-tree/",
    "titulo": "Maximum Depth of N-ary Tree",
    "enunciado": "Given a n-ary tree, find its maximum depth.\n\n\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe total number of nodes is in the range \n[0, 10\n4\n]\n.\n\n\nThe depth of the n-ary tree is less than or equal to \n1000\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 558,
    "slug": "logical-or-of-two-binary-grids-represented-as-quad-trees",
    "url": "https://leetcode.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/",
    "titulo": "Logical OR of Two Binary Grids Represented as Quad-Trees",
    "enunciado": "A Binary Matrix is a matrix in which all the elements are either \n0\n or \n1\n.\n\n\nGiven \nquadTree1\n and \nquadTree2\n. \nquadTree1\n represents a \nn * n\n binary matrix and \nquadTree2\n represents another \nn * n\n binary matrix.\n\n\nReturn \na Quad-Tree\n representing the \nn * n\n binary matrix which is the result of \nlogical bitwise OR\n of the two binary matrixes represented by \nquadTree1\n and \nquadTree2\n.\n\n\nNotice that you can assign the value of a node to \nTrue\n or \nFalse\n when \nisLeaf\n is \nFalse\n, and both are \naccepted\n in the answer.\n\n\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\n\n\n\nval\n: True if the node represents a grid of 1's or False if the node represents a grid of 0's.\n\n\nisLeaf\n: True if the node is leaf node on the tree or False if the node has the four children.\n\n\n\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\n\n\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\n\n\n\nIf the current grid has the same value (i.e all \n1's\n or all \n0's\n) set \nisLeaf\n True and set \nval\n to the value of the grid and set the four children to Null and stop.\n\n\nIf the current grid has different values, set \nisLeaf\n to False and set \nval\n to any value and divide the current grid into four sub-grids as shown in the photo.\n\n\nRecurse for each of the children with the proper sub-grid.\n\n\n\n\n\n\nIf you want to know more about the Quad-Tree, you can refer to the \nwiki\n.\n\n\nQuad-Tree format:\n\n\nThe input/output represents the serialized format of a Quad-Tree using level order traversal, where \nnull\n signifies a path terminator where no node exists below.\n\n\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list \n[isLeaf, val]\n.\n\n\nIf the value of \nisLeaf\n or \nval\n is True we represent it as \n1\n in the list \n[isLeaf, val]\n and if the value of \nisLeaf\n or \nval\n is False we represent it as \n0\n.\n\n\n \n\n\nExample 1:\n\n\n \n\n\n\n\nInput:\n quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n\nOutput:\n [[0,0],[1,1],[1,1],[1,1],[1,0]]\n\nExplanation:\n quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree.\nIf we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree.\nNotice that the binary matrices shown are only for illustration, you don't have to construct the binary matrix to get the result tree.\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n quadTree1 = [[1,0]], quadTree2 = [[1,0]]\n\nOutput:\n [[1,0]]\n\nExplanation:\n Each tree represents a binary matrix of size 1*1. Each matrix contains only zero.\nThe resulting matrix is of size 1*1 with also zero.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nquadTree1\n and \nquadTree2\n are both \nvalid\n Quad-Trees each representing a \nn * n\n grid.\n\n\nn == 2\nx\n where \n0 <= x <= 9\n.",
    "temas": [
      "Divide and Conquer",
      "Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Divide and Conquer",
    "has_image": true
  },
  {
    "id": 427,
    "slug": "construct-quad-tree",
    "url": "https://leetcode.com/problems/construct-quad-tree/",
    "titulo": "Construct Quad Tree",
    "enunciado": "Given a \nn * n\n matrix \ngrid\n of \n0's\n and \n1's\n only. We want to represent \ngrid\n with a Quad-Tree.\n\n\nReturn \nthe root of the Quad-Tree representing \ngrid\n.\n\n\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\n\n\n\nval\n: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the \nval\n to True or False when \nisLeaf\n is False, and both are accepted in the answer.\n\n\nisLeaf\n: True if the node is a leaf node on the tree or False if the node has four children.\n\n\n\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\n\n\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\n\n\n\nIf the current grid has the same value (i.e all \n1's\n or all \n0's\n) set \nisLeaf\n True and set \nval\n to the value of the grid and set the four children to Null and stop.\n\n\nIf the current grid has different values, set \nisLeaf\n to False and set \nval\n to any value and divide the current grid into four sub-grids as shown in the photo.\n\n\nRecurse for each of the children with the proper sub-grid.\n\n\n\n\n\n\nIf you want to know more about the Quad-Tree, you can refer to the \nwiki\n.\n\n\nQuad-Tree format:\n\n\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where \nnull\n signifies a path terminator where no node exists below.\n\n\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list \n[isLeaf, val]\n.\n\n\nIf the value of \nisLeaf\n or \nval\n is True we represent it as \n1\n in the list \n[isLeaf, val]\n and if the value of \nisLeaf\n or \nval\n is False we represent it as \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1],[1,0]]\n\nOutput:\n [[0,1],[1,0],[1,1],[1,1],[1,0]]\n\nExplanation:\n The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n\nOutput:\n [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n\nExplanation:\n All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\nn == 2\nx\n where \n0 <= x <= 6",
    "temas": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 764,
    "slug": "largest-plus-sign",
    "url": "https://leetcode.com/problems/largest-plus-sign/",
    "titulo": "Largest Plus Sign",
    "enunciado": "You are given an integer \nn\n. You have an \nn x n\n binary grid \ngrid\n with all values initially \n1\n's except for some indices given in the array \nmines\n. The \ni\nth\n element of the array \nmines\n is defined as \nmines[i] = [x\ni\n, y\ni\n]\n where \ngrid[x\ni\n][y\ni\n] == 0\n.\n\n\nReturn \nthe order of the largest \naxis-aligned\n plus sign of \n1\n's contained in \ngrid\n. If there is none, return \n0\n.\n\n\nAn \naxis-aligned plus sign\n of \n1\n's of order \nk\n has some center \ngrid[r][c] == 1\n along with four arms of length \nk - 1\n going up, down, left, and right, and made of \n1\n's. Note that there could be \n0\n's or \n1\n's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for \n1\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5, mines = [[4,2]]\n\nOutput:\n 2\n\nExplanation:\n In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 1, mines = [[0,0]]\n\nOutput:\n 0\n\nExplanation:\n There is no plus sign, so return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 500\n\n\n1 <= mines.length <= 5000\n\n\n0 <= x\ni\n, y\ni\n < n\n\n\nAll the pairs \n(x\ni\n, y\ni\n)\n are \nunique\n.",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 430,
    "slug": "flatten-a-multilevel-doubly-linked-list",
    "url": "https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/",
    "titulo": "Flatten a Multilevel Doubly Linked List",
    "enunciado": "You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional \nchild pointer\n. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a \nmultilevel data structure\n as shown in the example below.\n\n\nGiven the \nhead\n of the first level of the list, \nflatten\n the list so that all the nodes appear in a single-level, doubly linked list. Let \ncurr\n be a node with a child list. The nodes in the child list should appear \nafter\n \ncurr\n and \nbefore\n \ncurr.next\n in the flattened list.\n\n\nReturn \nthe \nhead\n of the flattened list. The nodes in the list must have \nall\n of their child pointers set to \nnull\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n\nOutput:\n [1,2,3,7,8,11,12,9,10,4,5,6]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,null,3]\n\nOutput:\n [1,3,2]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\nExplanation:\n There could be empty list in the input.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of Nodes will not exceed \n1000\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nHow the multilevel linked list is represented in test cases:\n\n\nWe use the multilevel linked list from \nExample 1\n above:\n\n\n\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\n\nThe serialization of each level is as follows:\n\n\n\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n\n\n\nTo serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:\n\n\n\n[1,    2,    3, 4, 5, 6, null]\n             |\n[null, null, 7,    8, 9, 10, null]\n                   |\n[            null, 11, 12, null]\n\n\n\nMerging the serialization of each level and removing trailing nulls we obtain:\n\n\n\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]",
    "temas": [
      "Linked List",
      "Depth-First Search",
      "Doubly-Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 429,
    "slug": "n-ary-tree-level-order-traversal",
    "url": "https://leetcode.com/problems/n-ary-tree-level-order-traversal/",
    "titulo": "N-ary Tree Level Order Traversal",
    "enunciado": "Given an n-ary tree, return the \nlevel order\n traversal of its nodes' values.\n\n\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,3,2,4,null,5,6]\n\nOutput:\n [[1],[3,2,4],[5,6]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\nOutput:\n [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe height of the n-ary tree is less than or equal to \n1000\n\n\nThe total number of nodes is between \n[0, 10\n4\n]",
    "temas": [
      "Tree",
      "Breadth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 756,
    "slug": "pyramid-transition-matrix",
    "url": "https://leetcode.com/problems/pyramid-transition-matrix/",
    "titulo": "Pyramid Transition Matrix",
    "enunciado": "You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains \none less block\n than the row beneath it and is centered on top.\n\n\nTo make the pyramid aesthetically pleasing, there are only specific \ntriangular patterns\n that are allowed. A triangular pattern consists of a \nsingle block\n stacked on top of \ntwo blocks\n. The patterns are given as a list of three-letter strings \nallowed\n, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.\n\n\n\n\nFor example, \n\"ABC\"\n represents a triangular pattern with a \n'C'\n block stacked on top of an \n'A'\n (left) and \n'B'\n (right) block. Note that this is different from \n\"BAC\"\n where \n'B'\n is on the left bottom and \n'A'\n is on the right bottom.\n\n\n\n\nYou start with a bottom row of blocks \nbottom\n, given as a single string, that you \nmust\n use as the base of the pyramid.\n\n\nGiven \nbottom\n and \nallowed\n, return \ntrue\n if you can build the pyramid all the way to the top such that \nevery triangular pattern\n in the pyramid is in \nallowed\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n\nOutput:\n true\n\nExplanation:\n The allowed triangular patterns are shown on the right.\nStarting from the bottom (level 3), we can build \"CE\" on level 2 and then build \"A\" on level 1.\nThere are three triangular patterns in the pyramid, which are \"BCC\", \"CDE\", and \"CEA\". All are allowed.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n\nOutput:\n false\n\nExplanation:\n The allowed triangular patterns are shown on the right.\nStarting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= bottom.length <= 6\n\n\n0 <= allowed.length <= 216\n\n\nallowed[i].length == 3\n\n\nThe letters in all input strings are from the set \n{'A', 'B', 'C', 'D', 'E', 'F'}\n.\n\n\nAll the values of \nallowed\n are \nunique\n.",
    "temas": [
      "Bit Manipulation",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Bit Manipulation",
    "has_image": true
  },
  {
    "id": 749,
    "slug": "contain-virus",
    "url": "https://leetcode.com/problems/contain-virus/",
    "titulo": "Contain Virus",
    "enunciado": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\n\nThe world is modeled as an \nm x n\n binary grid \nisInfected\n, where \nisInfected[i][j] == 0\n represents uninfected cells, and \nisInfected[i][j] == 1\n represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two \n4-directionally\n adjacent cells, on the shared boundary.\n\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There \nwill never be a tie\n.\n\n\nReturn \nthe number of walls used to quarantine all the infected regions\n. If the world will become fully infected, return the number of walls used.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\n\nOutput:\n 10\n\nExplanation:\n There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n\n\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isInfected = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n 4\n\nExplanation:\n Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n\n\nExample 3:\n\n\n\n\nInput:\n isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\n\nOutput:\n 13\n\nExplanation:\n The region on the left only builds two new walls.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == isInfected.length\n\n\nn == isInfected[i].length\n\n\n1 <= m, n <= 50\n\n\nisInfected[i][j]\n is either \n0\n or \n1\n.\n\n\nThere is always a contiguous viral region throughout the described process that will \ninfect strictly more uncontaminated squares\n in the next round.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 743,
    "slug": "network-delay-time",
    "url": "https://leetcode.com/problems/network-delay-time/",
    "titulo": "Network Delay Time",
    "enunciado": "You are given a network of \nn\n nodes, labeled from \n1\n to \nn\n. You are also given \ntimes\n, a list of travel times as directed edges \ntimes[i] = (u\ni\n, v\ni\n, w\ni\n)\n, where \nu\ni\n is the source node, \nv\ni\n is the target node, and \nw\ni\n is the time it takes for a signal to travel from source to target.\n\n\nWe will send a signal from a given node \nk\n. Return \nthe \nminimum\n time it takes for all the\n \nn\n \nnodes to receive the signal\n. If it is impossible for all the \nn\n nodes to receive the signal, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n times = [[1,2,1]], n = 2, k = 1\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n times = [[1,2,1]], n = 2, k = 2\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 100\n\n\n1 <= times.length <= 6000\n\n\ntimes[i].length == 3\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni\n != v\ni\n\n\n0 <= w\ni\n <= 100\n\n\nAll the pairs \n(u\ni\n, v\ni\n)\n are \nunique\n. (i.e., no multiple edges.)",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 741,
    "slug": "cherry-pickup",
    "url": "https://leetcode.com/problems/cherry-pickup/",
    "titulo": "Cherry Pickup",
    "enunciado": "You are given an \nn x n\n \ngrid\n representing a field of cherries, each cell is one of three possible integers.\n\n\n\n\n0\n means the cell is empty, so you can pass through,\n\n\n1\n means the cell contains a cherry that you can pick up and pass through, or\n\n\n-1\n means the cell contains a thorn that blocks your way.\n\n\n\n\nReturn \nthe maximum number of cherries you can collect by following the rules below\n:\n\n\n\n\nStarting at the position \n(0, 0)\n and reaching \n(n - 1, n - 1)\n by moving right or down through valid path cells (cells with value \n0\n or \n1\n).\n\n\nAfter reaching \n(n - 1, n - 1)\n, returning to \n(0, 0)\n by moving left or up through valid path cells.\n\n\nWhen passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell \n0\n.\n\n\nIf there is no valid path between \n(0, 0)\n and \n(n - 1, n - 1)\n, then no cherries can be collected.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,-1],[1,0,-1],[1,1,1]]\n\nOutput:\n 5\n\nExplanation:\n The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 50\n\n\ngrid[i][j]\n is \n-1\n, \n0\n, or \n1\n.\n\n\ngrid[0][0] != -1\n\n\ngrid[n - 1][n - 1] != -1",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 733,
    "slug": "flood-fill",
    "url": "https://leetcode.com/problems/flood-fill/",
    "titulo": "Flood Fill",
    "enunciado": "You are given an image represented by an \nm x n\n grid of integers \nimage\n, where \nimage[i][j]\n represents the pixel value of the image. You are also given three integers \nsr\n, \nsc\n, and \ncolor\n. Your task is to perform a \nflood fill\n on the image starting from the pixel \nimage[sr][sc]\n.\n\n\nTo perform a \nflood fill\n:\n\n\n\n\nBegin with the starting pixel and change its color to \ncolor\n.\n\n\nPerform the same process for each pixel that is \ndirectly adjacent\n (pixels that share a side with the original pixel, either horizontally or vertically) and shares the \nsame color\n as the starting pixel.\n\n\nKeep \nrepeating\n this process by checking neighboring pixels of the \nupdated\n pixels and modifying their color if it matches the original color of the starting pixel.\n\n\nThe process \nstops\n when there are \nno more\n adjacent pixels of the original color to update.\n\n\n\n\nReturn the \nmodified\n image after performing the flood fill.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nimage = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n\n\nOutput:\n \n[[2,2,2],[2,2,0],[2,0,1]]\n\n\nExplanation:\n\n\n\n\nFrom the center of the image with position \n(sr, sc) = (1, 1)\n (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n\n\nNote the bottom corner is \nnot\n colored 2, because it is not horizontally or vertically connected to the starting pixel.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nimage = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n\n\nOutput:\n \n[[0,0,0],[0,0,0]]\n\n\nExplanation:\n\n\nThe starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == image.length\n\n\nn == image[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= image[i][j], color < 2\n16\n\n\n0 <= sr < m\n\n\n0 <= sc < n",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 725,
    "slug": "split-linked-list-in-parts",
    "url": "https://leetcode.com/problems/split-linked-list-in-parts/",
    "titulo": "Split Linked List in Parts",
    "enunciado": "Given the \nhead\n of a singly linked list and an integer \nk\n, split the linked list into \nk\n consecutive linked list parts.\n\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\n\n\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\n\n\nReturn \nan array of the \nk\n parts\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3], k = 5\n\nOutput:\n [[1],[2],[3],[],[]]\n\nExplanation:\n\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6,7,8,9,10], k = 3\n\nOutput:\n [[1,2,3,4],[5,6,7],[8,9,10]]\n\nExplanation:\n\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 1000]\n.\n\n\n0 <= Node.val <= 1000\n\n\n1 <= k <= 50",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 699,
    "slug": "falling-squares",
    "url": "https://leetcode.com/problems/falling-squares/",
    "titulo": "Falling Squares",
    "enunciado": "There are several squares being dropped onto the X-axis of a 2D plane.\n\n\nYou are given a 2D integer array \npositions\n where \npositions[i] = [left\ni\n, sideLength\ni\n]\n represents the \ni\nth\n square with a side length of \nsideLength\ni\n that is dropped with its left edge aligned with X-coordinate \nleft\ni\n.\n\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands \non the top side of another square\n or \non the X-axis\n. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\n\nAfter each square is dropped, you must record the \nheight of the current tallest stack of squares\n.\n\n\nReturn \nan integer array \nans\n where \nans[i]\n represents the height described above after dropping the \ni\nth\n square\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n positions = [[1,2],[2,3],[6,1]]\n\nOutput:\n [2,5,5]\n\nExplanation:\n\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of [2, 5, 5].\n\n\n\nExample 2:\n\n\n\n\nInput:\n positions = [[100,100],[200,100]]\n\nOutput:\n [100,100]\n\nExplanation:\n\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of [100, 100].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= positions.length <= 1000\n\n\n1 <= left\ni\n <= 10\n8\n\n\n1 <= sideLength\ni\n <= 10\n6",
    "temas": [
      "Array",
      "Segment Tree",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 695,
    "slug": "max-area-of-island",
    "url": "https://leetcode.com/problems/max-area-of-island/",
    "titulo": "Max Area of Island",
    "enunciado": "You are given an \nm x n\n binary matrix \ngrid\n. An island is a group of \n1\n's (representing land) connected \n4-directionally\n (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\n\nThe \narea\n of an island is the number of cells with a value \n1\n in the island.\n\n\nReturn \nthe maximum \narea\n of an island in \ngrid\n. If there is no island, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n\nOutput:\n 6\n\nExplanation:\n The answer is not 11, because the island must be connected 4-directionally.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0,0,0,0,0,0,0,0]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 690,
    "slug": "employee-importance",
    "url": "https://leetcode.com/problems/employee-importance/",
    "titulo": "Employee Importance",
    "enunciado": "You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.\n\n\nYou are given an array of employees \nemployees\n where:\n\n\n\n\nemployees[i].id\n is the ID of the \ni\nth\n employee.\n\n\nemployees[i].importance\n is the importance value of the \ni\nth\n employee.\n\n\nemployees[i].subordinates\n is a list of the IDs of the direct subordinates of the \ni\nth\n employee.\n\n\n\n\nGiven an integer \nid\n that represents an employee's ID, return \nthe \ntotal\n importance value of this employee and all their direct and indirect subordinates\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1\n\nOutput:\n 11\n\nExplanation:\n Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.\nThey both have an importance value of 3.\nThus, the total importance value of employee 1 is 5 + 3 + 3 = 11.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n employees = [[1,2,[5]],[5,-3,[]]], id = 5\n\nOutput:\n -3\n\nExplanation:\n Employee 5 has an importance value of -3 and has no direct subordinates.\nThus, the total importance value of employee 5 is -3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= employees.length <= 2000\n\n\n1 <= employees[i].id <= 2000\n\n\nAll \nemployees[i].id\n are \nunique\n.\n\n\n-100 <= employees[i].importance <= 100\n\n\nOne employee has at most one direct leader and may have several subordinates.\n\n\nThe IDs in \nemployees[i].subordinates\n are valid IDs.",
    "temas": [
      "Array",
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 688,
    "slug": "knight-probability-in-chessboard",
    "url": "https://leetcode.com/problems/knight-probability-in-chessboard/",
    "titulo": "Knight Probability in Chessboard",
    "enunciado": "On an \nn x n\n chessboard, a knight starts at the cell \n(row, column)\n and attempts to make exactly \nk\n moves. The rows and columns are \n0-indexed\n, so the top-left cell is \n(0, 0)\n, and the bottom-right cell is \n(n - 1, n - 1)\n.\n\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\n\n\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\n\nThe knight continues moving until it has made exactly \nk\n moves or has moved off the chessboard.\n\n\nReturn \nthe probability that the knight remains on the board after it has stopped moving\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 3, k = 2, row = 0, column = 0\n\nOutput:\n 0.06250\n\nExplanation:\n There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, k = 0, row = 0, column = 0\n\nOutput:\n 1.00000\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 25\n\n\n0 <= k <= 100\n\n\n0 <= row, column <= n - 1",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 687,
    "slug": "longest-univalue-path",
    "url": "https://leetcode.com/problems/longest-univalue-path/",
    "titulo": "Longest Univalue Path",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe length of the longest path, where each node in the path has the same value\n. This path may or may not pass through the root.\n\n\nThe length of the path\n between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,4,5,1,1,null,5]\n\nOutput:\n 2\n\nExplanation:\n The shown image shows that the longest path of the same value (i.e. 5).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,4,5,4,4,null,5]\n\nOutput:\n 2\n\nExplanation:\n The shown image shows that the longest path of the same value (i.e. 4).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000\n\n\nThe depth of the tree will not exceed \n1000\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 685,
    "slug": "redundant-connection-ii",
    "url": "https://leetcode.com/problems/redundant-connection-ii/",
    "titulo": "Redundant Connection II",
    "enunciado": "In this problem, a rooted tree is a \ndirected\n graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\n\nThe given input is a directed graph that started as a rooted tree with \nn\n nodes (with distinct values from \n1\n to \nn\n), with one additional directed edge added. The added edge has two different vertices chosen from \n1\n to \nn\n, and was not an edge that already existed.\n\n\nThe resulting graph is given as a 2D-array of \nedges\n. Each element of \nedges\n is a pair \n[u\ni\n, v\ni\n]\n that represents a \ndirected\n edge connecting nodes \nu\ni\n and \nv\ni\n, where \nu\ni\n is a parent of child \nv\ni\n.\n\n\nReturn \nan edge that can be removed so that the resulting graph is a rooted tree of\n \nn\n \nnodes\n. If there are multiple answers, return the answer that occurs last in the given 2D-array.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[1,3],[2,3]]\n\nOutput:\n [2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n\nOutput:\n [4,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n3 <= n <= 1000\n\n\nedges[i].length == 2\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni\n != v\ni",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 684,
    "slug": "redundant-connection",
    "url": "https://leetcode.com/problems/redundant-connection/",
    "titulo": "Redundant Connection",
    "enunciado": "In this problem, a tree is an \nundirected graph\n that is connected and has no cycles.\n\n\nYou are given a graph that started as a tree with \nn\n nodes labeled from \n1\n to \nn\n, with one additional edge added. The added edge has two \ndifferent\n vertices chosen from \n1\n to \nn\n, and was not an edge that already existed. The graph is represented as an array \nedges\n of length \nn\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the graph.\n\n\nReturn \nan edge that can be removed so that the resulting graph is a tree of \nn\n nodes\n. If there are multiple answers, return the answer that occurs last in the input.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[1,3],[2,3]]\n\nOutput:\n [2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n\nOutput:\n [1,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n3 <= n <= 1000\n\n\nedges[i].length == 2\n\n\n1 <= a\ni\n < b\ni\n <= edges.length\n\n\na\ni\n != b\ni\n\n\nThere are no repeated edges.\n\n\nThe given graph is connected.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 675,
    "slug": "cut-off-trees-for-golf-event",
    "url": "https://leetcode.com/problems/cut-off-trees-for-golf-event/",
    "titulo": "Cut Off Trees for Golf Event",
    "enunciado": "You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an \nm x n\n matrix. In this matrix:\n\n\n\n\n0\n means the cell cannot be walked through.\n\n\n1\n represents an empty cell that can be walked through.\n\n\nA number greater than \n1\n represents a tree in a cell that can be walked through, and this number is the tree's height.\n\n\n\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes \n1\n (an empty cell).\n\n\nStarting from the point \n(0, 0)\n, return \nthe minimum steps you need to walk to cut off all the trees\n. If you cannot cut off all the trees, return \n-1\n.\n\n\nNote:\n The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n forest = [[1,2,3],[0,0,4],[7,6,5]]\n\nOutput:\n 6\n\nExplanation:\n Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n forest = [[1,2,3],[0,0,0],[7,6,5]]\n\nOutput:\n -1\n\nExplanation:\n The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n\n\nExample 3:\n\n\n\n\nInput:\n forest = [[2,3,4],[0,0,5],[8,7,6]]\n\nOutput:\n 6\n\nExplanation:\n You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == forest.length\n\n\nn == forest[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= forest[i][j] <= 10\n9\n\n\nHeights of all trees are \ndistinct\n.",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 671,
    "slug": "second-minimum-node-in-a-binary-tree",
    "url": "https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/",
    "titulo": "Second Minimum Node In a Binary Tree",
    "enunciado": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly \ntwo\n or \nzero\n sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property \nroot.val = min(root.left.val, root.right.val)\n always holds.\n\n\nGiven such a binary tree, you need to output the \nsecond minimum\n value in the set made of all the nodes' value in the whole tree.\n\n\nIf no such second minimum value exists, output -1 instead.\n\n\n \n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,2,5,null,null,5,7]\n\nOutput:\n 5\n\nExplanation:\n The smallest value is 2, the second smallest value is 5.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,2,2]\n\nOutput:\n -1\n\nExplanation:\n The smallest value is 2, but there isn't any second smallest value.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 25]\n.\n\n\n1 <= Node.val <= 2\n31\n - 1\n\n\nroot.val == min(root.left.val, root.right.val)\n for each internal node of the tree.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 669,
    "slug": "trim-a-binary-search-tree",
    "url": "https://leetcode.com/problems/trim-a-binary-search-tree/",
    "titulo": "Trim a Binary Search Tree",
    "enunciado": "Given the \nroot\n of a binary search tree and the lowest and highest boundaries as \nlow\n and \nhigh\n, trim the tree so that all its elements lies in \n[low, high]\n. Trimming the tree should \nnot\n change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a \nunique answer\n.\n\n\nReturn \nthe root of the trimmed binary search tree\n. Note that the root may change depending on the given bounds.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,0,2], low = 1, high = 2\n\nOutput:\n [1,null,2]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n\nOutput:\n [3,2,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4\n\n\nThe value of each node in the tree is \nunique\n.\n\n\nroot\n is guaranteed to be a valid binary search tree.\n\n\n0 <= low <= high <= 10\n4",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 668,
    "slug": "kth-smallest-number-in-multiplication-table",
    "url": "https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/",
    "titulo": "Kth Smallest Number in Multiplication Table",
    "enunciado": "Nearly everyone has used the \nMultiplication Table\n. The multiplication table of size \nm x n\n is an integer matrix \nmat\n where \nmat[i][j] == i * j\n (\n1-indexed\n).\n\n\nGiven three integers \nm\n, \nn\n, and \nk\n, return \nthe \nk\nth\n smallest element in the \nm x n\n multiplication table\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 3, k = 5\n\nOutput:\n 3\n\nExplanation:\n The 5\nth\n smallest number is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 2, n = 3, k = 6\n\nOutput:\n 6\n\nExplanation:\n The 6\nth\n smallest number is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 3 * 10\n4\n\n\n1 <= k <= m * n",
    "temas": [
      "Math",
      "Binary Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 662,
    "slug": "maximum-width-of-binary-tree",
    "url": "https://leetcode.com/problems/maximum-width-of-binary-tree/",
    "titulo": "Maximum Width of Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe \nmaximum width\n of the given tree\n.\n\n\nThe \nmaximum width\n of a tree is the maximum \nwidth\n among all levels.\n\n\nThe \nwidth\n of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.\n\n\nIt is \nguaranteed\n that the answer will in the range of a \n32-bit\n signed integer.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5,3,null,9]\n\nOutput:\n 4\n\nExplanation:\n The maximum width exists in the third level with length 4 (5,3,null,9).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5,null,null,9,6,null,7]\n\nOutput:\n 7\n\nExplanation:\n The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5]\n\nOutput:\n 2\n\nExplanation:\n The maximum width exists in the second level with length 2 (3,2).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3000]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 661,
    "slug": "image-smoother",
    "url": "https://leetcode.com/problems/image-smoother/",
    "titulo": "Image Smoother",
    "enunciado": "An \nimage smoother\n is a filter of the size \n3 x 3\n that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\n\n\n\nGiven an \nm x n\n integer matrix \nimg\n representing the grayscale of an image, return \nthe image after applying the smoother on each cell of it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n img = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n [[0,0,0],[0,0,0],[0,0,0]]\n\nExplanation:\n\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n img = [[100,200,100],[200,50,200],[100,200,100]]\n\nOutput:\n [[137,141,137],[141,138,141],[137,141,137]]\n\nExplanation:\n\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == img.length\n\n\nn == img[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= img[i][j] <= 255",
    "temas": [
      "Array",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 655,
    "slug": "print-binary-tree",
    "url": "https://leetcode.com/problems/print-binary-tree/",
    "titulo": "Print Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, construct a \n0-indexed\n \nm x n\n string matrix \nres\n that represents a \nformatted layout\n of the tree. The formatted layout matrix should be constructed using the following rules:\n\n\n\n\nThe \nheight\n of the tree is \nheight\n and the number of rows \nm\n should be equal to \nheight + 1\n.\n\n\nThe number of columns \nn\n should be equal to \n2\nheight+1\n - 1\n.\n\n\nPlace the \nroot node\n in the \nmiddle\n of the \ntop row\n (more formally, at location \nres[0][(n-1)/2]\n).\n\n\nFor each node that has been placed in the matrix at position \nres[r][c]\n, place its \nleft child\n at \nres[r+1][c-2\nheight-r-1\n]\n and its \nright child\n at \nres[r+1][c+2\nheight-r-1\n]\n.\n\n\nContinue this process until all the nodes in the tree have been placed.\n\n\nAny empty cells should contain the empty string \n\"\"\n.\n\n\n\n\nReturn \nthe constructed matrix \nres\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n \n[[\"\",\"1\",\"\"],\n [\"2\",\"\",\"\"]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4]\n\nOutput:\n \n[[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n [\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n [\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2\n10\n]\n.\n\n\n-99 <= Node.val <= 99\n\n\nThe depth of the tree will be in the range \n[1, 10]\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 654,
    "slug": "maximum-binary-tree",
    "url": "https://leetcode.com/problems/maximum-binary-tree/",
    "titulo": "Maximum Binary Tree",
    "enunciado": "You are given an integer array \nnums\n with no duplicates. A \nmaximum binary tree\n can be built recursively from \nnums\n using the following algorithm:\n\n\n\n\nCreate a root node whose value is the maximum value in \nnums\n.\n\n\nRecursively build the left subtree on the \nsubarray prefix\n to the \nleft\n of the maximum value.\n\n\nRecursively build the right subtree on the \nsubarray suffix\n to the \nright\n of the maximum value.\n\n\n\n\nReturn \nthe \nmaximum binary tree\n built from \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [3,2,1,6,0,5]\n\nOutput:\n [6,3,5,null,2,0,null,null,1]\n\nExplanation:\n The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [3,null,2,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n0 <= nums[i] <= 1000\n\n\nAll integers in \nnums\n are \nunique\n.",
    "temas": [
      "Array",
      "Divide and Conquer",
      "Stack",
      "Tree",
      "Monotonic Stack",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 653,
    "slug": "two-sum-iv-input-is-a-bst",
    "url": "https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",
    "titulo": "Two Sum IV - Input is a BST",
    "enunciado": "Given the \nroot\n of a binary search tree and an integer \nk\n, return \ntrue\n \nif there exist two elements in the BST such that their sum is equal to\n \nk\n, \nor\n \nfalse\n \notherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,7], k = 9\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,7], k = 28\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nroot\n is guaranteed to be a \nvalid\n binary search tree.\n\n\n-10\n5\n <= k <= 10\n5",
    "temas": [
      "Hash Table",
      "Two Pointers",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 652,
    "slug": "find-duplicate-subtrees",
    "url": "https://leetcode.com/problems/find-duplicate-subtrees/",
    "titulo": "Find Duplicate Subtrees",
    "enunciado": "Given the \nroot\n of a binary tree, return all \nduplicate subtrees\n.\n\n\nFor each kind of duplicate subtrees, you only need to return the root node of any \none\n of them.\n\n\nTwo trees are \nduplicate\n if they have the \nsame structure\n with the \nsame node values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,null,2,4,null,null,4]\n\nOutput:\n [[2,4],[4]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [2,2,2,3,null,3,null]\n\nOutput:\n [[2,3],[3]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the tree will be in the range \n[1, 5000]\n\n\n-200 <= Node.val <= 200",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 637,
    "slug": "average-of-levels-in-binary-tree",
    "url": "https://leetcode.com/problems/average-of-levels-in-binary-tree/",
    "titulo": "Average of Levels in Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe average value of the nodes on each level in the form of an array\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,9,20,15,7]\n\nOutput:\n [3.00000,14.50000,11.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 636,
    "slug": "exclusive-time-of-functions",
    "url": "https://leetcode.com/problems/exclusive-time-of-functions/",
    "titulo": "Exclusive Time of Functions",
    "enunciado": "On a \nsingle-threaded\n CPU, we execute a program containing \nn\n functions. Each function has a unique ID between \n0\n and \nn-1\n.\n\n\nFunction calls are \nstored in a \ncall stack\n: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is \nthe current function being executed\n. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n\n\nYou are given a list \nlogs\n, where \nlogs[i]\n represents the \ni\nth\n log message formatted as a string \n\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"\n. For example, \n\"0:start:3\"\n means a function call with function ID \n0\n \nstarted at the beginning\n of timestamp \n3\n, and \n\"1:end:2\"\n means a function call with function ID \n1\n \nended at the end\n of timestamp \n2\n. Note that a function can be called \nmultiple times, possibly recursively\n.\n\n\nA function's \nexclusive time\n is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for \n2\n time units and another call executing for \n1\n time unit, the \nexclusive time\n is \n2 + 1 = 3\n.\n\n\nReturn \nthe \nexclusive time\n of each function in an array, where the value at the \ni\nth\n index represents the exclusive time for the function with ID \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n\nOutput:\n [3,4]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n\nOutput:\n [8]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n\nOutput:\n [7,1]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n2 <= logs.length <= 500\n\n\n0 <= function_id < n\n\n\n0 <= timestamp <= 10\n9\n\n\nNo two start events will happen at the same timestamp.\n\n\nNo two end events will happen at the same timestamp.\n\n\nEach function has an \n\"end\"\n log for each \n\"start\"\n log.",
    "temas": [
      "Array",
      "Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 623,
    "slug": "add-one-row-to-tree",
    "url": "https://leetcode.com/problems/add-one-row-to-tree/",
    "titulo": "Add One Row to Tree",
    "enunciado": "Given the \nroot\n of a binary tree and two integers \nval\n and \ndepth\n, add a row of nodes with value \nval\n at the given depth \ndepth\n.\n\n\nNote that the \nroot\n node is at depth \n1\n.\n\n\nThe adding rule is:\n\n\n\n\nGiven the integer \ndepth\n, for each not null tree node \ncur\n at the depth \ndepth - 1\n, create two tree nodes with value \nval\n as \ncur\n's left subtree root and right subtree root.\n\n\ncur\n's original left subtree should be the left subtree of the new left subtree root.\n\n\ncur\n's original right subtree should be the right subtree of the new right subtree root.\n\n\nIf \ndepth == 1\n that means there is no depth \ndepth - 1\n at all, then create a tree node with value \nval\n as the new root of the whole original tree, and the original tree is the new root's left subtree.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,3,1,5], val = 1, depth = 2\n\nOutput:\n [4,1,1,2,null,null,6,3,1,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,2,null,3,1], val = 1, depth = 3\n\nOutput:\n [4,2,null,1,1,3,null,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\nThe depth of the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100\n\n\n-10\n5\n <= val <= 10\n5\n\n\n1 <= depth <= the depth of tree + 1",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 617,
    "slug": "merge-two-binary-trees",
    "url": "https://leetcode.com/problems/merge-two-binary-trees/",
    "titulo": "Merge Two Binary Trees",
    "enunciado": "You are given two binary trees \nroot1\n and \nroot2\n.\n\n\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n\n\nReturn \nthe merged tree\n.\n\n\nNote:\n The merging process must start from the root nodes of both trees.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n\nOutput:\n [3,4,5,5,4,null,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root1 = [1], root2 = [1,2]\n\nOutput:\n [2,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 2000]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 606,
    "slug": "construct-string-from-binary-tree",
    "url": "https://leetcode.com/problems/construct-string-from-binary-tree/",
    "titulo": "Construct String from Binary Tree",
    "enunciado": "Given the \nroot\n node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines:\n\n\n\n\n\n\nNode Representation\n: Each node in the tree should be represented by its integer value.\n\n\n\n\n\n\nParentheses for Children\n: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically:\n\n\n\n\nIf a node has a left child, the value of the left child should be enclosed in parentheses immediately following the node's value.\n\n\nIf a node has a right child, the value of the right child should also be enclosed in parentheses. The parentheses for the right child should follow those of the left child.\n\n\n\n\n\n\n\n\nOmitting Empty Parentheses\n: Any empty parentheses pairs (i.e., \n()\n) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained.\n\n\nIn summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree's structure accurately.\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4]\n\nOutput:\n \"1(2(4))(3)\"\n\nExplanation:\n Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the empty parenthesis pairs. And it will be \"1(2(4))(3)\".\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,4]\n\nOutput:\n \"1(2()(4))(3)\"\n\nExplanation:\n Almost the same as the first example, except the \n()\n after \n2\n is necessary to indicate the absence of a left child for \n2\n and the presence of a right child.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "String",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 598,
    "slug": "range-addition-ii",
    "url": "https://leetcode.com/problems/range-addition-ii/",
    "titulo": "Range Addition II",
    "enunciado": "You are given an \nm x n\n matrix \nM\n initialized with all \n0\n's and an array of operations \nops\n, where \nops[i] = [a\ni\n, b\ni\n]\n means \nM[x][y]\n should be incremented by one for all \n0 <= x < a\ni\n and \n0 <= y < b\ni\n.\n\n\nCount and return \nthe number of maximum integers in the matrix after performing all the operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 3, ops = [[2,2],[3,3]]\n\nOutput:\n 4\n\nExplanation:\n The maximum integer in M is 2, and there are four of it in M. So return 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n m = 3, n = 3, ops = []\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 4 * 10\n4\n\n\n0 <= ops.length <= 10\n4\n\n\nops[i].length == 2\n\n\n1 <= a\ni\n <= m\n\n\n1 <= b\ni\n <= n",
    "temas": [
      "Array",
      "Math"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 587,
    "slug": "erect-the-fence",
    "url": "https://leetcode.com/problems/erect-the-fence/",
    "titulo": "Erect the Fence",
    "enunciado": "You are given an array \ntrees\n where \ntrees[i] = [x\ni\n, y\ni\n]\n represents the location of a tree in the garden.\n\n\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if \nall the trees are enclosed\n.\n\n\nReturn \nthe coordinates of trees that are exactly located on the fence perimeter\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n\nOutput:\n [[1,1],[2,0],[4,2],[3,3],[2,4]]\n\nExplanation:\n All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n trees = [[1,2],[2,2],[4,2]]\n\nOutput:\n [[4,2],[2,2],[1,2]]\n\nExplanation:\n The fence forms a line that passes through all the trees.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= trees.length <= 3000\n\n\ntrees[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 100\n\n\nAll the given positions are \nunique\n.",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 576,
    "slug": "out-of-boundary-paths",
    "url": "https://leetcode.com/problems/out-of-boundary-paths/",
    "titulo": "Out of Boundary Paths",
    "enunciado": "There is an \nm x n\n grid with a ball. The ball is initially at the position \n[startRow, startColumn]\n. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply \nat most\n \nmaxMove\n moves to the ball.\n\n\nGiven the five integers \nm\n, \nn\n, \nmaxMove\n, \nstartRow\n, \nstartColumn\n, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n\nOutput:\n 12\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 50\n\n\n0 <= maxMove <= 50\n\n\n0 <= startRow < m\n\n\n0 <= startColumn < n",
    "temas": [
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 572,
    "slug": "subtree-of-another-tree",
    "url": "https://leetcode.com/problems/subtree-of-another-tree/",
    "titulo": "Subtree of Another Tree",
    "enunciado": "Given the roots of two binary trees \nroot\n and \nsubRoot\n, return \ntrue\n if there is a subtree of \nroot\n with the same structure and node values of\n subRoot\n and \nfalse\n otherwise.\n\n\nA subtree of a binary tree \ntree\n is a tree that consists of a node in \ntree\n and all of this node's descendants. The tree \ntree\n could also be considered as a subtree of itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,4,5,1,2], subRoot = [4,1,2]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the \nroot\n tree is in the range \n[1, 2000]\n.\n\n\nThe number of nodes in the \nsubRoot\n tree is in the range \n[1, 1000]\n.\n\n\n-10\n4\n <= root.val <= 10\n4\n\n\n-10\n4\n <= subRoot.val <= 10\n4",
    "temas": [
      "Tree",
      "Depth-First Search",
      "String Matching",
      "Binary Tree",
      "Hash Function"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 566,
    "slug": "reshape-the-matrix",
    "url": "https://leetcode.com/problems/reshape-the-matrix/",
    "titulo": "Reshape the Matrix",
    "enunciado": "In MATLAB, there is a handy function called \nreshape\n which can reshape an \nm x n\n matrix into a new one with a different size \nr x c\n keeping its original data.\n\n\nYou are given an \nm x n\n matrix \nmat\n and two integers \nr\n and \nc\n representing the number of rows and the number of columns of the wanted reshaped matrix.\n\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\n\nIf the \nreshape\n operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,2],[3,4]], r = 1, c = 4\n\nOutput:\n [[1,2,3,4]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[1,2],[3,4]], r = 2, c = 4\n\nOutput:\n [[1,2],[3,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 100\n\n\n-1000 <= mat[i][j] <= 1000\n\n\n1 <= r, c <= 300",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 563,
    "slug": "binary-tree-tilt",
    "url": "https://leetcode.com/problems/binary-tree-tilt/",
    "titulo": "Binary Tree Tilt",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe sum of every tree node's \ntilt\n.\n\n\nThe \ntilt\n of a tree node is the \nabsolute difference\n between the sum of all left subtree node \nvalues\n and all right subtree node \nvalues\n. If a node does not have a left child, then the sum of the left subtree node \nvalues\n is treated as \n0\n. The rule is similar if the node does not have a right child.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 1\n\nExplanation:\n \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,2,9,3,5,null,7]\n\nOutput:\n 15\n\nExplanation:\n \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [21,7,14,1,1,2,2,3,3]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 554,
    "slug": "brick-wall",
    "url": "https://leetcode.com/problems/brick-wall/",
    "titulo": "Brick Wall",
    "enunciado": "There is a rectangular brick wall in front of you with \nn\n rows of bricks. The \ni\nth\n row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.\n\n\nDraw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\n\n\nGiven the 2D array \nwall\n that contains the information about the wall, return \nthe minimum number of crossed bricks after drawing such a vertical line\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n wall = [[1],[1],[1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == wall.length\n\n\n1 <= n <= 10\n4\n\n\n1 <= wall[i].length <= 10\n4\n\n\n1 <= sum(wall[i].length) <= 2 * 10\n4\n\n\nsum(wall[i])\n is the same for each row \ni\n.\n\n\n1 <= wall[i][j] <= 2\n31\n - 1",
    "temas": [
      "Array",
      "Hash Table"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 547,
    "slug": "number-of-provinces",
    "url": "https://leetcode.com/problems/number-of-provinces/",
    "titulo": "Number of Provinces",
    "enunciado": "There are \nn\n cities. Some of them are connected, while some are not. If city \na\n is connected directly with city \nb\n, and city \nb\n is connected directly with city \nc\n, then city \na\n is connected indirectly with city \nc\n.\n\n\nA \nprovince\n is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an \nn x n\n matrix \nisConnected\n where \nisConnected[i][j] = 1\n if the \ni\nth\n city and the \nj\nth\n city are directly connected, and \nisConnected[i][j] = 0\n otherwise.\n\n\nReturn \nthe total number of \nprovinces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn == isConnected.length\n\n\nn == isConnected[i].length\n\n\nisConnected[i][j]\n is \n1\n or \n0\n.\n\n\nisConnected[i][i] == 1\n\n\nisConnected[i][j] == isConnected[j][i]",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 543,
    "slug": "diameter-of-binary-tree",
    "url": "https://leetcode.com/problems/diameter-of-binary-tree/",
    "titulo": "Diameter of Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 542,
    "slug": "01-matrix",
    "url": "https://leetcode.com/problems/01-matrix/",
    "titulo": "01 Matrix",
    "enunciado": "Given an \nm x n\n binary matrix \nmat\n, return \nthe distance of the nearest \n0\n for each cell\n.\n\n\nThe distance between two cells sharing a common edge is \n1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,0],[0,0,0]]\n\nOutput:\n [[0,0,0],[0,1,0],[0,0,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,0],[1,1,1]]\n\nOutput:\n [[0,0,0],[0,1,0],[1,2,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 10\n4\n\n\n1 <= m * n <= 10\n4\n\n\nmat[i][j]\n is either \n0\n or \n1\n.\n\n\nThere is at least one \n0\n in \nmat\n.\n\n\n\n\n \n\n\nNote:\n This question is the same as 1765: \nhttps://leetcode.com/problems/map-of-highest-peak/",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 538,
    "slug": "convert-bst-to-greater-tree",
    "url": "https://leetcode.com/problems/convert-bst-to-greater-tree/",
    "titulo": "Convert BST to Greater Tree",
    "enunciado": "Given the \nroot\n of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n\n\nAs a reminder, a \nbinary search tree\n is a tree that satisfies these constraints:\n\n\n\n\nThe left subtree of a node contains only nodes with keys \nless than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \ngreater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n\nOutput:\n [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0,null,1]\n\nOutput:\n [1,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nAll the values in the tree are \nunique\n.\n\n\nroot\n is guaranteed to be a valid binary search tree.\n\n\n\n\n \n\n\nNote:\n This question is the same as 1038: \nhttps://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 530,
    "slug": "minimum-absolute-difference-in-bst",
    "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
    "titulo": "Minimum Absolute Difference in BST",
    "enunciado": "Given the \nroot\n of a Binary Search Tree (BST), return \nthe minimum absolute difference between the values of any two different nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,48,null,null,12,49]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nNote:\n This question is the same as 783: \nhttps://leetcode.com/problems/minimum-distance-between-bst-nodes/",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 529,
    "slug": "minesweeper",
    "url": "https://leetcode.com/problems/minesweeper/",
    "titulo": "Minesweeper",
    "enunciado": "Let's play the minesweeper game (\nWikipedia\n, \nonline game\n)!\n\n\nYou are given an \nm x n\n char matrix \nboard\n representing the game board where:\n\n\n\n\n'M'\n represents an unrevealed mine,\n\n\n'E'\n represents an unrevealed empty square,\n\n\n'B'\n represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),\n\n\ndigit (\n'1'\n to \n'8'\n) represents how many mines are adjacent to this revealed square, and\n\n\n'X'\n represents a revealed mine.\n\n\n\n\nYou are also given an integer array \nclick\n where \nclick = [click\nr\n, click\nc\n]\n represents the next click position among all the unrevealed squares (\n'M'\n or \n'E'\n).\n\n\nReturn \nthe board after revealing this position according to the following rules\n:\n\n\n\n\nIf a mine \n'M'\n is revealed, then the game is over. You should change it to \n'X'\n.\n\n\nIf an empty square \n'E'\n with no adjacent mines is revealed, then change it to a revealed blank \n'B'\n and all of its adjacent unrevealed squares should be revealed recursively.\n\n\nIf an empty square \n'E'\n with at least one adjacent mine is revealed, then change it to a digit (\n'1'\n to \n'8'\n) representing the number of adjacent mines.\n\n\nReturn the board when no more squares will be revealed.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n\nOutput:\n [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n\nOutput:\n [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 50\n\n\nboard[i][j]\n is either \n'M'\n, \n'E'\n, \n'B'\n, or a digit from \n'1'\n to \n'8'\n.\n\n\nclick.length == 2\n\n\n0 <= click\nr\n < m\n\n\n0 <= click\nc\n < n\n\n\nboard[click\nr\n][click\nc\n]\n is either \n'M'\n or \n'E'\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1721,
    "slug": "swapping-nodes-in-a-linked-list",
    "url": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/",
    "titulo": "Swapping Nodes in a Linked List",
    "enunciado": "You are given the \nhead\n of a linked list, and an integer \nk\n.\n\n\nReturn \nthe head of the linked list after \nswapping\n the values of the \nk\nth\n \nnode from the beginning and the \nk\nth\n \nnode from the end (the list is \n1-indexed\n).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [1,4,3,2,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [7,9,6,6,7,8,3,0,9,5], k = 5\n\nOutput:\n [7,9,6,6,8,7,3,0,9,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 10\n5\n\n\n0 <= Node.val <= 100",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 515,
    "slug": "find-largest-value-in-each-tree-row",
    "url": "https://leetcode.com/problems/find-largest-value-in-each-tree-row/",
    "titulo": "Find Largest Value in Each Tree Row",
    "enunciado": "Given the \nroot\n of a binary tree, return \nan array of the largest value in each row\n of the tree \n(0-indexed)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5,3,null,9]\n\nOutput:\n [1,3,9]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n [1,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree will be in the range \n[0, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 514,
    "slug": "freedom-trail",
    "url": "https://leetcode.com/problems/freedom-trail/",
    "titulo": "Freedom Trail",
    "enunciado": "In the video game Fallout 4, the quest \n\"Road to Freedom\"\n requires players to reach a metal dial called the \n\"Freedom Trail Ring\"\n and use the dial to spell a specific keyword to open the door.\n\n\nGiven a string \nring\n that represents the code engraved on the outer ring and another string \nkey\n that represents the keyword that needs to be spelled, return \nthe minimum number of steps to spell all the characters in the keyword\n.\n\n\nInitially, the first character of the ring is aligned at the \n\"12:00\"\n direction. You should spell all the characters in \nkey\n one by one by rotating \nring\n clockwise or anticlockwise to make each character of the string key aligned at the \n\"12:00\"\n direction and then by pressing the center button.\n\n\nAt the stage of rotating the ring to spell the key character \nkey[i]\n:\n\n\n\n\nYou can rotate the ring clockwise or anticlockwise by one place, which counts as \none step\n. The final purpose of the rotation is to align one of \nring\n's characters at the \n\"12:00\"\n direction, where this character must equal \nkey[i]\n.\n\n\nIf the character \nkey[i]\n has been aligned at the \n\"12:00\"\n direction, press the center button to spell, which also counts as \none step\n. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n ring = \"godding\", key = \"gd\"\n\nOutput:\n 4\n\nExplanation:\n\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n ring = \"godding\", key = \"godding\"\n\nOutput:\n 13\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= ring.length, key.length <= 100\n\n\nring\n and \nkey\n consist of only lower case English letters.\n\n\nIt is guaranteed that \nkey\n could always be spelled by rotating \nring\n.",
    "temas": [
      "String",
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 513,
    "slug": "find-bottom-left-tree-value",
    "url": "https://leetcode.com/problems/find-bottom-left-tree-value/",
    "titulo": "Find Bottom Left Tree Value",
    "enunciado": "Given the \nroot\n of a binary tree, return the leftmost value in the last row of the tree.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,null,5,6,null,null,7]\n\nOutput:\n 7\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 508,
    "slug": "most-frequent-subtree-sum",
    "url": "https://leetcode.com/problems/most-frequent-subtree-sum/",
    "titulo": "Most Frequent Subtree Sum",
    "enunciado": "Given the \nroot\n of a binary tree, return the most frequent \nsubtree sum\n. If there is a tie, return all the values with the highest frequency in any order.\n\n\nThe \nsubtree sum\n of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,2,-3]\n\nOutput:\n [2,-3,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,2,-5]\n\nOutput:\n [2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5",
    "temas": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 501,
    "slug": "find-mode-in-binary-search-tree",
    "url": "https://leetcode.com/problems/find-mode-in-binary-search-tree/",
    "titulo": "Find Mode in Binary Search Tree",
    "enunciado": "Given the \nroot\n of a binary search tree (BST) with duplicates, return \nall the \nmode(s)\n (i.e., the most frequently occurred element) in it\n.\n\n\nIf the tree has more than one mode, return them in \nany order\n.\n\n\nAssume a BST is defined as follows:\n\n\n\n\nThe left subtree of a node contains only nodes with keys \nless than or equal to\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \ngreater than or equal to\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,null,2,2]\n\nOutput:\n [2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 500,
    "slug": "keyboard-row",
    "url": "https://leetcode.com/problems/keyboard-row/",
    "titulo": "Keyboard Row",
    "enunciado": "Given an array of strings \nwords\n, return \nthe words that can be typed using letters of the alphabet on only one row of American keyboard like the image below\n.\n\n\nNote\n that the strings are \ncase-insensitive\n, both lowercased and uppercased of the same letter are treated as if they are at the same row.\n\n\nIn the \nAmerican keyboard\n:\n\n\n\n\nthe first row consists of the characters \n\"qwertyuiop\"\n,\n\n\nthe second row consists of the characters \n\"asdfghjkl\"\n, and\n\n\nthe third row consists of the characters \n\"zxcvbnm\"\n.\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nwords = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\n\n\nOutput:\n \n[\"Alaska\",\"Dad\"]\n\n\nExplanation:\n\n\nBoth \n\"a\"\n and \n\"A\"\n are in the 2nd row of the American keyboard due to case insensitivity.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nwords = [\"omk\"]\n\n\nOutput:\n \n[]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nwords = [\"adsdf\",\"sfd\"]\n\n\nOutput:\n \n[\"adsdf\",\"sfd\"]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 20\n\n\n1 <= words[i].length <= 100\n\n\nwords[i]\n consists of English letters (both lowercase and uppercase).",
    "temas": [
      "Array",
      "Hash Table",
      "String"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 498,
    "slug": "diagonal-traverse",
    "url": "https://leetcode.com/problems/diagonal-traverse/",
    "titulo": "Diagonal Traverse",
    "enunciado": "Given an \nm x n\n matrix \nmat\n, return \nan array of all the elements of the array in a diagonal order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,4,7,5,3,6,8,9]\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[1,2],[3,4]]\n\nOutput:\n [1,2,3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 10\n4\n\n\n1 <= m * n <= 10\n4\n\n\n-10\n5\n <= mat[i][j] <= 10\n5",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 1643,
    "slug": "kth-smallest-instructions",
    "url": "https://leetcode.com/problems/kth-smallest-instructions/",
    "titulo": "Kth Smallest Instructions",
    "enunciado": "Bob is standing at cell \n(0, 0)\n, and he wants to reach \ndestination\n: \n(row, column)\n. He can only travel \nright\n and \ndown\n. You are going to help Bob by providing \ninstructions\n for him to reach \ndestination\n.\n\n\nThe \ninstructions\n are represented as a string, where each character is either:\n\n\n\n\n'H'\n, meaning move horizontally (go \nright\n), or\n\n\n'V'\n, meaning move vertically (go \ndown\n).\n\n\n\n\nMultiple \ninstructions\n will lead Bob to \ndestination\n. For example, if \ndestination\n is \n(2, 3)\n, both \n\"HHHVV\"\n and \n\"HVHVH\"\n are valid \ninstructions\n.\n\n\nHowever, Bob is very picky. Bob has a lucky number \nk\n, and he wants the \nk\nth\n \nlexicographically smallest instructions\n that will lead him to \ndestination\n. \nk\n is \n1-indexed\n.\n\n\nGiven an integer array \ndestination\n and an integer \nk\n, return \nthe \nk\nth\n \nlexicographically smallest instructions\n that will take Bob to \ndestination\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n destination = [2,3], k = 1\n\nOutput:\n \"HHHVV\"\n\nExplanation:\n All the instructions that reach (2, 3) in lexicographic order are as follows:\n[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n destination = [2,3], k = 2\n\nOutput:\n \"HHVHV\"\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n destination = [2,3], k = 3\n\nOutput:\n \"HHVVH\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\ndestination.length == 2\n\n\n1 <= row, column <= 15\n\n\n1 <= k <= nCr(row + column, row)\n, where \nnCr(a, b)\n denotes \na\n choose \nb\n​​​​​.",
    "temas": [
      "Array",
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 473,
    "slug": "matchsticks-to-square",
    "url": "https://leetcode.com/problems/matchsticks-to-square/",
    "titulo": "Matchsticks to Square",
    "enunciado": "You are given an integer array \nmatchsticks\n where \nmatchsticks[i]\n is the length of the \ni\nth\n matchstick. You want to use \nall the matchsticks\n to make one square. You \nshould not break\n any stick, but you can link them up, and each matchstick must be used \nexactly one time\n.\n\n\nReturn \ntrue\n if you can make this square and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matchsticks = [1,1,2,2,2]\n\nOutput:\n true\n\nExplanation:\n You can form a square with length 2, one side of the square came two sticks with length 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matchsticks = [3,3,3,3,4]\n\nOutput:\n false\n\nExplanation:\n You cannot find a way to form a square with all the matchsticks.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= matchsticks.length <= 15\n\n\n1 <= matchsticks[i] <= 10\n8",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Backtracking",
      "Bit Manipulation",
      "Bitmask"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 463,
    "slug": "island-perimeter",
    "url": "https://leetcode.com/problems/island-perimeter/",
    "titulo": "Island Perimeter",
    "enunciado": "You are given \nrow x col\n \ngrid\n representing a map where \ngrid[i][j] = 1\n represents land and \ngrid[i][j] = 0\n represents water.\n\n\nGrid cells are connected \nhorizontally/vertically\n (not diagonally). The \ngrid\n is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\n\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n\nOutput:\n 16\n\nExplanation:\n The perimeter is the 16 yellow stripes in the image above.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrow == grid.length\n\n\ncol == grid[i].length\n\n\n1 <= row, col <= 100\n\n\ngrid[i][j]\n is \n0\n or \n1\n.\n\n\nThere is exactly one island in \ngrid\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 457,
    "slug": "circular-array-loop",
    "url": "https://leetcode.com/problems/circular-array-loop/",
    "titulo": "Circular Array Loop",
    "enunciado": "You are playing a game involving a \ncircular\n array of non-zero integers \nnums\n. Each \nnums[i]\n denotes the number of indices forward/backward you must move if you are located at index \ni\n:\n\n\n\n\nIf \nnums[i]\n is positive, move \nnums[i]\n steps \nforward\n, and\n\n\nIf \nnums[i]\n is negative, move \nnums[i]\n steps \nbackward\n.\n\n\n\n\nSince the array is \ncircular\n, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.\n\n\nA \ncycle\n in the array consists of a sequence of indices \nseq\n of length \nk\n where:\n\n\n\n\nFollowing the movement rules above results in the repeating index sequence \nseq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...\n\n\nEvery \nnums[seq[j]]\n is either \nall positive\n or \nall negative\n.\n\n\nk > 1\n\n\n\n\nReturn \ntrue\n if there is a \ncycle\n in \nnums\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [2,-1,1,2,2]\n\nOutput:\n true\n\nExplanation:\n The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --> 2 --> 3 --> 0 --> ..., and all of its nodes are white (jumping in the same direction).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [-1,-2,-3,-4,-5,6]\n\nOutput:\n false\n\nExplanation:\n The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nThe only cycle is of size 1, so we return false.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n nums = [1,-1,5,1,4]\n\nOutput:\n true\n\nExplanation:\n The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --> 1 --> 0 --> ..., and while it is of size > 1, it has a node jumping forward and a node jumping backward, so \nit is not a cycle\n.\nWe can see the cycle 3 --> 4 --> 3 --> ..., and all of its nodes are white (jumping in the same direction).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-1000 <= nums[i] <= 1000\n\n\nnums[i] != 0\n\n\n\n\n \n\n\nFollow up:\n Could you solve it in \nO(n)\n time complexity and \nO(1)\n extra space complexity?",
    "temas": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 450,
    "slug": "delete-node-in-a-bst",
    "url": "https://leetcode.com/problems/delete-node-in-a-bst/",
    "titulo": "Delete Node in a BST",
    "enunciado": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return \nthe \nroot node reference\n (possibly updated) of the BST\n.\n\n\nBasically, the deletion can be divided into two stages:\n\n\n\n\nSearch for a node to remove.\n\n\nIf the node is found, delete the node.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,7], key = 3\n\nOutput:\n [5,4,6,2,null,null,7]\n\nExplanation:\n Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the above BST.\nPlease notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,7], key = 0\n\nOutput:\n [5,3,6,2,4,null,7]\n\nExplanation:\n The tree does not contain a node with value = 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [], key = 0\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\nEach node has a \nunique\n value.\n\n\nroot\n is a valid binary search tree.\n\n\n-10\n5\n <= key <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n Could you solve it with time complexity \nO(height of tree)\n?",
    "temas": [
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 445,
    "slug": "add-two-numbers-ii",
    "url": "https://leetcode.com/problems/add-two-numbers-ii/",
    "titulo": "Add Two Numbers II",
    "enunciado": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [7,2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,8,0,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [8,0,7]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without reversing the input lists?",
    "temas": [
      "Linked List",
      "Math",
      "Stack"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 441,
    "slug": "arranging-coins",
    "url": "https://leetcode.com/problems/arranging-coins/",
    "titulo": "Arranging Coins",
    "enunciado": "You have \nn\n coins and you want to build a staircase with these coins. The staircase consists of \nk\n rows where the \ni\nth\n row has exactly \ni\n coins. The last row of the staircase \nmay be\n incomplete.\n\n\nGiven the integer \nn\n, return \nthe number of \ncomplete rows\n of the staircase you will build\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 2\n\nExplanation:\n Because the 3\nrd\n row is incomplete, we return 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 8\n\nOutput:\n 3\n\nExplanation:\n Because the 4\nth\n row is incomplete, we return 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
    "temas": [
      "Math",
      "Binary Search"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 437,
    "slug": "path-sum-iii",
    "url": "https://leetcode.com/problems/path-sum-iii/",
    "titulo": "Path Sum III",
    "enunciado": "Given the \nroot\n of a binary tree and an integer \ntargetSum\n, return \nthe number of paths where the sum of the values along the path equals\n \ntargetSum\n.\n\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n\nOutput:\n 3\n\nExplanation:\n The paths that sum to 8 are shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 1000]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\n-1000 <= targetSum <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 419,
    "slug": "battleships-in-a-board",
    "url": "https://leetcode.com/problems/battleships-in-a-board/",
    "titulo": "Battleships in a Board",
    "enunciado": "Given an \nm x n\n matrix \nboard\n where each cell is a battleship \n'X'\n or empty \n'.'\n, return \nthe number of the \nbattleships\n on\n \nboard\n.\n\n\nBattleships\n can only be placed horizontally or vertically on \nboard\n. In other words, they can only be made of the shape \n1 x k\n (\n1\n row, \nk\n columns) or \nk x 1\n (\nk\n rows, \n1\n column), where \nk\n can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = [[\".\"]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 200\n\n\nboard[i][j]\n is either \n'.'\n or \n'X'\n.\n\n\n\n\n \n\n\nFollow up:\n Could you do it in one-pass, using only \nO(1)\n extra memory and without modifying the values \nboard\n?",
    "temas": [
      "Array",
      "Depth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 417,
    "slug": "pacific-atlantic-water-flow",
    "url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
    "titulo": "Pacific Atlantic Water Flow",
    "enunciado": "There is an \nm x n\n rectangular island that borders both the \nPacific Ocean\n and \nAtlantic Ocean\n. The \nPacific Ocean\n touches the island's left and top edges, and the \nAtlantic Ocean\n touches the island's right and bottom edges.\n\n\nThe island is partitioned into a grid of square cells. You are given an \nm x n\n integer matrix \nheights\n where \nheights[r][c]\n represents the \nheight above sea level\n of the cell at coordinate \n(r, c)\n.\n\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is \nless than or equal to\n the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\n\nReturn \na \n2D list\n of grid coordinates \nresult\n where \nresult[i] = [r\ni\n, c\ni\n]\n denotes that rain water can flow from cell \n(r\ni\n, c\ni\n)\n to \nboth\n the Pacific and Atlantic oceans\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n\nOutput:\n [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n\nExplanation:\n The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [[1]]\n\nOutput:\n [[0,0]]\n\nExplanation:\n The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == heights.length\n\n\nn == heights[r].length\n\n\n1 <= m, n <= 200\n\n\n0 <= heights[r][c] <= 10\n5",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 407,
    "slug": "trapping-rain-water-ii",
    "url": "https://leetcode.com/problems/trapping-rain-water-ii/",
    "titulo": "Trapping Rain Water II",
    "enunciado": "Given an \nm x n\n integer matrix \nheightMap\n representing the height of each unit cell in a 2D elevation map, return \nthe volume of water it can trap after raining\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n\nOutput:\n 4\n\nExplanation:\n After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n\nOutput:\n 10\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == heightMap.length\n\n\nn == heightMap[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= heightMap[i][j] <= 2 * 10\n4",
    "temas": [
      "Array",
      "Breadth-First Search",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 404,
    "slug": "sum-of-left-leaves",
    "url": "https://leetcode.com/problems/sum-of-left-leaves/",
    "titulo": "Sum of Left Leaves",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe sum of all left leaves.\n\n\nA \nleaf\n is a node with no children. A \nleft leaf\n is a leaf that is the left child of another node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n 24\n\nExplanation:\n There are two left leaves in the binary tree, with values 9 and 15 respectively.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 401,
    "slug": "binary-watch",
    "url": "https://leetcode.com/problems/binary-watch/",
    "titulo": "Binary Watch",
    "enunciado": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n\n\n\nFor example, the below binary watch reads \n\"4:51\"\n.\n\n\n\n\n\n\nGiven an integer \nturnedOn\n which represents the number of LEDs that are currently on (ignoring the PM), return \nall possible times the watch could represent\n. You may return the answer in \nany order\n.\n\n\nThe hour must not contain a leading zero.\n\n\n\n\nFor example, \n\"01:00\"\n is not valid. It should be \n\"1:00\"\n.\n\n\n\n\nThe minute must consist of two digits and may contain a leading zero.\n\n\n\n\nFor example, \n\"10:2\"\n is not valid. It should be \n\"10:02\"\n.\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n turnedOn = 1\n\nOutput:\n [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n\nExample 2:\n\n\nInput:\n turnedOn = 9\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= turnedOn <= 10",
    "temas": [
      "Backtracking",
      "Bit Manipulation"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Backtracking",
    "has_image": true
  },
  {
    "id": 391,
    "slug": "perfect-rectangle",
    "url": "https://leetcode.com/problems/perfect-rectangle/",
    "titulo": "Perfect Rectangle",
    "enunciado": "Given an array \nrectangles\n where \nrectangles[i] = [x\ni\n, y\ni\n, a\ni\n, b\ni\n]\n represents an axis-aligned rectangle. The bottom-left point of the rectangle is \n(x\ni\n, y\ni\n)\n and the top-right point of it is \n(a\ni\n, b\ni\n)\n.\n\n\nReturn \ntrue\n \nif all the rectangles together form an exact cover of a rectangular region\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n\nOutput:\n true\n\nExplanation:\n All 5 rectangles together form an exact cover of a rectangular region.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n\nOutput:\n false\n\nExplanation:\n Because there is a gap between the two rectangular regions.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n\nOutput:\n false\n\nExplanation:\n Because two of the rectangles overlap with each other.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= rectangles.length <= 2 * 10\n4\n\n\nrectangles[i].length == 4\n\n\n-10\n5\n <= x\ni\n < a\ni\n <= 10\n5\n\n\n-10\n5\n <= y\ni\n < b\ni\n <= 10\n5",
    "temas": [
      "Array",
      "Line Sweep"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 388,
    "slug": "longest-absolute-file-path",
    "url": "https://leetcode.com/problems/longest-absolute-file-path/",
    "titulo": "Longest Absolute File Path",
    "enunciado": "Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n\n\n\n\nHere, we have \ndir\n as the only directory in the root. \ndir\n contains two subdirectories, \nsubdir1\n and \nsubdir2\n. \nsubdir1\n contains a file \nfile1.ext\n and subdirectory \nsubsubdir1\n. \nsubdir2\n contains a subdirectory \nsubsubdir2\n, which contains a file \nfile2.ext\n.\n\n\nIn text form, it looks like this (with ⟶ representing the tab character):\n\n\n\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n\n\n\nIf we were to write this representation in code, it will look like this: \n\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n. Note that the \n'\\n'\n and \n'\\t'\n are the new-line and tab characters.\n\n\nEvery file and directory has a unique \nabsolute path\n in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by \n'/'s\n. Using the above example, the \nabsolute path\n to \nfile2.ext\n is \n\"dir/subdir2/subsubdir2/file2.ext\"\n. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form \nname.extension\n, where \nname\n and \nextension\n consist of letters, digits, and/or spaces.\n\n\nGiven a string \ninput\n representing the file system in the explained format, return \nthe length of the \nlongest absolute path\n to a \nfile\n in the abstracted file system\n. If there is no file in the system, return \n0\n.\n\n\nNote\n that the testcases are generated such that the file system is valid and no file or directory name has length 0.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"\n\nOutput:\n 20\n\nExplanation:\n We have only one file, and the absolute path is \"dir/subdir2/file.ext\" of length 20.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n\nOutput:\n 32\n\nExplanation:\n We have two files:\n\"dir/subdir1/file1.ext\" of length 21\n\"dir/subdir2/subsubdir2/file2.ext\" of length 32.\nWe return 32 since it is the longest absolute path to a file.\n\n\n\nExample 3:\n\n\n\n\nInput:\n input = \"a\"\n\nOutput:\n 0\n\nExplanation:\n We do not have any files, just a single directory named \"a\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= input.length <= 10\n4\n\n\ninput\n may contain lowercase or uppercase English letters, a new line character \n'\\n'\n, a tab character \n'\\t'\n, a dot \n'.'\n, a space \n' '\n, and digits.\n\n\nAll file and directory names have \npositive\n length.",
    "temas": [
      "String",
      "Stack",
      "Depth-First Search"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 382,
    "slug": "linked-list-random-node",
    "url": "https://leetcode.com/problems/linked-list-random-node/",
    "titulo": "Linked List Random Node",
    "enunciado": "Given a singly linked list, return a random node's value from the linked list. Each node must have the \nsame probability\n of being chosen.\n\n\nImplement the \nSolution\n class:\n\n\n\n\nSolution(ListNode head)\n Initializes the object with the head of the singly-linked list \nhead\n.\n\n\nint getRandom()\n Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"]\n[[[1, 2, 3]], [], [], [], [], []]\n\nOutput\n\n[null, 1, 3, 2, 2, 3]\n\n\nExplanation\n\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // return 1\nsolution.getRandom(); // return 3\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 3\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the linked list will be in the range \n[1, 10\n4\n]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nAt most \n10\n4\n calls will be made to \ngetRandom\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nWhat if the linked list is extremely large and its length is unknown to you?\n\n\nCould you solve this efficiently without using extra space?",
    "temas": [
      "Linked List",
      "Math",
      "Reservoir Sampling",
      "Randomized"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 375,
    "slug": "guess-number-higher-or-lower-ii",
    "url": "https://leetcode.com/problems/guess-number-higher-or-lower-ii/",
    "titulo": "Guess Number Higher or Lower II",
    "enunciado": "We are playing the Guessing Game. The game will work as follows:\n\n\n\n\nI pick a number between \n1\n and \nn\n.\n\n\nYou guess a number.\n\n\nIf you guess the right number, \nyou win the game\n.\n\n\nIf you guess the wrong number, then I will tell you whether the number I picked is \nhigher or lower\n, and you will continue guessing.\n\n\nEvery time you guess a wrong number \nx\n, you will pay \nx\n dollars. If you run out of money, \nyou lose the game\n.\n\n\n\n\nGiven a particular \nn\n, return \nthe minimum amount of money you need to \nguarantee a win regardless of what number I pick\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 10\n\nOutput:\n 16\n\nExplanation:\n The winning strategy is as follows:\n- The range is [1,10]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is [8,10]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is [1,6]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is [4,6]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is [1,2]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 0\n\nExplanation:\n There is only one possible number, so you can guess 1 and not have to pay anything.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Game Theory"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 363,
    "slug": "max-sum-of-rectangle-no-larger-than-k",
    "url": "https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/",
    "titulo": "Max Sum of Rectangle No Larger Than K",
    "enunciado": "Given an \nm x n\n matrix \nmatrix\n and an integer \nk\n, return \nthe max sum of a rectangle in the matrix such that its sum is no larger than\n \nk\n.\n\n\nIt is \nguaranteed\n that there will be a rectangle with a sum no larger than \nk\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,0,1],[0,-2,3]], k = 2\n\nOutput:\n 2\n\nExplanation:\n Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[2,2,-1]], k = 3\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-100 <= matrix[i][j] <= 100\n\n\n-10\n5\n <= k <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n What if the number of rows is much larger than the number of columns?",
    "temas": [
      "Array",
      "Binary Search",
      "Matrix",
      "Prefix Sum",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 337,
    "slug": "house-robber-iii",
    "url": "https://leetcode.com/problems/house-robber-iii/",
    "titulo": "House Robber III",
    "enunciado": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called \nroot\n.\n\n\nBesides the \nroot\n, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if \ntwo directly-linked houses were broken into on the same night\n.\n\n\nGiven the \nroot\n of the binary tree, return \nthe maximum amount of money the thief can rob \nwithout alerting the police\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,2,3,null,3,null,1]\n\nOutput:\n 7\n\nExplanation:\n Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,4,5,1,3,null,1]\n\nOutput:\n 9\n\nExplanation:\n Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 335,
    "slug": "self-crossing",
    "url": "https://leetcode.com/problems/self-crossing/",
    "titulo": "Self Crossing",
    "enunciado": "You are given an array of integers \ndistance\n.\n\n\nYou start at the point \n(0, 0)\n on an \nX-Y plane,\n and you move \ndistance[0]\n meters to the north, then \ndistance[1]\n meters to the west, \ndistance[2]\n meters to the south, \ndistance[3]\n meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\n\nReturn \ntrue\n \nif your path crosses itself or \nfalse\n if it does not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n distance = [2,1,1,2]\n\nOutput:\n true\n\nExplanation:\n The path crosses itself at the point (0, 1).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n distance = [1,2,3,4]\n\nOutput:\n false\n\nExplanation:\n The path does not cross itself at any point.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n distance = [1,1,1,2,1]\n\nOutput:\n true\n\nExplanation:\n The path crosses itself at the point (0, 0).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= distance.length <= 10\n5\n\n\n1 <= distance[i] <= 10\n5",
    "temas": [
      "Array",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 332,
    "slug": "reconstruct-itinerary",
    "url": "https://leetcode.com/problems/reconstruct-itinerary/",
    "titulo": "Reconstruct Itinerary",
    "enunciado": "You are given a list of airline \ntickets\n where \ntickets[i] = [from\ni\n, to\ni\n]\n represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\n\nAll of the tickets belong to a man who departs from \n\"JFK\"\n, thus, the itinerary must begin with \n\"JFK\"\n. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n\n\n\nFor example, the itinerary \n[\"JFK\", \"LGA\"]\n has a smaller lexical order than \n[\"JFK\", \"LGB\"]\n.\n\n\n\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n\nOutput:\n [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n\nOutput:\n [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n\nExplanation:\n Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= tickets.length <= 300\n\n\ntickets[i].length == 2\n\n\nfrom\ni\n.length == 3\n\n\nto\ni\n.length == 3\n\n\nfrom\ni\n and \nto\ni\n consist of uppercase English letters.\n\n\nfrom\ni\n != to\ni",
    "temas": [
      "Depth-First Search",
      "Graph",
      "Eulerian Circuit"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 331,
    "slug": "verify-preorder-serialization-of-a-binary-tree",
    "url": "https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/",
    "titulo": "Verify Preorder Serialization of a Binary Tree",
    "enunciado": "One way to serialize a binary tree is to use \npreorder traversal\n. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as \n'#'\n.\n\n\n\n\nFor example, the above binary tree can be serialized to the string \n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n, where \n'#'\n represents a null node.\n\n\nGiven a string of comma-separated values \npreorder\n, return \ntrue\n if it is a correct preorder traversal serialization of a binary tree.\n\n\nIt is \nguaranteed\n that each comma-separated value in the string must be either an integer or a character \n'#'\n representing null pointer.\n\n\nYou may assume that the input format is always valid.\n\n\n\n\nFor example, it could never contain two consecutive commas, such as \n\"1,,3\"\n.\n\n\n\n\nNote: \nYou are not allowed to reconstruct the tree.\n\n\n \n\n\nExample 1:\n\n\nInput:\n preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n preorder = \"1,#\"\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n preorder = \"9,#,#,1\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= preorder.length <= 10\n4\n\n\npreorder\n consist of integers in the range \n[0, 100]\n and \n'#'\n separated by commas \n','\n.",
    "temas": [
      "String",
      "Stack",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 329,
    "slug": "longest-increasing-path-in-a-matrix",
    "url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",
    "titulo": "Longest Increasing Path in a Matrix",
    "enunciado": "Given an \nm x n\n integers \nmatrix\n, return \nthe length of the longest increasing path in \nmatrix\n.\n\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You \nmay not\n move \ndiagonally\n or move \noutside the boundary\n (i.e., wrap-around is not allowed).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[9,9,4],[6,6,8],[2,1,1]]\n\nOutput:\n 4\n\nExplanation:\n The longest increasing path is \n[1, 2, 6, 9]\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[3,4,5],[3,2,6],[2,2,1]]\n\nOutput:\n 4\n\nExplanation: \nThe longest increasing path is \n[3, 4, 5, 6]\n. Moving diagonally is not allowed.\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[1]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= matrix[i][j] <= 2\n31\n - 1",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 328,
    "slug": "odd-even-linked-list",
    "url": "https://leetcode.com/problems/odd-even-linked-list/",
    "titulo": "Odd Even Linked List",
    "enunciado": "Given the \nhead\n of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return \nthe reordered list\n.\n\n\nThe \nfirst\n node is considered \nodd\n, and the \nsecond\n node is \neven\n, and so on.\n\n\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\n\n\nYou must solve the problem in \nO(1)\n extra space complexity and \nO(n)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [1,3,5,2,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [2,1,3,5,6,4,7]\n\nOutput:\n [2,3,6,7,1,5,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the linked list is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n6\n <= Node.val <= 10\n6",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 319,
    "slug": "bulb-switcher",
    "url": "https://leetcode.com/problems/bulb-switcher/",
    "titulo": "Bulb Switcher",
    "enunciado": "There are \nn\n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the \ni\nth\n round, you toggle every \ni\n bulb. For the \nn\nth\n round, you only toggle the last bulb.\n\n\nReturn \nthe number of bulbs that are on after \nn\n rounds\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 1\n\nExplanation:\n At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n\n\nExample 2:\n\n\n\n\nInput:\n n = 0\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10\n9",
    "temas": [
      "Math",
      "Brainteaser"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 310,
    "slug": "minimum-height-trees",
    "url": "https://leetcode.com/problems/minimum-height-trees/",
    "titulo": "Minimum Height Trees",
    "enunciado": "A tree is an undirected graph in which any two vertices are connected by \nexactly\n one path. In other words, any connected graph without simple cycles is a tree.\n\n\nGiven a tree of \nn\n nodes labelled from \n0\n to \nn - 1\n, and an array of \nn - 1\n \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an undirected edge between the two nodes \na\ni\n and \nb\ni\n in the tree, you can choose any node of the tree as the root. When you select a node \nx\n as the root, the result tree has height \nh\n. Among all possible rooted trees, those with minimum height (i.e. \nmin(h)\n)  are called \nminimum height trees\n (MHTs).\n\n\nReturn \na list of all \nMHTs'\n root labels\n. You can return the answer in \nany order\n.\n\n\nThe \nheight\n of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[1,0],[1,2],[1,3]]\n\nOutput:\n [1]\n\nExplanation:\n As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n\nOutput:\n [3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n4\n\n\nedges.length == n - 1\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nAll the pairs \n(a\ni\n, b\ni\n)\n are distinct.\n\n\nThe given input is \nguaranteed\n to be a tree and there will be \nno repeated\n edges.",
    "temas": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "dificuldade": "Média",
    "tema_principal": "Depth-First Search",
    "has_image": true
  },
  {
    "id": 304,
    "slug": "range-sum-query-2d-immutable",
    "url": "https://leetcode.com/problems/range-sum-query-2d-immutable/",
    "titulo": "Range Sum Query 2D - Immutable",
    "enunciado": "Given a 2D matrix \nmatrix\n, handle multiple queries of the following type:\n\n\n\n\nCalculate the \nsum\n of the elements of \nmatrix\n inside the rectangle defined by its \nupper left corner\n \n(row1, col1)\n and \nlower right corner\n \n(row2, col2)\n.\n\n\n\n\nImplement the \nNumMatrix\n class:\n\n\n\n\nNumMatrix(int[][] matrix)\n Initializes the object with the integer matrix \nmatrix\n.\n\n\nint sumRegion(int row1, int col1, int row2, int col2)\n Returns the \nsum\n of the elements of \nmatrix\n inside the rectangle defined by its \nupper left corner\n \n(row1, col1)\n and \nlower right corner\n \n(row2, col2)\n.\n\n\n\n\nYou must design an algorithm where \nsumRegion\n works on \nO(1)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"NumMatrix\", \"sumRegion\", \"sumRegion\", \"sumRegion\"]\n[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\n\nOutput\n\n[null, 8, 11, 12]\n\n\nExplanation\n\nNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 200\n\n\n-10\n4\n <= matrix[i][j] <= 10\n4\n\n\n0 <= row1 <= row2 < m\n\n\n0 <= col1 <= col2 < n\n\n\nAt most \n10\n4\n calls will be made to \nsumRegion\n.",
    "temas": [
      "Array",
      "Design",
      "Matrix",
      "Prefix Sum"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 297,
    "slug": "serialize-and-deserialize-binary-tree",
    "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    "titulo": "Serialize and Deserialize Binary Tree",
    "enunciado": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n\nClarification:\n The input/output format is the same as \nhow LeetCode serializes a binary tree\n. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,null,4,5]\n\nOutput:\n [1,2,3,null,null,4,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "String",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 289,
    "slug": "game-of-life",
    "url": "https://leetcode.com/problems/game-of-life/",
    "titulo": "Game of Life",
    "enunciado": "According to \nWikipedia's article\n: \"The \nGame of Life\n, also known simply as \nLife\n, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n\n\nThe board is made up of an \nm x n\n grid of cells, where each cell has an initial state: \nlive\n (represented by a \n1\n) or \ndead\n (represented by a \n0\n). Each cell interacts with its \neight neighbors\n (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n\n\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\n\n\nAny live cell with two or three live neighbors lives on to the next generation.\n\n\nAny live cell with more than three live neighbors dies, as if by over-population.\n\n\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\n\n\n\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the \nm x n\n grid \nboard\n. In this process, births and deaths occur \nsimultaneously\n.\n\n\nGiven the current state of the \nboard\n, \nupdate\n the \nboard\n to reflect its next state.\n\n\nNote\n that you do not need to return anything.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n\nOutput:\n [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[1,1],[1,0]]\n\nOutput:\n [[1,1],[1,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 25\n\n\nboard[i][j]\n is \n0\n or \n1\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n\n\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 257,
    "slug": "binary-tree-paths",
    "url": "https://leetcode.com/problems/binary-tree-paths/",
    "titulo": "Binary Tree Paths",
    "enunciado": "Given the \nroot\n of a binary tree, return \nall root-to-leaf paths in \nany order\n.\n\n\nA \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,5]\n\nOutput:\n [\"1->2->5\",\"1->3\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [\"1\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "String",
      "Backtracking",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 240,
    "slug": "search-a-2d-matrix-ii",
    "url": "https://leetcode.com/problems/search-a-2d-matrix-ii/",
    "titulo": "Search a 2D Matrix II",
    "enunciado": "Write an efficient algorithm that searches for a value \ntarget\n in an \nm x n\n integer matrix \nmatrix\n. This matrix has the following properties:\n\n\n\n\nIntegers in each row are sorted in ascending from left to right.\n\n\nIntegers in each column are sorted in ascending from top to bottom.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= n, m <= 300\n\n\n-10\n9\n <= matrix[i][j] <= 10\n9\n\n\nAll the integers in each row are \nsorted\n in ascending order.\n\n\nAll the integers in each column are \nsorted\n in ascending order.\n\n\n-10\n9\n <= target <= 10\n9",
    "temas": [
      "Array",
      "Binary Search",
      "Divide and Conquer",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 237,
    "slug": "delete-node-in-a-linked-list",
    "url": "https://leetcode.com/problems/delete-node-in-a-linked-list/",
    "titulo": "Delete Node in a Linked List",
    "enunciado": "There is a singly-linked list \nhead\n and we want to delete a node \nnode\n in it.\n\n\nYou are given the node to be deleted \nnode\n. You will \nnot be given access\n to the first node of \nhead\n.\n\n\nAll the values of the linked list are \nunique\n, and it is guaranteed that the given node \nnode\n is not the last node in the linked list.\n\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\n\n\n\nThe value of the given node should not exist in the linked list.\n\n\nThe number of nodes in the linked list should decrease by one.\n\n\nAll the values before \nnode\n should be in the same order.\n\n\nAll the values after \nnode\n should be in the same order.\n\n\n\n\nCustom testing:\n\n\n\n\nFor the input, you should provide the entire linked list \nhead\n and the node to be given \nnode\n. \nnode\n should not be the last node of the list and should be an actual node in the list.\n\n\nWe will build the linked list and pass the node to your function.\n\n\nThe output will be the entire list after calling your function.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [4,5,1,9], node = 5\n\nOutput:\n [4,1,9]\n\nExplanation: \nYou are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [4,5,1,9], node = 1\n\nOutput:\n [4,5,9]\n\nExplanation: \nYou are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the given list is in the range \n[2, 1000]\n.\n\n\n-1000 <= Node.val <= 1000\n\n\nThe value of each node in the list is \nunique\n.\n\n\nThe \nnode\n to be deleted is \nin the list\n and is \nnot a tail\n node.",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 236,
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
    "titulo": "Lowest Common Ancestor of a Binary Tree",
    "enunciado": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 235,
    "slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "titulo": "Lowest Common Ancestor of a Binary Search Tree",
    "enunciado": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n\nOutput:\n 6\n\nExplanation:\n The LCA of nodes 2 and 8 is 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n\nOutput:\n 2\n\nExplanation:\n The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [2,1], p = 2, q = 1\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the BST.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 234,
    "slug": "palindrome-linked-list",
    "url": "https://leetcode.com/problems/palindrome-linked-list/",
    "titulo": "Palindrome Linked List",
    "enunciado": "Given the \nhead\n of a singly linked list, return \ntrue\n if it is a \npalindrome\n or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,2,1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 9\n\n\n\n\n \n\n\nFollow up:\n Could you do it in \nO(n)\n time and \nO(1)\n space?",
    "temas": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 230,
    "slug": "kth-smallest-element-in-a-bst",
    "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
    "titulo": "Kth Smallest Element in a BST",
    "enunciado": "Given the \nroot\n of a binary search tree, and an integer \nk\n, return \nthe\n \nk\nth\n \nsmallest value (\n1-indexed\n) of all the values of the nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,2], k = 1\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,null,1], k = 3\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= k <= n <= 10\n4\n\n\n0 <= Node.val <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 226,
    "slug": "invert-binary-tree",
    "url": "https://leetcode.com/problems/invert-binary-tree/",
    "titulo": "Invert Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, invert the tree, and return \nits root\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3,6,9]\n\nOutput:\n [4,7,2,9,6,3,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n [2,3,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 223,
    "slug": "rectangle-area",
    "url": "https://leetcode.com/problems/rectangle-area/",
    "titulo": "Rectangle Area",
    "enunciado": "Given the coordinates of two \nrectilinear\n rectangles in a 2D plane, return \nthe total area covered by the two rectangles\n.\n\n\nThe first rectangle is defined by its \nbottom-left\n corner \n(ax1, ay1)\n and its \ntop-right\n corner \n(ax2, ay2)\n.\n\n\nThe second rectangle is defined by its \nbottom-left\n corner \n(bx1, by1)\n and its \ntop-right\n corner \n(bx2, by2)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n\nOutput:\n 45\n\n\n\nExample 2:\n\n\n\n\nInput:\n ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n\nOutput:\n 16\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-10\n4\n <= ax1 <= ax2 <= 10\n4\n\n\n-10\n4\n <= ay1 <= ay2 <= 10\n4\n\n\n-10\n4\n <= bx1 <= bx2 <= 10\n4\n\n\n-10\n4\n <= by1 <= by2 <= 10\n4",
    "temas": [
      "Math",
      "Geometry"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 222,
    "slug": "count-complete-tree-nodes",
    "url": "https://leetcode.com/problems/count-complete-tree-nodes/",
    "titulo": "Count Complete Tree Nodes",
    "enunciado": "Given the \nroot\n of a \ncomplete\n binary tree, return the number of the nodes in the tree.\n\n\nAccording to \nWikipedia\n, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between \n1\n and \n2\nh\n nodes inclusive at the last level \nh\n.\n\n\nDesign an algorithm that runs in less than \nO(n)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6]\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5 * 10\n4\n]\n.\n\n\n0 <= Node.val <= 5 * 10\n4\n\n\nThe tree is guaranteed to be \ncomplete\n.",
    "temas": [
      "Binary Search",
      "Bit Manipulation",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Binary Search",
    "has_image": true
  },
  {
    "id": 221,
    "slug": "maximal-square",
    "url": "https://leetcode.com/problems/maximal-square/",
    "titulo": "Maximal Square",
    "enunciado": "Given an \nm x n\n binary \nmatrix\n filled with \n0\n's and \n1\n's, \nfind the largest square containing only\n \n1\n's \nand return its area\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[\"0\"]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 300\n\n\nmatrix[i][j]\n is \n'0'\n or \n'1'\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 218,
    "slug": "the-skyline-problem",
    "url": "https://leetcode.com/problems/the-skyline-problem/",
    "titulo": "The Skyline Problem",
    "enunciado": "A city's \nskyline\n is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return \nthe \nskyline\n formed by these buildings collectively\n.\n\n\nThe geometric information of each building is given in the array \nbuildings\n where \nbuildings[i] = [left\ni\n, right\ni\n, height\ni\n]\n:\n\n\n\n\nleft\ni\n is the x coordinate of the left edge of the \ni\nth\n building.\n\n\nright\ni\n is the x coordinate of the right edge of the \ni\nth\n building.\n\n\nheight\ni\n is the height of the \ni\nth\n building.\n\n\n\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height \n0\n.\n\n\nThe \nskyline\n should be represented as a list of \"key points\" \nsorted by their x-coordinate\n in the form \n[[x\n1\n,y\n1\n],[x\n2\n,y\n2\n],...]\n. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate \n0\n and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n\nNote:\n There must be no consecutive horizontal lines of equal height in the output skyline. For instance, \n[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]\n is not acceptable; the three lines of height 5 should be merged into one in the final output as such: \n[...,[2 3],[4 5],[12 7],...]\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n\nOutput:\n [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n\nExplanation:\n\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n\n\nExample 2:\n\n\n\n\nInput:\n buildings = [[0,2,3],[2,5,3]]\n\nOutput:\n [[0,3],[5,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= buildings.length <= 10\n4\n\n\n0 <= left\ni\n < right\ni\n <= 2\n31\n - 1\n\n\n1 <= height\ni\n <= 2\n31\n - 1\n\n\nbuildings\n is sorted by \nleft\ni\n in non-decreasing order.",
    "temas": [
      "Array",
      "Divide and Conquer",
      "Binary Indexed Tree",
      "Segment Tree",
      "Line Sweep",
      "Heap (Priority Queue)",
      "Ordered Set"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 212,
    "slug": "word-search-ii",
    "url": "https://leetcode.com/problems/word-search-ii/",
    "titulo": "Word Search II",
    "enunciado": "Given an \nm x n\n \nboard\n of characters and a list of strings \nwords\n, return \nall words on the board\n.\n\n\nEach word must be constructed from letters of sequentially adjacent cells, where \nadjacent cells\n are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n\nOutput:\n [\"eat\",\"oath\"]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 12\n\n\nboard[i][j]\n is a lowercase English letter.\n\n\n1 <= words.length <= 3 * 10\n4\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nAll the strings of \nwords\n are unique.",
    "temas": [
      "Array",
      "String",
      "Backtracking",
      "Trie",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 206,
    "slug": "reverse-linked-list",
    "url": "https://leetcode.com/problems/reverse-linked-list/",
    "titulo": "Reverse Linked List",
    "enunciado": "Given the \nhead\n of a singly linked list, reverse the list, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [5,4,3,2,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n [2,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is the range \n[0, 5000]\n.\n\n\n-5000 <= Node.val <= 5000\n\n\n\n\n \n\n\nFollow up:\n A linked list can be reversed either iteratively or recursively. Could you implement both?",
    "temas": [
      "Linked List",
      "Recursion"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 203,
    "slug": "remove-linked-list-elements",
    "url": "https://leetcode.com/problems/remove-linked-list-elements/",
    "titulo": "Remove Linked List Elements",
    "enunciado": "Given the \nhead\n of a linked list and an integer \nval\n, remove all the nodes of the linked list that has \nNode.val == val\n, and return \nthe new head\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,6,3,4,5,6], val = 6\n\nOutput:\n [1,2,3,4,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [], val = 1\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [7,7,7,7], val = 7\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 10\n4\n]\n.\n\n\n1 <= Node.val <= 50\n\n\n0 <= val <= 50",
    "temas": [
      "Linked List",
      "Recursion"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 199,
    "slug": "binary-tree-right-side-view",
    "url": "https://leetcode.com/problems/binary-tree-right-side-view/",
    "titulo": "Binary Tree Right Side View",
    "enunciado": "Given the \nroot\n of a binary tree, imagine yourself standing on the \nright side\n of it, return \nthe values of the nodes you can see ordered from top to bottom\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,2,3,null,5,null,4]\n\n\nOutput:\n \n[1,3,4]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,null,null,null,5]\n\n\nOutput:\n \n[1,3,4,5]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = [1,null,3]\n\n\nOutput:\n \n[1,3]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 174,
    "slug": "dungeon-game",
    "url": "https://leetcode.com/problems/dungeon-game/",
    "titulo": "Dungeon Game",
    "enunciado": "The demons had captured the princess and imprisoned her in \nthe bottom-right corner\n of a \ndungeon\n. The \ndungeon\n consists of \nm x n\n rooms laid out in a 2D grid. Our valiant knight was initially positioned in \nthe top-left room\n and must fight his way through \ndungeon\n to rescue the princess.\n\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to \n0\n or below, he dies immediately.\n\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\n\nTo reach the princess as quickly as possible, the knight decides to move only \nrightward\n or \ndownward\n in each step.\n\n\nReturn \nthe knight's minimum initial health so that he can rescue the princess\n.\n\n\nNote\n that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n\nOutput:\n 7\n\nExplanation:\n The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n\n\nExample 2:\n\n\n\n\nInput:\n dungeon = [[0]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == dungeon.length\n\n\nn == dungeon[i].length\n\n\n1 <= m, n <= 200\n\n\n-1000 <= dungeon[i][j] <= 1000",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 173,
    "slug": "binary-search-tree-iterator",
    "url": "https://leetcode.com/problems/binary-search-tree-iterator/",
    "titulo": "Binary Search Tree Iterator",
    "enunciado": "Implement the \nBSTIterator\n class that represents an iterator over the \nin-order traversal\n of a binary search tree (BST):\n\n\n\n\nBSTIterator(TreeNode root)\n Initializes an object of the \nBSTIterator\n class. The \nroot\n of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\n\nboolean hasNext()\n Returns \ntrue\n if there exists a number in the traversal to the right of the pointer, otherwise returns \nfalse\n.\n\n\nint next()\n Moves the pointer to the right, then returns the number at the pointer.\n\n\n\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to \nnext()\n will return the smallest element in the BST.\n\n\nYou may assume that \nnext()\n calls will always be valid. That is, there will be at least a next number in the in-order traversal when \nnext()\n is called.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n\nOutput\n\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n\nExplanation\n\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 10\n6\n\n\nAt most \n10\n5\n calls will be made to \nhasNext\n, and \nnext\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you implement \nnext()\n and \nhasNext()\n to run in average \nO(1)\n time and use \nO(h)\n memory, where \nh\n is the height of the tree?",
    "temas": [
      "Stack",
      "Tree",
      "Design",
      "Binary Search Tree",
      "Binary Tree",
      "Iterator"
    ],
    "dificuldade": "Média",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 160,
    "slug": "intersection-of-two-linked-lists",
    "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/",
    "titulo": "Intersection of Two Linked Lists",
    "enunciado": "Given the heads of two singly linked-lists \nheadA\n and \nheadB\n, return \nthe node at which the two lists intersect\n. If the two linked lists have no intersection at all, return \nnull\n.\n\n\nFor example, the following two linked lists begin to intersect at node \nc1\n:\n\n\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n\nNote\n that the linked lists must \nretain their original structure\n after the function returns.\n\n\nCustom Judge:\n\n\nThe inputs to the \njudge\n are given as follows (your program is \nnot\n given these inputs):\n\n\n\n\nintersectVal\n - The value of the node where the intersection occurs. This is \n0\n if there is no intersected node.\n\n\nlistA\n - The first linked list.\n\n\nlistB\n - The second linked list.\n\n\nskipA\n - The number of nodes to skip ahead in \nlistA\n (starting from the head) to get to the intersected node.\n\n\nskipB\n - The number of nodes to skip ahead in \nlistB\n (starting from the head) to get to the intersected node.\n\n\n\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, \nheadA\n and \nheadB\n to your program. If you correctly return the intersected node, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\nOutput:\n Intersected at '8'\n\nExplanation:\n The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2\nnd\n node in A and 3\nrd\n node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3\nrd\n node in A and 4\nth\n node in B) point to the same location in memory.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\nOutput:\n Intersected at '2'\n\nExplanation:\n The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\nOutput:\n No intersection\n\nExplanation:\n From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes of \nlistA\n is in the \nm\n.\n\n\nThe number of nodes of \nlistB\n is in the \nn\n.\n\n\n1 <= m, n <= 3 * 10\n4\n\n\n1 <= Node.val <= 10\n5\n\n\n0 <= skipA <= m\n\n\n0 <= skipB <= n\n\n\nintersectVal\n is \n0\n if \nlistA\n and \nlistB\n do not intersect.\n\n\nintersectVal == listA[skipA] == listB[skipB]\n if \nlistA\n and \nlistB\n intersect.\n\n\n\n\n \n\n\nFollow up:\n Could you write a solution that runs in \nO(m + n)\n time and use only \nO(1)\n memory?",
    "temas": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 149,
    "slug": "max-points-on-a-line",
    "url": "https://leetcode.com/problems/max-points-on-a-line/",
    "titulo": "Max Points on a Line",
    "enunciado": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane, return \nthe maximum number of points that lie on the same straight line\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,1],[2,2],[3,3]]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 300\n\n\npoints[i].length == 2\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4\n\n\nAll the \npoints\n are \nunique\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 148,
    "slug": "sort-list",
    "url": "https://leetcode.com/problems/sort-list/",
    "titulo": "Sort List",
    "enunciado": "Given the \nhead\n of a linked list, return \nthe list after sorting it in \nascending order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [4,2,1,3]\n\nOutput:\n [1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [-1,5,3,4,0]\n\nOutput:\n [-1,0,3,4,5]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 5 * 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n Can you sort the linked list in \nO(n logn)\n time and \nO(1)\n memory (i.e. constant space)?",
    "temas": [
      "Linked List",
      "Two Pointers",
      "Divide and Conquer",
      "Sorting",
      "Merge Sort"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 147,
    "slug": "insertion-sort-list",
    "url": "https://leetcode.com/problems/insertion-sort-list/",
    "titulo": "Insertion Sort List",
    "enunciado": "Given the \nhead\n of a singly linked list, sort the list using \ninsertion sort\n, and return \nthe sorted list's head\n.\n\n\nThe steps of the \ninsertion sort\n algorithm:\n\n\n\n\nInsertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n\n\nAt each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n\n\nIt repeats until no input elements remain.\n\n\n\n\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [4,2,1,3]\n\nOutput:\n [1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [-1,5,3,4,0]\n\nOutput:\n [-1,0,3,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 5000]\n.\n\n\n-5000 <= Node.val <= 5000",
    "temas": [
      "Linked List",
      "Sorting"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 145,
    "slug": "binary-tree-postorder-traversal",
    "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    "titulo": "Binary Tree Postorder Traversal",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe postorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[3,2,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[4,6,7,5,2,9,8,3,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
    "temas": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 144,
    "slug": "binary-tree-preorder-traversal",
    "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
    "titulo": "Binary Tree Preorder Traversal",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe preorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[1,2,3]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[1,2,4,5,6,7,3,8,9]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
    "temas": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 143,
    "slug": "reorder-list",
    "url": "https://leetcode.com/problems/reorder-list/",
    "titulo": "Reorder List",
    "enunciado": "You are given the head of a singly linked-list. The list can be represented as:\n\n\n\nL\n0\n → L\n1\n → … → L\nn - 1\n → L\nn\n\n\n\n\nReorder the list to be on the following form:\n\n\n\nL\n0\n → L\nn\n → L\n1\n → L\nn - 1\n → L\n2\n → L\nn - 2\n → …\n\n\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4]\n\nOutput:\n [1,4,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [1,5,2,4,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 5 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 1000",
    "temas": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 142,
    "slug": "linked-list-cycle-ii",
    "url": "https://leetcode.com/problems/linked-list-cycle-ii/",
    "titulo": "Linked List Cycle II",
    "enunciado": "Given the \nhead\n of a linked list, return \nthe node where the cycle begins. If there is no cycle, return \nnull\n.\n\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the \nnext\n pointer. Internally, \npos\n is used to denote the index of the node that tail's \nnext\n pointer is connected to (\n0-indexed\n). It is \n-1\n if there is no cycle. \nNote that\n \npos\n \nis not passed as a parameter\n.\n\n\nDo not modify\n the linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [3,2,0,-4], pos = 1\n\nOutput:\n tail connects to node index 1\n\nExplanation:\n There is a cycle in the linked list, where tail connects to the second node.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2], pos = 0\n\nOutput:\n tail connects to node index 0\n\nExplanation:\n There is a cycle in the linked list, where tail connects to the first node.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1], pos = -1\n\nOutput:\n no cycle\n\nExplanation:\n There is no cycle in the linked list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the list is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\npos\n is \n-1\n or a \nvalid index\n in the linked-list.\n\n\n\n\n \n\n\nFollow up:\n Can you solve it using \nO(1)\n (i.e. constant) memory?",
    "temas": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 141,
    "slug": "linked-list-cycle",
    "url": "https://leetcode.com/problems/linked-list-cycle/",
    "titulo": "Linked List Cycle",
    "enunciado": "Given \nhead\n, the head of a linked list, determine if the linked list has a cycle in it.\n\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the \nnext\n pointer. Internally, \npos\n is used to denote the index of the node that tail's \nnext\n pointer is connected to. \nNote that \npos\n is not passed as a parameter\n.\n\n\nReturn \ntrue\n if there is a cycle in the linked list\n. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [3,2,0,-4], pos = 1\n\nOutput:\n true\n\nExplanation:\n There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2], pos = 0\n\nOutput:\n true\n\nExplanation:\n There is a cycle in the linked list, where the tail connects to the 0th node.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1], pos = -1\n\nOutput:\n false\n\nExplanation:\n There is no cycle in the linked list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the list is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\npos\n is \n-1\n or a \nvalid index\n in the linked-list.\n\n\n\n\n \n\n\nFollow up:\n Can you solve it using \nO(1)\n (i.e. constant) memory?",
    "temas": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 138,
    "slug": "copy-list-with-random-pointer",
    "url": "https://leetcode.com/problems/copy-list-with-random-pointer/",
    "titulo": "Copy List with Random Pointer",
    "enunciado": "A linked list of length \nn\n is given such that each node contains an additional random pointer, which could point to any node in the list, or \nnull\n.\n\n\nConstruct a \ndeep copy\n of the list. The deep copy should consist of exactly \nn\n \nbrand new\n nodes, where each new node has its value set to the value of its corresponding original node. Both the \nnext\n and \nrandom\n pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. \nNone of the pointers in the new list should point to nodes in the original list\n.\n\n\nFor example, if there are two nodes \nX\n and \nY\n in the original list, where \nX.random --> Y\n, then for the corresponding two nodes \nx\n and \ny\n in the copied list, \nx.random --> y\n.\n\n\nReturn \nthe head of the copied linked list\n.\n\n\nThe linked list is represented in the input/output as a list of \nn\n nodes. Each node is represented as a pair of \n[val, random_index]\n where:\n\n\n\n\nval\n: an integer representing \nNode.val\n\n\nrandom_index\n: the index of the node (range from \n0\n to \nn-1\n) that the \nrandom\n pointer points to, or \nnull\n if it does not point to any node.\n\n\n\n\nYour code will \nonly\n be given the \nhead\n of the original linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nOutput:\n [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [[1,1],[2,1]]\n\nOutput:\n [[1,1],[2,1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [[3,null],[3,0],[3,null]]\n\nOutput:\n [[3,null],[3,0],[3,null]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 1000\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nNode.random\n is \nnull\n or is pointing to some node in the linked list.",
    "temas": [
      "Hash Table",
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 133,
    "slug": "clone-graph",
    "url": "https://leetcode.com/problems/clone-graph/",
    "titulo": "Clone Graph",
    "enunciado": "Given a reference of a node in a \nconnected\n undirected graph.\n\n\nReturn a \ndeep copy\n (clone) of the graph.\n\n\nEach node in the graph contains a value (\nint\n) and a list (\nList[Node]\n) of its neighbors.\n\n\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\n\n \n\n\nTest case format:\n\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with \nval == 1\n, the second node with \nval == 2\n, and so on. The graph is represented in the test case using an adjacency list.\n\n\nAn adjacency list\n is a collection of unordered \nlists\n used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\n\nThe given node will always be the first node with \nval = 1\n. You must return the \ncopy of the given node\n as a reference to the cloned graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n adjList = [[2,4],[1,3],[2,4],[1,3]]\n\nOutput:\n [[2,4],[1,3],[2,4],[1,3]]\n\nExplanation:\n There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n adjList = [[]]\n\nOutput:\n [[]]\n\nExplanation:\n Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n\n\nExample 3:\n\n\n\n\nInput:\n adjList = []\n\nOutput:\n []\n\nExplanation:\n This an empty graph, it does not have any nodes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the graph is in the range \n[0, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nNode.val\n is unique for each node.\n\n\nThere are no repeated edges and no self-loops in the graph.\n\n\nThe Graph is connected and all nodes can be visited starting from the given node.",
    "temas": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 130,
    "slug": "surrounded-regions",
    "url": "https://leetcode.com/problems/surrounded-regions/",
    "titulo": "Surrounded Regions",
    "enunciado": "You are given an \nm x n\n matrix \nboard\n containing \nletters\n \n'X'\n and \n'O'\n, \ncapture regions\n that are \nsurrounded\n:\n\n\n\n\nConnect\n: A cell is connected to adjacent cells horizontally or vertically.\n\n\nRegion\n: To form a region \nconnect every\n \n'O'\n cell.\n\n\nSurround\n: The region is surrounded with \n'X'\n cells if you can \nconnect the region \nwith \n'X'\n cells and none of the region cells are on the edge of the \nboard\n.\n\n\n\n\nTo capture a \nsurrounded region\n, replace all \n'O'\ns with \n'X'\ns \nin-place\n within the original board. You do not need to return anything.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nboard = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n\n\nOutput:\n \n[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n\n\nExplanation:\n\n\n\n\nIn the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nboard = [[\"X\"]]\n\n\nOutput:\n \n[[\"X\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 200\n\n\nboard[i][j]\n is \n'X'\n or \n'O'\n.",
    "temas": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 129,
    "slug": "sum-root-to-leaf-numbers",
    "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/",
    "titulo": "Sum Root to Leaf Numbers",
    "enunciado": "You are given the \nroot\n of a binary tree containing digits from \n0\n to \n9\n only.\n\n\nEach root-to-leaf path in the tree represents a number.\n\n\n\n\nFor example, the root-to-leaf path \n1 -> 2 -> 3\n represents the number \n123\n.\n\n\n\n\nReturn \nthe total sum of all root-to-leaf numbers\n. Test cases are generated so that the answer will fit in a \n32-bit\n integer.\n\n\nA \nleaf\n node is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 25\n\nExplanation:\n\nThe root-to-leaf path \n1->2\n represents the number \n12\n.\nThe root-to-leaf path \n1->3\n represents the number \n13\n.\nTherefore, sum = 12 + 13 = \n25\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,9,0,5,1]\n\nOutput:\n 1026\n\nExplanation:\n\nThe root-to-leaf path \n4->9->5\n represents the number 495.\nThe root-to-leaf path \n4->9->1\n represents the number 491.\nThe root-to-leaf path \n4->0\n represents the number 40.\nTherefore, sum = 495 + 491 + 40 = \n1026\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 9\n\n\nThe depth of the tree will not exceed \n10\n.",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 124,
    "slug": "binary-tree-maximum-path-sum",
    "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    "titulo": "Binary Tree Maximum Path Sum",
    "enunciado": "A \npath\n in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \nat most once\n. Note that the path does not need to pass through the root.\n\n\nThe \npath sum\n of a path is the sum of the node's values in the path.\n\n\nGiven the \nroot\n of a binary tree, return \nthe maximum \npath sum\n of any \nnon-empty\n path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 6\n\nExplanation:\n The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [-10,9,20,null,null,15,7]\n\nOutput:\n 42\n\nExplanation:\n The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3 * 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 119,
    "slug": "pascals-triangle-ii",
    "url": "https://leetcode.com/problems/pascals-triangle-ii/",
    "titulo": "Pascal's Triangle II",
    "enunciado": "Given an integer \nrowIndex\n, return the \nrowIndex\nth\n (\n0-indexed\n) row of the \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n rowIndex = 3\n\nOutput:\n [1,3,3,1]\n\nExample 2:\n\n\nInput:\n rowIndex = 0\n\nOutput:\n [1]\n\nExample 3:\n\n\nInput:\n rowIndex = 1\n\nOutput:\n [1,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= rowIndex <= 33\n\n\n\n\n \n\n\nFollow up:\n Could you optimize your algorithm to use only \nO(rowIndex)\n extra space?",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 118,
    "slug": "pascals-triangle",
    "url": "https://leetcode.com/problems/pascals-triangle/",
    "titulo": "Pascal's Triangle",
    "enunciado": "Given an integer \nnumRows\n, return the first numRows of \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n numRows = 5\n\nOutput:\n [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\n\nInput:\n numRows = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numRows <= 30",
    "temas": [
      "Array",
      "Dynamic Programming"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 117,
    "slug": "populating-next-right-pointers-in-each-node-ii",
    "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/",
    "titulo": "Populating Next Right Pointers in Each Node II",
    "enunciado": "Given a binary tree\n\n\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\n\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to \nNULL\n.\n\n\nInitially, all next pointers are set to \nNULL\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,null,7]\n\nOutput:\n [1,#,2,3,#,4,5,7,#]\n\nExplanation: \nGiven the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 6000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow-up:\n\n\n\n\nYou may only use constant extra space.\n\n\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
    "temas": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 116,
    "slug": "populating-next-right-pointers-in-each-node",
    "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/",
    "titulo": "Populating Next Right Pointers in Each Node",
    "enunciado": "You are given a \nperfect binary tree\n where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\n\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\n\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to \nNULL\n.\n\n\nInitially, all next pointers are set to \nNULL\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7]\n\nOutput:\n [1,#,2,3,#,4,5,6,7,#]\n\nExplanation: \nGiven the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2\n12\n - 1]\n.\n\n\n-1000 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n\n\n\n\nYou may only use constant extra space.\n\n\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
    "temas": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 114,
    "slug": "flatten-binary-tree-to-linked-list",
    "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
    "titulo": "Flatten Binary Tree to Linked List",
    "enunciado": "Given the \nroot\n of a binary tree, flatten the tree into a \"linked list\":\n\n\n\n\nThe \"linked list\" should use the same \nTreeNode\n class where the \nright\n child pointer points to the next node in the list and the \nleft\n child pointer is always \nnull\n.\n\n\nThe \"linked list\" should be in the same order as a \npre-order\n traversal\n of the binary tree.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,5,3,4,null,6]\n\nOutput:\n [1,null,2,null,3,null,4,null,5,null,6]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Can you flatten the tree in-place (with \nO(1)\n extra space)?",
    "temas": [
      "Linked List",
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 113,
    "slug": "path-sum-ii",
    "url": "https://leetcode.com/problems/path-sum-ii/",
    "titulo": "Path Sum II",
    "enunciado": "Given the \nroot\n of a binary tree and an integer \ntargetSum\n, return \nall \nroot-to-leaf\n paths where the sum of the node values in the path equals \ntargetSum\n. Each path should be returned as a list of the node \nvalues\n, not node references\n.\n\n\nA \nroot-to-leaf\n path is a path starting from the root and ending at any leaf node. A \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n\nOutput:\n [[5,4,11,2],[5,8,4,5]]\n\nExplanation:\n There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3], targetSum = 5\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], targetSum = 0\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5000]\n.\n\n\n-1000 <= Node.val <= 1000\n\n\n-1000 <= targetSum <= 1000",
    "temas": [
      "Backtracking",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Backtracking",
    "has_image": true
  },
  {
    "id": 112,
    "slug": "path-sum",
    "url": "https://leetcode.com/problems/path-sum/",
    "titulo": "Path Sum",
    "enunciado": "Given the \nroot\n of a binary tree and an integer \ntargetSum\n, return \ntrue\n if the tree has a \nroot-to-leaf\n path such that adding up all the values along the path equals \ntargetSum\n.\n\n\nA \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n\nOutput:\n true\n\nExplanation:\n The root-to-leaf path with the target sum is shown.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3], targetSum = 5\n\nOutput:\n false\n\nExplanation:\n There are two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [], targetSum = 0\n\nOutput:\n false\n\nExplanation:\n Since the tree is empty, there are no root-to-leaf paths.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5000]\n.\n\n\n-1000 <= Node.val <= 1000\n\n\n-1000 <= targetSum <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 111,
    "slug": "minimum-depth-of-binary-tree",
    "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/",
    "titulo": "Minimum Depth of Binary Tree",
    "enunciado": "Given a binary tree, find its minimum depth.\n\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n\nNote:\n A leaf is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [2,null,3,null,4,null,5,null,6]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n5\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 110,
    "slug": "balanced-binary-tree",
    "url": "https://leetcode.com/problems/balanced-binary-tree/",
    "titulo": "Balanced Binary Tree",
    "enunciado": "Given a binary tree, determine if it is \nheight-balanced\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,2,3,3,null,null,4,4]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5000]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 109,
    "slug": "convert-sorted-list-to-binary-search-tree",
    "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/",
    "titulo": "Convert Sorted List to Binary Search Tree",
    "enunciado": "Given the \nhead\n of a singly linked list where elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in \nhead\n is in the range \n[0, 2 * 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5",
    "temas": [
      "Linked List",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 108,
    "slug": "convert-sorted-array-to-binary-search-tree",
    "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/",
    "titulo": "Convert Sorted Array to Binary Search Tree",
    "enunciado": "Given an integer array \nnums\n where the elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n [0,-10,5,null,-3,null,9] is also accepted:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,3]\n\nOutput:\n [3,1]\n\nExplanation:\n [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in a \nstrictly increasing\n order.",
    "temas": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 107,
    "slug": "binary-tree-level-order-traversal-ii",
    "url": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/",
    "titulo": "Binary Tree Level Order Traversal II",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe bottom-up level order traversal of its nodes' values\n. (i.e., from left to right, level by level from leaf to root).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[15,7],[9,20],[3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 106,
    "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
    "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
    "titulo": "Construct Binary Tree from Inorder and Postorder Traversal",
    "enunciado": "Given two integer arrays \ninorder\n and \npostorder\n where \ninorder\n is the inorder traversal of a binary tree and \npostorder\n is the postorder traversal of the same tree, construct and return \nthe binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n\nOutput:\n [3,9,20,null,null,15,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n inorder = [-1], postorder = [-1]\n\nOutput:\n [-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= inorder.length <= 3000\n\n\npostorder.length == inorder.length\n\n\n-3000 <= inorder[i], postorder[i] <= 3000\n\n\ninorder\n and \npostorder\n consist of \nunique\n values.\n\n\nEach value of \npostorder\n also appears in \ninorder\n.\n\n\ninorder\n is \nguaranteed\n to be the inorder traversal of the tree.\n\n\npostorder\n is \nguaranteed\n to be the postorder traversal of the tree.",
    "temas": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 105,
    "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
    "titulo": "Construct Binary Tree from Preorder and Inorder Traversal",
    "enunciado": "Given two integer arrays \npreorder\n and \ninorder\n where \npreorder\n is the preorder traversal of a binary tree and \ninorder\n is the inorder traversal of the same tree, construct and return \nthe binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n\nOutput:\n [3,9,20,null,null,15,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n preorder = [-1], inorder = [-1]\n\nOutput:\n [-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= preorder.length <= 3000\n\n\ninorder.length == preorder.length\n\n\n-3000 <= preorder[i], inorder[i] <= 3000\n\n\npreorder\n and \ninorder\n consist of \nunique\n values.\n\n\nEach value of \ninorder\n also appears in \npreorder\n.\n\n\npreorder\n is \nguaranteed\n to be the preorder traversal of the tree.\n\n\ninorder\n is \nguaranteed\n to be the inorder traversal of the tree.",
    "temas": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 104,
    "slug": "maximum-depth-of-binary-tree",
    "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
    "titulo": "Maximum Depth of Binary Tree",
    "enunciado": "Given the \nroot\n of a binary tree, return \nits maximum depth\n.\n\n\nA binary tree's \nmaximum depth\n is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,null,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 103,
    "slug": "binary-tree-zigzag-level-order-traversal",
    "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
    "titulo": "Binary Tree Zigzag Level Order Traversal",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe zigzag level order traversal of its nodes' values\n. (i.e., from left to right, then right to left for the next level and alternate between).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[20,9],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-100 <= Node.val <= 100",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 102,
    "slug": "binary-tree-level-order-traversal",
    "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    "titulo": "Binary Tree Level Order Traversal",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe level order traversal of its nodes' values\n. (i.e., from left to right, level by level).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[9,20],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
    "temas": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 101,
    "slug": "symmetric-tree",
    "url": "https://leetcode.com/problems/symmetric-tree/",
    "titulo": "Symmetric Tree",
    "enunciado": "Given the \nroot\n of a binary tree, \ncheck whether it is a mirror of itself\n (i.e., symmetric around its center).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,2,3,4,4,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,2,null,3,null,3]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Could you solve it both recursively and iteratively?",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 100,
    "slug": "same-tree",
    "url": "https://leetcode.com/problems/same-tree/",
    "titulo": "Same Tree",
    "enunciado": "Given the roots of two binary trees \np\n and \nq\n, write a function to check if they are the same or not.\n\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n p = [1,2,3], q = [1,2,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n p = [1,2], q = [1,null,2]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n p = [1,2,1], q = [1,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 100]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 99,
    "slug": "recover-binary-search-tree",
    "url": "https://leetcode.com/problems/recover-binary-search-tree/",
    "titulo": "Recover Binary Search Tree",
    "enunciado": "You are given the \nroot\n of a binary search tree (BST), where the values of \nexactly\n two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,null,null,2]\n\nOutput:\n [3,1,null,null,2]\n\nExplanation:\n 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,null,2]\n\nOutput:\n [2,1,4,null,null,3]\n\nExplanation:\n 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 1000]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n A solution using \nO(n)\n space is pretty straight-forward. Could you devise a constant \nO(1)\n space solution?",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 98,
    "slug": "validate-binary-search-tree",
    "url": "https://leetcode.com/problems/validate-binary-search-tree/",
    "titulo": "Validate Binary Search Tree",
    "enunciado": "Given the \nroot\n of a binary tree, \ndetermine if it is a valid binary search tree (BST)\n.\n\n\nA \nvalid BST\n is defined as follows:\n\n\n\n\nThe left \nsubtree\n of a node contains only nodes with keys \nless than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \ngreater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,1,4,null,null,3,6]\n\nOutput:\n false\n\nExplanation:\n The root node's value is 5 but its right child's value is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
    "temas": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Tree",
    "has_image": true
  },
  {
    "id": 97,
    "slug": "interleaving-string",
    "url": "https://leetcode.com/problems/interleaving-string/",
    "titulo": "Interleaving String",
    "enunciado": "Given strings \ns1\n, \ns2\n, and \ns3\n, find whether \ns3\n is formed by an \ninterleaving\n of \ns1\n and \ns2\n.\n\n\nAn \ninterleaving\n of two strings \ns\n and \nt\n is a configuration where \ns\n and \nt\n are divided into \nn\n and \nm\n \nsubstrings\n respectively, such that:\n\n\n\n\ns = s\n1\n + s\n2\n + ... + s\nn\n\n\nt = t\n1\n + t\n2\n + ... + t\nm\n\n\n|n - m| <= 1\n\n\nThe \ninterleaving\n is \ns\n1\n + t\n1\n + s\n2\n + t\n2\n + s\n3\n + t\n3\n + ...\n or \nt\n1\n + s\n1\n + t\n2\n + s\n2\n + t\n3\n + s\n3\n + ...\n\n\n\n\nNote:\n \na + b\n is the concatenation of strings \na\n and \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n\nOutput:\n true\n\nExplanation:\n One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n\nOutput:\n false\n\nExplanation:\n Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s1 = \"\", s2 = \"\", s3 = \"\"\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s1.length, s2.length <= 100\n\n\n0 <= s3.length <= 200\n\n\ns1\n, \ns2\n, and \ns3\n consist of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you solve it using only \nO(s2.length)\n additional memory space?",
    "temas": [
      "String",
      "Dynamic Programming"
    ],
    "dificuldade": "Média",
    "tema_principal": "String",
    "has_image": true
  },
  {
    "id": 96,
    "slug": "unique-binary-search-trees",
    "url": "https://leetcode.com/problems/unique-binary-search-trees/",
    "titulo": "Unique Binary Search Trees",
    "enunciado": "Given an integer \nn\n, return \nthe number of structurally unique \nBST'\ns (binary search trees) which has exactly \nn\n nodes of unique values from\n \n1\n \nto\n \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 5\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 19",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 95,
    "slug": "unique-binary-search-trees-ii",
    "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/",
    "titulo": "Unique Binary Search Trees II",
    "enunciado": "Given an integer \nn\n, return \nall the structurally unique \nBST'\ns (binary search trees), which has exactly \nn\n nodes of unique values from\n \n1\n \nto\n \nn\n. Return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
    "temas": [
      "Dynamic Programming",
      "Backtracking",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "dificuldade": "Média",
    "tema_principal": "Dynamic Programming",
    "has_image": true
  },
  {
    "id": 94,
    "slug": "binary-tree-inorder-traversal",
    "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    "titulo": "Binary Tree Inorder Traversal",
    "enunciado": "Given the \nroot\n of a binary tree, return \nthe inorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[1,3,2]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[4,2,6,5,7,1,3,9,8]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
    "temas": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Stack",
    "has_image": true
  },
  {
    "id": 92,
    "slug": "reverse-linked-list-ii",
    "url": "https://leetcode.com/problems/reverse-linked-list-ii/",
    "titulo": "Reverse Linked List II",
    "enunciado": "Given the \nhead\n of a singly linked list and two integers \nleft\n and \nright\n where \nleft <= right\n, reverse the nodes of the list from position \nleft\n to position \nright\n, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], left = 2, right = 4\n\nOutput:\n [1,4,3,2,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [5], left = 1, right = 1\n\nOutput:\n [5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= n <= 500\n\n\n-500 <= Node.val <= 500\n\n\n1 <= left <= right <= n\n\n\n\n\n \n\n\nFollow up:\n Could you do it in one pass?",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 86,
    "slug": "partition-list",
    "url": "https://leetcode.com/problems/partition-list/",
    "titulo": "Partition List",
    "enunciado": "Given the \nhead\n of a linked list and a value \nx\n, partition it such that all nodes \nless than\n \nx\n come before nodes \ngreater than or equal\n to \nx\n.\n\n\nYou should \npreserve\n the original relative order of the nodes in each of the two partitions.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,4,3,2,5,2], x = 3\n\nOutput:\n [1,2,2,4,3,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [2,1], x = 2\n\nOutput:\n [1,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 200]\n.\n\n\n-100 <= Node.val <= 100\n\n\n-200 <= x <= 200",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 85,
    "slug": "maximal-rectangle",
    "url": "https://leetcode.com/problems/maximal-rectangle/",
    "titulo": "Maximal Rectangle",
    "enunciado": "Given a \nrows x cols\n binary \nmatrix\n filled with \n0\n's and \n1\n's, find the largest rectangle containing only \n1\n's and return \nits area\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\nOutput:\n 6\n\nExplanation:\n The maximal rectangle is shown in the above picture.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[\"0\"]]\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[\"1\"]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == matrix.length\n\n\ncols == matrix[i].length\n\n\n1 <= row, cols <= 200\n\n\nmatrix[i][j]\n is \n'0'\n or \n'1'\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Matrix",
      "Monotonic Stack"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 84,
    "slug": "largest-rectangle-in-histogram",
    "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
    "titulo": "Largest Rectangle in Histogram",
    "enunciado": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
    "temas": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 83,
    "slug": "remove-duplicates-from-sorted-list",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/",
    "titulo": "Remove Duplicates from Sorted List",
    "enunciado": "Given the \nhead\n of a sorted linked list, \ndelete all duplicates such that each element appears only once\n. Return \nthe linked list \nsorted\n as well\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,1,2]\n\nOutput:\n [1,2]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,1,2,3,3]\n\nOutput:\n [1,2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 300]\n.\n\n\n-100 <= Node.val <= 100\n\n\nThe list is guaranteed to be \nsorted\n in ascending order.",
    "temas": [
      "Linked List"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 82,
    "slug": "remove-duplicates-from-sorted-list-ii",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/",
    "titulo": "Remove Duplicates from Sorted List II",
    "enunciado": "Given the \nhead\n of a sorted linked list, \ndelete all nodes that have duplicate numbers, leaving only distinct numbers from the original list\n. Return \nthe linked list \nsorted\n as well\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,3,4,4,5]\n\nOutput:\n [1,2,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,1,1,2,3]\n\nOutput:\n [2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 300]\n.\n\n\n-100 <= Node.val <= 100\n\n\nThe list is guaranteed to be \nsorted\n in ascending order.",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 79,
    "slug": "word-search",
    "url": "https://leetcode.com/problems/word-search/",
    "titulo": "Word Search",
    "enunciado": "Given an \nm x n\n grid of characters \nboard\n and a string \nword\n, return \ntrue\n \nif\n \nword\n \nexists in the grid\n.\n\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn = board[i].length\n\n\n1 <= m, n <= 6\n\n\n1 <= word.length <= 15\n\n\nboard\n and \nword\n consists of only lowercase and uppercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you use search pruning to make your solution faster with a larger \nboard\n?",
    "temas": [
      "Array",
      "String",
      "Backtracking",
      "Depth-First Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 74,
    "slug": "search-a-2d-matrix",
    "url": "https://leetcode.com/problems/search-a-2d-matrix/",
    "titulo": "Search a 2D Matrix",
    "enunciado": "You are given an \nm x n\n integer matrix \nmatrix\n with the following two properties:\n\n\n\n\nEach row is sorted in non-decreasing order.\n\n\nThe first integer of each row is greater than the last integer of the previous row.\n\n\n\n\nGiven an integer \ntarget\n, return \ntrue\n \nif\n \ntarget\n \nis in\n \nmatrix\n \nor\n \nfalse\n \notherwise\n.\n\n\nYou must write a solution in \nO(log(m * n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-10\n4\n <= matrix[i][j], target <= 10\n4",
    "temas": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 73,
    "slug": "set-matrix-zeroes",
    "url": "https://leetcode.com/problems/set-matrix-zeroes/",
    "titulo": "Set Matrix Zeroes",
    "enunciado": "Given an \nm x n\n integer matrix \nmatrix\n, if an element is \n0\n, set its entire row and column to \n0\n's.\n\n\nYou must do it \nin place\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n [[1,0,1],[0,0,0],[1,0,1]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n\nOutput:\n [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[0].length\n\n\n1 <= m, n <= 200\n\n\n-2\n31\n <= matrix[i][j] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nA straightforward solution using \nO(mn)\n space is probably a bad idea.\n\n\nA simple improvement uses \nO(m + n)\n space, but still not the best solution.\n\n\nCould you devise a constant space solution?",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 64,
    "slug": "minimum-path-sum",
    "url": "https://leetcode.com/problems/minimum-path-sum/",
    "titulo": "Minimum Path Sum",
    "enunciado": "Given a \nm x n\n \ngrid\n filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n\nNote:\n You can only move either down or right at any point in time.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,3,1],[1,5,1],[4,2,1]]\n\nOutput:\n 7\n\nExplanation:\n Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,2,3],[4,5,6]]\n\nOutput:\n 12\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= grid[i][j] <= 200",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 63,
    "slug": "unique-paths-ii",
    "url": "https://leetcode.com/problems/unique-paths-ii/",
    "titulo": "Unique Paths II",
    "enunciado": "You are given an \nm x n\n integer array \ngrid\n. There is a robot initially located at the \ntop-left corner\n (i.e., \ngrid[0][0]\n). The robot tries to move to the \nbottom-right corner\n (i.e., \ngrid[m - 1][n - 1]\n). The robot can only move either down or right at any point in time.\n\n\nAn obstacle and space are marked as \n1\n or \n0\n respectively in \ngrid\n. A path that the robot takes cannot include \nany\n square that is an obstacle.\n\n\nReturn \nthe number of possible unique paths that the robot can take to reach the bottom-right corner\n.\n\n\nThe testcases are generated so that the answer will be less than or equal to \n2 * 10\n9\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n\nOutput:\n 2\n\nExplanation:\n There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n obstacleGrid = [[0,1],[0,0]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == obstacleGrid.length\n\n\nn == obstacleGrid[i].length\n\n\n1 <= m, n <= 100\n\n\nobstacleGrid[i][j]\n is \n0\n or \n1\n.",
    "temas": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 62,
    "slug": "unique-paths",
    "url": "https://leetcode.com/problems/unique-paths/",
    "titulo": "Unique Paths",
    "enunciado": "There is a robot on an \nm x n\n grid. The robot is initially located at the \ntop-left corner\n (i.e., \ngrid[0][0]\n). The robot tries to move to the \nbottom-right corner\n (i.e., \ngrid[m - 1][n - 1]\n). The robot can only move either down or right at any point in time.\n\n\nGiven the two integers \nm\n and \nn\n, return \nthe number of possible unique paths that the robot can take to reach the bottom-right corner\n.\n\n\nThe test cases are generated so that the answer will be less than or equal to \n2 * 10\n9\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 7\n\nOutput:\n 28\n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 2\n\nOutput:\n 3\n\nExplanation:\n From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 100",
    "temas": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "dificuldade": "Média",
    "tema_principal": "Math",
    "has_image": true
  },
  {
    "id": 61,
    "slug": "rotate-list",
    "url": "https://leetcode.com/problems/rotate-list/",
    "titulo": "Rotate List",
    "enunciado": "Given the \nhead\n of a linked list, rotate the list to the right by \nk\n places.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [4,5,1,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [0,1,2], k = 4\n\nOutput:\n [2,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 500]\n.\n\n\n-100 <= Node.val <= 100\n\n\n0 <= k <= 2 * 10\n9",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 59,
    "slug": "spiral-matrix-ii",
    "url": "https://leetcode.com/problems/spiral-matrix-ii/",
    "titulo": "Spiral Matrix II",
    "enunciado": "Given a positive integer \nn\n, generate an \nn x n\n \nmatrix\n filled with elements from \n1\n to \nn\n2\n in spiral order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n [[1,2,3],[8,9,4],[7,6,5]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 20",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 54,
    "slug": "spiral-matrix",
    "url": "https://leetcode.com/problems/spiral-matrix/",
    "titulo": "Spiral Matrix",
    "enunciado": "Given an \nm x n\n \nmatrix\n, return \nall elements of the\n \nmatrix\n \nin spiral order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,3,6,9,8,7,4,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput:\n [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 10\n\n\n-100 <= matrix[i][j] <= 100",
    "temas": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 52,
    "slug": "n-queens-ii",
    "url": "https://leetcode.com/problems/n-queens-ii/",
    "titulo": "N-Queens II",
    "enunciado": "The \nn-queens\n puzzle is the problem of placing \nn\n queens on an \nn x n\n chessboard such that no two queens attack each other.\n\n\nGiven an integer \nn\n, return \nthe number of distinct solutions to the \nn-queens puzzle\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 2\n\nExplanation:\n There are two distinct solutions to the 4-queens puzzle as shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 9",
    "temas": [
      "Backtracking"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Backtracking",
    "has_image": true
  },
  {
    "id": 51,
    "slug": "n-queens",
    "url": "https://leetcode.com/problems/n-queens/",
    "titulo": "N-Queens",
    "enunciado": "The \nn-queens\n puzzle is the problem of placing \nn\n queens on an \nn x n\n chessboard such that no two queens attack each other.\n\n\nGiven an integer \nn\n, return \nall distinct solutions to the \nn-queens puzzle\n. You may return the answer in \nany order\n.\n\n\nEach solution contains a distinct board configuration of the n-queens' placement, where \n'Q'\n and \n'.'\n both indicate a queen and an empty space, respectively.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n\nExplanation:\n There exist two distinct solutions to the 4-queens puzzle as shown above\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[\"Q\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 9",
    "temas": [
      "Array",
      "Backtracking"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 48,
    "slug": "rotate-image",
    "url": "https://leetcode.com/problems/rotate-image/",
    "titulo": "Rotate Image",
    "enunciado": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
    "temas": [
      "Array",
      "Math",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 42,
    "slug": "trapping-rain-water",
    "url": "https://leetcode.com/problems/trapping-rain-water/",
    "titulo": "Trapping Rain Water",
    "enunciado": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
    "temas": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 37,
    "slug": "sudoku-solver",
    "url": "https://leetcode.com/problems/sudoku-solver/",
    "titulo": "Sudoku Solver",
    "enunciado": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\n\nA sudoku solution must satisfy \nall of the following rules\n:\n\n\n\n\nEach of the digits \n1-9\n must occur exactly once in each row.\n\n\nEach of the digits \n1-9\n must occur exactly once in each column.\n\n\nEach of the digits \n1-9\n must occur exactly once in each of the 9 \n3x3\n sub-boxes of the grid.\n\n\n\n\nThe \n'.'\n character indicates empty cells.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n\nExplanation:\n The input board is shown above and the only valid solution is shown below:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit or \n'.'\n.\n\n\nIt is \nguaranteed\n that the input board has only one solution.",
    "temas": [
      "Array",
      "Hash Table",
      "Backtracking",
      "Matrix"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 36,
    "slug": "valid-sudoku",
    "url": "https://leetcode.com/problems/valid-sudoku/",
    "titulo": "Valid Sudoku",
    "enunciado": "Determine if a \n9 x 9\n Sudoku board is valid. Only the filled cells need to be validated \naccording to the following rules\n:\n\n\n\n\nEach row must contain the digits \n1-9\n without repetition.\n\n\nEach column must contain the digits \n1-9\n without repetition.\n\n\nEach of the nine \n3 x 3\n sub-boxes of the grid must contain the digits \n1-9\n without repetition.\n\n\n\n\nNote:\n\n\n\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n false\n\nExplanation:\n Same as Example 1, except with the \n5\n in the top left corner being modified to \n8\n. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit \n1-9\n or \n'.'\n.",
    "temas": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 25,
    "slug": "reverse-nodes-in-k-group",
    "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
    "titulo": "Reverse Nodes in k-Group",
    "enunciado": "Given the \nhead\n of a linked list, reverse the nodes of the list \nk\n at a time, and return \nthe modified list\n.\n\n\nk\n is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of \nk\n then left-out nodes, in the end, should remain as it is.\n\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [2,1,4,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 3\n\nOutput:\n [3,2,1,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 5000\n\n\n0 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n Can you solve the problem in \nO(1)\n extra memory space?",
    "temas": [
      "Linked List",
      "Recursion"
    ],
    "dificuldade": "Difícil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 24,
    "slug": "swap-nodes-in-pairs",
    "url": "https://leetcode.com/problems/swap-nodes-in-pairs/",
    "titulo": "Swap Nodes in Pairs",
    "enunciado": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nhead = [1,2,3,4]\n\n\nOutput:\n \n[2,1,4,3]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nhead = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nhead = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nhead = [1,2,3]\n\n\nOutput:\n \n[2,1,3]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 100]\n.\n\n\n0 <= Node.val <= 100",
    "temas": [
      "Linked List",
      "Recursion"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 21,
    "slug": "merge-two-sorted-lists",
    "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
    "titulo": "Merge Two Sorted Lists",
    "enunciado": "You are given the heads of two sorted linked lists \nlist1\n and \nlist2\n.\n\n\nMerge the two lists into one \nsorted\n list. The list should be made by splicing together the nodes of the first two lists.\n\n\nReturn \nthe head of the merged linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n list1 = [1,2,4], list2 = [1,3,4]\n\nOutput:\n [1,1,2,3,4,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n list1 = [], list2 = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n list1 = [], list2 = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both lists is in the range \n[0, 50]\n.\n\n\n-100 <= Node.val <= 100\n\n\nBoth \nlist1\n and \nlist2\n are sorted in \nnon-decreasing\n order.",
    "temas": [
      "Linked List",
      "Recursion"
    ],
    "dificuldade": "Fácil",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 19,
    "slug": "remove-nth-node-from-end-of-list",
    "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
    "titulo": "Remove Nth Node From End of List",
    "enunciado": "Given the \nhead\n of a linked list, remove the \nn\nth\n node from the end of the list and return its head.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], n = 2\n\nOutput:\n [1,2,3,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [1], n = 1\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [1,2], n = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nsz\n.\n\n\n1 <= sz <= 30\n\n\n0 <= Node.val <= 100\n\n\n1 <= n <= sz\n\n\n\n\n \n\n\nFollow up:\n Could you do this in one pass?",
    "temas": [
      "Linked List",
      "Two Pointers"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  },
  {
    "id": 17,
    "slug": "letter-combinations-of-a-phone-number",
    "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
    "titulo": "Letter Combinations of a Phone Number",
    "enunciado": "Given a string containing digits from \n2-9\n inclusive, return all possible letter combinations that the number could represent. Return the answer in \nany order\n.\n\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = \"23\"\n\nOutput:\n [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = \"\"\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = \"2\"\n\nOutput:\n [\"a\",\"b\",\"c\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= digits.length <= 4\n\n\ndigits[i]\n is a digit in the range \n['2', '9']\n.",
    "temas": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "dificuldade": "Média",
    "tema_principal": "Hash Table",
    "has_image": true
  },
  {
    "id": 11,
    "slug": "container-with-most-water",
    "url": "https://leetcode.com/problems/container-with-most-water/",
    "titulo": "Container With Most Water",
    "enunciado": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
    "temas": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "dificuldade": "Média",
    "tema_principal": "Array",
    "has_image": true
  },
  {
    "id": 2,
    "slug": "add-two-numbers",
    "url": "https://leetcode.com/problems/add-two-numbers/",
    "titulo": "Add Two Numbers",
    "enunciado": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
    "temas": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "dificuldade": "Média",
    "tema_principal": "Linked List",
    "has_image": true
  }
]