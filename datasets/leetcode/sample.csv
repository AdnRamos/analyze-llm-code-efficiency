id,slug,url,titulo,enunciado,temas,dificuldade,tema_principal,has_image
1157,online-majority-element-in-subarray,https://leetcode.com/problems/online-majority-element-in-subarray/,Online Majority Element In Subarray,"Design a data structure that efficiently finds the  majority element  of a given subarray. The  majority element  of a subarray is an element that occurs  threshold  times or more in the subarray. Implementing the  MajorityChecker  class: MajorityChecker(int[] arr)  Initializes the instance of the class with the given array  arr . int query(int left, int right, int threshold)  returns the element in the subarray  arr[left...right]  that occurs at least  threshold  times, or  -1  if no such element exists.   Example 1: Input [""MajorityChecker"", ""query"", ""query"", ""query""] [[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]] Output [null, 1, -1, 2] Explanation MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]); majorityChecker.query(0, 5, 4); // return 1 majorityChecker.query(0, 3, 3); // return -1 majorityChecker.query(2, 3, 2); // return 2   Constraints: 1 <= arr.length <= 2 * 10 4 1 <= arr[i] <= 2 * 10 4 0 <= left <= right < arr.length threshold <= right - left + 1 2 * threshold > right - left + 1 At most  10 4  calls will be made to  query .","['Array', 'Binary Search', 'Design', 'Binary Indexed Tree', 'Segment Tree']",Difícil,Array,False
1178,number-of-valid-words-for-each-puzzle,https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/,Number of Valid Words for Each Puzzle,"With respect to a given  puzzle  string, a  word  is  valid  if both the following conditions are satisfied: word  contains the first letter of  puzzle . For each letter in  word , that letter is in  puzzle . 	 For example, if the puzzle is  ""abcdefg"" , then valid words are  ""faced"" ,  ""cabbage"" , and  ""baggage"" , while invalid words are  ""beefed""  (does not include  'a' ) and  ""based""  (includes  's'  which is not in the puzzle). Return  an array  answer , where  answer[i]  is the number of words in the given word list  words  that is valid with respect to the puzzle  puzzles[i] .   Example 1: Input:  words = [""aaaa"",""asas"",""able"",""ability"",""actt"",""actor"",""access""], puzzles = [""aboveyz"",""abrodyz"",""abslute"",""absoryz"",""actresz"",""gaswxyz""] Output:  [1,1,3,2,4,0] Explanation:   1 valid word for ""aboveyz"" : ""aaaa""  1 valid word for ""abrodyz"" : ""aaaa"" 3 valid words for ""abslute"" : ""aaaa"", ""asas"", ""able"" 2 valid words for ""absoryz"" : ""aaaa"", ""asas"" 4 valid words for ""actresz"" : ""aaaa"", ""asas"", ""actt"", ""access"" There are no valid words for ""gaswxyz"" cause none of the words in the list contains letter 'g'. Example 2: Input:  words = [""apple"",""pleas"",""please""], puzzles = [""aelwxyz"",""aelpxyz"",""aelpsxy"",""saelpxy"",""xaelpsy""] Output:  [0,1,3,2,0]   Constraints: 1 <= words.length <= 10 5 4 <= words[i].length <= 50 1 <= puzzles.length <= 10 4 puzzles[i].length == 7 words[i]  and  puzzles[i]  consist of lowercase English letters. Each  puzzles[i]  does not contain repeated characters.","['Array', 'Hash Table', 'String', 'Bit Manipulation', 'Trie']",Difícil,Array,False
1354,construct-target-array-with-multiple-sums,https://leetcode.com/problems/construct-target-array-with-multiple-sums/,Construct Target Array With Multiple Sums,"You are given an array  target  of n integers. From a starting array  arr  consisting of  n  1's, you may perform the following procedure : let  x  be the sum of all elements currently in your array. choose index  i , such that  0 <= i < n  and set the value of  arr  at index  i  to  x . You may repeat this procedure as many times as needed. Return  true   if it is possible to construct the   target   array from   arr , otherwise, return   false .   Example 1: Input:  target = [9,3,5] Output:  true Explanation:  Start with arr = [1, 1, 1]  [1, 1, 1], sum = 3 choose index 1 [1, 3, 1], sum = 5 choose index 2 [1, 3, 5], sum = 9 choose index 0 [9, 3, 5] Done Example 2: Input:  target = [1,1,1,2] Output:  false Explanation:  Impossible to create target array from [1,1,1,1]. Example 3: Input:  target = [8,5] Output:  true   Constraints: n == target.length 1 <= n <= 5 * 10 4 1 <= target[i] <= 10 9","['Array', 'Heap (Priority Queue)']",Difícil,Array,False
1799,maximize-score-after-n-operations,https://leetcode.com/problems/maximize-score-after-n-operations/,Maximize Score After N Operations,"You are given  nums , an array of positive integers of size  2 * n . You must perform  n  operations on this array. In the  i th  operation  (1-indexed) , you will: Choose two elements,  x  and  y . Receive a score of  i * gcd(x, y) . Remove  x  and  y  from  nums . Return  the maximum score you can receive after performing  n  operations. The function  gcd(x, y)  is the greatest common divisor of  x  and  y .   Example 1: Input:  nums = [1,2] Output:  1 Explanation:  The optimal choice of operations is: (1 * gcd(1, 2)) = 1 Example 2: Input:  nums = [3,4,6,8] Output:  11 Explanation:  The optimal choice of operations is: (1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11 Example 3: Input:  nums = [1,2,3,4,5,6] Output:  14 Explanation:  The optimal choice of operations is: (1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14   Constraints: 1 <= n <= 7 nums.length == 2 * n 1 <= nums[i] <= 10 6","['Array', 'Math', 'Dynamic Programming', 'Backtracking', 'Bit Manipulation', 'Number Theory', 'Bitmask']",Difícil,Array,False
3045,count-prefix-and-suffix-pairs-ii,https://leetcode.com/problems/count-prefix-and-suffix-pairs-ii/,Count Prefix and Suffix Pairs II,"You are given a  0-indexed  string array  words . Let's define a  boolean  function  isPrefixAndSuffix  that takes two strings,  str1  and  str2 : isPrefixAndSuffix(str1, str2)  returns  true  if  str1  is  both  a  prefix  and a  suffix  of  str2 , and  false  otherwise. For example,  isPrefixAndSuffix(""aba"", ""ababa"")  is  true  because  ""aba""  is a prefix of  ""ababa""  and also a suffix, but  isPrefixAndSuffix(""abc"", ""abcd"")  is  false . Return  an integer denoting the  number  of index pairs  (i ,  j)  such that  i < j , and  isPrefixAndSuffix(words[i], words[j])  is  true .   Example 1: Input:  words = [""a"",""aba"",""ababa"",""aa""] Output:  4 Explanation:  In this example, the counted index pairs are: i = 0 and j = 1 because isPrefixAndSuffix(""a"", ""aba"") is true. i = 0 and j = 2 because isPrefixAndSuffix(""a"", ""ababa"") is true. i = 0 and j = 3 because isPrefixAndSuffix(""a"", ""aa"") is true. i = 1 and j = 2 because isPrefixAndSuffix(""aba"", ""ababa"") is true. Therefore, the answer is 4. Example 2: Input:  words = [""pa"",""papa"",""ma"",""mama""] Output:  2 Explanation:  In this example, the counted index pairs are: i = 0 and j = 1 because isPrefixAndSuffix(""pa"", ""papa"") is true. i = 2 and j = 3 because isPrefixAndSuffix(""ma"", ""mama"") is true. Therefore, the answer is 2.   Example 3: Input:  words = [""abab"",""ab""] Output:  0 Explanation:  In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(""abab"", ""ab"") is false. Therefore, the answer is 0.   Constraints: 1 <= words.length <= 10 5 1 <= words[i].length <= 10 5 words[i]  consists only of lowercase English letters. The sum of the lengths of all  words[i]  does not exceed  5 * 10 5 .","['Array', 'String', 'Trie', 'Rolling Hash', 'String Matching', 'Hash Function']",Difícil,Array,False
3525,find-x-value-of-array-ii,https://leetcode.com/problems/find-x-value-of-array-ii/,Find X Value of Array II,"You are given an array of  positive  integers  nums  and a  positive  integer  k . You are also given a 2D array  queries , where  queries[i] = [index i , value i , start i , x i ] . You are allowed to perform an operation  once  on  nums , where you can remove any  suffix  from  nums  such that  nums  remains  non-empty . The  x-value  of  nums   for a given   x  is defined as the number of ways to perform this operation so that the  product  of the remaining elements leaves a  remainder  of  x   modulo   k . For each query in  queries  you need to determine the  x-value  of  nums  for  x i  after performing the following actions: Update  nums[index i ]  to  value i . Only this step persists for the rest of the queries. Remove  the prefix  nums[0..(start i  - 1)]  (where  nums[0..(-1)]  will be used to represent the  empty  prefix). Return an array  result  of size  queries.length  where  result[i]  is the answer for the  i th  query. A  prefix  of an array is a  subarray  that starts from the beginning of the array and extends to any point within it. A  suffix  of an array is a  subarray  that starts at any point within the array and extends to the end of the array. Note  that the prefix and suffix to be chosen for the operation can be  empty . Note  that x-value has a  different  definition in this version.   Example 1: Input:   nums = [1,2,3,4,5], k = 3, queries = [[2,2,0,2],[3,3,3,0],[0,1,0,1]] Output:   [2,2,2] Explanation: For query 0,  nums  becomes  [1, 2, 2, 4, 5] , and the empty prefix  must  be removed. The possible operations are: 	 Remove the suffix  [2, 4, 5] .  nums  becomes  [1, 2] . Remove the empty suffix.  nums  becomes  [1, 2, 2, 4, 5]  with a product 80, which gives remainder 2 when divided by 3. For query 1,  nums  becomes  [1, 2, 2, 3, 5] , and the prefix  [1, 2, 2]   must  be removed. The possible operations are: 	 Remove the empty suffix.  nums  becomes  [3, 5] . Remove the suffix  [5] .  nums  becomes  [3] . For query 2,  nums  becomes  [1, 2, 2, 3, 5] , and the empty prefix  must  be removed. The possible operations are: 	 Remove the suffix  [2, 2, 3, 5] .  nums  becomes  [1] . Remove the suffix  [3, 5] .  nums  becomes  [1, 2, 2] . Example 2: Input:   nums = [1,2,4,8,16,32], k = 4, queries = [[0,2,0,2],[0,2,0,1]] Output:   [1,0] Explanation: For query 0,  nums  becomes  [2, 2, 4, 8, 16, 32] . The only possible operation is: 	 Remove the suffix  [2, 4, 8, 16, 32] . For query 1,  nums  becomes  [2, 2, 4, 8, 16, 32] . There is no possible way to perform the operation. Example 3: Input:   nums = [1,1,2,1,1], k = 2, queries = [[2,1,0,1]] Output:   [5]   Constraints: 1 <= nums[i] <= 10 9 1 <= nums.length <= 10 5 1 <= k <= 5 1 <= queries.length <= 2 * 10 4 queries[i] == [index i , value i , start i , x i ] 0 <= index i  <= nums.length - 1 1 <= value i  <= 10 9 0 <= start i  <= nums.length - 1 0 <= x i  <= k - 1","['Array', 'Math', 'Segment Tree']",Difícil,Array,False
3533,concatenated-divisibility,https://leetcode.com/problems/concatenated-divisibility/,Concatenated Divisibility,"You are given an array of positive integers  nums  and a positive integer  k . A  permutation  of  nums  is said to form a  divisible concatenation  if, when you  concatenate   the decimal representations  of the numbers in the order specified by the permutation, the resulting number is  divisible by   k . Return the  lexicographically smallest  permutation (when considered as a list of integers) that forms a  divisible concatenation . If no such permutation exists, return an empty list.   Example 1: Input:   nums = [3,12,45], k = 5 Output:   [3,12,45] Explanation: Permutation Concatenated Value Divisible by 5 [3, 12, 45] 31245 Yes [3, 45, 12] 34512 No [12, 3, 45] 12345 Yes [12, 45, 3] 12453 No [45, 3, 12] 45312 No [45, 12, 3] 45123 No The lexicographically smallest permutation that forms a divisible concatenation is  [3,12,45] . Example 2: Input:   nums = [10,5], k = 10 Output:   [5,10] Explanation: Permutation Concatenated Value Divisible by 10 [5, 10] 510 Yes [10, 5] 105 No The lexicographically smallest permutation that forms a divisible concatenation is  [5,10] . Example 3: Input:   nums = [1,2,3], k = 5 Output:   [] Explanation: Since no permutation of  nums  forms a valid divisible concatenation, return an empty list.   Constraints: 1 <= nums.length <= 13 1 <= nums[i] <= 10 5 1 <= k <= 100","['Array', 'Dynamic Programming', 'Bit Manipulation', 'Bitmask']",Difícil,Array,False
3538,merge-operations-for-minimum-travel-time,https://leetcode.com/problems/merge-operations-for-minimum-travel-time/,Merge Operations for Minimum Travel Time,"You are given a straight road of length  l  km, an integer  n , an integer  k ,  and  two  integer arrays,  position  and  time , each of length  n . The array  position  lists the positions (in km) of signs in  strictly  increasing order (with  position[0] = 0  and  position[n - 1] = l ). Each  time[i]  represents the time (in minutes) required to travel 1 km between  position[i]  and  position[i + 1] . You  must  perform  exactly   k  merge operations. In one merge, you can choose any  two  adjacent signs at indices  i  and  i + 1  (with  i > 0  and  i + 1 < n ) and: Update the sign at index  i + 1  so that its time becomes  time[i] + time[i + 1] . Remove the sign at index  i . Return the  minimum   total   travel time  (in minutes) to travel from 0 to  l  after  exactly   k  merges.   Example 1: Input:   l = 10, n = 4, k = 1, position = [0,3,8,10], time = [5,8,3,6] Output:   62 Explanation: Merge the signs at indices 1 and 2. Remove the sign at index 1, and change the time at index 2 to  8 + 3 = 11 . After the merge: 	 position  array:  [0, 8, 10] time  array:  [5, 11, 6]   Segment Distance (km) Time per km (min) Segment Travel Time (min) 0 → 8 8 5 8 × 5 = 40 8 → 10 2 11 2 × 11 = 22 Total Travel Time:  40 + 22 = 62 , which is the minimum possible time after exactly 1 merge. Example 2: Input:   l = 5, n = 5, k = 1, position = [0,1,2,3,5], time = [8,3,9,3,3] Output:   34 Explanation: Merge the signs at indices 1 and 2. Remove the sign at index 1, and change the time at index 2 to  3 + 9 = 12 . After the merge: 	 position  array:  [0, 2, 3, 5] time  array:  [8, 12, 3, 3]   Segment Distance (km) Time per km (min) Segment Travel Time (min) 0 → 2 2 8 2 × 8 = 16 2 → 3 1 12 1 × 12 = 12 3 → 5 2 3 2 × 3 = 6 Total Travel Time:  16 + 12 + 6 = 34 ,  which is the minimum possible time after exactly 1 merge.   Constraints: 1 <= l <= 10 5 2 <= n <= min(l + 1, 50) 0 <= k <= min(n - 2, 10) position.length == n position[0] = 0  and  position[n - 1] = l position  is sorted in strictly increasing order. time.length == n 1 <= time[i] <= 100​ 1 <= sum(time) <= 100 ​​​​​​","['Array', 'Dynamic Programming', 'Prefix Sum']",Difícil,Array,False
3539,find-sum-of-array-product-of-magical-sequences,https://leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/,Find Sum of Array Product of Magical Sequences,"You are given two integers,  m  and  k , and an integer array  nums . A sequence of integers  seq  is called  magical  if: seq  has a size of  m . 0 <= seq[i] < nums.length The  binary representation  of  2 seq[0]  + 2 seq[1]  + ... + 2 seq[m - 1]  has  k   set bits . The  array product  of this sequence is defined as  prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[m - 1]]) . Return the  sum  of the  array products  for all valid  magical  sequences. Since the answer may be large, return it  modulo   10 9  + 7 . A  set bit  refers to a bit in the binary representation of a number that has a value of 1.   Example 1: Input:   m = 5, k = 5, nums = [1,10,100,10000,1000000] Output:   991600007 Explanation: All permutations of  [0, 1, 2, 3, 4]  are magical sequences, each with an array product of 10 13 . Example 2: Input:   m = 2, k = 2, nums = [5,4,3,2,1] Output:   170 Explanation: The magical sequences are  [0, 1] ,  [0, 2] ,  [0, 3] ,  [0, 4] ,  [1, 0] ,  [1, 2] ,  [1, 3] ,  [1, 4] ,  [2, 0] ,  [2, 1] ,  [2, 3] ,  [2, 4] ,  [3, 0] ,  [3, 1] ,  [3, 2] ,  [3, 4] ,  [4, 0] ,  [4, 1] ,  [4, 2] , and  [4, 3] . Example 3: Input:   m = 1, k = 1, nums = [28] Output:   28 Explanation: The only magical sequence is  [0] .   Constraints: 1 <= k <= m <= 30 1 <= nums.length <= 50 1 <= nums[i] <= 10 8","['Array', 'Math', 'Dynamic Programming', 'Bit Manipulation', 'Combinatorics', 'Bitmask']",Difícil,Array,False
3569,maximize-count-of-distinct-primes-after-split,https://leetcode.com/problems/maximize-count-of-distinct-primes-after-split/,Maximize Count of Distinct Primes After Split,"You are given an integer array  nums  having length  n  and a 2D integer array  queries  where  queries[i] = [idx, val] . For each query: Update  nums[idx] = val . Choose an integer  k  with  1 <= k < n  to split the array into the non-empty prefix  nums[0..k-1]  and suffix  nums[k..n-1]  such that the sum of the counts of  distinct   prime  values in each part is  maximum . Note:  The changes made to the array in one query persist into the next query. Return an array containing the result for each query, in the order they are given.   Example 1: Input:   nums = [2,1,3,1,2], queries = [[1,2],[3,3]] Output:   [3,4] Explanation: Initially  nums = [2, 1, 3, 1, 2] . After 1 st  query,  nums = [2, 2, 3, 1, 2] . Split  nums  into  [2]  and  [2, 3, 1, 2] .  [2]  consists of 1 distinct prime and  [2, 3, 1, 2]  consists of 2 distinct primes. Hence, the answer for this query is  1 + 2 = 3 . After 2 nd  query,  nums = [2, 2, 3, 3, 2] . Split  nums  into  [2, 2, 3]  and  [3, 2]  with an answer of  2 + 2 = 4 . The output is  [3, 4] . Example 2: Input:   nums = [2,1,4], queries = [[0,1]] Output:   [0] Explanation: Initially  nums = [2, 1, 4] . After 1 st  query,  nums = [1, 1, 4] . There are no prime numbers in  nums , hence the answer for this query is 0. The output is  [0] .   Constraints: 2 <= n == nums.length <= 5 * 10 4 1 <= queries.length <= 5 * 10 4 1 <= nums[i] <= 10 5 0 <= queries[i][0] < nums.length 1 <= queries[i][1] <= 10 5","['Array', 'Math', 'Segment Tree', 'Number Theory']",Difícil,Array,False
3574,maximize-subarray-gcd-score,https://leetcode.com/problems/maximize-subarray-gcd-score/,Maximize Subarray GCD Score,"You are given an array of positive integers  nums  and an integer  k . You may perform at most  k  operations. In each operation, you can choose one element in the array and  double  its value. Each element can be doubled  at most  once. The  score  of a contiguous  subarray  is defined as the  product  of its length and the  greatest common divisor (GCD)  of all its elements. Your task is to return the  maximum   score  that can be achieved by selecting a contiguous subarray from the modified array. Note: The  greatest common divisor (GCD)  of an array is the largest integer that evenly divides all the array elements.   Example 1: Input:   nums = [2,4], k = 1 Output:   8 Explanation: Double  nums[0]  to 4 using one operation. The modified array becomes  [4, 4] . The GCD of the subarray  [4, 4]  is 4, and the length is 2. Thus, the maximum possible score is  2 × 4 = 8 . Example 2: Input:   nums = [3,5,7], k = 2 Output:   14 Explanation: Double  nums[2]  to 14 using one operation. The modified array becomes  [3, 5, 14] . The GCD of the subarray  [14]  is 14, and the length is 1. Thus, the maximum possible score is  1 × 14 = 14 . Example 3: Input:   nums = [5,5,5], k = 1 Output:   15 Explanation: The subarray  [5, 5, 5]  has a GCD of 5, and its length is 3. Since doubling any element doesn't improve the score, the maximum score is  3 × 5 = 15 .   Constraints: 1 <= n == nums.length <= 1500 1 <= nums[i] <= 10 9 1 <= k <= n","['Array', 'Math', 'Enumeration', 'Number Theory']",Difícil,Array,False
1037,valid-boomerang,https://leetcode.com/problems/valid-boomerang/,Valid Boomerang,"Given an array  points  where  points[i] = [x i , y i ]  represents a point on the  X-Y  plane, return  true   if these points are a  boomerang . A  boomerang  is a set of three points that are  all distinct  and  not in a straight line .   Example 1: Input:  points = [[1,1],[2,3],[3,2]] Output:  true Example 2: Input:  points = [[1,1],[2,2],[3,3]] Output:  false   Constraints: points.length == 3 points[i].length == 2 0 <= x i , y i  <= 100","['Array', 'Math', 'Geometry']",Fácil,Array,False
1207,unique-number-of-occurrences,https://leetcode.com/problems/unique-number-of-occurrences/,Unique Number of Occurrences,"Given an array of integers  arr , return  true   if the number of occurrences of each value in the array is  unique  or  false  otherwise .   Example 1: Input:  arr = [1,2,2,1,1,3] Output:  true Explanation:  The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: Input:  arr = [1,2] Output:  false Example 3: Input:  arr = [-3,0,1,-3,1,1,1,-3,10,0] Output:  true   Constraints: 1 <= arr.length <= 1000 -1000 <= arr[i] <= 1000","['Array', 'Hash Table']",Fácil,Array,False
1929,concatenation-of-array,https://leetcode.com/problems/concatenation-of-array/,Concatenation of Array,"Given an integer array  nums  of length  n , you want to create an array  ans  of length  2n  where  ans[i] == nums[i]  and  ans[i + n] == nums[i]  for  0 <= i < n  ( 0-indexed ). Specifically,  ans  is the  concatenation  of two  nums  arrays. Return  the array  ans .   Example 1: Input:  nums = [1,2,1] Output:  [1,2,1,1,2,1] Explanation:  The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] - ans = [1,2,1,1,2,1] Example 2: Input:  nums = [1,3,2,1] Output:  [1,3,2,1,1,3,2,1] Explanation:  The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] - ans = [1,3,2,1,1,3,2,1]   Constraints: n == nums.length 1 <= n <= 1000 1 <= nums[i] <= 1000","['Array', 'Simulation']",Fácil,Array,False
1961,check-if-string-is-a-prefix-of-array,https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/,Check If String Is a Prefix of Array,"Given a string  s  and an array of strings  words , determine whether  s  is a  prefix string  of  words . A string  s  is a  prefix string  of  words  if  s  can be made by concatenating the first  k  strings in  words  for some  positive   k  no larger than  words.length . Return  true  if  s  is a  prefix string  of  words , or  false  otherwise .   Example 1: Input:  s = ""iloveleetcode"", words = [""i"",""love"",""leetcode"",""apples""] Output:  true Explanation: s can be made by concatenating ""i"", ""love"", and ""leetcode"" together. Example 2: Input:  s = ""iloveleetcode"", words = [""apples"",""i"",""love"",""leetcode""] Output:  false Explanation: It is impossible to make s using a prefix of arr.   Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 20 1 <= s.length <= 1000 words[i]  and  s  consist of only lowercase English letters.","['Array', 'Two Pointers', 'String']",Fácil,Array,False
1984,minimum-difference-between-highest-and-lowest-of-k-scores,https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/,Minimum Difference Between Highest and Lowest of K Scores,"You are given a  0-indexed  integer array  nums , where  nums[i]  represents the score of the  i th  student. You are also given an integer  k . Pick the scores of any  k  students from the array so that the  difference  between the  highest  and the  lowest  of the  k  scores is  minimized . Return  the  minimum  possible difference .   Example 1: Input:  nums = [90], k = 1 Output:  0 Explanation:  There is one way to pick score(s) of one student: - [ 90 ]. The difference between the highest and lowest score is 90 - 90 = 0. The minimum possible difference is 0. Example 2: Input:  nums = [9,4,1,7], k = 2 Output:  2 Explanation:  There are six ways to pick score(s) of two students: - [ 9 , 4 ,1,7]. The difference between the highest and lowest score is 9 - 4 = 5. - [ 9 ,4, 1 ,7]. The difference between the highest and lowest score is 9 - 1 = 8. - [ 9 ,4,1, 7 ]. The difference between the highest and lowest score is 9 - 7 = 2. - [9, 4 , 1 ,7]. The difference between the highest and lowest score is 4 - 1 = 3. - [9, 4 ,1, 7 ]. The difference between the highest and lowest score is 7 - 4 = 3. - [9,4, 1 , 7 ]. The difference between the highest and lowest score is 7 - 1 = 6. The minimum possible difference is 2.   Constraints: 1 <= k <= nums.length <= 1000 0 <= nums[i] <= 10 5","['Array', 'Sliding Window', 'Sorting']",Fácil,Array,False
2404,most-frequent-even-element,https://leetcode.com/problems/most-frequent-even-element/,Most Frequent Even Element,"Given an integer array  nums , return  the most frequent even element . If there is a tie, return the  smallest  one. If there is no such element, return  -1 .   Example 1: Input:  nums = [0,1,2,2,4,4,1] Output:  2 Explanation: The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most. We return the smallest one, which is 2. Example 2: Input:  nums = [4,4,4,9,2,4] Output:  4 Explanation:  4 is the even element appears the most. Example 3: Input:  nums = [29,47,21,41,13,37,25,7] Output:  -1 Explanation:  There is no even element.   Constraints: 1 <= nums.length <= 2000 0 <= nums[i] <= 10 5","['Array', 'Hash Table', 'Counting']",Fácil,Array,False
2418,sort-the-people,https://leetcode.com/problems/sort-the-people/,Sort the People,"You are given an array of strings  names , and an array  heights  that consists of  distinct  positive integers. Both arrays are of length  n . For each index  i ,  names[i]  and  heights[i]  denote the name and height of the  i th  person. Return  names  sorted in  descending  order by the people's heights .   Example 1: Input:  names = [""Mary"",""John"",""Emma""], heights = [180,165,170] Output:  [""Mary"",""Emma"",""John""] Explanation:  Mary is the tallest, followed by Emma and John. Example 2: Input:  names = [""Alice"",""Bob"",""Bob""], heights = [155,185,150] Output:  [""Bob"",""Alice"",""Bob""] Explanation:  The first Bob is the tallest, followed by Alice and the second Bob.   Constraints: n == names.length == heights.length 1 <= n <= 10 3 1 <= names[i].length <= 20 1 <= heights[i] <= 10 5 names[i]  consists of lower and upper case English letters. All the values of  heights  are distinct.","['Array', 'Hash Table', 'String', 'Sorting']",Fácil,Array,False
2432,the-employee-that-worked-on-the-longest-task,https://leetcode.com/problems/the-employee-that-worked-on-the-longest-task/,The Employee That Worked on the Longest Task,"There are  n  employees, each with a unique id from  0  to  n - 1 . You are given a 2D integer array  logs  where  logs[i] = [id i , leaveTime i ]  where: id i  is the id of the employee that worked on the  i th  task, and leaveTime i  is the time at which the employee finished the  i th  task. All the values  leaveTime i  are  unique . Note that the  i th  task starts the moment right after the  (i - 1) th  task ends, and the  0 th  task starts at time  0 . Return  the id of the employee that worked the task with the longest time.  If there is a tie between two or more employees, return  the  smallest  id among them .   Example 1: Input:  n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] Output:  1 Explanation:   Task 0 started at 0 and ended at 3 with 3 units of times. Task 1 started at 3 and ended at 5 with 2 units of times. Task 2 started at 5 and ended at 9 with 4 units of times. Task 3 started at 9 and ended at 15 with 6 units of times. The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1. Example 2: Input:  n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] Output:  3 Explanation:   Task 0 started at 0 and ended at 1 with 1 unit of times. Task 1 started at 1 and ended at 7 with 6 units of times. Task 2 started at 7 and ended at 12 with 5 units of times. Task 3 started at 12 and ended at 17 with 5 units of times. The tasks with the longest time is task 1. The employee that worked on it is 3, so we return 3. Example 3: Input:  n = 2, logs = [[0,10],[1,20]] Output:  0 Explanation:   Task 0 started at 0 and ended at 10 with 10 units of times. Task 1 started at 10 and ended at 20 with 10 units of times. The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.   Constraints: 2 <= n <= 500 1 <= logs.length <= 500 logs[i].length == 2 0 <= id i  <= n - 1 1 <= leaveTime i  <= 500 id i  != id i+1 leaveTime i  are sorted in a strictly increasing order.",['Array'],Fácil,Array,False
2441,largest-positive-integer-that-exists-with-its-negative,https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/,Largest Positive Integer That Exists With Its Negative,"Given an integer array  nums  that  does not contain  any zeros, find  the largest positive  integer  k  such that  -k  also exists in the array. Return  the positive integer  k . If there is no such integer, return  -1 .   Example 1: Input:  nums = [-1,2,-3,3] Output:  3 Explanation:  3 is the only valid k we can find in the array. Example 2: Input:  nums = [-1,10,6,7,-7,1] Output:  7 Explanation:  Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value. Example 3: Input:  nums = [-10,8,6,7,-2,-3] Output:  -1 Explanation:  There is no a single valid k, we return -1.   Constraints: 1 <= nums.length <= 1000 -1000 <= nums[i] <= 1000 nums[i] != 0","['Array', 'Hash Table', 'Two Pointers', 'Sorting']",Fácil,Array,False
2529,maximum-count-of-positive-integer-and-negative-integer,https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/,Maximum Count of Positive Integer and Negative Integer,"Given an array  nums  sorted in  non-decreasing  order, return  the maximum between the number of positive integers and the number of negative integers. In other words, if the number of positive integers in  nums  is  pos  and the number of negative integers is  neg , then return the maximum of  pos  and  neg . Note  that  0  is neither positive nor negative.   Example 1: Input:  nums = [-2,-1,-1,1,2,3] Output:  3 Explanation:  There are 3 positive integers and 3 negative integers. The maximum count among them is 3. Example 2: Input:  nums = [-3,-2,-1,0,0,1,2] Output:  3 Explanation:  There are 2 positive integers and 3 negative integers. The maximum count among them is 3. Example 3: Input:  nums = [5,20,66,1314] Output:  4 Explanation:  There are 4 positive integers and 0 negative integers. The maximum count among them is 4.   Constraints: 1 <= nums.length <= 2000 -2000 <= nums[i] <= 2000 nums  is sorted in a  non-decreasing order .   Follow up:  Can you solve the problem in  O(log(n))  time complexity?","['Array', 'Binary Search', 'Counting']",Fácil,Array,False
2535,difference-between-element-sum-and-digit-sum-of-an-array,https://leetcode.com/problems/difference-between-element-sum-and-digit-sum-of-an-array/,Difference Between Element Sum and Digit Sum of an Array,"You are given a positive integer array  nums . The  element sum  is the sum of all the elements in  nums . The  digit sum  is the sum of all the digits (not necessarily distinct) that appear in  nums . Return  the  absolute  difference between the  element sum  and  digit sum  of  nums . Note  that the absolute difference between two integers  x  and  y  is defined as  |x - y| .   Example 1: Input:  nums = [1,15,6,3] Output:  9 Explanation:   The element sum of nums is 1 + 15 + 6 + 3 = 25. The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16. The absolute difference between the element sum and digit sum is |25 - 16| = 9. Example 2: Input:  nums = [1,2,3,4] Output:  0 Explanation: The element sum of nums is 1 + 2 + 3 + 4 = 10. The digit sum of nums is 1 + 2 + 3 + 4 = 10. The absolute difference between the element sum and digit sum is |10 - 10| = 0.   Constraints: 1 <= nums.length <= 2000 1 <= nums[i] <= 2000","['Array', 'Math']",Fácil,Array,False
2540,minimum-common-value,https://leetcode.com/problems/minimum-common-value/,Minimum Common Value,"Given two integer arrays  nums1  and  nums2 , sorted in non-decreasing order, return  the  minimum integer common  to both arrays . If there is no common integer amongst  nums1  and  nums2 , return  -1 . Note that an integer is said to be  common  to  nums1  and  nums2  if both arrays have  at least one  occurrence of that integer.   Example 1: Input:  nums1 = [1,2,3], nums2 = [2,4] Output:  2 Explanation:  The smallest element common to both arrays is 2, so we return 2. Example 2: Input:  nums1 = [1,2,3,6], nums2 = [2,3,4,5] Output:  2 Explanation:  There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.   Constraints: 1 <= nums1.length, nums2.length <= 10 5 1 <= nums1[i], nums2[j] <= 10 9 Both  nums1  and  nums2  are sorted in  non-decreasing  order.","['Array', 'Hash Table', 'Two Pointers', 'Binary Search']",Fácil,Array,False
2553,separate-the-digits-in-an-array,https://leetcode.com/problems/separate-the-digits-in-an-array/,Separate the Digits in an Array,"Given an array of positive integers  nums , return  an array  answer  that consists of the digits of each integer in  nums  after separating them in  the same order  they appear in  nums . To separate the digits of an integer is to get all the digits it has in the same order. For example, for the integer  10921 , the separation of its digits is  [1,0,9,2,1] .   Example 1: Input:  nums = [13,25,83,77] Output:  [1,3,2,5,8,3,7,7] Explanation:   - The separation of 13 is [1,3]. - The separation of 25 is [2,5]. - The separation of 83 is [8,3]. - The separation of 77 is [7,7]. answer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order. Example 2: Input:  nums = [7,1,3,9] Output:  [7,1,3,9] Explanation:  The separation of each integer in nums is itself. answer = [7,1,3,9].   Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 10 5","['Array', 'Simulation']",Fácil,Array,False
2900,longest-unequal-adjacent-groups-subsequence-i,https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/,Longest Unequal Adjacent Groups Subsequence I,"You are given a string array  words  and a  binary  array  groups  both of length  n . A  subsequence  of  words  is  alternating  if for any two  consecutive  strings in the sequence, their corresponding elements at the  same  indices in  groups  are  different  (that is, there  cannot  be consecutive 0 or 1). Your task is to select the  longest alternating  subsequence from  words . Return  the selected subsequence. If there are multiple answers, return  any  of them. Note:  The elements in  words  are distinct.   Example 1: Input:   words = [""e"",""a"",""b""], groups = [0,0,1] Output:   [""e"",""b""] Explanation:  A subsequence that can be selected is  [""e"",""b""]  because  groups[0] != groups[2] . Another subsequence that can be selected is  [""a"",""b""]  because  groups[1] != groups[2] . It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is  2 . Example 2: Input:   words = [""a"",""b"",""c"",""d""], groups = [1,0,1,1] Output:   [""a"",""b"",""c""] Explanation:  A subsequence that can be selected is  [""a"",""b"",""c""]  because  groups[0] != groups[1]  and  groups[1] != groups[2] . Another subsequence that can be selected is  [""a"",""b"",""d""]  because  groups[0] != groups[1]  and  groups[1] != groups[3] . It can be shown that the length of the longest subsequence of indices that satisfies the condition is  3 .   Constraints: 1 <= n == words.length == groups.length <= 100 1 <= words[i].length <= 10 groups[i]  is either  0  or  1. words  consists of  distinct  strings. words[i]  consists of lowercase English letters.","['Array', 'String', 'Dynamic Programming', 'Greedy']",Fácil,Array,False
368,largest-divisible-subset,https://leetcode.com/problems/largest-divisible-subset/,Largest Divisible Subset,"Given a set of  distinct  positive integers  nums , return the largest subset  answer  such that every pair  (answer[i], answer[j])  of elements in this subset satisfies: answer[i] % answer[j] == 0 , or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them.   Example 1: Input:  nums = [1,2,3] Output:  [1,2] Explanation:  [1,3] is also accepted. Example 2: Input:  nums = [1,2,4,8] Output:  [1,2,4,8]   Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 2 * 10 9 All the integers in  nums  are  unique .","['Array', 'Math', 'Dynamic Programming', 'Sorting']",Média,Array,False
416,partition-equal-subset-sum,https://leetcode.com/problems/partition-equal-subset-sum/,Partition Equal Subset Sum,"Given an integer array  nums , return  true   if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or  false  otherwise .   Example 1: Input:  nums = [1,5,11,5] Output:  true Explanation:  The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input:  nums = [1,2,3,5] Output:  false Explanation:  The array cannot be partitioned into equal sum subsets.   Constraints: 1 <= nums.length <= 200 1 <= nums[i] <= 100","['Array', 'Dynamic Programming']",Média,Array,False
421,maximum-xor-of-two-numbers-in-an-array,https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/,Maximum XOR of Two Numbers in an Array,"Given an integer array  nums , return  the maximum result of  nums[i] XOR nums[j] , where  0 <= i <= j < n .   Example 1: Input:  nums = [3,10,5,25,2,8] Output:  28 Explanation:  The maximum result is 5 XOR 25 = 28. Example 2: Input:  nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output:  127   Constraints: 1 <= nums.length <= 2 * 10 5 0 <= nums[i] <= 2 31  - 1","['Array', 'Hash Table', 'Bit Manipulation', 'Trie']",Média,Array,False
442,find-all-duplicates-in-an-array,https://leetcode.com/problems/find-all-duplicates-in-an-array/,Find All Duplicates in an Array,"Given an integer array  nums  of length  n  where all the integers of  nums  are in the range  [1, n]  and each integer appears  at most   twice , return  an array of all the integers that appears  twice . You must write an algorithm that runs in  O(n)  time and uses only  constant  auxiliary space, excluding the space needed to store the output   Example 1: Input:  nums = [4,3,2,7,8,2,3,1] Output:  [2,3] Example 2: Input:  nums = [1,1,2] Output:  [1] Example 3: Input:  nums = [1] Output:  []   Constraints: n == nums.length 1 <= n <= 10 5 1 <= nums[i] <= n Each element in  nums  appears  once  or  twice .","['Array', 'Hash Table']",Média,Array,False
523,continuous-subarray-sum,https://leetcode.com/problems/continuous-subarray-sum/,Continuous Subarray Sum,"Given an integer array nums and an integer k, return  true   if  nums  has a  good subarray  or  false  otherwise . A  good subarray  is a subarray where: its length is  at least two , and the sum of the elements of the subarray is a multiple of  k . Note  that: A  subarray  is a contiguous part of the array. An integer  x  is a multiple of  k  if there exists an integer  n  such that  x = n * k .  0  is  always  a multiple of  k .   Example 1: Input:  nums = [23, 2,4 ,6,7], k = 6 Output:  true Explanation:  [2, 4] is a continuous subarray of size 2 whose elements sum up to 6. Example 2: Input:  nums = [ 23,2,6,4,7 ], k = 6 Output:  true Explanation:  [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer. Example 3: Input:  nums = [23,2,6,4,7], k = 13 Output:  false   Constraints: 1 <= nums.length <= 10 5 0 <= nums[i] <= 10 9 0 <= sum(nums[i]) <= 2 31  - 1 1 <= k <= 2 31  - 1","['Array', 'Hash Table', 'Math', 'Prefix Sum']",Média,Array,False
648,replace-words,https://leetcode.com/problems/replace-words/,Replace Words,"In English, we have a concept called  root , which can be followed by some other word to form another longer word - let's call this word  derivative . For example, when the  root   ""help""  is followed by the word  ""ful"" , we can form a derivative  ""helpful"" . Given a  dictionary  consisting of many  roots  and a  sentence  consisting of words separated by spaces, replace all the derivatives in the sentence with the  root  forming it. If a derivative can be replaced by more than one  root , replace it with the  root  that has  the shortest length . Return  the  sentence  after the replacement.   Example 1: Input:  dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery"" Output:  ""the cat was rat by the bat"" Example 2: Input:  dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs"" Output:  ""a a b c""   Constraints: 1 <= dictionary.length <= 1000 1 <= dictionary[i].length <= 100 dictionary[i]  consists of only lower-case letters. 1 <= sentence.length <= 10 6 sentence  consists of only lower-case letters and spaces. The number of words in  sentence  is in the range  [1, 1000] The length of each word in  sentence  is in the range  [1, 1000] Every two consecutive words in  sentence  will be separated by exactly one space. sentence  does not have leading or trailing spaces.","['Array', 'Hash Table', 'String', 'Trie']",Média,Array,False
665,non-decreasing-array,https://leetcode.com/problems/non-decreasing-array/,Non-decreasing Array,"Given an array  nums  with  n  integers, your task is to check if it could become non-decreasing by modifying  at most one element . We define an array is non-decreasing if  nums[i] <= nums[i + 1]  holds for every  i  ( 0-based ) such that ( 0 <= i <= n - 2 ).   Example 1: Input:  nums = [4,2,3] Output:  true Explanation:  You could modify the first 4 to 1 to get a non-decreasing array. Example 2: Input:  nums = [4,2,1] Output:  false Explanation:  You cannot get a non-decreasing array by modifying at most one element.   Constraints: n == nums.length 1 <= n <= 10 4 -10 5  <= nums[i] <= 10 5",['Array'],Média,Array,False
667,beautiful-arrangement-ii,https://leetcode.com/problems/beautiful-arrangement-ii/,Beautiful Arrangement II,"Given two integers  n  and  k , construct a list  answer  that contains  n  different positive integers ranging from  1  to  n  and obeys the following requirement: Suppose this list is  answer = [a 1 , a 2 , a 3 , ... , a n ] , then the list  [|a 1  - a 2 |, |a 2  - a 3 |, |a 3  - a 4 |, ... , |a n-1  - a n |]  has exactly  k  distinct integers. Return  the list   answer . If there multiple valid answers, return  any of them .   Example 1: Input:  n = 3, k = 1 Output:  [1,2,3] Explanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1 Example 2: Input:  n = 3, k = 2 Output:  [1,3,2] Explanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.   Constraints: 1 <= k < n <= 10 4","['Array', 'Math']",Média,Array,False
673,number-of-longest-increasing-subsequence,https://leetcode.com/problems/number-of-longest-increasing-subsequence/,Number of Longest Increasing Subsequence,"Given an integer array  nums , return  the number of longest increasing subsequences. Notice  that the sequence has to be  strictly  increasing.   Example 1: Input:  nums = [1,3,5,4,7] Output:  2 Explanation:  The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input:  nums = [2,2,2,2,2] Output:  5 Explanation:  The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.   Constraints: 1 <= nums.length <= 2000 -10 6  <= nums[i] <= 10 6 The answer is guaranteed to fit inside a 32-bit integer.","['Array', 'Dynamic Programming', 'Binary Indexed Tree', 'Segment Tree']",Média,Array,False
875,koko-eating-bananas,https://leetcode.com/problems/koko-eating-bananas/,Koko Eating Bananas,"Koko loves to eat bananas. There are  n  piles of bananas, the  i th  pile has  piles[i]  bananas. The guards have gone and will come back in  h  hours. Koko can decide her bananas-per-hour eating speed of  k . Each hour, she chooses some pile of bananas and eats  k  bananas from that pile. If the pile has less than  k  bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return  the minimum integer   k   such that she can eat all the bananas within   h   hours .   Example 1: Input:  piles = [3,6,7,11], h = 8 Output:  4 Example 2: Input:  piles = [30,11,23,4,20], h = 5 Output:  30 Example 3: Input:  piles = [30,11,23,4,20], h = 6 Output:  23   Constraints: 1 <= piles.length <= 10 4 piles.length <= h <= 10 9 1 <= piles[i] <= 10 9","['Array', 'Binary Search']",Média,Array,False
990,satisfiability-of-equality-equations,https://leetcode.com/problems/satisfiability-of-equality-equations/,Satisfiability of Equality Equations,"You are given an array of strings  equations  that represent relationships between variables where each string  equations[i]  is of length  4  and takes one of two different forms:  ""x i ==y i ""  or  ""x i !=y i "" .Here,  x i  and  y i  are lowercase letters (not necessarily different) that represent one-letter variable names. Return  true  if it is possible to assign integers to variable names so as to satisfy all the given equations, or  false  otherwise .   Example 1: Input:  equations = [""a==b"",""b!=a""] Output:  false Explanation:  If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations. Example 2: Input:  equations = [""b==a"",""a==b""] Output:  true Explanation:  We could assign a = 1 and b = 1 to satisfy both equations.   Constraints: 1 <= equations.length <= 500 equations[i].length == 4 equations[i][0]  is a lowercase letter. equations[i][1]  is either  '='  or  '!' . equations[i][2]  is  '=' . equations[i][3]  is a lowercase letter.","['Array', 'String', 'Union Find', 'Graph']",Média,Array,False
1004,max-consecutive-ones-iii,https://leetcode.com/problems/max-consecutive-ones-iii/,Max Consecutive Ones III,"Given a binary array  nums  and an integer  k , return  the maximum number of consecutive  1 's in the array if you can flip at most   k   0 's.   Example 1: Input:  nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2 Output:  6 Explanation:  [1,1,1,0,0, 1 ,1,1,1,1, 1 ] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2: Input:  nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3 Output:  10 Explanation:  [0,0, 1,1, 1 , 1 ,1,1,1, 1 ,1,1 ,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.   Constraints: 1 <= nums.length <= 10 5 nums[i]  is either  0  or  1 . 0 <= k <= nums.length","['Array', 'Binary Search', 'Sliding Window', 'Prefix Sum']",Média,Array,False
1010,pairs-of-songs-with-total-durations-divisible-by-60,https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/,Pairs of Songs With Total Durations Divisible by 60,"You are given a list of songs where the  i th  song has a duration of  time[i]  seconds. Return  the number of pairs of songs for which their total duration in seconds is divisible by   60 . Formally, we want the number of indices  i ,  j  such that  i < j  with  (time[i] + time[j]) % 60 == 0 .   Example 1: Input:  time = [30,20,150,100,40] Output:  3 Explanation:  Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input:  time = [60,60,60] Output:  3 Explanation:  All three pairs have a total duration of 120, which is divisible by 60.   Constraints: 1 <= time.length <= 6 * 10 4 1 <= time[i] <= 500","['Array', 'Hash Table', 'Counting']",Média,Array,False
1048,longest-string-chain,https://leetcode.com/problems/longest-string-chain/,Longest String Chain,"You are given an array of  words  where each word consists of lowercase English letters. word A  is a  predecessor  of  word B  if and only if we can insert  exactly one  letter anywhere in  word A   without changing the order of the other characters  to make it equal to  word B . For example,  ""abc""  is a  predecessor  of  ""ab a c"" , while  ""cba""  is not a  predecessor  of  ""bcad"" . A  word chain   is a sequence of words  [word 1 , word 2 , ..., word k ]  with  k >= 1 , where  word 1  is a  predecessor  of  word 2 ,  word 2  is a  predecessor  of  word 3 , and so on. A single word is trivially a  word chain  with  k == 1 . Return  the  length  of the  longest possible word chain  with words chosen from the given list of  words .   Example 1: Input:  words = [""a"",""b"",""ba"",""bca"",""bda"",""bdca""] Output:  4 Explanation : One of the longest word chains is [""a"","" b a"",""b d a"",""bd c a""]. Example 2: Input:  words = [""xbc"",""pcxbcf"",""xb"",""cxbc"",""pcxbc""] Output:  5 Explanation:  All the words can be put in a word chain [""xb"", ""xb c "", "" c xbc"", "" p cxbc"", ""pcxbc f ""]. Example 3: Input:  words = [""abcd"",""dbqca""] Output:  1 Explanation:  The trivial word chain [""abcd""] is one of the longest word chains. [""abcd"",""dbqca""] is not a valid word chain because the ordering of the letters is changed.   Constraints: 1 <= words.length <= 1000 1 <= words[i].length <= 16 words[i]  only consists of lowercase English letters.","['Array', 'Hash Table', 'Two Pointers', 'String', 'Dynamic Programming', 'Sorting']",Média,Array,False
1124,longest-well-performing-interval,https://leetcode.com/problems/longest-well-performing-interval/,Longest Well-Performing Interval,"We are given  hours , a list of the number of hours worked per day for a given employee. A day is considered to be a  tiring day  if and only if the number of hours worked is (strictly) greater than  8 . A  well-performing interval  is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days. Return the length of the longest well-performing interval.   Example 1: Input:  hours = [9,9,6,0,6,6,9] Output:  3 Explanation:  The longest well-performing interval is [9,9,6]. Example 2: Input:  hours = [6,6,6] Output:  0   Constraints: 1 <= hours.length <= 10 4 0 <= hours[i] <= 16","['Array', 'Hash Table', 'Stack', 'Monotonic Stack', 'Prefix Sum']",Média,Array,False
1288,remove-covered-intervals,https://leetcode.com/problems/remove-covered-intervals/,Remove Covered Intervals,"Given an array  intervals  where  intervals[i] = [l i , r i ]  represent the interval  [l i , r i ) , remove all intervals that are covered by another interval in the list. The interval  [a, b)  is covered by the interval  [c, d)  if and only if  c <= a  and  b <= d . Return  the number of remaining intervals .   Example 1: Input:  intervals = [[1,4],[3,6],[2,8]] Output:  2 Explanation:  Interval [3,6] is covered by [2,8], therefore it is removed. Example 2: Input:  intervals = [[1,4],[2,3]] Output:  1   Constraints: 1 <= intervals.length <= 1000 intervals[i].length == 2 0 <= l i  < r i  <= 10 5 All the given intervals are  unique .","['Array', 'Sorting']",Média,Array,False
1497,check-if-array-pairs-are-divisible-by-k,https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/,Check If Array Pairs Are Divisible by k,"Given an array of integers  arr  of even length  n  and an integer  k . We want to divide the array into exactly  n / 2  pairs such that the sum of each pair is divisible by  k . Return  true  If you can find a way to do that or  false  otherwise .   Example 1: Input:  arr = [1,2,3,4,5,10,6,7,8,9], k = 5 Output:  true Explanation:  Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10). Example 2: Input:  arr = [1,2,3,4,5,6], k = 7 Output:  true Explanation:  Pairs are (1,6),(2,5) and(3,4). Example 3: Input:  arr = [1,2,3,4,5,6], k = 10 Output:  false Explanation:  You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.   Constraints: arr.length == n 1 <= n <= 10 5 n  is even. -10 9  <= arr[i] <= 10 9 1 <= k <= 10 5","['Array', 'Hash Table', 'Counting']",Média,Array,False
1509,minimum-difference-between-largest-and-smallest-value-in-three-moves,https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/,Minimum Difference Between Largest and Smallest Value in Three Moves,"You are given an integer array  nums . In one move, you can choose one element of  nums  and change it to  any value . Return  the minimum difference between the largest and smallest value of  nums   after performing at most three moves .   Example 1: Input:  nums = [5,3,2,4] Output:  0 Explanation:  We can make at most 3 moves. In the first move, change 2 to 3. nums becomes [5,3,3,4]. In the second move, change 4 to 3. nums becomes [5,3,3,3]. In the third move, change 5 to 3. nums becomes [3,3,3,3]. After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0. Example 2: Input:  nums = [1,5,0,10,14] Output:  1 Explanation:  We can make at most 3 moves. In the first move, change 5 to 0. nums becomes [1,0,0,10,14]. In the second move, change 10 to 0. nums becomes [1,0,0,0,14]. In the third move, change 14 to 1. nums becomes [1,0,0,0,1]. After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1. It can be shown that there is no way to make the difference 0 in 3 moves. Example 3: Input:  nums = [3,100,20] Output:  0 Explanation:  We can make at most 3 moves. In the first move, change 100 to 7. nums becomes [3,7,20]. In the second move, change 20 to 7. nums becomes [3,7,7]. In the third move, change 3 to 7. nums becomes [7,7,7]. After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.   Constraints: 1 <= nums.length <= 10 5 -10 9  <= nums[i] <= 10 9","['Array', 'Greedy', 'Sorting']",Média,Array,False
1696,jump-game-vi,https://leetcode.com/problems/jump-game-vi/,Jump Game VI,"You are given a  0-indexed  integer array  nums  and an integer  k . You are initially standing at index  0 . In one move, you can jump at most  k  steps forward without going outside the boundaries of the array. That is, you can jump from index  i  to any index in the range  [i + 1, min(n - 1, i + k)]   inclusive . You want to reach the last index of the array (index  n - 1 ). Your  score  is the  sum  of all  nums[j]  for each index  j  you visited in the array. Return  the  maximum score  you can get .   Example 1: Input:  nums = [ 1 , -1 ,-2, 4 ,-7, 3 ], k = 2 Output:  7 Explanation:  You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7. Example 2: Input:  nums = [ 10 ,-5,-2, 4 ,0, 3 ], k = 3 Output:  17 Explanation:  You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17. Example 3: Input:  nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 Output:  0   Constraints: 1 <= nums.length, k <= 10 5 -10 4  <= nums[i] <= 10 4","['Array', 'Dynamic Programming', 'Queue', 'Heap (Priority Queue)', 'Monotonic Queue']",Média,Array,False
1718,construct-the-lexicographically-largest-valid-sequence,https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/,Construct the Lexicographically Largest Valid Sequence,"Given an integer  n , find a sequence with elements in the range  [1, n]  that satisfies all of the following: The integer  1  occurs once in the sequence. Each integer between  2  and  n  occurs twice in the sequence. For every integer  i  between  2  and  n , the  distance  between the two occurrences of  i  is exactly  i . The  distance  between two numbers on the sequence,  a[i]  and  a[j] , is the absolute difference of their indices,  |j - i| . Return  the  lexicographically largest  sequence . It is guaranteed that under the given constraints, there is always a solution.  A sequence  a  is lexicographically larger than a sequence  b  (of the same length) if in the first position where  a  and  b  differ, sequence  a  has a number greater than the corresponding number in  b . For example,  [0,1,9,0]  is lexicographically larger than  [0,1,5,6]  because the first position they differ is at the third number, and  9  is greater than  5 .   Example 1: Input:  n = 3 Output:  [3,1,2,3,2] Explanation:  [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence. Example 2: Input:  n = 5 Output:  [5,3,1,4,3,5,2,4,2]   Constraints: 1 <= n <= 20","['Array', 'Backtracking']",Média,Array,False
2244,minimum-rounds-to-complete-all-tasks,https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/,Minimum Rounds to Complete All Tasks,"You are given a  0-indexed  integer array  tasks , where  tasks[i]  represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the  same difficulty level . Return  the  minimum  rounds required to complete all the tasks, or  -1  if it is not possible to complete all the tasks.   Example 1: Input:  tasks = [2,2,3,3,2,4,4,4,4,4] Output:  4 Explanation:  To complete all the tasks, a possible plan is: - In the first round, you complete 3 tasks of difficulty level 2.  - In the second round, you complete 2 tasks of difficulty level 3.  - In the third round, you complete 3 tasks of difficulty level 4.  - In the fourth round, you complete 2 tasks of difficulty level 4.   It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4. Example 2: Input:  tasks = [2,3,3] Output:  -1 Explanation:  There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.   Constraints: 1 <= tasks.length <= 10 5 1 <= tasks[i] <= 10 9   Note:  This question is the same as  2870: Minimum Number of Operations to Make Array Empty.","['Array', 'Hash Table', 'Greedy', 'Counting']",Média,Array,False
2270,number-of-ways-to-split-array,https://leetcode.com/problems/number-of-ways-to-split-array/,Number of Ways to Split Array,"You are given a  0-indexed  integer array  nums  of length  n . nums  contains a  valid split  at index  i  if the following are true: The sum of the first  i + 1  elements is  greater than or equal to  the sum of the last  n - i - 1  elements. There is  at least one  element to the right of  i . That is,  0 <= i < n - 1 . Return  the number of  valid splits  in   nums .   Example 1: Input:  nums = [10,4,-8,7] Output:  2 Explanation:   There are three ways of splitting nums into two non-empty parts: - Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split. - Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split. - Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split. Thus, the number of valid splits in nums is 2. Example 2: Input:  nums = [2,3,1,0] Output:  2 Explanation:   There are two valid splits in nums: - Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split.  - Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split.   Constraints: 2 <= nums.length <= 10 5 -10 5  <= nums[i] <= 10 5","['Array', 'Prefix Sum']",Média,Array,False
2279,maximum-bags-with-full-capacity-of-rocks,https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/,Maximum Bags With Full Capacity of Rocks,"You have  n  bags numbered from  0  to  n - 1 . You are given two  0-indexed  integer arrays  capacity  and  rocks . The  i th  bag can hold a maximum of  capacity[i]  rocks and currently contains  rocks[i]  rocks. You are also given an integer  additionalRocks , the number of additional rocks you can place in  any  of the bags. Return  the  maximum  number of bags that could have full capacity after placing the additional rocks in some bags.   Example 1: Input:  capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2 Output:  3 Explanation: Place 1 rock in bag 0 and 1 rock in bag 1. The number of rocks in each bag are now [2,3,4,4]. Bags 0, 1, and 2 have full capacity. There are 3 bags at full capacity, so we return 3. It can be shown that it is not possible to have more than 3 bags at full capacity. Note that there may be other ways of placing the rocks that result in an answer of 3. Example 2: Input:  capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100 Output:  3 Explanation: Place 8 rocks in bag 0 and 2 rocks in bag 2. The number of rocks in each bag are now [10,2,2]. Bags 0, 1, and 2 have full capacity. There are 3 bags at full capacity, so we return 3. It can be shown that it is not possible to have more than 3 bags at full capacity. Note that we did not use all of the additional rocks.   Constraints: n == capacity.length == rocks.length 1 <= n <= 5 * 10 4 1 <= capacity[i] <= 10 9 0 <= rocks[i] <= capacity[i] 1 <= additionalRocks <= 10 9","['Array', 'Greedy', 'Sorting']",Média,Array,False
2284,sender-with-largest-word-count,https://leetcode.com/problems/sender-with-largest-word-count/,Sender With Largest Word Count,"You have a chat log of  n  messages. You are given two string arrays  messages  and  senders  where  messages[i]  is a  message  sent by  senders[i] . A  message  is list of  words  that are separated by a single space with no leading or trailing spaces. The  word count  of a sender is the total number of  words  sent by the sender. Note that a sender may send more than one message. Return  the sender with the  largest  word count . If there is more than one sender with the largest word count, return  the one with the  lexicographically largest  name . Note: Uppercase letters come before lowercase letters in lexicographical order. ""Alice""  and  ""alice""  are distinct.   Example 1: Input:  messages = [""Hello userTwooo"",""Hi userThree"",""Wonderful day Alice"",""Nice day userThree""], senders = [""Alice"",""userTwo"",""userThree"",""Alice""] Output:  ""Alice"" Explanation:  Alice sends a total of 2 + 3 = 5 words. userTwo sends a total of 2 words. userThree sends a total of 3 words. Since Alice has the largest word count, we return ""Alice"". Example 2: Input:  messages = [""How is leetcode for everyone"",""Leetcode is useful for practice""], senders = [""Bob"",""Charlie""] Output:  ""Charlie"" Explanation:  Bob sends a total of 5 words. Charlie sends a total of 5 words. Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.   Constraints: n == messages.length == senders.length 1 <= n <= 10 4 1 <= messages[i].length <= 100 1 <= senders[i].length <= 10 messages[i]  consists of uppercase and lowercase English letters and  ' ' . All the words in  messages[i]  are separated by  a single space . messages[i]  does not have leading or trailing spaces. senders[i]  consists of uppercase and lowercase English letters only.","['Array', 'Hash Table', 'String', 'Counting']",Média,Array,False
2289,steps-to-make-array-non-decreasing,https://leetcode.com/problems/steps-to-make-array-non-decreasing/,Steps to Make Array Non-decreasing,"You are given a  0-indexed  integer array  nums . In one step,  remove  all elements  nums[i]  where  nums[i - 1] > nums[i]  for all  0 < i < nums.length . Return  the number of steps performed until  nums  becomes a  non-decreasing  array .   Example 1: Input:  nums = [5,3,4,4,7,3,6,11,8,5,11] Output:  3 Explanation:  The following are the steps performed: - Step 1: [5, 3 ,4,4,7, 3 ,6,11, 8 , 5 ,11] becomes [5,4,4,7,6,11,11] - Step 2: [5, 4 ,4,7, 6 ,11,11] becomes [5,4,7,11,11] - Step 3: [5, 4 ,7,11,11] becomes [5,7,11,11] [5,7,11,11] is a non-decreasing array. Therefore, we return 3. Example 2: Input:  nums = [4,5,7,7,13] Output:  0 Explanation:  nums is already a non-decreasing array. Therefore, we return 0.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9","['Array', 'Linked List', 'Stack', 'Monotonic Stack']",Média,Array,False
2419,longest-subarray-with-maximum-bitwise-and,https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/,Longest Subarray With Maximum Bitwise AND,"You are given an integer array  nums  of size  n . Consider a  non-empty  subarray from  nums  that has the  maximum  possible  bitwise AND . In other words, let  k  be the maximum value of the bitwise AND of  any  subarray of  nums . Then, only subarrays with a bitwise AND equal to  k  should be considered. Return  the length of the  longest  such subarray . The bitwise AND of an array is the bitwise AND of all the numbers in it. A  subarray  is a contiguous sequence of elements within an array.   Example 1: Input:  nums = [1,2,3,3,2,2] Output:  2 Explanation: The maximum possible bitwise AND of a subarray is 3. The longest subarray with that value is [3,3], so we return 2. Example 2: Input:  nums = [1,2,3,4] Output:  1 Explanation: The maximum possible bitwise AND of a subarray is 4. The longest subarray with that value is [4], so we return 1.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 6","['Array', 'Bit Manipulation', 'Brainteaser']",Média,Array,False
2537,count-the-number-of-good-subarrays,https://leetcode.com/problems/count-the-number-of-good-subarrays/,Count the Number of Good Subarrays,"Given an integer array  nums  and an integer  k , return  the number of  good  subarrays of   nums . A subarray  arr  is  good  if there are  at least  k  pairs of indices  (i, j)  such that  i < j  and  arr[i] == arr[j] . A  subarray  is a contiguous  non-empty  sequence of elements within an array.   Example 1: Input:  nums = [1,1,1,1,1], k = 10 Output:  1 Explanation:  The only good subarray is the array nums itself. Example 2: Input:  nums = [3,1,4,3,2,2,4], k = 2 Output:  4 Explanation:  There are 4 different good subarrays: - [3,1,4,3,2,2] that has 2 pairs. - [3,1,4,3,2,2,4] that has 3 pairs. - [1,4,3,2,2,4] that has 2 pairs. - [4,3,2,2,4] that has 2 pairs.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i], k <= 10 9","['Array', 'Hash Table', 'Sliding Window']",Média,Array,False
2542,maximum-subsequence-score,https://leetcode.com/problems/maximum-subsequence-score/,Maximum Subsequence Score,"You are given two  0-indexed  integer arrays  nums1  and  nums2  of equal length  n  and a positive integer  k . You must choose a  subsequence  of indices from  nums1  of length  k . For chosen indices  i 0 ,  i 1 , ...,  i k - 1 , your  score  is defined as: The sum of the selected elements from  nums1  multiplied with the  minimum  of the selected elements from  nums2 . It can defined simply as:  (nums1[i 0 ] + nums1[i 1 ] +...+ nums1[i k - 1 ]) * min(nums2[i 0 ] , nums2[i 1 ], ... ,nums2[i k - 1 ]) . Return  the  maximum  possible score. A  subsequence  of indices of an array is a set that can be derived from the set  {0, 1, ..., n-1}  by deleting some or no elements.   Example 1: Input:  nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3 Output:  12 Explanation:   The four possible subsequence scores are: - We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7. - We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6.  - We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12.  - We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8. Therefore, we return the max score, which is 12. Example 2: Input:  nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1 Output:  30 Explanation:   Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.   Constraints: n == nums1.length == nums2.length 1 <= n <= 10 5 0 <= nums1[i], nums2[j] <= 10 5 1 <= k <= n","['Array', 'Greedy', 'Sorting', 'Heap (Priority Queue)']",Média,Array,False
2575,find-the-divisibility-array-of-a-string,https://leetcode.com/problems/find-the-divisibility-array-of-a-string/,Find the Divisibility Array of a String,"You are given a  0-indexed  string  word  of length  n  consisting of digits, and a positive integer  m . The  divisibility array   div  of  word  is an integer array of length  n  such that: div[i] = 1  if the  numeric value  of  word[0,...,i]  is divisible by  m , or div[i] = 0  otherwise. Return  the divisibility array of   word .   Example 1: Input:  word = ""998244353"", m = 3 Output:  [1,1,0,0,0,1,1,0,0] Explanation:  There are only 4 prefixes that are divisible by 3: ""9"", ""99"", ""998244"", and ""9982443"". Example 2: Input:  word = ""1010"", m = 10 Output:  [0,1,0,1] Explanation:  There are only 2 prefixes that are divisible by 10: ""10"", and ""1010"".   Constraints: 1 <= n <= 10 5 word.length == n word  consists of digits from  0  to  9 1 <= m <= 10 9","['Array', 'Math', 'String']",Média,Array,False
2576,find-the-maximum-number-of-marked-indices,https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/,Find the Maximum Number of Marked Indices,"You are given a  0-indexed  integer array  nums . Initially, all of the indices are unmarked. You are allowed to make this operation any number of times: Pick two  different unmarked  indices  i  and  j  such that  2 * nums[i] <= nums[j] , then mark  i  and  j . Return  the maximum possible number of marked indices in  nums  using the above operation any number of times .   Example 1: Input:  nums = [3,5,2,4] Output:  2 Explanation:  In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1. It can be shown that there's no other valid operation so the answer is 2. Example 2: Input:  nums = [9,2,5,4] Output:  4 Explanation:  In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0. In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2. Since there is no other operation, the answer is 4. Example 3: Input:  nums = [7,6,8] Output:  0 Explanation:  There is no valid operation to do, so the answer is 0.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9","['Array', 'Two Pointers', 'Binary Search', 'Greedy', 'Sorting']",Média,Array,False
77,combinations,https://leetcode.com/problems/combinations/,Combinations,"Given two integers  n  and  k , return  all possible combinations of   k   numbers chosen from the range   [1, n] . You may return the answer in  any order .   Example 1: Input:  n = 4, k = 2 Output:  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Explanation:  There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination. Example 2: Input:  n = 1, k = 1 Output:  [[1]] Explanation:  There is 1 choose 1 = 1 total combination.   Constraints: 1 <= n <= 20 1 <= k <= n",['Backtracking'],Média,Backtracking,False
967,numbers-with-same-consecutive-differences,https://leetcode.com/problems/numbers-with-same-consecutive-differences/,Numbers With Same Consecutive Differences,"Given two integers n and k, return  an array of all the integers of length  n  where the difference between every two consecutive digits is  k . You may return the answer in  any order . Note that the integers should not have leading zeros. Integers as  02  and  043  are not allowed.   Example 1: Input:  n = 3, k = 7 Output:  [181,292,707,818,929] Explanation:  Note that 070 is not a valid number, because it has leading zeroes. Example 2: Input:  n = 2, k = 1 Output:  [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]   Constraints: 2 <= n <= 9 0 <= k <= 9","['Backtracking', 'Breadth-First Search']",Média,Backtracking,False
352,data-stream-as-disjoint-intervals,https://leetcode.com/problems/data-stream-as-disjoint-intervals/,Data Stream as Disjoint Intervals,"Given a data stream input of non-negative integers  a 1 , a 2 , ..., a n , summarize the numbers seen so far as a list of disjoint intervals. Implement the  SummaryRanges  class: SummaryRanges()  Initializes the object with an empty stream. void addNum(int value)  Adds the integer  value  to the stream. int[][] getIntervals()  Returns a summary of the integers in the stream currently as a list of disjoint intervals  [start i , end i ] . The answer should be sorted by  start i .   Example 1: Input [""SummaryRanges"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals""] [[], [1], [], [3], [], [7], [], [2], [], [6], []] Output [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]] Explanation SummaryRanges summaryRanges = new SummaryRanges(); summaryRanges.addNum(1);      // arr = [1] summaryRanges.getIntervals(); // return [[1, 1]] summaryRanges.addNum(3);      // arr = [1, 3] summaryRanges.getIntervals(); // return [[1, 1], [3, 3]] summaryRanges.addNum(7);      // arr = [1, 3, 7] summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]] summaryRanges.addNum(2);      // arr = [1, 2, 3, 7] summaryRanges.getIntervals(); // return [[1, 3], [7, 7]] summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7] summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]   Constraints: 0 <= value <= 10 4 At most  3 * 10 4  calls will be made to  addNum  and  getIntervals . At most  10 2  calls will be made to  getIntervals .   Follow up:  What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?","['Binary Search', 'Design', 'Ordered Set']",Difícil,Binary Search,False
732,my-calendar-iii,https://leetcode.com/problems/my-calendar-iii/,My Calendar III,"A  k -booking happens when  k  events have some non-empty intersection (i.e., there is some time that is common to all  k  events.) You are given some events  [startTime, endTime) , after each given event, return an integer  k  representing the maximum  k -booking between all the previous events. Implement the  MyCalendarThree  class: MyCalendarThree()  Initializes the object. int book(int startTime, int endTime)  Returns an integer  k  representing the largest integer such that there exists a  k -booking in the calendar.   Example 1: Input [""MyCalendarThree"", ""book"", ""book"", ""book"", ""book"", ""book"", ""book""] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1 myCalendarThree.book(50, 60); // return 1 myCalendarThree.book(10, 40); // return 2 myCalendarThree.book(5, 15); // return 3 myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3   Constraints: 0 <= startTime < endTime <= 10 9 At most  400  calls will be made to  book .","['Binary Search', 'Design', 'Segment Tree', 'Prefix Sum', 'Ordered Set']",Difícil,Binary Search,False
2286,booking-concert-tickets-in-groups,https://leetcode.com/problems/booking-concert-tickets-in-groups/,Booking Concert Tickets in Groups,"A concert hall has  n  rows numbered from  0  to  n - 1 , each with  m  seats, numbered from  0  to  m - 1 . You need to design a ticketing system that can allocate seats in the following cases: If a group of  k  spectators can sit  together  in a row. If  every  member of a group of  k  spectators can get a seat. They may or  may not  sit together. Note that the spectators are very picky. Hence: They will book seats only if each member of their group can get a seat with row number  less than or equal  to  maxRow .  maxRow  can  vary  from group to group. In case there are multiple rows to choose from, the row with the  smallest  number is chosen. If there are multiple seats to choose in the same row, the seat with the  smallest  number is chosen. Implement the  BookMyShow  class: BookMyShow(int n, int m)  Initializes the object with  n  as number of rows and  m  as number of seats per row. int[] gather(int k, int maxRow)  Returns an array of length  2  denoting the row and seat number (respectively) of the  first seat  being allocated to the  k  members of the group, who must sit  together . In other words, it returns the smallest possible  r  and  c  such that all  [c, c + k - 1]  seats are valid and empty in row  r , and  r <= maxRow . Returns  []  in case it is  not possible  to allocate seats to the group. boolean scatter(int k, int maxRow)  Returns  true  if all  k  members of the group can be allocated seats in rows  0  to  maxRow , who may or  may not  sit together. If the seats can be allocated, it allocates  k  seats to the group with the  smallest  row numbers, and the smallest possible seat numbers in each row. Otherwise, returns  false .   Example 1: Input [""BookMyShow"", ""gather"", ""gather"", ""scatter"", ""scatter""] [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]] Output [null, [0, 0], [], true, false] Explanation BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each  bms.gather(4, 0); // return [0, 0]                   // The group books seats [0, 3] of row 0.  bms.gather(2, 0); // return []                   // There is only 1 seat left in row 0,                   // so it is not possible to book 2 consecutive seats.  bms.scatter(5, 1); // return True                    // The group books seat 4 of row 0 and seats [0, 3] of row 1.  bms.scatter(5, 1); // return False                    // There is only one seat left in the hall.   Constraints: 1 <= n <= 5 * 10 4 1 <= m, k <= 10 9 0 <= maxRow <= n - 1 At most  5 * 10 4  calls  in total  will be made to  gather  and  scatter .","['Binary Search', 'Design', 'Binary Indexed Tree', 'Segment Tree']",Difícil,Binary Search,False
278,first-bad-version,https://leetcode.com/problems/first-bad-version/,First Bad Version,"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have  n  versions  [1, 2, ..., n]  and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API  bool isBadVersion(version)  which returns whether  version  is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.   Example 1: Input:  n = 5, bad = 4 Output:  4 Explanation: call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version. Example 2: Input:  n = 1, bad = 1 Output:  1   Constraints: 1 <= bad <= n <= 2 31  - 1","['Binary Search', 'Interactive']",Fácil,Binary Search,False
374,guess-number-higher-or-lower,https://leetcode.com/problems/guess-number-higher-or-lower/,Guess Number Higher or Lower,"We are playing the Guess Game. The game is as follows: I pick a number from  1  to  n . You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API  int guess(int num) , which returns three possible results: -1 : Your guess is higher than the number I picked (i.e.  num > pick ). 1 : Your guess is lower than the number I picked (i.e.  num < pick ). 0 : your guess is equal to the number I picked (i.e.  num == pick ). Return  the number that I picked .   Example 1: Input:  n = 10, pick = 6 Output:  6 Example 2: Input:  n = 1, pick = 1 Output:  1 Example 3: Input:  n = 2, pick = 1 Output:  1   Constraints: 1 <= n <= 2 31  - 1 1 <= pick <= n","['Binary Search', 'Interactive']",Fácil,Binary Search,False
2424,longest-uploaded-prefix,https://leetcode.com/problems/longest-uploaded-prefix/,Longest Uploaded Prefix,"You are given a stream of  n  videos, each represented by a  distinct  number from  1  to  n  that you need to ""upload"" to a server. You need to implement a data structure that calculates the length of the  longest uploaded prefix  at various points in the upload process. We consider  i  to be an uploaded prefix if all videos in the range  1  to  i  ( inclusive ) have been uploaded to the server. The longest uploaded prefix is the  maximum  value of  i  that satisfies this definition. Implement the  LUPrefix  class: LUPrefix(int n)  Initializes the object for a stream of  n  videos. void upload(int video)  Uploads  video  to the server. int longest()  Returns the length of the  longest uploaded prefix  defined above.   Example 1: Input [""LUPrefix"", ""upload"", ""longest"", ""upload"", ""longest"", ""upload"", ""longest""] [[4], [3], [], [1], [], [2], []] Output [null, null, 0, null, 1, null, 3] Explanation LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos. server.upload(3);                    // Upload video 3. server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.                                      // So, we return 0. server.upload(1);                    // Upload video 1. server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1. server.upload(2);                    // Upload video 2. server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.   Constraints: 1 <= n <= 10 5 1 <= video <= n All values of  video  are  distinct . At most  2 * 10 5  calls  in total  will be made to  upload  and  longest . At least one call will be made to  longest .","['Binary Search', 'Union Find', 'Design', 'Binary Indexed Tree', 'Segment Tree', 'Heap (Priority Queue)', 'Ordered Set']",Média,Binary Search,False
3007,maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k,https://leetcode.com/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/,Maximum Number That Sum of the Prices Is Less Than or Equal to K,"You are given an integer  k  and an integer  x . The price of a number  num  is calculated by the count of  set bits  at positions  x ,  2x ,  3x , etc., in its binary representation, starting from the least significant bit. The following table contains examples of how price is calculated. x num Binary Representation Price 1 13 0 0 0 0 0 1 1 0 1 3 2 13 0 0 0 0 0 1 1 0 1 1 2 233 0 1 1 1 0 1 0 0 1 3 3 13 0 00 0 01 1 01 1 3 362 1 01 1 01 0 10 2 The  accumulated price  of  num  is the  total  price of numbers from  1  to  num .  num  is considered  cheap  if its accumulated price is less than or equal to  k . Return the  greatest  cheap number.   Example 1: Input:   k = 9, x = 1 Output:   6 Explanation: As shown in the table below,  6  is the greatest cheap number. x num Binary Representation Price Accumulated Price 1 1 0 0 1 1 1 1 2 0 1 0 1 2 1 3 0 1 1 2 4 1 4 1 0 0 1 5 1 5 1 0 1 2 7 1 6 1 1 0 2 9 1 7 1 1 1 3 12 Example 2: Input:   k = 7, x = 2 Output:   9 Explanation: As shown in the table below,  9  is the greatest cheap number. x num Binary Representation Price Accumulated Price 2 1 0 0 0 1 0 0 2 2 0 0 1 0 1 1 2 3 0 0 1 1 1 2 2 4 0 1 0 0 0 2 2 5 0 1 0 1 0 2 2 6 0 1 1 0 1 3 2 7 0 1 1 1 1 4 2 8 1 0 0 0 1 5 2 9 1 0 0 1 1 6 2 10 1 0 1 0 2 8   Constraints: 1 <= k <= 10 15 1 <= x <= 8","['Binary Search', 'Dynamic Programming', 'Bit Manipulation']",Média,Binary Search,False
461,hamming-distance,https://leetcode.com/problems/hamming-distance/,Hamming Distance,"The  Hamming distance  between two integers is the number of positions at which the corresponding bits are different. Given two integers  x  and  y , return  the  Hamming distance  between them .   Example 1: Input:  x = 1, y = 4 Output:  2 Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑ The above arrows point to positions where the corresponding bits are different. Example 2: Input:  x = 3, y = 1 Output:  1   Constraints: 0 <= x, y <= 2 31  - 1   Note:  This question is the same as   2220: Minimum Bit Flips to Convert Number.",['Bit Manipulation'],Fácil,Bit Manipulation,False
476,number-complement,https://leetcode.com/problems/number-complement/,Number Complement,"The  complement  of an integer is the integer you get when you flip all the  0 's to  1 's and all the  1 's to  0 's in its binary representation. For example, The integer  5  is  ""101""  in binary and its  complement  is  ""010""  which is the integer  2 . Given an integer  num , return  its complement .   Example 1: Input:  num = 5 Output:  2 Explanation:  The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: Input:  num = 1 Output:  0 Explanation:  The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Constraints: 1 <= num < 2 31   Note:  This question is the same as 1009:  https://leetcode.com/problems/complement-of-base-10-integer/",['Bit Manipulation'],Fácil,Bit Manipulation,False
693,binary-number-with-alternating-bits,https://leetcode.com/problems/binary-number-with-alternating-bits/,Binary Number with Alternating Bits,"Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.   Example 1: Input:  n = 5 Output:  true Explanation:  The binary representation of 5 is: 101 Example 2: Input:  n = 7 Output:  false Explanation:  The binary representation of 7 is: 111. Example 3: Input:  n = 11 Output:  false Explanation:  The binary representation of 11 is: 1011.   Constraints: 1 <= n <= 2 31  - 1",['Bit Manipulation'],Fácil,Bit Manipulation,False
868,binary-gap,https://leetcode.com/problems/binary-gap/,Binary Gap,"Given a positive integer  n , find and return  the  longest distance  between any two  adjacent   1 's in the binary representation of  n . If there are no two adjacent  1 's, return  0 . Two  1 's are  adjacent  if there are only  0 's separating them (possibly no  0 's). The  distance  between two  1 's is the absolute difference between their bit positions. For example, the two  1 's in  ""1001""  have a distance of 3.   Example 1: Input:  n = 22 Output:  2 Explanation:  22 in binary is ""10110"". The first adjacent pair of 1's is "" 1 0 1 10"" with a distance of 2. The second adjacent pair of 1's is ""10 11 0"" with a distance of 1. The answer is the largest of these two distances, which is 2. Note that "" 1 01 1 0"" is not a valid pair since there is a 1 separating the two 1's underlined. Example 2: Input:  n = 8 Output:  0 Explanation:  8 in binary is ""1000"". There are not any adjacent pairs of 1's in the binary representation of 8, so we return 0. Example 3: Input:  n = 5 Output:  2 Explanation:  5 in binary is ""101"".   Constraints: 1 <= n <= 10 9",['Bit Manipulation'],Fácil,Bit Manipulation,False
1009,complement-of-base-10-integer,https://leetcode.com/problems/complement-of-base-10-integer/,Complement of Base 10 Integer,"The  complement  of an integer is the integer you get when you flip all the  0 's to  1 's and all the  1 's to  0 's in its binary representation. For example, The integer  5  is  ""101""  in binary and its  complement  is  ""010""  which is the integer  2 . Given an integer  n , return  its complement .   Example 1: Input:  n = 5 Output:  2 Explanation:  5 is ""101"" in binary, with complement ""010"" in binary, which is 2 in base-10. Example 2: Input:  n = 7 Output:  0 Explanation:  7 is ""111"" in binary, with complement ""000"" in binary, which is 0 in base-10. Example 3: Input:  n = 10 Output:  5 Explanation:  10 is ""1010"" in binary, with complement ""0101"" in binary, which is 5 in base-10.   Constraints: 0 <= n < 10 9   Note:  This question is the same as 476:  https://leetcode.com/problems/number-complement/",['Bit Manipulation'],Fácil,Bit Manipulation,False
2220,minimum-bit-flips-to-convert-number,https://leetcode.com/problems/minimum-bit-flips-to-convert-number/,Minimum Bit Flips to Convert Number,"A  bit flip  of a number  x  is choosing a bit in the binary representation of  x  and  flipping  it from either  0  to  1  or  1  to  0 . For example, for  x = 7 , the binary representation is  111  and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get  110 , flip the second bit from the right to get  101 , flip the fifth bit from the right (a leading zero) to get  10111 , etc. Given two integers  start  and  goal , return  the  minimum  number of  bit flips  to convert  start  to  goal .   Example 1: Input:  start = 10, goal = 7 Output:  3 Explanation:  The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps: - Flip the first bit from the right: 101 0  -> 101 1 . - Flip the third bit from the right: 1 0 11 -> 1 1 11. - Flip the fourth bit from the right:  1 111 ->  0 111. It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3. Example 2: Input:  start = 3, goal = 4 Output:  3 Explanation:  The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps: - Flip the first bit from the right: 01 1  -> 01 0 . - Flip the second bit from the right: 0 1 0 -> 0 0 0. - Flip the third bit from the right:  0 00 ->  1 00. It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.   Constraints: 0 <= start, goal <= 10 9   Note:  This question is the same as  461: Hamming Distance.",['Bit Manipulation'],Fácil,Bit Manipulation,False
2595,number-of-even-and-odd-bits,https://leetcode.com/problems/number-of-even-and-odd-bits/,Number of Even and Odd Bits,"You are given a  positive  integer  n . Let  even  denote the number of even indices in the binary representation of  n  with value 1. Let  odd  denote the number of odd indices in the binary representation of  n  with value 1. Note that bits are indexed from  right to left  in the binary representation of a number. Return the array  [even, odd] .   Example 1: Input:   n = 50 Output:   [1,2] Explanation: The binary representation of 50 is  110010 . It contains 1 on indices 1, 4, and 5. Example 2: Input:   n = 2 Output:   [0,1] Explanation: The binary representation of 2 is  10 . It contains 1 only on index 1.   Constraints: 1 <= n <= 1000",['Bit Manipulation'],Fácil,Bit Manipulation,False
3226,number-of-bit-changes-to-make-two-integers-equal,https://leetcode.com/problems/number-of-bit-changes-to-make-two-integers-equal/,Number of Bit Changes to Make Two Integers Equal,"You are given two positive integers  n  and  k . You can choose  any  bit in the  binary representation  of  n  that is equal to 1 and change it to 0. Return the  number of changes  needed to make  n  equal to  k . If it is impossible, return -1.   Example 1: Input:   n = 13, k = 4 Output:   2 Explanation: Initially, the binary representations of  n  and  k  are  n = (1101) 2  and  k = (0100) 2 . We can change the first and fourth bits of  n . The resulting integer is  n = ( 0 10 0 ) 2  = k . Example 2: Input:   n = 21, k = 21 Output:   0 Explanation: n  and  k  are already equal, so no changes are needed. Example 3: Input:   n = 14, k = 13 Output:   -1 Explanation: It is not possible to make  n  equal to  k .   Constraints: 1 <= n, k <= 10 6",['Bit Manipulation'],Fácil,Bit Manipulation,False
201,bitwise-and-of-numbers-range,https://leetcode.com/problems/bitwise-and-of-numbers-range/,Bitwise AND of Numbers Range,"Given two integers  left  and  right  that represent the range  [left, right] , return  the bitwise AND of all numbers in this range, inclusive .   Example 1: Input:  left = 5, right = 7 Output:  4 Example 2: Input:  left = 0, right = 0 Output:  0 Example 3: Input:  left = 1, right = 2147483647 Output:  0   Constraints: 0 <= left <= right <= 2 31  - 1",['Bit Manipulation'],Média,Bit Manipulation,False
2749,minimum-operations-to-make-the-integer-zero,https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/,Minimum Operations to Make the Integer Zero,"You are given two integers  num1  and  num2 . In one operation, you can choose integer  i  in the range  [0, 60]  and subtract  2 i  + num2  from  num1 . Return  the integer denoting the  minimum  number of operations needed to make   num1   equal to   0 . If it is impossible to make  num1  equal to  0 , return  -1 .   Example 1: Input:  num1 = 3, num2 = -2 Output:  3 Explanation:  We can make 3 equal to 0 with the following operations: - We choose i = 2 and subtract 2 2  + (-2) from 3, 3 - (4 + (-2)) = 1. - We choose i = 2 and subtract 2 2  + (-2) from 1, 1 - (4 + (-2)) = -1. - We choose i = 0 and subtract 2 0  + (-2) from -1, (-1) - (1 + (-2)) = 0. It can be proven, that 3 is the minimum number of operations that we need to perform. Example 2: Input:  num1 = 5, num2 = 7 Output:  -1 Explanation:  It can be proven, that it is impossible to make 5 equal to 0 with the given operation.   Constraints: 1 <= num1 <= 10 9 -10 9  <= num2 <= 10 9","['Bit Manipulation', 'Brainteaser', 'Enumeration']",Média,Bit Manipulation,False
3133,minimum-array-end,https://leetcode.com/problems/minimum-array-end/,Minimum Array End,"You are given two integers  n  and  x . You have to construct an array of  positive  integers  nums  of size  n  where for every  0 <= i < n - 1 ,  nums[i + 1]  is  greater than   nums[i] , and the result of the bitwise  AND  operation between all elements of  nums  is  x . Return the  minimum  possible value of  nums[n - 1] .   Example 1: Input:   n = 3, x = 4 Output:   6 Explanation: nums  can be  [4,5,6]  and its last element is 6. Example 2: Input:   n = 2, x = 7 Output:   15 Explanation: nums  can be  [7,15]  and its last element is 15.   Constraints: 1 <= n, x <= 10 8",['Bit Manipulation'],Média,Bit Manipulation,False
1129,shortest-path-with-alternating-colors,https://leetcode.com/problems/shortest-path-with-alternating-colors/,Shortest Path with Alternating Colors,"You are given an integer  n , the number of nodes in a directed graph where the nodes are labeled from  0  to  n - 1 . Each edge is red or blue in this graph, and there could be self-edges and parallel edges. You are given two arrays  redEdges  and  blueEdges  where: redEdges[i] = [a i , b i ]  indicates that there is a directed red edge from node  a i  to node  b i  in the graph, and blueEdges[j] = [u j , v j ]  indicates that there is a directed blue edge from node  u j  to node  v j  in the graph. Return an array  answer  of length  n , where each  answer[x]  is the length of the shortest path from node  0  to node  x  such that the edge colors alternate along the path, or  -1  if such a path does not exist.   Example 1: Input:  n = 3, redEdges = [[0,1],[1,2]], blueEdges = [] Output:  [0,1,-1] Example 2: Input:  n = 3, redEdges = [[0,1]], blueEdges = [[2,1]] Output:  [0,1,-1]   Constraints: 1 <= n <= 100 0 <= redEdges.length, blueEdges.length <= 400 redEdges[i].length == blueEdges[j].length == 2 0 <= a i , b i , u j , v j  < n","['Breadth-First Search', 'Graph']",Média,Breadth-First Search,False
753,cracking-the-safe,https://leetcode.com/problems/cracking-the-safe/,Cracking the Safe,"There is a safe protected by a password. The password is a sequence of  n  digits where each digit can be in the range  [0, k - 1] . The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the  most recent  n  digits  that were entered each time you type a digit. For example, the correct password is  ""345""  and you enter in  ""012345"" : 	 After typing  0 , the most recent  3  digits is  ""0"" , which is incorrect. After typing  1 , the most recent  3  digits is  ""01"" , which is incorrect. After typing  2 , the most recent  3  digits is  ""012"" , which is incorrect. After typing  3 , the most recent  3  digits is  ""123"" , which is incorrect. After typing  4 , the most recent  3  digits is  ""234"" , which is incorrect. After typing  5 , the most recent  3  digits is  ""345"" , which is correct and the safe unlocks. Return  any string of  minimum length  that will unlock the safe  at some point  of entering it .   Example 1: Input:  n = 1, k = 2 Output:  ""10"" Explanation:  The password is a single digit, so enter each digit. ""01"" would also unlock the safe. Example 2: Input:  n = 2, k = 2 Output:  ""01100"" Explanation:  For each possible password: - ""00"" is typed in starting from the 4 th  digit. - ""01"" is typed in starting from the 1 st  digit. - ""10"" is typed in starting from the 3 rd  digit. - ""11"" is typed in starting from the 2 nd  digit. Thus ""01100"" will unlock the safe. ""10011"", and ""11001"" would also unlock the safe.   Constraints: 1 <= n <= 4 1 <= k <= 10 1 <= k n  <= 4096","['Depth-First Search', 'Graph', 'Eulerian Circuit']",Difícil,Depth-First Search,False
2092,find-all-people-with-secret,https://leetcode.com/problems/find-all-people-with-secret/,Find All People With Secret,"You are given an integer  n  indicating there are  n  people numbered from  0  to  n - 1 . You are also given a  0-indexed  2D integer array  meetings  where  meetings[i] = [x i , y i , time i ]  indicates that person  x i  and person  y i  have a meeting at  time i . A person may attend  multiple meetings  at the same time. Finally, you are given an integer  firstPerson . Person  0  has a  secret  and initially shares the secret with a person  firstPerson  at time  0 . This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person  x i  has the secret at  time i , then they will share the secret with person  y i , and vice versa. The secrets are shared  instantaneously . That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return  a list of all the people that have the secret after all the meetings have taken place.  You may return the answer in  any order .   Example 1: Input:  n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 Output:  [0,1,2,3,5] Explanation: At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.​​​​ Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings. Example 2: Input:  n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 Output:  [0,1,3] Explanation: At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings. Example 3: Input:  n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 Output:  [0,1,2,3,4] Explanation: At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.   Constraints: 2 <= n <= 10 5 1 <= meetings.length <= 10 5 meetings[i].length == 3 0 <= x i , y i  <= n - 1 x i  != y i 1 <= time i  <= 10 5 1 <= firstPerson <= n - 1","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph', 'Sorting']",Difícil,Depth-First Search,False
2097,valid-arrangement-of-pairs,https://leetcode.com/problems/valid-arrangement-of-pairs/,Valid Arrangement of Pairs,"You are given a  0-indexed  2D integer array  pairs  where  pairs[i] = [start i , end i ] . An arrangement of  pairs  is  valid  if for every index  i  where  1 <= i < pairs.length , we have  end i-1  == start i . Return  any  valid arrangement of  pairs . Note:  The inputs will be generated such that there exists a valid arrangement of  pairs .   Example 1: Input:  pairs = [[5,1],[4,5],[11,9],[9,4]] Output:  [[11,9],[9,4],[4,5],[5,1]] Explanation: This is a valid arrangement since end i-1  always equals start i . end 0  = 9 == 9 = start 1   end 1  = 4 == 4 = start 2 end 2  = 5 == 5 = start 3 Example 2: Input:  pairs = [[1,3],[3,2],[2,1]] Output:  [[1,3],[3,2],[2,1]] Explanation: This is a valid arrangement since end i-1  always equals start i . end 0  = 3 == 3 = start 1 end 1  = 2 == 2 = start 2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid. Example 3: Input:  pairs = [[1,2],[1,3],[2,1]] Output:  [[1,2],[2,1],[1,3]] Explanation: This is a valid arrangement since end i-1  always equals start i . end 0  = 2 == 2 = start 1 end 1  = 1 == 1 = start 2   Constraints: 1 <= pairs.length <= 10 5 pairs[i].length == 2 0 <= start i , end i  <= 10 9 start i  != end i No two pairs are exactly the same. There  exists  a valid arrangement of  pairs .","['Depth-First Search', 'Graph', 'Eulerian Circuit']",Difícil,Depth-First Search,False
207,course-schedule,https://leetcode.com/problems/course-schedule/,Course Schedule,"There are a total of  numCourses  courses you have to take, labeled from  0  to  numCourses - 1 . You are given an array  prerequisites  where  prerequisites[i] = [a i , b i ]  indicates that you  must  take course  b i  first if you want to take course  a i . For example, the pair  [0, 1] , indicates that to take course  0  you have to first take course  1 . Return  true  if you can finish all courses. Otherwise, return  false .   Example 1: Input:  numCourses = 2, prerequisites = [[1,0]] Output:  true Explanation:  There are a total of 2 courses to take.  To take course 1 you should have finished course 0. So it is possible. Example 2: Input:  numCourses = 2, prerequisites = [[1,0],[0,1]] Output:  false Explanation:  There are a total of 2 courses to take.  To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.   Constraints: 1 <= numCourses <= 2000 0 <= prerequisites.length <= 5000 prerequisites[i].length == 2 0 <= a i , b i  < numCourses All the pairs prerequisites[i] are  unique .","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Média,Depth-First Search,False
210,course-schedule-ii,https://leetcode.com/problems/course-schedule-ii/,Course Schedule II,"There are a total of  numCourses  courses you have to take, labeled from  0  to  numCourses - 1 . You are given an array  prerequisites  where  prerequisites[i] = [a i , b i ]  indicates that you  must  take course  b i  first if you want to take course  a i . For example, the pair  [0, 1] , indicates that to take course  0  you have to first take course  1 . Return  the ordering of courses you should take to finish all courses . If there are many valid answers, return  any  of them. If it is impossible to finish all courses, return  an empty array .   Example 1: Input:  numCourses = 2, prerequisites = [[1,0]] Output:  [0,1] Explanation:  There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]. Example 2: Input:  numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] Output:  [0,2,1,3] Explanation:  There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]. Example 3: Input:  numCourses = 1, prerequisites = [] Output:  [0]   Constraints: 1 <= numCourses <= 2000 0 <= prerequisites.length <= numCourses * (numCourses - 1) prerequisites[i].length == 2 0 <= a i , b i  < numCourses a i  != b i All the pairs  [a i , b i ]  are  distinct .","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Média,Depth-First Search,False
386,lexicographical-numbers,https://leetcode.com/problems/lexicographical-numbers/,Lexicographical Numbers,"Given an integer  n , return all the numbers in the range  [1, n]  sorted in lexicographical order. You must write an algorithm that runs in  O(n)  time and uses  O(1)  extra space.    Example 1: Input:  n = 13 Output:  [1,10,11,12,13,2,3,4,5,6,7,8,9] Example 2: Input:  n = 2 Output:  [1,2]   Constraints: 1 <= n <= 5 * 10 4","['Depth-First Search', 'Trie']",Média,Depth-First Search,False
841,keys-and-rooms,https://leetcode.com/problems/keys-and-rooms/,Keys and Rooms,"There are  n  rooms labeled from  0  to  n - 1  and all the rooms are locked except for room  0 . Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of  distinct keys  in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array  rooms  where  rooms[i]  is the set of keys that you can obtain if you visited room  i , return  true   if you can visit  all  the rooms, or   false   otherwise .   Example 1: Input:  rooms = [[1],[2],[3],[]] Output:  true Explanation:   We visit room 0 and pick up key 1. We then visit room 1 and pick up key 2. We then visit room 2 and pick up key 3. We then visit room 3. Since we were able to visit every room, we return true. Example 2: Input:  rooms = [[1,3],[3,0,1],[2],[0]] Output:  false Explanation:  We can not enter room number 2 since the only key that unlocks it is in that room.   Constraints: n == rooms.length 2 <= n <= 1000 0 <= rooms[i].length <= 1000 1 <= sum(rooms[i].length) <= 3000 0 <= rooms[i][j] < n All the values of  rooms[i]  are  unique .","['Depth-First Search', 'Breadth-First Search', 'Graph']",Média,Depth-First Search,False
886,possible-bipartition,https://leetcode.com/problems/possible-bipartition/,Possible Bipartition,"We want to split a group of  n  people (labeled from  1  to  n ) into two groups of  any size . Each person may dislike some other people, and they should not go into the same group. Given the integer  n  and the array  dislikes  where  dislikes[i] = [a i , b i ]  indicates that the person labeled  a i  does not like the person labeled  b i , return  true   if it is possible to split everyone into two groups in this way .   Example 1: Input:  n = 4, dislikes = [[1,2],[1,3],[2,4]] Output:  true Explanation:  The first group has [1,4], and the second group has [2,3]. Example 2: Input:  n = 3, dislikes = [[1,2],[1,3],[2,3]] Output:  false Explanation:  We need at least 3 groups to divide them. We cannot put them in two groups.   Constraints: 1 <= n <= 2000 0 <= dislikes.length <= 10 4 dislikes[i].length == 2 1 <= a i  < b i  <= n All the pairs of  dislikes  are  unique .","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search,False
1042,flower-planting-with-no-adjacent,https://leetcode.com/problems/flower-planting-with-no-adjacent/,Flower Planting With No Adjacent,"You have  n  gardens, labeled from  1  to  n , and an array  paths  where  paths[i] = [x i , y i ]  describes a bidirectional path between garden  x i  to garden  y i . In each garden, you want to plant one of 4 types of flowers. All gardens have  at most 3  paths coming into or leaving it. Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers. Return  any  such a choice as an array  answer , where  answer[i]  is the type of flower planted in the  (i+1) th  garden. The flower types are denoted  1 ,  2 ,  3 , or  4 . It is guaranteed an answer exists.   Example 1: Input:  n = 3, paths = [[1,2],[2,3],[3,1]] Output:  [1,2,3] Explanation: Gardens 1 and 2 have different types. Gardens 2 and 3 have different types. Gardens 3 and 1 have different types. Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1]. Example 2: Input:  n = 4, paths = [[1,2],[3,4]] Output:  [1,2,1,2] Example 3: Input:  n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] Output:  [1,2,3,4]   Constraints: 1 <= n <= 10 4 0 <= paths.length <= 2 * 10 4 paths[i].length == 2 1 <= x i , y i  <= n x i  != y i Every garden has  at most 3  paths coming into or leaving it.","['Depth-First Search', 'Breadth-First Search', 'Graph']",Média,Depth-First Search,False
715,range-module,https://leetcode.com/problems/range-module/,Range Module,"A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as  half-open intervals  and query about them. A  half-open interval   [left, right)  denotes all the real numbers  x  where  left <= x < right . Implement the  RangeModule  class: RangeModule()  Initializes the object of the data structure. void addRange(int left, int right)  Adds the  half-open interval   [left, right) , tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval  [left, right)  that are not already tracked. boolean queryRange(int left, int right)  Returns  true  if every real number in the interval  [left, right)  is currently being tracked, and  false  otherwise. void removeRange(int left, int right)  Stops tracking every real number currently being tracked in the  half-open interval   [left, right) .   Example 1: Input [""RangeModule"", ""addRange"", ""removeRange"", ""queryRange"", ""queryRange"", ""queryRange""] [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]] Output [null, null, null, true, false, true] Explanation RangeModule rangeModule = new RangeModule(); rangeModule.addRange(10, 20); rangeModule.removeRange(14, 16); rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked) rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Constraints: 1 <= left < right <= 10 9 At most  10 4  calls will be made to  addRange ,  queryRange , and  removeRange .","['Design', 'Segment Tree', 'Ordered Set']",Difícil,Design,False
1825,finding-mk-average,https://leetcode.com/problems/finding-mk-average/,Finding MK Average,"You are given two integers,  m  and  k , and a stream of integers. You are tasked to implement a data structure that calculates the  MKAverage  for the stream. The  MKAverage  can be calculated using these steps: If the number of the elements in the stream is less than  m  you should consider the  MKAverage  to be  -1 . Otherwise, copy the last  m  elements of the stream to a separate container. Remove the smallest  k  elements and the largest  k  elements from the container. Calculate the average value for the rest of the elements  rounded down to the nearest integer . Implement the  MKAverage  class: MKAverage(int m, int k)  Initializes the  MKAverage  object with an empty stream and the two integers  m  and  k . void addElement(int num)  Inserts a new element  num  into the stream. int calculateMKAverage()  Calculates and returns the  MKAverage  for the current stream  rounded down to the nearest integer .   Example 1: Input [""MKAverage"", ""addElement"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""addElement"", ""addElement"", ""calculateMKAverage""] [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []] Output [null, null, null, -1, null, 3, null, null, null, 5] Explanation MKAverage obj = new MKAverage(3, 1);  obj.addElement(3);        // current elements are [3] obj.addElement(1);        // current elements are [3,1] obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist. obj.addElement(10);       // current elements are [3,1,10] obj.calculateMKAverage(); // The last 3 elements are [3,1,10].                           // After removing smallest and largest 1 element the container will be [3].                           // The average of [3] equals 3/1 = 3, return 3 obj.addElement(5);        // current elements are [3,1,10,5] obj.addElement(5);        // current elements are [3,1,10,5,5] obj.addElement(5);        // current elements are [3,1,10,5,5,5] obj.calculateMKAverage(); // The last 3 elements are [5,5,5].                           // After removing smallest and largest 1 element the container will be [5].                           // The average of [5] equals 5/1 = 5, return 5   Constraints: 3 <= m <= 10 5 1 < k*2 < m 1 <= num <= 10 5 At most  10 5  calls will be made to  addElement  and  calculateMKAverage .","['Design', 'Queue', 'Heap (Priority Queue)', 'Data Stream', 'Ordered Set']",Difícil,Design,False
2102,sequentially-ordinal-rank-tracker,https://leetcode.com/problems/sequentially-ordinal-rank-tracker/,Sequentially Ordinal Rank Tracker,"A scenic location is represented by its  name  and attractiveness  score , where  name  is a  unique  string among all locations and  score  is an integer. Locations can be ranked from the best to the worst. The  higher  the score, the better the location. If the scores of two locations are equal, then the location with the  lexicographically smaller  name is better. You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports: Adding  scenic locations,  one at a time . Querying  the  i th   best  location of  all locations already added , where  i  is the number of times the system has been queried (including the current query). 	 For example, when the system is queried for the  4 th  time, it returns the  4 th  best location of all locations already added. Note that the test data are generated so that  at any time , the number of queries  does not exceed  the number of locations added to the system. Implement the  SORTracker  class: SORTracker()  Initializes the tracker system. void add(string name, int score)  Adds a scenic location with  name  and  score  to the system. string get()  Queries and returns the  i th  best location, where  i  is the number of times this method has been invoked (including this invocation).   Example 1: Input [""SORTracker"", ""add"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""get""] [[], [""bradford"", 2], [""branford"", 3], [], [""alps"", 2], [], [""orland"", 2], [], [""orlando"", 3], [], [""alpine"", 2], [], []] Output [null, null, null, ""branford"", null, ""alps"", null, ""bradford"", null, ""bradford"", null, ""bradford"", ""orland""] Explanation SORTracker tracker = new SORTracker(); // Initialize the tracker system. tracker.add(""bradford"", 2); // Add location with name=""bradford"" and score=2 to the system. tracker.add(""branford"", 3); // Add location with name=""branford"" and score=3 to the system. tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.                             // Note that branford precedes bradford due to its  higher score  (3 > 2).                             // This is the 1 st  time get() is called, so return the best location: ""branford"". tracker.add(""alps"", 2);     // Add location with name=""alps"" and score=2 to the system. tracker.get();              // Sorted locations: branford, alps, bradford.                             // Note that alps precedes bradford even though they have the same score (2).                             // This is because ""alps"" is  lexicographically smaller  than ""bradford"".                             // Return the 2 nd  best location ""alps"", as it is the 2 nd  time get() is called. tracker.add(""orland"", 2);   // Add location with name=""orland"" and score=2 to the system. tracker.get();              // Sorted locations: branford, alps, bradford, orland.                             // Return ""bradford"", as it is the 3 rd  time get() is called. tracker.add(""orlando"", 3);  // Add location with name=""orlando"" and score=3 to the system. tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.                             // Return ""bradford"". tracker.add(""alpine"", 2);   // Add location with name=""alpine"" and score=2 to the system. tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.                             // Return ""bradford"". tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.                             // Return ""orland"".   Constraints: name  consists of lowercase English letters, and is unique among all locations. 1 <= name.length <= 10 1 <= score <= 10 5 At any time, the number of calls to  get  does not exceed the number of calls to  add . At most  4 * 10 4  calls  in total  will be made to  add  and  get .","['Design', 'Heap (Priority Queue)', 'Data Stream', 'Ordered Set']",Difícil,Design,False
2276,count-integers-in-intervals,https://leetcode.com/problems/count-integers-in-intervals/,Count Integers in Intervals,"Given an  empty  set of intervals, implement a data structure that can: Add  an interval to the set of intervals. Count  the number of integers that are present in  at least one  interval. Implement the  CountIntervals  class: CountIntervals()  Initializes the object with an empty set of intervals. void add(int left, int right)  Adds the interval  [left, right]  to the set of intervals. int count()  Returns the number of integers that are present in  at least one  interval. Note  that an interval  [left, right]  denotes all the integers  x  where  left <= x <= right .   Example 1: Input [""CountIntervals"", ""add"", ""add"", ""count"", ""add"", ""count""] [[], [2, 3], [7, 10], [], [5, 8], []] Output [null, null, null, 6, null, 8] Explanation CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals.  countIntervals.add(2, 3);  // add [2, 3] to the set of intervals. countIntervals.add(7, 10); // add [7, 10] to the set of intervals. countIntervals.count();    // return 6                            // the integers 2 and 3 are present in the interval [2, 3].                            // the integers 7, 8, 9, and 10 are present in the interval [7, 10]. countIntervals.add(5, 8);  // add [5, 8] to the set of intervals. countIntervals.count();    // return 8                            // the integers 2 and 3 are present in the interval [2, 3].                            // the integers 5 and 6 are present in the interval [5, 8].                            // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].                            // the integers 9 and 10 are present in the interval [7, 10].   Constraints: 1 <= left <= right <= 10 9 At most  10 5  calls  in total  will be made to  add  and  count . At least  one  call will be made to  count .","['Design', 'Segment Tree', 'Ordered Set']",Difícil,Design,False
933,number-of-recent-calls,https://leetcode.com/problems/number-of-recent-calls/,Number of Recent Calls,"You have a  RecentCounter  class which counts the number of recent requests within a certain time frame. Implement the  RecentCounter  class: RecentCounter()  Initializes the counter with zero recent requests. int ping(int t)  Adds a new request at time  t , where  t  represents some time in milliseconds, and returns the number of requests that has happened in the past  3000  milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range  [t - 3000, t] . It is  guaranteed  that every call to  ping  uses a strictly larger value of  t  than the previous call.   Example 1: Input [""RecentCounter"", ""ping"", ""ping"", ""ping"", ""ping""] [[], [1], [100], [3001], [3002]] Output [null, 1, 2, 3, 3] Explanation RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1);     // requests = [ 1 ], range is [-2999,1], return 1 recentCounter.ping(100);   // requests = [ 1 ,  100 ], range is [-2900,100], return 2 recentCounter.ping(3001);  // requests = [ 1 ,  100 ,  3001 ], range is [1,3001], return 3 recentCounter.ping(3002);  // requests = [1,  100 ,  3001 ,  3002 ], range is [2,3002], return 3   Constraints: 1 <= t <= 10 9 Each test case will call  ping  with  strictly increasing  values of  t . At most  10 4  calls will be made to  ping .","['Design', 'Queue', 'Data Stream']",Fácil,Design,False
1603,design-parking-system,https://leetcode.com/problems/design-parking-system/,Design Parking System,"Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the  ParkingSystem  class: ParkingSystem(int big, int medium, int small)  Initializes object of the  ParkingSystem  class. The number of slots for each parking space are given as part of the constructor. bool addCar(int carType)  Checks whether there is a parking space of  carType  for the car that wants to get into the parking lot.  carType  can be of three kinds: big, medium, or small, which are represented by  1 ,  2 , and  3  respectively.  A car can only park in a parking space of its  carType . If there is no space available, return  false , else park the car in that size space and return  true .   Example 1: Input [""ParkingSystem"", ""addCar"", ""addCar"", ""addCar"", ""addCar""] [[1, 1, 0], [1], [2], [3], [1]] Output [null, true, true, false, false] Explanation ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // return true because there is 1 available slot for a big car parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car parkingSystem.addCar(3); // return false because there is no available slot for a small car parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.   Constraints: 0 <= big, medium, small <= 1000 carType  is  1 ,  2 , or  3 At most  1000  calls will be made to  addCar","['Design', 'Simulation', 'Counting']",Fácil,Design,False
855,exam-room,https://leetcode.com/problems/exam-room/,Exam Room,"There is an exam room with  n  seats in a single row labeled from  0  to  n - 1 . When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number  0 . Design a class that simulates the mentioned exam room. Implement the  ExamRoom  class: ExamRoom(int n)  Initializes the object of the exam room with the number of the seats  n . int seat()  Returns the label of the seat at which the next student will set. void leave(int p)  Indicates that the student sitting at seat  p  will leave the room. It is guaranteed that there will be a student sitting at seat  p .   Example 1: Input [""ExamRoom"", ""seat"", ""seat"", ""seat"", ""seat"", ""leave"", ""seat""] [[10], [], [], [], [], [4], []] Output [null, 0, 9, 4, 2, null, 5] Explanation ExamRoom examRoom = new ExamRoom(10); examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0. examRoom.seat(); // return 9, the student sits at the last seat number 9. examRoom.seat(); // return 4, the student sits at the last seat number 4. examRoom.seat(); // return 2, the student sits at the last seat number 2. examRoom.leave(4); examRoom.seat(); // return 5, the student sits at the last seat number 5.   Constraints: 1 <= n <= 10 9 It is guaranteed that there is a student sitting at seat  p . At most  10 4  calls will be made to  seat  and  leave .","['Design', 'Heap (Priority Queue)', 'Ordered Set']",Média,Design,False
1845,seat-reservation-manager,https://leetcode.com/problems/seat-reservation-manager/,Seat Reservation Manager,"Design a system that manages the reservation state of  n  seats that are numbered from  1  to  n . Implement the  SeatManager  class: SeatManager(int n)  Initializes a  SeatManager  object that will manage  n  seats numbered from  1  to  n . All seats are initially available. int reserve()  Fetches the  smallest-numbered  unreserved seat, reserves it, and returns its number. void unreserve(int seatNumber)  Unreserves the seat with the given  seatNumber .   Example 1: Input [""SeatManager"", ""reserve"", ""reserve"", ""unreserve"", ""reserve"", ""reserve"", ""reserve"", ""reserve"", ""unreserve""] [[5], [], [], [2], [], [], [], [], [5]] Output [null, 1, 2, null, 2, 3, 4, 5, null] Explanation SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats. seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1. seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5]. seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3. seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4. seatManager.reserve();    // The only available seat is seat 5, so return 5. seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].   Constraints: 1 <= n <= 10 5 1 <= seatNumber <= n For each call to  reserve , it is guaranteed that there will be at least one unreserved seat. For each call to  unreserve , it is guaranteed that  seatNumber  will be reserved. At most  10 5  calls  in total  will be made to  reserve  and  unreserve .","['Design', 'Heap (Priority Queue)']",Média,Design,False
190,reverse-bits,https://leetcode.com/problems/reverse-bits/,Reverse Bits,"Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using  2's complement notation . Therefore, in  Example 2  above, the input represents the signed integer  -3  and the output represents the signed integer  -1073741825 .   Example 1: Input:  n = 00000010100101000001111010011100 Output:     964176192 (00111001011110000010100101000000) Explanation:  The input binary string  00000010100101000001111010011100  represents the unsigned integer 43261596, so return 964176192 which its binary representation is  00111001011110000010100101000000 . Example 2: Input:  n = 11111111111111111111111111111101 Output:    3221225471 (10111111111111111111111111111111) Explanation:  The input binary string  11111111111111111111111111111101  represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is  10111111111111111111111111111111 .   Constraints: The input must be a  binary string  of length  32   Follow up:  If this function is called many times, how would you optimize it?","['Divide and Conquer', 'Bit Manipulation']",Fácil,Divide and Conquer,False
191,number-of-1-bits,https://leetcode.com/problems/number-of-1-bits/,Number of 1 Bits,"Given a positive integer  n , write a function that returns the number of  set bits  in its binary representation (also known as the  Hamming weight ).   Example 1: Input:   n = 11 Output:   3 Explanation: The input binary string  1011  has a total of three set bits. Example 2: Input:   n = 128 Output:   1 Explanation: The input binary string  10000000  has a total of one set bit. Example 3: Input:   n = 2147483645 Output:   30 Explanation: The input binary string  1111111111111111111111111111101  has a total of thirty set bits.   Constraints: 1 <= n <= 2 31  - 1   Follow up:  If this function is called many times, how would you optimize it?","['Divide and Conquer', 'Bit Manipulation']",Fácil,Divide and Conquer,False
600,non-negative-integers-without-consecutive-ones,https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/,Non-negative Integers without Consecutive Ones,"Given a positive integer  n , return the number of the integers in the range  [0, n]  whose binary representations  do not  contain consecutive ones.   Example 1: Input:  n = 5 Output:  5 Explanation: Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.  Example 2: Input:  n = 1 Output:  2 Example 3: Input:  n = 2 Output:  3   Constraints: 1 <= n <= 10 9",['Dynamic Programming'],Difícil,Dynamic Programming,False
818,race-car,https://leetcode.com/problems/race-car/,Race Car,"Your car starts at position  0  and speed  +1  on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions  'A'  (accelerate) and  'R'  (reverse): When you get an instruction  'A' , your car does the following: 	 position += speed speed *= 2 When you get an instruction  'R' , your car does the following: 	 If your speed is positive then  speed = -1 otherwise  speed = 1 	Your position stays the same. For example, after commands  ""AAR"" , your car goes to positions  0 --> 1 --> 3 --> 3 , and your speed goes to  1 --> 2 --> 4 --> -1 . Given a target position  target , return  the length of the shortest sequence of instructions to get there .   Example 1: Input:  target = 3 Output:  2 Explanation:   The shortest instruction sequence is ""AA"". Your position goes from 0 --> 1 --> 3. Example 2: Input:  target = 6 Output:  5 Explanation:   The shortest instruction sequence is ""AAARA"". Your position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.   Constraints: 1 <= target <= 10 4",['Dynamic Programming'],Difícil,Dynamic Programming,False
1220,count-vowels-permutation,https://leetcode.com/problems/count-vowels-permutation/,Count Vowels Permutation,"Given an integer  n , your task is to count how many strings of length  n  can be formed under the following rules: Each character is a lower case vowel ( 'a' ,  'e' ,  'i' ,  'o' ,  'u' ) Each vowel  'a'  may only be followed by an  'e' . Each vowel  'e'  may only be followed by an  'a'  or an  'i' . Each vowel  'i'   may not  be followed by another  'i' . Each vowel  'o'  may only be followed by an  'i'  or a  'u' . Each vowel  'u'  may only be followed by an  'a' . Since the answer may be too large, return it modulo  10^9 + 7 .   Example 1: Input:  n = 1 Output:  5 Explanation:  All possible strings are: ""a"", ""e"", ""i"" , ""o"" and ""u"". Example 2: Input:  n = 2 Output:  10 Explanation:  All possible strings are: ""ae"", ""ea"", ""ei"", ""ia"", ""ie"", ""io"", ""iu"", ""oi"", ""ou"" and ""ua"". Example 3:  Input:  n = 5 Output:  68   Constraints: 1 <= n <= 2 * 10^4",['Dynamic Programming'],Difícil,Dynamic Programming,False
1269,number-of-ways-to-stay-in-the-same-place-after-some-steps,https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/,Number of Ways to Stay in the Same Place After Some Steps,"You have a pointer at index  0  in an array of size  arrLen . At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time). Given two integers  steps  and  arrLen , return the number of ways such that your pointer is still at index  0  after  exactly   steps  steps. Since the answer may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:  steps = 3, arrLen = 2 Output:  4 Explanation:  There are 4 differents ways to stay at index 0 after 3 steps. Right, Left, Stay Stay, Right, Left Right, Stay, Left Stay, Stay, Stay Example 2: Input:  steps = 2, arrLen = 4 Output:  2 Explanation:  There are 2 differents ways to stay at index 0 after 2 steps Right, Left Stay, Stay Example 3: Input:  steps = 4, arrLen = 2 Output:  8   Constraints: 1 <= steps <= 500 1 <= arrLen <= 10 6",['Dynamic Programming'],Difícil,Dynamic Programming,False
1553,minimum-number-of-days-to-eat-n-oranges,https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/,Minimum Number of Days to Eat N Oranges,"There are  n  oranges in the kitchen and you decided to eat some of these oranges every day as follows: Eat one orange. If the number of remaining oranges  n  is divisible by  2  then you can eat  n / 2  oranges. If the number of remaining oranges  n  is divisible by  3  then you can eat  2 * (n / 3)  oranges. You can only choose one of the actions per day. Given the integer  n , return  the minimum number of days to eat   n   oranges .   Example 1: Input:  n = 10 Output:  4 Explanation:  You have 10 oranges. Day 1: Eat 1 orange,  10 - 1 = 9.   Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3) Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1.  Day 4: Eat the last orange  1 - 1  = 0. You need at least 4 days to eat the 10 oranges. Example 2: Input:  n = 6 Output:  3 Explanation:  You have 6 oranges. Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2). Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3) Day 3: Eat the last orange  1 - 1  = 0. You need at least 3 days to eat the 6 oranges.   Constraints: 1 <= n <= 2 * 10 9","['Dynamic Programming', 'Memoization']",Difícil,Dynamic Programming,False
1611,minimum-one-bit-operations-to-make-integers-zero,https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/,Minimum One Bit Operations to Make Integers Zero,"Given an integer  n , you must transform it into  0  using the following operations any number of times: Change the rightmost ( 0 th ) bit in the binary representation of  n . Change the  i th  bit in the binary representation of  n  if the  (i-1) th  bit is set to  1  and the  (i-2) th  through  0 th  bits are set to  0 . Return  the minimum number of operations to transform  n  into  0 .   Example 1: Input:  n = 3 Output:  2 Explanation:  The binary representation of 3 is ""11"". "" 1 1"" -> "" 0 1"" with the 2 nd  operation since the 0 th  bit is 1. ""0 1 "" -> ""0 0 "" with the 1 st  operation. Example 2: Input:  n = 6 Output:  4 Explanation:  The binary representation of 6 is ""110"". "" 1 10"" -> "" 0 10"" with the 2 nd  operation since the 1 st  bit is 1 and 0 th  through 0 th  bits are 0. ""01 0 "" -> ""01 1 "" with the 1 st  operation. ""0 1 1"" -> ""0 0 1"" with the 2 nd  operation since the 0 th  bit is 1. ""00 1 "" -> ""00 0 "" with the 1 st  operation.   Constraints: 0 <= n <= 10 9","['Dynamic Programming', 'Bit Manipulation', 'Memoization']",Difícil,Dynamic Programming,False
1900,the-earliest-and-latest-rounds-where-players-compete,https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/,The Earliest and Latest Rounds Where Players Compete,"There is a tournament where  n  players are participating. The players are standing in a single row and are numbered from  1  to  n  based on their  initial  standing position (player  1  is the first player in the row, player  2  is the second player in the row, etc.). The tournament consists of multiple rounds (starting from round number  1 ). In each round, the  i th  player from the front of the row competes against the  i th  player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round. For example, if the row consists of players  1, 2, 4, 6, 7 Player  1  competes against player  7 . Player  2  competes against player  6 . Player  4  automatically advances to the next round. After each round is over, the winners are lined back up in the row based on the  original ordering  assigned to them initially (ascending order). The players numbered  firstPlayer  and  secondPlayer  are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may  choose  the outcome of this round. Given the integers  n ,  firstPlayer , and  secondPlayer , return  an integer array containing two values, the  earliest  possible round number and the  latest  possible round number in which these two players will compete against each other, respectively .   Example 1: Input:  n = 11, firstPlayer = 2, secondPlayer = 4 Output:  [3,4] Explanation: One possible scenario which leads to the earliest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 2, 3, 4, 5, 6, 11 Third round: 2, 3, 4 One possible scenario which leads to the latest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 1, 2, 3, 4, 5, 6 Third round: 1, 2, 4 Fourth round: 2, 4 Example 2: Input:  n = 5, firstPlayer = 1, secondPlayer = 5 Output:  [1,1] Explanation:  The players numbered 1 and 5 compete in the first round. There is no way to make them compete in any other round.   Constraints: 2 <= n <= 28 1 <= firstPlayer < secondPlayer <= n","['Dynamic Programming', 'Memoization']",Difícil,Dynamic Programming,False
2318,number-of-distinct-roll-sequences,https://leetcode.com/problems/number-of-distinct-roll-sequences/,Number of Distinct Roll Sequences,"You are given an integer  n . You roll a fair 6-sided dice  n  times. Determine the total number of  distinct  sequences of rolls possible such that the following conditions are satisfied: The  greatest common divisor  of any  adjacent  values in the sequence is equal to  1 . There is  at least  a gap of  2  rolls between  equal  valued rolls. More formally, if the value of the  i th  roll is  equal  to the value of the  j th  roll, then  abs(i - j) > 2 . Return  the  total number  of distinct sequences possible . Since the answer may be very large, return it  modulo   10 9  + 7 . Two sequences are considered distinct if at least one element is different.   Example 1: Input:  n = 4 Output:  184 Explanation:  Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc. Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6). (1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed). (1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3. There are a total of 184 distinct sequences possible, so we return 184. Example 2: Input:  n = 2 Output:  22 Explanation:  Some of the possible sequences are (1, 2), (2, 1), (3, 2). Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1. There are a total of 22 distinct sequences possible, so we return 22.   Constraints: 1 <= n <= 10 4","['Dynamic Programming', 'Memoization']",Difícil,Dynamic Programming,False
3130,find-all-possible-stable-binary-arrays-ii,https://leetcode.com/problems/find-all-possible-stable-binary-arrays-ii/,Find All Possible Stable Binary Arrays II,"You are given 3 positive integers  zero ,  one , and  limit . A  binary array   arr  is called  stable  if: The number of occurrences of 0 in  arr  is  exactly  zero . The number of occurrences of 1 in  arr  is  exactly   one . Each  subarray  of  arr  with a size greater than  limit  must contain  both  0 and 1. Return the  total  number of  stable  binary arrays. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:   zero = 1, one = 1, limit = 2 Output:   2 Explanation: The two possible stable binary arrays are  [1,0]  and  [0,1] . Example 2: Input:   zero = 1, one = 2, limit = 1 Output:   1 Explanation: The only possible stable binary array is  [1,0,1] . Example 3: Input:   zero = 3, one = 3, limit = 2 Output:   14 Explanation: All the possible stable binary arrays are  [0,0,1,0,1,1] ,  [0,0,1,1,0,1] ,  [0,1,0,0,1,1] ,  [0,1,0,1,0,1] ,  [0,1,0,1,1,0] ,  [0,1,1,0,0,1] ,  [0,1,1,0,1,0] ,  [1,0,0,1,0,1] ,  [1,0,0,1,1,0] ,  [1,0,1,0,0,1] ,  [1,0,1,0,1,0] ,  [1,0,1,1,0,0] ,  [1,1,0,0,1,0] , and  [1,1,0,1,0,0] .   Constraints: 1 <= zero, one, limit <= 1000","['Dynamic Programming', 'Prefix Sum']",Difícil,Dynamic Programming,False
338,counting-bits,https://leetcode.com/problems/counting-bits/,Counting Bits,"Given an integer  n , return  an array  ans  of length  n + 1  such that for each  i   ( 0 <= i <= n ) ,  ans[i]  is the  number of  1 's  in the binary representation of  i .   Example 1: Input:  n = 2 Output:  [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10 Example 2: Input:  n = 5 Output:  [0,1,1,2,1,2] Explanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101   Constraints: 0 <= n <= 10 5   Follow up: It is very easy to come up with a solution with a runtime of  O(n log n) . Can you do it in linear time  O(n)  and possibly in a single pass? Can you do it without using any built-in function (i.e., like  __builtin_popcount  in C++)?","['Dynamic Programming', 'Bit Manipulation']",Fácil,Dynamic Programming,False
397,integer-replacement,https://leetcode.com/problems/integer-replacement/,Integer Replacement,"Given a positive integer  n , you can apply one of the following operations: If  n  is even, replace  n  with  n / 2 . If  n  is odd, replace  n  with either  n + 1  or  n - 1 . Return  the minimum number of operations needed for   n   to become   1 .   Example 1: Input:  n = 8 Output:  3 Explanation:  8 -> 4 -> 2 -> 1 Example 2: Input:  n = 7 Output:  4 Explanation:  7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1 Example 3: Input:  n = 4 Output:  2   Constraints: 1 <= n <= 2 31  - 1","['Dynamic Programming', 'Greedy', 'Bit Manipulation', 'Memoization']",Média,Dynamic Programming,False
1155,number-of-dice-rolls-with-target-sum,https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/,Number of Dice Rolls With Target Sum,"You have  n  dice, and each dice has  k  faces numbered from  1  to  k . Given three integers  n ,  k , and  target , return  the number of possible ways (out of the  k n  total ways)  to roll the dice, so the sum of the face-up numbers equals  target . Since the answer may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 1, k = 6, target = 3 Output:  1 Explanation:  You throw one die with 6 faces. There is only one way to get a sum of 3. Example 2: Input:  n = 2, k = 6, target = 7 Output:  6 Explanation:  You throw two dice, each with 6 faces. There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1. Example 3: Input:  n = 30, k = 30, target = 500 Output:  222616187 Explanation:  The answer must be returned modulo 10 9  + 7.   Constraints: 1 <= n, k <= 30 1 <= target <= 1000",['Dynamic Programming'],Média,Dynamic Programming,False
1387,sort-integers-by-the-power-value,https://leetcode.com/problems/sort-integers-by-the-power-value/,Sort Integers by The Power Value,"The power of an integer  x  is defined as the number of steps needed to transform  x  into  1  using the following steps: if  x  is even then  x = x / 2 if  x  is odd then  x = 3 * x + 1 For example, the power of  x = 3  is  7  because  3  needs  7  steps to become  1  ( 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1 ). Given three integers  lo ,  hi  and  k . The task is to sort all integers in the interval  [lo, hi]  by the power value in  ascending order , if two or more integers have  the same  power value sort them by  ascending order . Return the  k th  integer in the range  [lo, hi]  sorted by the power value. Notice that for any integer  x   (lo <= x <= hi)  it is  guaranteed  that  x  will transform into  1  using these steps and that the power of  x  is will  fit  in a 32-bit signed integer.   Example 1: Input:  lo = 12, hi = 15, k = 2 Output:  13 Explanation:  The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1) The power of 13 is 9 The power of 14 is 17 The power of 15 is 17 The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13. Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15. Example 2: Input:  lo = 7, hi = 11, k = 4 Output:  7 Explanation:  The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14]. The interval sorted by power is [8, 10, 11, 7, 9]. The fourth number in the sorted array is 7.   Constraints: 1 <= lo <= hi <= 1000 1 <= k <= hi - lo + 1","['Dynamic Programming', 'Memoization', 'Sorting']",Média,Dynamic Programming,False
2327,number-of-people-aware-of-a-secret,https://leetcode.com/problems/number-of-people-aware-of-a-secret/,Number of People Aware of a Secret,"On day  1 , one person discovers a secret. You are given an integer  delay , which means that each person will  share  the secret with a new person  every day , starting from  delay  days after discovering the secret. You are also given an integer  forget , which means that each person will  forget  the secret  forget  days after discovering it. A person  cannot  share the secret on the same day they forgot it, or on any day afterwards. Given an integer  n , return  the number of people who know the secret at the end of day  n . Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 6, delay = 2, forget = 4 Output:  5 Explanation: Day 1: Suppose the first person is named A. (1 person) Day 2: A is the only person who knows the secret. (1 person) Day 3: A shares the secret with a new person, B. (2 people) Day 4: A shares the secret with a new person, C. (3 people) Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people) Day 6: B shares the secret with E, and C shares the secret with F. (5 people) Example 2: Input:  n = 4, delay = 1, forget = 3 Output:  6 Explanation: Day 1: The first person is named A. (1 person) Day 2: A shares the secret with B. (2 people) Day 3: A and B share the secret with 2 new people, C and D. (4 people) Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)   Constraints: 2 <= n <= 1000 1 <= delay < forget <= n","['Dynamic Programming', 'Queue', 'Simulation']",Média,Dynamic Programming,False
2466,count-ways-to-build-good-strings,https://leetcode.com/problems/count-ways-to-build-good-strings/,Count Ways To Build Good Strings,"Given the integers  zero ,  one ,  low , and  high , we can construct a string by starting with an empty string, and then at each step perform either of the following: Append the character  '0'   zero  times. Append the character  '1'   one  times. This can be performed any number of times. A  good  string is a string constructed by the above process having a  length  between  low  and  high  ( inclusive ). Return  the number of  different  good strings that can be constructed satisfying these properties.  Since the answer can be large, return it  modulo   10 9  + 7 .   Example 1: Input:  low = 3, high = 3, zero = 1, one = 1 Output:  8 Explanation:   One possible valid good string is ""011"".  It can be constructed as follows: """" -> ""0"" -> ""01"" -> ""011"".  All binary strings from ""000"" to ""111"" are good strings in this example. Example 2: Input:  low = 2, high = 3, zero = 1, one = 2 Output:  5 Explanation:  The good strings are ""00"", ""11"", ""000"", ""110"", and ""011"".   Constraints: 1 <= low <= high <= 10 5 1 <= zero, one <= low",['Dynamic Programming'],Média,Dynamic Programming,False
2571,minimum-operations-to-reduce-an-integer-to-0,https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/,Minimum Operations to Reduce an Integer to 0,"You are given a positive integer  n , you can do the following operation  any  number of times: Add or subtract a  power  of  2  from  n . Return  the  minimum  number of operations to make  n  equal to  0 . A number  x  is power of  2  if  x == 2 i  where  i >= 0 .   Example 1: Input:  n = 39 Output:  3 Explanation:  We can do the following operations: - Add 2 0  = 1 to n, so now n = 40. - Subtract 2 3  = 8 from n, so now n = 32. - Subtract 2 5  = 32 from n, so now n = 0. It can be shown that 3 is the minimum number of operations we need to make n equal to 0. Example 2: Input:  n = 54 Output:  3 Explanation:  We can do the following operations: - Add 2 1  = 2 to n, so now n = 56. - Add 2 3  = 8 to n, so now n = 64. - Subtract 2 6  = 64 from n, so now n = 0. So the minimum number of operations is 3.   Constraints: 1 <= n <= 10 5","['Dynamic Programming', 'Greedy', 'Bit Manipulation']",Média,Dynamic Programming,False
2787,ways-to-express-an-integer-as-sum-of-powers,https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/,Ways to Express an Integer as Sum of Powers,"Given two  positive  integers  n  and  x . Return  the number of ways  n  can be expressed as the sum of the  x th  power of  unique  positive integers, in other words, the number of sets of unique integers  [n 1 , n 2 , ..., n k ]  where  n = n 1 x  + n 2 x  + ... + n k x . Since the result can be very large, return it modulo  10 9  + 7 . For example, if  n = 160  and  x = 3 , one way to express  n  is  n = 2 3  + 3 3  + 5 3 .   Example 1: Input:  n = 10, x = 2 Output:  1 Explanation:  We can express n as the following: n = 3 2  + 1 2  = 10. It can be shown that it is the only way to express 10 as the sum of the 2 nd  power of unique integers. Example 2: Input:  n = 4, x = 1 Output:  2 Explanation:  We can express n in the following ways: - n = 4 1  = 4. - n = 3 1  + 1 1  = 4.   Constraints: 1 <= n <= 300 1 <= x <= 5",['Dynamic Programming'],Média,Dynamic Programming,False
2998,minimum-number-of-operations-to-make-x-and-y-equal,https://leetcode.com/problems/minimum-number-of-operations-to-make-x-and-y-equal/,Minimum Number of Operations to Make X and Y Equal,"You are given two positive integers  x  and  y . In one operation, you can do one of the four following operations: Divide  x  by  11  if  x  is a multiple of  11 . Divide  x  by  5  if  x  is a multiple of  5 . Decrement  x  by  1 . Increment  x  by  1 . Return  the  minimum  number of operations required to make    x   and   y  equal.   Example 1: Input:  x = 26, y = 1 Output:  3 Explanation:  We can make 26 equal to 1 by applying the following operations:  1. Decrement x by 1 2. Divide x by 5 3. Divide x by 5 It can be shown that 3 is the minimum number of operations required to make 26 equal to 1. Example 2: Input:  x = 54, y = 2 Output:  4 Explanation:  We can make 54 equal to 2 by applying the following operations:  1. Increment x by 1 2. Divide x by 11  3. Divide x by 5 4. Increment x by 1 It can be shown that 4 is the minimum number of operations required to make 54 equal to 2. Example 3: Input:  x = 25, y = 30 Output:  5 Explanation:  We can make 25 equal to 30 by applying the following operations:  1. Increment x by 1 2. Increment x by 1 3. Increment x by 1 4. Increment x by 1 5. Increment x by 1 It can be shown that 5 is the minimum number of operations required to make 25 equal to 30.   Constraints: 1 <= x, y <= 10 4","['Dynamic Programming', 'Breadth-First Search', 'Memoization']",Média,Dynamic Programming,False
3129,find-all-possible-stable-binary-arrays-i,https://leetcode.com/problems/find-all-possible-stable-binary-arrays-i/,Find All Possible Stable Binary Arrays I,"You are given 3 positive integers  zero ,  one , and  limit . A  binary array   arr  is called  stable  if: The number of occurrences of 0 in  arr  is  exactly  zero . The number of occurrences of 1 in  arr  is  exactly   one . Each  subarray  of  arr  with a size greater than  limit  must contain  both  0 and 1. Return the  total  number of  stable  binary arrays. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:   zero = 1, one = 1, limit = 2 Output:   2 Explanation: The two possible stable binary arrays are  [1,0]  and  [0,1] , as both arrays have a single 0 and a single 1, and no subarray has a length greater than 2. Example 2: Input:   zero = 1, one = 2, limit = 1 Output:   1 Explanation: The only possible stable binary array is  [1,0,1] . Note that the binary arrays  [1,1,0]  and  [0,1,1]  have subarrays of length 2 with identical elements, hence, they are not stable. Example 3: Input:   zero = 3, one = 3, limit = 2 Output:   14 Explanation: All the possible stable binary arrays are  [0,0,1,0,1,1] ,  [0,0,1,1,0,1] ,  [0,1,0,0,1,1] ,  [0,1,0,1,0,1] ,  [0,1,0,1,1,0] ,  [0,1,1,0,0,1] ,  [0,1,1,0,1,0] ,  [1,0,0,1,0,1] ,  [1,0,0,1,1,0] ,  [1,0,1,0,0,1] ,  [1,0,1,0,1,0] ,  [1,0,1,1,0,0] ,  [1,1,0,0,1,0] , and  [1,1,0,1,0,0] .   Constraints: 1 <= zero, one, limit <= 200","['Dynamic Programming', 'Prefix Sum']",Média,Dynamic Programming,False
1291,sequential-digits,https://leetcode.com/problems/sequential-digits/,Sequential Digits,"An integer has  sequential digits  if and only if each digit in the number is one more than the previous digit. Return a  sorted  list of all the integers in the range  [low, high]  inclusive that have sequential digits.   Example 1: Input:  low = 100, high = 300 Output:  [123,234] Example 2: Input:  low = 1000, high = 13000 Output:  [1234,2345,3456,4567,5678,6789,12345]   Constraints: 10 <= low <= high <= 10^9",['Enumeration'],Média,Enumeration,False
765,couples-holding-hands,https://leetcode.com/problems/couples-holding-hands/,Couples Holding Hands,"There are  n  couples sitting in  2n  seats arranged in a row and want to hold hands. The people and seats are represented by an integer array  row  where  row[i]  is the ID of the person sitting in the  i th  seat. The couples are numbered in order, the first couple being  (0, 1) , the second couple being  (2, 3) , and so on with the last couple being  (2n - 2, 2n - 1) . Return  the minimum number of swaps so that every couple is sitting side by side . A swap consists of choosing any two people, then they stand up and switch seats.   Example 1: Input:  row = [0,2,1,3] Output:  1 Explanation:  We only need to swap the second (row[1]) and third (row[2]) person. Example 2: Input:  row = [3,2,0,1] Output:  0 Explanation:  All couples are already seated side by side.   Constraints: 2n == row.length 2 <= n <= 30 n  is even. 0 <= row[i] < 2n All the elements of  row  are  unique .","['Greedy', 'Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Difícil,Greedy,False
2429,minimize-xor,https://leetcode.com/problems/minimize-xor/,Minimize XOR,"Given two positive integers  num1  and  num2 , find the positive integer  x  such that: x  has the same number of set bits as  num2 , and The value  x XOR num1  is  minimal . Note that  XOR  is the bitwise XOR operation. Return  the integer  x . The test cases are generated such that  x  is  uniquely determined . The number of  set bits  of an integer is the number of  1 's in its binary representation.   Example 1: Input:  num1 = 3, num2 = 5 Output:  3 Explanation: The binary representations of num1 and num2 are 0011 and 0101, respectively. The integer  3  has the same number of set bits as num2, and the value  3 XOR 3 = 0  is minimal. Example 2: Input:  num1 = 1, num2 = 12 Output:  3 Explanation: The binary representations of num1 and num2 are 0001 and 1100, respectively. The integer  3  has the same number of set bits as num2, and the value  3 XOR 1 = 2  is minimal.   Constraints: 1 <= num1, num2 <= 10 9","['Greedy', 'Bit Manipulation']",Média,Greedy,False
30,substring-with-concatenation-of-all-words,https://leetcode.com/problems/substring-with-concatenation-of-all-words/,Substring with Concatenation of All Words,"You are given a string  s  and an array of strings  words . All the strings of  words  are of  the same length . A  concatenated string  is a string that exactly contains all the strings of any permutation of  words  concatenated. For example, if  words = [""ab"",""cd"",""ef""] , then  ""abcdef"" ,  ""abefcd"" ,  ""cdabef"" ,  ""cdefab"" ,  ""efabcd"" , and  ""efcdab""  are all concatenated strings.  ""acdbef""  is not a concatenated string because it is not the concatenation of any permutation of  words . Return an array of  the starting indices  of all the concatenated substrings in  s . You can return the answer in  any order .   Example 1: Input:   s = ""barfoothefoobarman"", words = [""foo"",""bar""] Output:   [0,9] Explanation: The substring starting at 0 is  ""barfoo"" . It is the concatenation of  [""bar"",""foo""]  which is a permutation of  words . The substring starting at 9 is  ""foobar"" . It is the concatenation of  [""foo"",""bar""]  which is a permutation of  words . Example 2: Input:   s = ""wordgoodgoodgoodbestword"", words = [""word"",""good"",""best"",""word""] Output:   [] Explanation: There is no concatenated substring. Example 3: Input:   s = ""barfoofoobarthefoobarman"", words = [""bar"",""foo"",""the""] Output:   [6,9,12] Explanation: The substring starting at 6 is  ""foobarthe"" . It is the concatenation of  [""foo"",""bar"",""the""] . The substring starting at 9 is  ""barthefoo"" . It is the concatenation of  [""bar"",""the"",""foo""] . The substring starting at 12 is  ""thefoobar"" . It is the concatenation of  [""the"",""foo"",""bar""] .   Constraints: 1 <= s.length <= 10 4 1 <= words.length <= 5000 1 <= words[i].length <= 30 s  and  words[i]  consist of lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Difícil,Hash Table,False
76,minimum-window-substring,https://leetcode.com/problems/minimum-window-substring/,Minimum Window Substring,"Given two strings  s  and  t  of lengths  m  and  n  respectively, return  the  minimum window   substring  of  s  such that every character in  t  ( including duplicates ) is included in the window . If there is no such substring, return  the empty string  """" . The testcases will be generated such that the answer is  unique .   Example 1: Input:  s = ""ADOBECODEBANC"", t = ""ABC"" Output:  ""BANC"" Explanation:  The minimum window substring ""BANC"" includes 'A', 'B', and 'C' from string t. Example 2: Input:  s = ""a"", t = ""a"" Output:  ""a"" Explanation:  The entire string s is the minimum window. Example 3: Input:  s = ""a"", t = ""aa"" Output:  """" Explanation:  Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string.   Constraints: m == s.length n == t.length 1 <= m, n <= 10 5 s  and  t  consist of uppercase and lowercase English letters.   Follow up:  Could you find an algorithm that runs in  O(m + n)  time?","['Hash Table', 'String', 'Sliding Window']",Difícil,Hash Table,False
432,all-oone-data-structure,https://leetcode.com/problems/all-oone-data-structure/,All O`one Data Structure,"Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts. Implement the  AllOne  class: AllOne()  Initializes the object of the data structure. inc(String key)  Increments the count of the string  key  by  1 . If  key  does not exist in the data structure, insert it with count  1 . dec(String key)  Decrements the count of the string  key  by  1 . If the count of  key  is  0  after the decrement, remove it from the data structure. It is guaranteed that  key  exists in the data structure before the decrement. getMaxKey()  Returns one of the keys with the maximal count. If no element exists, return an empty string  """" . getMinKey()  Returns one of the keys with the minimum count. If no element exists, return an empty string  """" . Note  that each function must run in  O(1)  average time complexity.   Example 1: Input [""AllOne"", ""inc"", ""inc"", ""getMaxKey"", ""getMinKey"", ""inc"", ""getMaxKey"", ""getMinKey""] [[], [""hello""], [""hello""], [], [], [""leet""], [], []] Output [null, null, null, ""hello"", ""hello"", null, ""hello"", ""leet""] Explanation AllOne allOne = new AllOne(); allOne.inc(""hello""); allOne.inc(""hello""); allOne.getMaxKey(); // return ""hello"" allOne.getMinKey(); // return ""hello"" allOne.inc(""leet""); allOne.getMaxKey(); // return ""hello"" allOne.getMinKey(); // return ""leet""   Constraints: 1 <= key.length <= 10 key  consists of lowercase English letters. It is guaranteed that for each call to  dec ,  key  is existing in the data structure. At most  5 * 10 4  calls will be made to  inc ,  dec ,  getMaxKey , and  getMinKey .","['Hash Table', 'Linked List', 'Design', 'Doubly-Linked List']",Difícil,Hash Table,False
460,lfu-cache,https://leetcode.com/problems/lfu-cache/,LFU Cache,"Design and implement a data structure for a  Least Frequently Used (LFU)  cache. Implement the  LFUCache  class: LFUCache(int capacity)  Initializes the object with the  capacity  of the data structure. int get(int key)  Gets the value of the  key  if the  key  exists in the cache. Otherwise, returns  -1 . void put(int key, int value)  Update the value of the  key  if present, or inserts the  key  if not already present. When the cache reaches its  capacity , it should invalidate and remove the  least frequently used  key before inserting a new item. For this problem, when there is a  tie  (i.e., two or more keys with the same frequency), the  least recently used   key  would be invalidated. To determine the least frequently used key, a  use counter  is maintained for each key in the cache. The key with the smallest  use counter  is the least frequently used key. When a key is first inserted into the cache, its  use counter  is set to  1  (due to the  put  operation). The  use counter  for a key in the cache is incremented either a  get  or  put  operation is called on it. The functions  get  and  put  must each run in  O(1)  average time complexity.   Example 1: Input [""LFUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""get"", ""put"", ""get"", ""get"", ""get""] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, 3, null, -1, 3, 4] Explanation // cnt(x) = the use counter for key x // cache=[] will show the last used order for tiebreakers (leftmost element is  most recent) LFUCache lfu = new LFUCache(2); lfu.put(1, 1);   // cache=[1,_], cnt(1)=1 lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1 lfu.get(1);      // return 1                  // cache=[1,2], cnt(2)=1, cnt(1)=2 lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.                  // cache=[3,1], cnt(3)=1, cnt(1)=2 lfu.get(2);      // return -1 (not found) lfu.get(3);      // return 3                  // cache=[3,1], cnt(3)=2, cnt(1)=2 lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.                  // cache=[4,3], cnt(4)=1, cnt(3)=2 lfu.get(1);      // return -1 (not found) lfu.get(3);      // return 3                  // cache=[3,4], cnt(4)=1, cnt(3)=3 lfu.get(4);      // return 4                  // cache=[4,3], cnt(4)=2, cnt(3)=3   Constraints: 1 <= capacity <= 10 4 0 <= key <= 10 5 0 <= value <= 10 9 At most  2 * 10 5  calls will be made to  get  and  put .","['Hash Table', 'Linked List', 'Design', 'Doubly-Linked List']",Difícil,Hash Table,False
726,number-of-atoms,https://leetcode.com/problems/number-of-atoms/,Number of Atoms,"Given a string  formula  representing a chemical formula, return  the count of each atom . The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element's count may follow if the count is greater than  1 . If the count is  1 , no digits will follow. For example,  ""H2O""  and  ""H2O2""  are possible, but  ""H1O2""  is impossible. Two formulas are concatenated together to produce another formula. For example,  ""H2O2He3Mg4""  is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula. For example,  ""(H2O2)""  and  ""(H2O2)3""  are formulas. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than  1 ), followed by the second name (in sorted order), followed by its count (if that count is more than  1 ), and so on. The test cases are generated so that all the values in the output fit in a  32-bit  integer.   Example 1: Input:  formula = ""H2O"" Output:  ""H2O"" Explanation:  The count of elements are {'H': 2, 'O': 1}. Example 2: Input:  formula = ""Mg(OH)2"" Output:  ""H2MgO2"" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}. Example 3: Input:  formula = ""K4(ON(SO3)2)2"" Output:  ""K4N2O14S4"" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Constraints: 1 <= formula.length <= 1000 formula  consists of English letters, digits,  '(' , and  ')' . formula  is always valid.","['Hash Table', 'String', 'Stack', 'Sorting']",Difícil,Hash Table,False
895,maximum-frequency-stack,https://leetcode.com/problems/maximum-frequency-stack/,Maximum Frequency Stack,"Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the  FreqStack  class: FreqStack()  constructs an empty frequency stack. void push(int val)  pushes an integer  val  onto the top of the stack. int pop()  removes and returns the most frequent element in the stack. 	 If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.   Example 1: Input [""FreqStack"", ""push"", ""push"", ""push"", ""push"", ""push"", ""push"", ""pop"", ""pop"", ""pop"", ""pop""] [[], [5], [7], [5], [7], [4], [5], [], [], [], []] Output [null, null, null, null, null, null, null, 5, 7, 5, 4] Explanation FreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].   Constraints: 0 <= val <= 10 9 At most  2 * 10 4  calls will be made to  push  and  pop . It is guaranteed that there will be at least one element in the stack before calling  pop .","['Hash Table', 'Stack', 'Design', 'Ordered Set']",Difícil,Hash Table,False
1172,dinner-plate-stacks,https://leetcode.com/problems/dinner-plate-stacks/,Dinner Plate Stacks,"You have an infinite number of stacks arranged in a row and numbered (left to right) from  0 , each of the stacks has the same maximum capacity. Implement the  DinnerPlates  class: DinnerPlates(int capacity)  Initializes the object with the maximum capacity of the stacks  capacity . void push(int val)  Pushes the given integer  val  into the leftmost stack with a size less than  capacity . int pop()  Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns  -1  if all the stacks are empty. int popAtStack(int index)  Returns the value at the top of the stack with the given index  index  and removes it from that stack or returns  -1  if the stack with that given index is empty.   Example 1: Input [""DinnerPlates"", ""push"", ""push"", ""push"", ""push"", ""push"", ""popAtStack"", ""push"", ""push"", ""popAtStack"", ""popAtStack"", ""pop"", ""pop"", ""pop"", ""pop"", ""pop""] [[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []] Output [null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1] Explanation:   DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5);         // The stacks are now:  2  4                                            1  3  5                                            ﹈ ﹈ ﹈ D.popAtStack(0);   // Returns 2.  The stacks are now:     4                                                        1  3  5                                                        ﹈ ﹈ ﹈ D.push(20);        // The stacks are now: 20  4                                            1  3  5                                            ﹈ ﹈ ﹈ D.push(21);        // The stacks are now: 20  4 21                                            1  3  5                                            ﹈ ﹈ ﹈ D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21                                                         1  3  5                                                         ﹈ ﹈ ﹈ D.popAtStack(2);   // Returns 21.  The stacks are now:     4                                                         1  3  5                                                         ﹈ ﹈ ﹈  D.pop()            // Returns 5.  The stacks are now:      4                                                         1  3                                                          ﹈ ﹈   D.pop()            // Returns 4.  The stacks are now:   1  3                                                          ﹈ ﹈    D.pop()            // Returns 3.  The stacks are now:   1                                                          ﹈    D.pop()            // Returns 1.  There are no stacks. D.pop()            // Returns -1.  There are still no stacks.   Constraints: 1 <= capacity <= 2 * 10 4 1 <= val <= 2 * 10 4 0 <= index <= 10 5 At most  2 * 10 5  calls will be made to  push ,  pop , and  popAtStack .","['Hash Table', 'Stack', 'Design', 'Heap (Priority Queue)']",Difícil,Hash Table,False
2949,count-beautiful-substrings-ii,https://leetcode.com/problems/count-beautiful-substrings-ii/,Count Beautiful Substrings II,"You are given a string  s  and a positive integer  k . Let  vowels  and  consonants  be the number of vowels and consonants in a string. A string is  beautiful  if: vowels == consonants . (vowels * consonants) % k == 0 , in other terms the multiplication of  vowels  and  consonants  is divisible by  k . Return  the number of  non-empty beautiful substrings  in the given string   s . A  substring  is a contiguous sequence of characters in a string. Vowel letters  in English are  'a' ,  'e' ,  'i' ,  'o' , and  'u' . Consonant letters  in English are every letter except vowels.   Example 1: Input:  s = ""baeyh"", k = 2 Output:  2 Explanation:  There are 2 beautiful substrings in the given string. - Substring ""b aeyh "", vowels = 2 ([""a"",e""]), consonants = 2 ([""y"",""h""]). You can see that string ""aeyh"" is beautiful as vowels == consonants and vowels * consonants % k == 0. - Substring "" baey h"", vowels = 2 ([""a"",e""]), consonants = 2 ([""b"",""y""]). You can see that string ""baey"" is beautiful as vowels == consonants and vowels * consonants % k == 0. It can be shown that there are only 2 beautiful substrings in the given string. Example 2: Input:  s = ""abba"", k = 1 Output:  3 Explanation:  There are 3 beautiful substrings in the given string. - Substring "" ab ba"", vowels = 1 ([""a""]), consonants = 1 ([""b""]). - Substring ""ab ba "", vowels = 1 ([""a""]), consonants = 1 ([""b""]). - Substring "" abba "", vowels = 2 ([""a"",""a""]), consonants = 2 ([""b"",""b""]). It can be shown that there are only 3 beautiful substrings in the given string. Example 3: Input:  s = ""bcdf"", k = 1 Output:  0 Explanation:  There are no beautiful substrings in the given string.   Constraints: 1 <= s.length <= 5 * 10 4 1 <= k <= 1000 s  consists of only English lowercase letters.","['Hash Table', 'Math', 'String', 'Number Theory', 'Prefix Sum']",Difícil,Hash Table,False
3298,count-substrings-that-can-be-rearranged-to-contain-a-string-ii,https://leetcode.com/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/,Count Substrings That Can Be Rearranged to Contain a String II,"You are given two strings  word1  and  word2 . A string  x  is called  valid  if  x  can be rearranged to have  word2  as a  prefix . Return the total number of  valid   substrings  of  word1 . Note  that the memory limits in this problem are  smaller  than usual, so you  must  implement a solution with a  linear  runtime complexity.   Example 1: Input:   word1 = ""bcca"", word2 = ""abc"" Output:   1 Explanation: The only valid substring is  ""bcca""  which can be rearranged to  ""abcc""  having  ""abc""  as a prefix. Example 2: Input:   word1 = ""abcabc"", word2 = ""abc"" Output:   10 Explanation: All the substrings except substrings of size 1 and size 2 are valid. Example 3: Input:   word1 = ""abcabc"", word2 = ""aaabc"" Output:   0   Constraints: 1 <= word1.length <= 10 6 1 <= word2.length <= 10 4 word1  and  word2  consist only of lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Difícil,Hash Table,False
3337,total-characters-in-string-after-transformations-ii,https://leetcode.com/problems/total-characters-in-string-after-transformations-ii/,Total Characters in String After Transformations II,"You are given a string  s  consisting of lowercase English letters, an integer  t  representing the number of  transformations  to perform, and an array  nums  of size 26. In one  transformation , every character in  s  is replaced according to the following rules: Replace  s[i]  with the  next   nums[s[i] - 'a']  consecutive characters in the alphabet. For example, if  s[i] = 'a'  and  nums[0] = 3 , the character  'a'  transforms into the next 3 consecutive characters ahead of it, which results in  ""bcd"" . The transformation  wraps  around the alphabet if it exceeds  'z' . For example, if  s[i] = 'y'  and  nums[24] = 3 , the character  'y'  transforms into the next 3 consecutive characters ahead of it, which results in  ""zab"" . Return the length of the resulting string after  exactly   t  transformations. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:   s = ""abcyy"", t = 2, nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2] Output:   7 Explanation: First Transformation (t = 1): 'a'  becomes  'b'  as  nums[0] == 1 'b'  becomes  'c'  as  nums[1] == 1 'c'  becomes  'd'  as  nums[2] == 1 'y'  becomes  'z'  as  nums[24] == 1 'y'  becomes  'z'  as  nums[24] == 1 String after the first transformation:  ""bcdzz"" Second Transformation (t = 2): 'b'  becomes  'c'  as  nums[1] == 1 'c'  becomes  'd'  as  nums[2] == 1 'd'  becomes  'e'  as  nums[3] == 1 'z'  becomes  'ab'  as  nums[25] == 2 'z'  becomes  'ab'  as  nums[25] == 2 String after the second transformation:  ""cdeabab"" Final Length of the string:  The string is  ""cdeabab"" , which has 7 characters. Example 2: Input:   s = ""azbk"", t = 1, nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2] Output:   8 Explanation: First Transformation (t = 1): 'a'  becomes  'bc'  as  nums[0] == 2 'z'  becomes  'ab'  as  nums[25] == 2 'b'  becomes  'cd'  as  nums[1] == 2 'k'  becomes  'lm'  as  nums[10] == 2 String after the first transformation:  ""bcabcdlm"" Final Length of the string:  The string is  ""bcabcdlm"" , which has 8 characters.   Constraints: 1 <= s.length <= 10 5 s  consists only of lowercase English letters. 1 <= t <= 10 9 nums.length == 26 1 <= nums[i] <= 25","['Hash Table', 'Math', 'String', 'Dynamic Programming', 'Counting']",Difícil,Hash Table,False
884,uncommon-words-from-two-sentences,https://leetcode.com/problems/uncommon-words-from-two-sentences/,Uncommon Words from Two Sentences,"A  sentence  is a string of single-space separated words where each word consists only of lowercase letters. A word is  uncommon  if it appears exactly once in one of the sentences, and  does not appear  in the other sentence. Given two  sentences   s1  and  s2 , return  a list of all the  uncommon words . You may return the answer in  any order .   Example 1: Input:   s1 = ""this apple is sweet"", s2 = ""this apple is sour"" Output:   [""sweet"",""sour""] Explanation: The word  ""sweet""  appears only in  s1 , while the word  ""sour""  appears only in  s2 . Example 2: Input:   s1 = ""apple apple"", s2 = ""banana"" Output:   [""banana""]   Constraints: 1 <= s1.length, s2.length <= 200 s1  and  s2  consist of lowercase English letters and spaces. s1  and  s2  do not have leading or trailing spaces. All the words in  s1  and  s2  are separated by a single space.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table,False
1370,increasing-decreasing-string,https://leetcode.com/problems/increasing-decreasing-string/,Increasing Decreasing String,"You are given a string  s . Reorder the string using the following algorithm: Remove the  smallest  character from  s  and  append  it to the result. Remove the  smallest  character from  s  that is greater than the last appended character, and  append  it to the result. Repeat step 2 until no more characters can be removed. Remove the  largest  character from  s  and  append  it to the result. Remove the  largest  character from  s  that is smaller than the last appended character, and  append  it to the result. Repeat step 5 until no more characters can be removed. Repeat steps 1 through 6 until all characters from  s  have been removed. If the smallest or largest character appears more than once, you may choose any occurrence to append to the result. Return the resulting string after reordering  s  using this algorithm.   Example 1: Input:  s = ""aaaabbbbcccc"" Output:  ""abccbaabccba"" Explanation:  After steps 1, 2 and 3 of the first iteration, result = ""abc"" After steps 4, 5 and 6 of the first iteration, result = ""abccba"" First iteration is done. Now s = ""aabbcc"" and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = ""abccbaabc"" After steps 4, 5 and 6 of the second iteration, result = ""abccbaabccba"" Example 2: Input:  s = ""rat"" Output:  ""art"" Explanation:  The word ""rat"" becomes ""art"" after re-ordering it with the mentioned algorithm.   Constraints: 1 <= s.length <= 500 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table,False
1399,count-largest-group,https://leetcode.com/problems/count-largest-group/,Count Largest Group,"You are given an integer  n . We need to group the numbers from  1  to  n  according to the sum of its digits. For example, the numbers 14 and 5 belong to the  same  group, whereas 13 and 3 belong to  different  groups. Return the number of groups that have the largest size, i.e. the  maximum  number of elements.   Example 1: Input:  n = 13 Output:  4 Explanation:  There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13: [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size. Example 2: Input:  n = 2 Output:  2 Explanation:  There are 2 groups [1], [2] of size 1.   Constraints: 1 <= n <= 10 4","['Hash Table', 'Math']",Fácil,Hash Table,False
1624,largest-substring-between-two-equal-characters,https://leetcode.com/problems/largest-substring-between-two-equal-characters/,Largest Substring Between Two Equal Characters,"Given a string  s , return  the length of the longest substring between two equal characters, excluding the two characters.  If there is no such substring return  -1 . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""aa"" Output:  0 Explanation:  The optimal substring here is an empty substring between the two  'a's . Example 2: Input:  s = ""abca"" Output:  2 Explanation:  The optimal substring here is ""bc"". Example 3: Input:  s = ""cbzxy"" Output:  -1 Explanation:  There are no characters that appear twice in s.   Constraints: 1 <= s.length <= 300 s  contains only lowercase English letters.","['Hash Table', 'String']",Fácil,Hash Table,False
1935,maximum-number-of-words-you-can-type,https://leetcode.com/problems/maximum-number-of-words-you-can-type/,Maximum Number of Words You Can Type,"There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly. Given a string  text  of words separated by a single space (no leading or trailing spaces) and a string  brokenLetters  of all  distinct  letter keys that are broken, return  the  number of words  in   text   you can fully type using this keyboard .   Example 1: Input:  text = ""hello world"", brokenLetters = ""ad"" Output:  1 Explanation:  We cannot type ""world"" because the 'd' key is broken. Example 2: Input:  text = ""leet code"", brokenLetters = ""lt"" Output:  1 Explanation:  We cannot type ""leet"" because the 'l' and 't' keys are broken. Example 3: Input:  text = ""leet code"", brokenLetters = ""e"" Output:  0 Explanation:  We cannot type either word because the 'e' key is broken.   Constraints: 1 <= text.length <= 10 4 0 <= brokenLetters.length <= 26 text  consists of words separated by a single space without any leading or trailing spaces. Each word only consists of lowercase English letters. brokenLetters  consists of  distinct  lowercase English letters.","['Hash Table', 'String']",Fácil,Hash Table,False
2283,check-if-number-has-equal-digit-count-and-digit-value,https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/,Check if Number Has Equal Digit Count and Digit Value,"You are given a  0-indexed  string  num  of length  n  consisting of digits. Return  true   if for  every  index  i  in the range  0 <= i < n , the digit  i  occurs  num[i]  times in  num , otherwise return  false .   Example 1: Input:  num = ""1210"" Output:  true Explanation: num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in ""1210"", so return true. Example 2: Input:  num = ""030"" Output:  false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false.   Constraints: n == num.length 1 <= n <= 10 num  consists of digits.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table,False
2287,rearrange-characters-to-make-target-string,https://leetcode.com/problems/rearrange-characters-to-make-target-string/,Rearrange Characters to Make Target String,"You are given two  0-indexed  strings  s  and  target . You can take some letters from  s  and rearrange them to form new strings. Return  the  maximum  number of copies of  target  that can be formed by taking letters from  s  and rearranging them.   Example 1: Input:  s = ""ilovecodingonleetcode"", target = ""code"" Output:  2 Explanation: For the first copy of ""code"", take the letters at indices 4, 5, 6, and 7. For the second copy of ""code"", take the letters at indices 17, 18, 19, and 20. The strings that are formed are ""ecod"" and ""code"" which can both be rearranged into ""code"". We can make at most two copies of ""code"", so we return 2. Example 2: Input:  s = ""abcba"", target = ""abc"" Output:  1 Explanation: We can make one copy of ""abc"" by taking the letters at indices 0, 1, and 2. We can make at most one copy of ""abc"", so we return 1. Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of ""abc"". Example 3: Input:  s = ""abbaccaddaeea"", target = ""aaaaa"" Output:  1 Explanation: We can make one copy of ""aaaaa"" by taking the letters at indices 0, 3, 6, 9, and 12. We can make at most one copy of ""aaaaa"", so we return 1.   Constraints: 1 <= s.length <= 100 1 <= target.length <= 10 s  and  target  consist of lowercase English letters.   Note:  This question is the same as   1189: Maximum Number of Balloons.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table,False
2309,greatest-english-letter-in-upper-and-lower-case,https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/,Greatest English Letter in Upper and Lower Case,"Given a string of English letters  s , return  the  greatest  English letter which occurs as  both  a lowercase and uppercase letter in   s . The returned letter should be in  uppercase . If no such letter exists, return  an empty string . An English letter  b  is  greater  than another letter  a  if  b  appears  after   a  in the English alphabet.   Example 1: Input:  s = ""l Ee TcOd E "" Output:  ""E"" Explanation: The letter 'E' is the only letter to appear in both lower and upper case. Example 2: Input:  s = ""a rR AzFif"" Output:  ""R"" Explanation: The letter 'R' is the greatest letter to appear in both lower and upper case. Note that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'. Example 3: Input:  s = ""AbCdEfGhIjK"" Output:  """" Explanation: There is no letter that appears in both lower and upper case.   Constraints: 1 <= s.length <= 1000 s  consists of lowercase and uppercase English letters.","['Hash Table', 'String', 'Enumeration']",Fácil,Hash Table,False
2351,first-letter-to-appear-twice,https://leetcode.com/problems/first-letter-to-appear-twice/,First Letter to Appear Twice,"Given a string  s  consisting of lowercase English letters, return  the first letter to appear  twice . Note : A letter  a  appears twice before another letter  b  if the  second  occurrence of  a  is before the  second  occurrence of  b . s  will contain at least one letter that appears twice.   Example 1: Input:  s = ""abccbaacz"" Output:  ""c"" Explanation: The letter 'a' appears on the indexes 0, 5 and 6. The letter 'b' appears on the indexes 1 and 4. The letter 'c' appears on the indexes 2, 3 and 7. The letter 'z' appears on the index 8. The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest. Example 2: Input:  s = ""abcdd"" Output:  ""d"" Explanation: The only letter that appears twice is 'd' so we return 'd'.   Constraints: 2 <= s.length <= 100 s  consists of lowercase English letters. s  has at least one repeated letter.","['Hash Table', 'String', 'Bit Manipulation', 'Counting']",Fácil,Hash Table,False
2423,remove-letter-to-equalize-frequency,https://leetcode.com/problems/remove-letter-to-equalize-frequency/,Remove Letter To Equalize Frequency,"You are given a  0-indexed  string  word , consisting of lowercase English letters. You need to select  one  index and  remove  the letter at that index from  word  so that the  frequency  of every letter present in  word  is equal. Return   true  if it is possible to remove one letter so that the frequency of all letters in  word  are equal, and  false  otherwise . Note: The  frequency  of a letter  x  is the number of times it occurs in the string. You  must  remove exactly one letter and cannot choose to do nothing.   Example 1: Input:  word = ""abcc"" Output:  true Explanation:  Select index 3 and delete it: word becomes ""abc"" and each character has a frequency of 1. Example 2: Input:  word = ""aazz"" Output:  false Explanation:  We must delete a character, so either the frequency of ""a"" is 1 and the frequency of ""z"" is 2, or vice versa. It is impossible to make all present letters have equal frequency.   Constraints: 2 <= word.length <= 100 word  consists of lowercase English letters only.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table,False
2716,minimize-string-length,https://leetcode.com/problems/minimize-string-length/,Minimize String Length,"Given a string  s , you have two types of operation: Choose an index  i  in the string, and let  c  be the character in position  i .  Delete  the  closest occurrence  of  c  to the  left  of  i  (if exists). Choose an index  i  in the string, and let  c  be the character in position  i .  Delete  the  closest occurrence  of  c  to the  right  of  i  (if exists). Your task is to  minimize  the length of  s  by performing the above operations zero or more times. Return an integer denoting the length of the  minimized  string.   Example 1: Input:   s = ""aaabc"" Output:   3 Explanation: Operation 2: we choose  i = 1  so  c  is 'a', then we remove  s[2]  as it is closest 'a' character to the right of  s[1] . s  becomes ""aabc"" after this. Operation 1: we choose  i = 1  so  c  is 'a', then we remove  s[0]  as it is closest 'a' character to the left of  s[1] . s  becomes ""abc"" after this. Example 2: Input:   s = ""cbbd"" Output:   3 Explanation: Operation 1: we choose  i = 2  so  c  is 'b', then we remove  s[1]  as it is closest 'b' character to the left of  s[1] . s  becomes ""cbd"" after this. Example 3: Input:   s = ""baadccab"" Output:  4 Explanation: Operation 1: we choose  i = 6  so  c  is 'a', then we remove  s[2]  as it is closest 'a' character to the left of  s[6] . s  becomes ""badccab"" after this. Operation 2: we choose  i = 0  so  c  is 'b', then we remove  s[6]  as it is closest 'b' character to the right of  s[0] . s  becomes ""badcca"" fter this. Operation 2: we choose  i = 3  so  c  is 'c', then we remove  s[4]  as it is closest 'c' character to the right of  s[3] . s  becomes ""badca"" after this. Operation 1: we choose  i = 4  so  c  is 'a', then we remove  s[1]  as it is closest 'a' character to the left of  s[4] . s  becomes ""bdca"" after this.   Constraints: 1 <= s.length <= 100 s  contains only lowercase English letters","['Hash Table', 'String']",Fácil,Hash Table,False
2729,check-if-the-number-is-fascinating,https://leetcode.com/problems/check-if-the-number-is-fascinating/,Check if The Number is Fascinating,"You are given an integer  n  that consists of exactly  3  digits. We call the number  n   fascinating  if, after the following modification, the resulting number contains all the digits from  1  to  9   exactly  once and does not contain any  0 's: Concatenate   n  with the numbers  2 * n  and  3 * n . Return  true  if  n  is fascinating, or  false  otherwise . Concatenating  two numbers means joining them together. For example, the concatenation of  121  and  371  is  121371 .   Example 1: Input:  n = 192 Output:  true Explanation:  We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once. Example 2: Input:  n = 100 Output:  false Explanation:  We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.   Constraints: 100 <= n <= 999","['Hash Table', 'Math']",Fácil,Hash Table,False
3083,existence-of-a-substring-in-a-string-and-its-reverse,https://leetcode.com/problems/existence-of-a-substring-in-a-string-and-its-reverse/,Existence of a Substring in a String and Its Reverse,"Given a   string  s , find any  substring  of length  2  which is also present in the reverse of  s . Return  true  if such a substring exists, and  false  otherwise.   Example 1: Input:  s = ""leetcode"" Output:  true Explanation:  Substring  ""ee""  is of length  2  which is also present in  reverse(s) == ""edocteel"" . Example 2: Input:  s = ""abcba"" Output:  true Explanation:  All of the substrings of length  2   ""ab"" ,  ""bc"" ,  ""cb"" ,  ""ba""  are also present in  reverse(s) == ""abcba"" . Example 3: Input:  s = ""abcd"" Output:  false Explanation:  There is no substring of length  2  in  s , which is also present in the reverse of  s .   Constraints: 1 <= s.length <= 100 s  consists only of lowercase English letters.","['Hash Table', 'String']",Fácil,Hash Table,False
3090,maximum-length-substring-with-two-occurrences,https://leetcode.com/problems/maximum-length-substring-with-two-occurrences/,Maximum Length Substring With Two Occurrences,"Given a string  s , return the  maximum  length of a  substring  such that it contains  at most two occurrences  of each character.   Example 1: Input:   s = ""bcbbbcba"" Output:   4 Explanation: The following substring has a length of 4 and contains at most two occurrences of each character:  ""bcbb bcba "" . Example 2: Input:   s = ""aaaa"" Output:   2 Explanation: The following substring has a length of 2 and contains at most two occurrences of each character:  "" aa aa"" .   Constraints: 2 <= s.length <= 100 s  consists only of lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Fácil,Hash Table,False
3,longest-substring-without-repeating-characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/,Longest Substring Without Repeating Characters,"Given a string  s , find the length of the  longest   substring  without duplicate characters.   Example 1: Input:  s = ""abcabcbb"" Output:  3 Explanation:  The answer is ""abc"", with the length of 3. Example 2: Input:  s = ""bbbbb"" Output:  1 Explanation:  The answer is ""b"", with the length of 1. Example 3: Input:  s = ""pwwkew"" Output:  3 Explanation:  The answer is ""wke"", with the length of 3. Notice that the answer must be a substring, ""pwke"" is a subsequence and not a substring.   Constraints: 0 <= s.length <= 5 * 10 4 s  consists of English letters, digits, symbols and spaces.","['Hash Table', 'String', 'Sliding Window']",Média,Hash Table,False
146,lru-cache,https://leetcode.com/problems/lru-cache/,LRU Cache,"Design a data structure that follows the constraints of a  Least Recently Used (LRU) cache . Implement the  LRUCache  class: LRUCache(int capacity)  Initialize the LRU cache with  positive  size  capacity . int get(int key)  Return the value of the  key  if the key exists, otherwise return  -1 . void put(int key, int value)  Update the value of the  key  if the  key  exists. Otherwise, add the  key-value  pair to the cache. If the number of keys exceeds the  capacity  from this operation,  evict  the least recently used key. The functions  get  and  put  must each run in  O(1)  average time complexity.   Example 1: Input [""LRUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1);    // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2);    // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1);    // return -1 (not found) lRUCache.get(3);    // return 3 lRUCache.get(4);    // return 4   Constraints: 1 <= capacity <= 3000 0 <= key <= 10 4 0 <= value <= 10 5 At most  2 * 10 5  calls will be made to  get  and  put .","['Hash Table', 'Linked List', 'Design', 'Doubly-Linked List']",Média,Hash Table,False
187,repeated-dna-sequences,https://leetcode.com/problems/repeated-dna-sequences/,Repeated DNA Sequences,"The  DNA sequence  is composed of a series of nucleotides abbreviated as  'A' ,  'C' ,  'G' , and  'T' . For example,  ""ACGAATTCCG""  is a  DNA sequence . When studying  DNA , it is useful to identify repeated sequences within the DNA. Given a string  s  that represents a  DNA sequence , return all the  10 -letter-long  sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in  any order .   Example 1: Input:  s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"" Output:  [""AAAAACCCCC"",""CCCCCAAAAA""] Example 2: Input:  s = ""AAAAAAAAAAAAA"" Output:  [""AAAAAAAAAA""]   Constraints: 1 <= s.length <= 10 5 s[i]  is either  'A' ,  'C' ,  'G' , or  'T' .","['Hash Table', 'String', 'Bit Manipulation', 'Sliding Window', 'Rolling Hash', 'Hash Function']",Média,Hash Table,False
208,implement-trie-prefix-tree,https://leetcode.com/problems/implement-trie-prefix-tree/,Implement Trie (Prefix Tree),"A  trie  (pronounced as ""try"") or  prefix tree  is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie()  Initializes the trie object. void insert(String word)  Inserts the string  word  into the trie. boolean search(String word)  Returns  true  if the string  word  is in the trie (i.e., was inserted before), and  false  otherwise. boolean startsWith(String prefix)  Returns  true  if there is a previously inserted string  word  that has the prefix  prefix , and  false  otherwise.   Example 1: Input [""Trie"", ""insert"", ""search"", ""search"", ""startsWith"", ""insert"", ""search""] [[], [""apple""], [""apple""], [""app""], [""app""], [""app""], [""app""]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(""apple""); trie.search(""apple"");   // return True trie.search(""app"");     // return False trie.startsWith(""app""); // return True trie.insert(""app""); trie.search(""app"");     // return True   Constraints: 1 <= word.length, prefix.length <= 2000 word  and  prefix  consist only of lowercase English letters. At most  3 * 10 4  calls  in total  will be made to  insert ,  search , and  startsWith .","['Hash Table', 'String', 'Design', 'Trie']",Média,Hash Table,False
264,ugly-number-ii,https://leetcode.com/problems/ugly-number-ii/,Ugly Number II,"An  ugly number  is a positive integer whose prime factors are limited to  2 ,  3 , and  5 . Given an integer  n , return  the   n th   ugly number .   Example 1: Input:  n = 10 Output:  12 Explanation:  [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. Example 2: Input:  n = 1 Output:  1 Explanation:  1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.   Constraints: 1 <= n <= 1690","['Hash Table', 'Math', 'Dynamic Programming', 'Heap (Priority Queue)']",Média,Hash Table,False
299,bulls-and-cows,https://leetcode.com/problems/bulls-and-cows/,Bulls and Cows,"You are playing the  Bulls and Cows  game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: The number of ""bulls"", which are digits in the guess that are in the correct position. The number of ""cows"", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls. Given the secret number  secret  and your friend's guess  guess , return  the hint for your friend's guess . The hint should be formatted as  ""xAyB"" , where  x  is the number of bulls and  y  is the number of cows. Note that both  secret  and  guess  may contain duplicate digits.   Example 1: Input:  secret = ""1807"", guess = ""7810"" Output:  ""1A3B"" Explanation:  Bulls are connected with a '|' and cows are underlined: ""1807""   | "" 7 8 10 "" Example 2: Input:  secret = ""1123"", guess = ""0111"" Output:  ""1A1B"" Explanation:  Bulls are connected with a '|' and cows are underlined: ""1123""        ""1123""   |      or     | ""01 1 1""        ""011 1 "" Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.   Constraints: 1 <= secret.length, guess.length <= 1000 secret.length == guess.length secret  and  guess  consist of digits only.","['Hash Table', 'String', 'Counting']",Média,Hash Table,False
423,reconstruct-original-digits-from-english,https://leetcode.com/problems/reconstruct-original-digits-from-english/,Reconstruct Original Digits from English,"Given a string  s  containing an out-of-order English representation of digits  0-9 , return  the digits in  ascending  order .   Example 1: Input:  s = ""owoztneoer"" Output:  ""012"" Example 2: Input:  s = ""fviefuro"" Output:  ""45""   Constraints: 1 <= s.length <= 10 5 s[i]  is one of the characters  [""e"",""g"",""f"",""i"",""h"",""o"",""n"",""s"",""r"",""u"",""t"",""w"",""v"",""x"",""z""] . s  is  guaranteed  to be valid.","['Hash Table', 'Math', 'String']",Média,Hash Table,False
438,find-all-anagrams-in-a-string,https://leetcode.com/problems/find-all-anagrams-in-a-string/,Find All Anagrams in a String,"Given two strings  s  and  p , return an array of all the start indices of  p 's  anagrams  in  s . You may return the answer in  any order .   Example 1: Input:  s = ""cbaebabacd"", p = ""abc"" Output:  [0,6] Explanation: The substring with start index = 0 is ""cba"", which is an anagram of ""abc"". The substring with start index = 6 is ""bac"", which is an anagram of ""abc"". Example 2: Input:  s = ""abab"", p = ""ab"" Output:  [0,1,2] Explanation: The substring with start index = 0 is ""ab"", which is an anagram of ""ab"". The substring with start index = 1 is ""ba"", which is an anagram of ""ab"". The substring with start index = 2 is ""ab"", which is an anagram of ""ab"".   Constraints: 1 <= s.length, p.length <= 3 * 10 4 s  and  p  consist of lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Média,Hash Table,False
519,random-flip-matrix,https://leetcode.com/problems/random-flip-matrix/,Random Flip Matrix,"There is an  m x n  binary grid  matrix  with all the values set  0  initially. Design an algorithm to randomly pick an index  (i, j)  where  matrix[i][j] == 0  and flips it to  1 . All the indices  (i, j)  where  matrix[i][j] == 0  should be equally likely to be returned. Optimize your algorithm to minimize the number of calls made to the  built-in  random function of your language and optimize the time and space complexity. Implement the  Solution  class: Solution(int m, int n)  Initializes the object with the size of the binary matrix  m  and  n . int[] flip()  Returns a random index  [i, j]  of the matrix where  matrix[i][j] == 0  and flips it to  1 . void reset()  Resets all the values of the matrix to be  0 .   Example 1: Input [""Solution"", ""flip"", ""flip"", ""flip"", ""reset"", ""flip""] [[3, 1], [], [], [], [], []] Output [null, [1, 0], [2, 0], [0, 0], null, [2, 0]] Explanation Solution solution = new Solution(3, 1); solution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned. solution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0] solution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned. solution.reset(); // All the values are reset to 0 and can be returned. solution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.   Constraints: 1 <= m, n <= 10 4 There will be at least one free cell for each call to  flip . At most  1000  calls will be made to  flip  and  reset .","['Hash Table', 'Math', 'Reservoir Sampling', 'Randomized']",Média,Hash Table,False
535,encode-and-decode-tinyurl,https://leetcode.com/problems/encode-and-decode-tinyurl/,Encode and Decode TinyURL,"Note: This is a companion problem to the  System Design  problem:  Design TinyURL . TinyURL is a URL shortening service where you enter a URL such as  https://leetcode.com/problems/design-tinyurl  and it returns a short URL such as  http://tinyurl.com/4e9iAk . Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the  Solution  class: Solution()  Initializes the object of the system. String encode(String longUrl)  Returns a tiny URL for the given  longUrl . String decode(String shortUrl)  Returns the original long URL for the given  shortUrl . It is guaranteed that the given  shortUrl  was encoded by the same object.   Example 1: Input:  url = ""https://leetcode.com/problems/design-tinyurl"" Output:  ""https://leetcode.com/problems/design-tinyurl"" Explanation: Solution obj = new Solution(); string tiny = obj.encode(url); // returns the encoded tiny url. string ans = obj.decode(tiny); // returns the original url after decoding it.   Constraints: 1 <= url.length <= 10 4 url  is guranteed to be a valid URL.","['Hash Table', 'String', 'Design', 'Hash Function']",Média,Hash Table,False
567,permutation-in-string,https://leetcode.com/problems/permutation-in-string/,Permutation in String,"Given two strings  s1  and  s2 , return  true  if  s2  contains a  permutation  of  s1 , or  false  otherwise. In other words, return  true  if one of  s1 's permutations is the substring of  s2 .   Example 1: Input:  s1 = ""ab"", s2 = ""eidbaooo"" Output:  true Explanation:  s2 contains one permutation of s1 (""ba""). Example 2: Input:  s1 = ""ab"", s2 = ""eidboaoo"" Output:  false   Constraints: 1 <= s1.length, s2.length <= 10 4 s1  and  s2  consist of lowercase English letters.","['Hash Table', 'Two Pointers', 'String', 'Sliding Window']",Média,Hash Table,False
869,reordered-power-of-2,https://leetcode.com/problems/reordered-power-of-2/,Reordered Power of 2,You are given an integer  n . We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return  true   if and only if we can do this so that the resulting number is a power of two .   Example 1: Input:  n = 1 Output:  true Example 2: Input:  n = 10 Output:  false   Constraints: 1 <= n <= 10 9,"['Hash Table', 'Math', 'Sorting', 'Counting', 'Enumeration']",Média,Hash Table,False
970,powerful-integers,https://leetcode.com/problems/powerful-integers/,Powerful Integers,"Given three integers  x ,  y , and  bound , return  a list of all the  powerful integers  that have a value less than or equal to   bound . An integer is  powerful  if it can be represented as  x i  + y j  for some integers  i >= 0  and  j >= 0 . You may return the answer in  any order . In your answer, each value should occur  at most once .   Example 1: Input:  x = 2, y = 3, bound = 10 Output:  [2,3,4,5,7,9,10] Explanation: 2 = 2 0  + 3 0 3 = 2 1  + 3 0 4 = 2 0  + 3 1 5 = 2 1  + 3 1 7 = 2 2  + 3 1 9 = 2 3  + 3 0 10 = 2 0  + 3 2 Example 2: Input:  x = 3, y = 5, bound = 15 Output:  [2,4,6,8,10,14]   Constraints: 1 <= x, y <= 100 0 <= bound <= 10 6","['Hash Table', 'Math', 'Enumeration']",Média,Hash Table,False
1015,smallest-integer-divisible-by-k,https://leetcode.com/problems/smallest-integer-divisible-by-k/,Smallest Integer Divisible by K,"Given a positive integer  k , you need to find the  length  of the  smallest  positive integer  n  such that  n  is divisible by  k , and  n  only contains the digit  1 . Return  the  length  of  n . If there is no such  n , return -1. Note:   n  may not fit in a 64-bit signed integer.   Example 1: Input:  k = 1 Output:  1 Explanation:  The smallest answer is n = 1, which has length 1. Example 2: Input:  k = 2 Output:  -1 Explanation:  There is no such positive integer n divisible by 2. Example 3: Input:  k = 3 Output:  3 Explanation:  The smallest answer is n = 111, which has length 3.   Constraints: 1 <= k <= 10 5","['Hash Table', 'Math']",Média,Hash Table,False
1016,binary-string-with-substrings-representing-1-to-n,https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/,Binary String With Substrings Representing 1 To N,"Given a binary string  s  and a positive integer  n , return  true  if the binary representation of all the integers in the range  [1, n]  are  substrings  of  s , or  false  otherwise . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""0110"", n = 3 Output:  true Example 2: Input:  s = ""0110"", n = 4 Output:  false   Constraints: 1 <= s.length <= 1000 s[i]  is either  '0'  or  '1' . 1 <= n <= 10 9","['Hash Table', 'String', 'Bit Manipulation', 'Sliding Window']",Média,Hash Table,False
1171,remove-zero-sum-consecutive-nodes-from-linked-list,https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/,Remove Zero Sum Consecutive Nodes from Linked List,"Given the  head  of a linked list, we repeatedly delete consecutive sequences of nodes that sum to  0  until there are no such sequences. After doing so, return the head of the final linked list.  You may return any such answer.   (Note that in the examples below, all sequences are serializations of  ListNode  objects.) Example 1: Input:  head = [1,2,-3,3,1] Output:  [3,1] Note:  The answer [1,2,1] would also be accepted. Example 2: Input:  head = [1,2,3,-3,4] Output:  [1,2,4] Example 3: Input:  head = [1,2,3,-3,-2] Output:  [1]   Constraints: The given linked list will contain between  1  and  1000  nodes. Each node in the linked list has  -1000 <= node.val <= 1000 .","['Hash Table', 'Linked List']",Média,Hash Table,False
1297,maximum-number-of-occurrences-of-a-substring,https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/,Maximum Number of Occurrences of a Substring,"Given a string  s , return the maximum number of occurrences of  any  substring under the following rules: The number of unique characters in the substring must be less than or equal to  maxLetters . The substring size must be between  minSize  and  maxSize  inclusive.   Example 1: Input:  s = ""aababcaab"", maxLetters = 2, minSize = 3, maxSize = 4 Output:  2 Explanation:  Substring ""aab"" has 2 occurrences in the original string. It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize). Example 2: Input:  s = ""aaaa"", maxLetters = 1, minSize = 3, maxSize = 3 Output:  2 Explanation:  Substring ""aaa"" occur 2 times in the string. It can overlap.   Constraints: 1 <= s.length <= 10 5 1 <= maxLetters <= 26 1 <= minSize <= maxSize <= min(26, s.length) s  consists of only lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Média,Hash Table,False
1347,minimum-number-of-steps-to-make-two-strings-anagram,https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/,Minimum Number of Steps to Make Two Strings Anagram,"You are given two strings of the same length  s  and  t . In one step you can choose  any character  of  t  and replace it with  another character . Return  the minimum number of steps  to make  t  an anagram of  s . An  Anagram  of a string is a string that contains the same characters with a different (or the same) ordering.   Example 1: Input:  s = ""bab"", t = ""aba"" Output:  1 Explanation:  Replace the first 'a' in t with b, t = ""bba"" which is anagram of s. Example 2: Input:  s = ""leetcode"", t = ""practice"" Output:  5 Explanation:  Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s. Example 3: Input:  s = ""anagram"", t = ""mangaar"" Output:  0 Explanation:  ""anagram"" and ""mangaar"" are anagrams.    Constraints: 1 <= s.length <= 5 * 10 4 s.length == t.length s  and  t  consist of lowercase English letters only.","['Hash Table', 'String', 'Counting']",Média,Hash Table,False
1348,tweet-counts-per-frequency,https://leetcode.com/problems/tweet-counts-per-frequency/,Tweet Counts Per Frequency,"A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller  time chunks  based on a certain frequency (every  minute ,  hour , or  day ). For example, the period  [10, 10000]  (in  seconds ) would be partitioned into the following  time chunks  with these frequencies: Every  minute  (60-second chunks):  [10,69] ,  [70,129] ,  [130,189] ,  ... ,  [9970,10000] Every  hour  (3600-second chunks):  [10,3609] ,  [3610,7209] ,  [7210,10000] Every  day  (86400-second chunks):  [10,10000] Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period ( 10000  in the above example). Design and implement an API to help the company with their analysis. Implement the  TweetCounts  class: TweetCounts()  Initializes the  TweetCounts  object. void recordTweet(String tweetName, int time)  Stores the  tweetName  at the recorded  time  (in  seconds ). List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)  Returns a list of integers representing the number of tweets with  tweetName  in each  time chunk  for the given period of time  [startTime, endTime]  (in  seconds ) and frequency  freq . 	 freq  is one of  ""minute"" ,  ""hour"" , or  ""day""  representing a frequency of every  minute ,  hour , or  day  respectively.   Example: Input [""TweetCounts"",""recordTweet"",""recordTweet"",""recordTweet"",""getTweetCountsPerFrequency"",""getTweetCountsPerFrequency"",""recordTweet"",""getTweetCountsPerFrequency""] [[],[""tweet3"",0],[""tweet3"",60],[""tweet3"",10],[""minute"",""tweet3"",0,59],[""minute"",""tweet3"",0,60],[""tweet3"",120],[""hour"",""tweet3"",0,210]] Output [null,null,null,null,[2],[2,1],null,[4]] Explanation TweetCounts tweetCounts = new TweetCounts(); tweetCounts.recordTweet(""tweet3"", 0);                              // New tweet ""tweet3"" at time 0 tweetCounts.recordTweet(""tweet3"", 60);                             // New tweet ""tweet3"" at time 60 tweetCounts.recordTweet(""tweet3"", 10);                             // New tweet ""tweet3"" at time 10 tweetCounts.getTweetCountsPerFrequency(""minute"", ""tweet3"", 0, 59); // return [2]; chunk [0,59] had 2 tweets tweetCounts.getTweetCountsPerFrequency(""minute"", ""tweet3"", 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet tweetCounts.recordTweet(""tweet3"", 120);                            // New tweet ""tweet3"" at time 120 tweetCounts.getTweetCountsPerFrequency(""hour"", ""tweet3"", 0, 210);  // return [4]; chunk [0,210] had 4 tweets   Constraints: 0 <= time, startTime, endTime <= 10 9 0 <= endTime - startTime <= 10 4 There will be at most  10 4  calls  in total  to  recordTweet  and  getTweetCountsPerFrequency .","['Hash Table', 'Binary Search', 'Design', 'Sorting', 'Ordered Set']",Média,Hash Table,False
1358,number-of-substrings-containing-all-three-characters,https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/,Number of Substrings Containing All Three Characters,"Given a string  s  consisting only of characters  a ,  b  and  c . Return the number of substrings containing  at least  one occurrence of all these characters  a ,  b  and  c .   Example 1: Input:  s = ""abcabc"" Output:  10 Explanation:  The substrings containing at least one occurrence of the characters  a ,  b  and  c are "" abc "", "" abca "", "" abcab "", "" abcabc "", "" bca "", "" bcab "", "" bcabc "", "" cab "", "" cabc ""  and  "" abc ""  ( again ) .  Example 2: Input:  s = ""aaacb"" Output:  3 Explanation:  The substrings containing at least one occurrence of the characters  a ,  b  and  c are "" aaacb "", "" aacb ""  and  "" acb "".   Example 3: Input:  s = ""abc"" Output:  1   Constraints: 3 <= s.length <= 5 x 10^4 s  only consists of  a ,  b  or  c  characters.","['Hash Table', 'String', 'Sliding Window']",Média,Hash Table,False
1461,check-if-a-string-contains-all-binary-codes-of-size-k,https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/,Check If a String Contains All Binary Codes of Size K,"Given a binary string  s  and an integer  k , return  true   if every binary code of length   k   is a substring of   s . Otherwise, return  false .   Example 1: Input:  s = ""00110110"", k = 2 Output:  true Explanation:  The binary codes of length 2 are ""00"", ""01"", ""10"" and ""11"". They can be all found as substrings at indices 0, 1, 3 and 2 respectively. Example 2: Input:  s = ""0110"", k = 1 Output:  true Explanation:  The binary codes of length 1 are ""0"" and ""1"", it is clear that both exist as a substring.  Example 3: Input:  s = ""0110"", k = 2 Output:  false Explanation:  The binary code ""00"" is of length 2 and does not exist in the array.   Constraints: 1 <= s.length <= 5 * 10 5 s[i]  is either  '0'  or  '1' . 1 <= k <= 20","['Hash Table', 'String', 'Bit Manipulation', 'Rolling Hash', 'Hash Function']",Média,Hash Table,False
1525,number-of-good-ways-to-split-a-string,https://leetcode.com/problems/number-of-good-ways-to-split-a-string/,Number of Good Ways to Split a String,"You are given a string  s . A split is called  good  if you can split  s  into two non-empty strings  s left  and  s right  where their concatenation is equal to  s  (i.e.,  s left  + s right  = s ) and the number of distinct letters in  s left  and  s right  is the same. Return  the number of  good splits  you can make in  s .   Example 1: Input:  s = ""aacaba"" Output:  2 Explanation:  There are 5 ways to split  ""aacaba""  and 2 of them are good.  (""a"", ""acaba"") Left string and right string contains 1 and 3 different letters respectively. (""aa"", ""caba"") Left string and right string contains 1 and 3 different letters respectively. (""aac"", ""aba"") Left string and right string contains 2 and 2 different letters respectively (good split). (""aaca"", ""ba"") Left string and right string contains 2 and 2 different letters respectively (good split). (""aacab"", ""a"") Left string and right string contains 3 and 1 different letters respectively. Example 2: Input:  s = ""abcd"" Output:  1 Explanation:  Split the string as follows (""ab"", ""cd"").   Constraints: 1 <= s.length <= 10 5 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Dynamic Programming', 'Bit Manipulation']",Média,Hash Table,False
1915,number-of-wonderful-substrings,https://leetcode.com/problems/number-of-wonderful-substrings/,Number of Wonderful Substrings,"A  wonderful  string is a string where  at most one  letter appears an  odd  number of times. For example,  ""ccjjc""  and  ""abab""  are wonderful, but  ""ab""  is not. Given a string  word  that consists of the first ten lowercase English letters ( 'a'  through  'j' ), return  the  number of wonderful non-empty substrings  in  word . If the same substring appears multiple times in  word , then count  each occurrence  separately. A  substring  is a contiguous sequence of characters in a string.   Example 1: Input:  word = ""aba"" Output:  4 Explanation:  The four wonderful substrings are underlined below: - "" a ba"" -> ""a"" - ""a b a"" -> ""b"" - ""ab a "" -> ""a"" - "" aba "" -> ""aba"" Example 2: Input:  word = ""aabb"" Output:  9 Explanation:  The nine wonderful substrings are underlined below: - "" a abb"" -> ""a"" - "" aa bb"" -> ""aa"" - "" aab b"" -> ""aab"" - "" aabb "" -> ""aabb"" - ""a a bb"" -> ""a"" - ""a abb "" -> ""abb"" - ""aa b b"" -> ""b"" - ""aa bb "" -> ""bb"" - ""aab b "" -> ""b"" Example 3: Input:  word = ""he"" Output:  2 Explanation:  The two wonderful substrings are underlined below: - "" h e"" -> ""h"" - ""h e "" -> ""e""   Constraints: 1 <= word.length <= 10 5 word  consists of lowercase English letters from  'a'  to  'j' .","['Hash Table', 'String', 'Bit Manipulation', 'Prefix Sum']",Média,Hash Table,False
1930,unique-length-3-palindromic-subsequences,https://leetcode.com/problems/unique-length-3-palindromic-subsequences/,Unique Length-3 Palindromic Subsequences,"Given a string  s , return  the number of  unique palindromes of length three  that are a  subsequence  of  s . Note that even if there are multiple ways to obtain the same subsequence, it is still only counted  once . A  palindrome  is a string that reads the same forwards and backwards. A  subsequence  of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example,  ""ace""  is a subsequence of  "" a b c d e "" .   Example 1: Input:  s = ""aabca"" Output:  3 Explanation:  The 3 palindromic subsequences of length 3 are: - ""aba"" (subsequence of "" a a b c a "") - ""aaa"" (subsequence of "" aa bc a "") - ""aca"" (subsequence of "" a ab ca "") Example 2: Input:  s = ""adc"" Output:  0 Explanation:  There are no palindromic subsequences of length 3 in ""adc"". Example 3: Input:  s = ""bbcbaba"" Output:  4 Explanation:  The 4 palindromic subsequences of length 3 are: - ""bbb"" (subsequence of "" bb c b aba"") - ""bcb"" (subsequence of "" b b cb aba"") - ""bab"" (subsequence of "" b bcb ab a"") - ""aba"" (subsequence of ""bbcb aba "")   Constraints: 3 <= s.length <= 10 5 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Bit Manipulation', 'Prefix Sum']",Média,Hash Table,False
2384,largest-palindromic-number,https://leetcode.com/problems/largest-palindromic-number/,Largest Palindromic Number,"You are given a string  num  consisting of digits only. Return  the  largest palindromic  integer (in the form of a string) that can be formed using digits taken from  num . It should not contain  leading zeroes . Notes: You do  not  need to use all the digits of  num , but you must use  at least  one digit. The digits can be reordered.   Example 1: Input:  num = ""444947137"" Output:  ""7449447"" Explanation:   Use the digits ""4449477"" from "" 44494 7 13 7 "" to form the palindromic integer ""7449447"". It can be shown that ""7449447"" is the largest palindromic integer that can be formed. Example 2: Input:  num = ""00009"" Output:  ""9"" Explanation:   It can be shown that ""9"" is the largest palindromic integer that can be formed. Note that the integer returned should not contain leading zeroes.   Constraints: 1 <= num.length <= 10 5 num  consists of digits.","['Hash Table', 'String', 'Greedy', 'Counting']",Média,Hash Table,False
2405,optimal-partition-of-string,https://leetcode.com/problems/optimal-partition-of-string/,Optimal Partition of String,"Given a string  s , partition the string into one or more  substrings  such that the characters in each substring are  unique . That is, no letter appears in a single substring more than  once . Return  the  minimum  number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition.   Example 1: Input:  s = ""abacaba"" Output:  4 Explanation: Two possible partitions are (""a"",""ba"",""cab"",""a"") and (""ab"",""a"",""ca"",""ba""). It can be shown that 4 is the minimum number of substrings needed. Example 2: Input:  s = ""ssssss"" Output:  6 Explanation: The only valid partition is (""s"",""s"",""s"",""s"",""s"",""s"").   Constraints: 1 <= s.length <= 10 5 s  consists of only English lowercase letters.","['Hash Table', 'String', 'Greedy']",Média,Hash Table,False
2981,find-longest-special-substring-that-occurs-thrice-i,https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/,Find Longest Special Substring That Occurs Thrice I,"You are given a string  s  that consists of lowercase English letters. A string is called  special  if it is made up of only a single character. For example, the string  ""abc""  is not special, whereas the strings  ""ddd"" ,  ""zz"" , and  ""f""  are special. Return  the length of the  longest special substring  of  s   which occurs  at least thrice ,  or  -1  if no special substring occurs at least thrice . A  substring  is a contiguous  non-empty  sequence of characters within a string.   Example 1: Input:  s = ""aaaa"" Output:  2 Explanation:  The longest special substring which occurs thrice is ""aa"": substrings "" aa aa"", ""a aa a"", and ""aa aa "". It can be shown that the maximum length achievable is 2. Example 2: Input:  s = ""abcdef"" Output:  -1 Explanation:  There exists no special substring which occurs at least thrice. Hence return -1. Example 3: Input:  s = ""abcaba"" Output:  1 Explanation:  The longest special substring which occurs thrice is ""a"": substrings "" a bcaba"", ""abc a ba"", and ""abcab a "". It can be shown that the maximum length achievable is 1.   Constraints: 3 <= s.length <= 50 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Binary Search', 'Sliding Window', 'Counting']",Média,Hash Table,False
2982,find-longest-special-substring-that-occurs-thrice-ii,https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/,Find Longest Special Substring That Occurs Thrice II,"You are given a string  s  that consists of lowercase English letters. A string is called  special  if it is made up of only a single character. For example, the string  ""abc""  is not special, whereas the strings  ""ddd"" ,  ""zz"" , and  ""f""  are special. Return  the length of the  longest special substring  of  s   which occurs  at least thrice ,  or  -1  if no special substring occurs at least thrice . A  substring  is a contiguous  non-empty  sequence of characters within a string.   Example 1: Input:  s = ""aaaa"" Output:  2 Explanation:  The longest special substring which occurs thrice is ""aa"": substrings "" aa aa"", ""a aa a"", and ""aa aa "". It can be shown that the maximum length achievable is 2. Example 2: Input:  s = ""abcdef"" Output:  -1 Explanation:  There exists no special substring which occurs at least thrice. Hence return -1. Example 3: Input:  s = ""abcaba"" Output:  1 Explanation:  The longest special substring which occurs thrice is ""a"": substrings "" a bcaba"", ""abc a ba"", and ""abcab a "". It can be shown that the maximum length achievable is 1.   Constraints: 3 <= s.length <= 5 * 10 5 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Binary Search', 'Sliding Window', 'Counting']",Média,Hash Table,False
3144,minimum-substring-partition-of-equal-character-frequency,https://leetcode.com/problems/minimum-substring-partition-of-equal-character-frequency/,Minimum Substring Partition of Equal Character Frequency,"Given a string  s , you need to partition it into one or more  balanced   substrings . For example, if  s == ""ababcc""  then  (""abab"", ""c"", ""c"") ,  (""ab"", ""abc"", ""c"") , and  (""ababcc"")  are all valid partitions, but  (""a"",  ""bab"" , ""cc"") ,  ( ""aba"" , ""bc"", ""c"") , and  (""ab"",  ""abcc"" )  are not. The unbalanced substrings are bolded. Return the  minimum  number of substrings that you can partition  s  into. Note:  A  balanced  string is a string where each character in the string occurs the same number of times.   Example 1: Input:   s = ""fabccddg"" Output:   3 Explanation: We can partition the string  s  into 3 substrings in one of the following ways:  (""fab, ""ccdd"", ""g"") , or  (""fabc"", ""cd"", ""dg"") . Example 2: Input:   s = ""abababaccddb"" Output:   2 Explanation: We can partition the string  s  into 2 substrings like so:  (""abab"", ""abaccddb"") .   Constraints: 1 <= s.length <= 1000 s  consists only of English lowercase letters.","['Hash Table', 'String', 'Dynamic Programming', 'Counting']",Média,Hash Table,False
3556,sum-of-largest-prime-substrings,https://leetcode.com/problems/sum-of-largest-prime-substrings/,Sum of Largest Prime Substrings,"Given a string  s , find the sum of the  3 largest unique  prime numbers  that can be formed using any of its   substrings . Return the  sum  of the three largest unique prime numbers that can be formed. If fewer than three exist, return the sum of  all  available primes. If no prime numbers can be formed, return 0. Note:  Each prime number should be counted only  once , even if it appears in  multiple  substrings. Additionally, when converting a substring to an integer, any leading zeros are ignored.   Example 1: Input:   s = ""12234"" Output:   1469 Explanation: The unique prime numbers formed from the substrings of  ""12234""  are 2, 3, 23, 223, and 1223. The 3 largest primes are 1223, 223, and 23. Their sum is 1469. Example 2: Input:   s = ""111"" Output:   11 Explanation: The unique prime number formed from the substrings of  ""111""  is 11. Since there is only one prime number, the sum is 11.   Constraints: 1 <= s.length <= 10 s  consists of only digits.","['Hash Table', 'Math', 'String', 'Sorting', 'Number Theory']",Média,Hash Table,False
23,merge-k-sorted-lists,https://leetcode.com/problems/merge-k-sorted-lists/,Merge k Sorted Lists,"You are given an array of  k  linked-lists  lists , each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.   Example 1: Input:  lists = [[1,4,5],[1,3,4],[2,6]] Output:  [1,1,2,3,4,4,5,6] Explanation:  The linked-lists are: [   1->4->5,   1->3->4,   2->6 ] merging them into one sorted list: 1->1->2->3->4->4->5->6 Example 2: Input:  lists = [] Output:  [] Example 3: Input:  lists = [[]] Output:  []   Constraints: k == lists.length 0 <= k <= 10 4 0 <= lists[i].length <= 500 -10 4  <= lists[i][j] <= 10 4 lists[i]  is sorted in  ascending order . The sum of  lists[i].length  will not exceed  10 4 .","['Linked List', 'Divide and Conquer', 'Heap (Priority Queue)', 'Merge Sort']",Difícil,Linked List,False
2296,design-a-text-editor,https://leetcode.com/problems/design-a-text-editor/,Design a Text Editor,"Design a text editor with a cursor that can do the following: Add  text to where the cursor is. Delete  text from where the cursor is (simulating the backspace key). Move  the cursor either left or right. When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that  0 <= cursor.position <= currentText.length  always holds. Implement the  TextEditor  class: TextEditor()  Initializes the object with empty text. void addText(string text)  Appends  text  to where the cursor is. The cursor ends to the right of  text . int deleteText(int k)  Deletes  k  characters to the left of the cursor. Returns the number of characters actually deleted. string cursorLeft(int k)  Moves the cursor to the left  k  times. Returns the last  min(10, len)  characters to the left of the cursor, where  len  is the number of characters to the left of the cursor. string cursorRight(int k)  Moves the cursor to the right  k  times. Returns the last  min(10, len)  characters to the left of the cursor, where  len  is the number of characters to the left of the cursor.   Example 1: Input [""TextEditor"", ""addText"", ""deleteText"", ""addText"", ""cursorRight"", ""cursorLeft"", ""deleteText"", ""cursorLeft"", ""cursorRight""] [[], [""leetcode""], [4], [""practice""], [3], [8], [10], [2], [6]] Output [null, null, 4, null, ""etpractice"", ""leet"", 4, """", ""practi""] Explanation TextEditor textEditor = new TextEditor(); // The current text is ""|"". (The '|' character represents the cursor) textEditor.addText(""leetcode""); // The current text is ""leetcode|"". textEditor.deleteText(4); // return 4                           // The current text is ""leet|"".                            // 4 characters were deleted. textEditor.addText(""practice""); // The current text is ""leetpractice|"".  textEditor.cursorRight(3); // return ""etpractice""                            // The current text is ""leetpractice|"".                             // The cursor cannot be moved beyond the actual text and thus did not move.                            // ""etpractice"" is the last 10 characters to the left of the cursor. textEditor.cursorLeft(8); // return ""leet""                           // The current text is ""leet|practice"".                           // ""leet"" is the last min(10, 4) = 4 characters to the left of the cursor. textEditor.deleteText(10); // return 4                            // The current text is ""|practice"".                            // Only 4 characters were deleted. textEditor.cursorLeft(2); // return """"                           // The current text is ""|practice"".                           // The cursor cannot be moved beyond the actual text and thus did not move.                            // """" is the last min(10, 0) = 0 characters to the left of the cursor. textEditor.cursorRight(6); // return ""practi""                            // The current text is ""practi|ce"".                            // ""practi"" is the last min(10, 6) = 6 characters to the left of the cursor.   Constraints: 1 <= text.length, k <= 40 text  consists of lowercase English letters. At most  2 * 10 4  calls  in total  will be made to  addText ,  deleteText ,  cursorLeft  and  cursorRight .   Follow-up:  Could you find a solution with time complexity of  O(k)  per call?","['Linked List', 'String', 'Stack', 'Design', 'Simulation', 'Doubly-Linked List']",Difícil,Linked List,False
707,design-linked-list,https://leetcode.com/problems/design-linked-list/,Design Linked List,"Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes:  val  and  next .  val  is the value of the current node, and  next  is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute  prev  to indicate the previous node in the linked list. Assume all nodes in the linked list are  0-indexed . Implement the  MyLinkedList  class: MyLinkedList()  Initializes the  MyLinkedList  object. int get(int index)  Get the value of the  index th  node in the linked list. If the index is invalid, return  -1 . void addAtHead(int val)  Add a node of value  val  before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val)  Append a node of value  val  as the last element of the linked list. void addAtIndex(int index, int val)  Add a node of value  val  before the  index th  node in the linked list. If  index  equals the length of the linked list, the node will be appended to the end of the linked list. If  index  is greater than the length, the node  will not be inserted . void deleteAtIndex(int index)  Delete the  index th  node in the linked list, if the index is valid.   Example 1: Input [""MyLinkedList"", ""addAtHead"", ""addAtTail"", ""addAtIndex"", ""get"", ""deleteAtIndex"", ""get""] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3] Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3 myLinkedList.get(1);              // return 2 myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3 myLinkedList.get(1);              // return 3   Constraints: 0 <= index, val <= 1000 Please do not use the built-in LinkedList library. At most  2000  calls will be made to  get ,  addAtHead ,  addAtTail ,  addAtIndex  and  deleteAtIndex .","['Linked List', 'Design']",Média,Linked List,False
233,number-of-digit-one,https://leetcode.com/problems/number-of-digit-one/,Number of Digit One,"Given an integer  n , count  the total number of digit  1  appearing in all non-negative integers less than or equal to   n .   Example 1: Input:  n = 13 Output:  6 Example 2: Input:  n = 0 Output:  0   Constraints: 0 <= n <= 10 9","['Math', 'Dynamic Programming', 'Recursion']",Difícil,Math,False
887,super-egg-drop,https://leetcode.com/problems/super-egg-drop/,Super Egg Drop,"You are given  k  identical eggs and you have access to a building with  n  floors labeled from  1  to  n . You know that there exists a floor  f  where  0 <= f <= n  such that any egg dropped at a floor  higher  than  f  will  break , and any egg dropped  at or below  floor  f  will  not break . Each move, you may take an unbroken egg and drop it from any floor  x  (where  1 <= x <= n ). If the egg breaks, you can no longer use it. However, if the egg does not break, you may  reuse  it in future moves. Return  the  minimum number of moves  that you need to determine  with certainty  what the value of  f  is.   Example 1: Input:  k = 1, n = 2 Output:  2 Explanation:  Drop the egg from floor 1. If it breaks, we know that f = 0. Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1. If it does not break, then we know f = 2. Hence, we need at minimum 2 moves to determine with certainty what the value of f is. Example 2: Input:  k = 2, n = 6 Output:  3 Example 3: Input:  k = 3, n = 14 Output:  4   Constraints: 1 <= k <= 100 1 <= n <= 10 4","['Math', 'Binary Search', 'Dynamic Programming']",Difícil,Math,False
920,number-of-music-playlists,https://leetcode.com/problems/number-of-music-playlists/,Number of Music Playlists,"Your music player contains  n  different songs. You want to listen to  goal  songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that: Every song is played  at least once . A song can only be played again only if  k  other songs have been played. Given  n ,  goal , and  k , return  the number of possible playlists that you can create . Since the answer can be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 3, goal = 3, k = 1 Output:  6 Explanation:  There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. Example 2: Input:  n = 2, goal = 3, k = 0 Output:  6 Explanation:  There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2]. Example 3: Input:  n = 2, goal = 3, k = 1 Output:  2 Explanation:  There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].   Constraints: 0 <= k < n <= goal <= 100","['Math', 'Dynamic Programming', 'Combinatorics']",Difícil,Math,False
964,least-operators-to-express-number,https://leetcode.com/problems/least-operators-to-express-number/,Least Operators to Express Number,"Given a single positive integer  x , we will write an expression of the form  x (op1) x (op2) x (op3) x ...  where each operator  op1 ,  op2 , etc. is either addition, subtraction, multiplication, or division ( + ,  - ,  * , or  /) . For example, with  x = 3 , we might write  3 * 3 / 3 + 3 - 3  which is a value of  3 . When writing such an expression, we adhere to the following conventions: The division operator ( / ) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happen before addition and subtraction. It is not allowed to use the unary negation operator ( - ). For example, "" x - x "" is a valid expression as it only uses subtraction, but "" -x + x "" is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given  target . Return the least number of operators used.   Example 1: Input:  x = 3, target = 19 Output:  5 Explanation:  3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations. Example 2: Input:  x = 5, target = 501 Output:  8 Explanation:  5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8 operations. Example 3: Input:  x = 100, target = 100000000 Output:  3 Explanation:  100 * 100 * 100 * 100. The expression contains 3 operations.   Constraints: 2 <= x <= 100 1 <= target <= 2 * 10 8","['Math', 'Dynamic Programming', 'Memoization']",Difícil,Math,False
2851,string-transformation,https://leetcode.com/problems/string-transformation/,String Transformation,"You are given two strings  s  and  t  of equal length  n . You can perform the following operation on the string  s : Remove a  suffix  of  s  of length  l  where  0 < l < n  and append it at the start of  s . 	For example, let  s = 'abcd'  then in one operation you can remove the suffix  'cd'  and append it in front of  s  making  s = 'cdab' . You are also given an integer  k . Return  the number of ways in which  s   can be transformed into  t  in  exactly   k  operations. Since the answer can be large, return it  modulo   10 9  + 7 .   Example 1: Input:  s = ""abcd"", t = ""cdab"", k = 2 Output:  2 Explanation:   First way: In first operation, choose suffix from index = 3, so resulting s = ""dabc"". In second operation, choose suffix from index = 3, so resulting s = ""cdab"". Second way: In first operation, choose suffix from index = 1, so resulting s = ""bcda"". In second operation, choose suffix from index = 1, so resulting s = ""cdab"". Example 2: Input:  s = ""ababab"", t = ""ababab"", k = 1 Output:  2 Explanation:   First way: Choose suffix from index = 2, so resulting s = ""ababab"". Second way: Choose suffix from index = 4, so resulting s = ""ababab"".   Constraints: 2 <= s.length <= 5 * 10 5 1 <= k <= 10 15 s.length == t.length s  and  t  consist of only lowercase English alphabets.","['Math', 'String', 'Dynamic Programming', 'String Matching']",Difícil,Math,False
2999,count-the-number-of-powerful-integers,https://leetcode.com/problems/count-the-number-of-powerful-integers/,Count the Number of Powerful Integers,"You are given three integers  start ,  finish , and  limit . You are also given a  0-indexed  string  s  representing a  positive  integer. A  positive  integer  x  is called  powerful  if it ends with  s  (in other words,  s  is a  suffix  of  x ) and each digit in  x  is at most  limit . Return  the  total  number of powerful integers in the range   [start..finish] . A string  x  is a suffix of a string  y  if and only if  x  is a substring of  y  that starts from some index ( including  0 ) in  y  and extends to the index  y.length - 1 . For example,  25  is a suffix of  5125  whereas  512  is not.   Example 1: Input:  start = 1, finish = 6000, limit = 4, s = ""124"" Output:  5 Explanation:  The powerful integers in the range [1..6000] are 124, 1124, 2124, 3124, and, 4124. All these integers have each digit <= 4, and ""124"" as a suffix. Note that 5124 is not a powerful integer because the first digit is 5 which is greater than 4. It can be shown that there are only 5 powerful integers in this range. Example 2: Input:  start = 15, finish = 215, limit = 6, s = ""10"" Output:  2 Explanation:  The powerful integers in the range [15..215] are 110 and 210. All these integers have each digit <= 6, and ""10"" as a suffix. It can be shown that there are only 2 powerful integers in this range. Example 3: Input:  start = 1000, finish = 2000, limit = 4, s = ""3000"" Output:  0 Explanation:  All integers in the range [1000..2000] are smaller than 3000, hence ""3000"" cannot be a suffix of any integer in this range.   Constraints: 1 <= start <= finish <= 10 15 1 <= limit <= 9 1 <= s.length <= floor(log 10 (finish)) + 1 s  only consists of numeric digits which are at most  limit . s  does not have leading zeros.","['Math', 'String', 'Dynamic Programming']",Difícil,Math,False
3154,find-number-of-ways-to-reach-the-k-th-stair,https://leetcode.com/problems/find-number-of-ways-to-reach-the-k-th-stair/,Find Number of Ways to Reach the K-th Stair,"You are given a  non-negative  integer  k . There exists a staircase with an infinite number of stairs, with the  lowest  stair numbered 0. Alice has an integer  jump , with an initial value of 0. She starts on stair 1 and wants to reach stair  k  using  any  number of  operations . If she is on stair  i , in one  operation  she can: Go down to stair  i - 1 . This operation  cannot  be used consecutively or on stair 0. Go up to stair  i + 2 jump . And then,  jump  becomes  jump + 1 . Return the  total  number of ways Alice can reach stair  k . Note  that it is possible that Alice reaches the stair  k , and performs some operations to reach the stair  k  again.   Example 1: Input:   k = 0 Output:   2 Explanation: The 2 possible ways of reaching stair 0 are: Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 0  stairs to reach stair 1. Using an operation of the first type, she goes down 1 stair to reach stair 0. Example 2: Input:   k = 1 Output:   4 Explanation: The 4 possible ways of reaching stair 1 are: Alice starts at stair 1. Alice is at stair 1. Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 0  stairs to reach stair 1. Alice starts at stair 1. 	 Using an operation of the second type, she goes up 2 0  stairs to reach stair 2. Using an operation of the first type, she goes down 1 stair to reach stair 1. Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 0  stairs to reach stair 1. Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 1  stairs to reach stair 2. Using an operation of the first type, she goes down 1 stair to reach stair 1.   Constraints: 0 <= k <= 10 9","['Math', 'Dynamic Programming', 'Bit Manipulation', 'Memoization', 'Combinatorics']",Difícil,Math,False
3260,find-the-largest-palindrome-divisible-by-k,https://leetcode.com/problems/find-the-largest-palindrome-divisible-by-k/,Find the Largest Palindrome Divisible by K,"You are given two  positive  integers  n  and  k . An integer  x  is called  k-palindromic  if: x  is a  palindrome . x  is divisible by  k . Return the  largest  integer having  n  digits (as a string) that is  k-palindromic . Note  that the integer must  not  have leading zeros.   Example 1: Input:   n = 3, k = 5 Output:   ""595"" Explanation: 595 is the largest k-palindromic integer with 3 digits. Example 2: Input:   n = 1, k = 4 Output:   ""8"" Explanation: 4 and 8 are the only k-palindromic integers with 1 digit. Example 3: Input:   n = 5, k = 6 Output:   ""89898""   Constraints: 1 <= n <= 10 5 1 <= k <= 9","['Math', 'String', 'Dynamic Programming', 'Greedy', 'Number Theory']",Difícil,Math,False
3307,find-the-k-th-character-in-string-game-ii,https://leetcode.com/problems/find-the-k-th-character-in-string-game-ii/,Find the K-th Character in String Game II,"Alice and Bob are playing a game. Initially, Alice has a string  word = ""a"" . You are given a  positive  integer  k . You are also given an integer array  operations , where  operations[i]  represents the  type  of the  i th  operation. Now Bob will ask Alice to perform  all  operations in sequence: If  operations[i] == 0 ,  append  a copy of  word  to itself. If  operations[i] == 1 , generate a new string by  changing  each character in  word  to its  next  character in the English alphabet, and  append  it to the  original   word . For example, performing the operation on  ""c""  generates  ""cd""  and performing the operation on  ""zb""  generates  ""zbac"" . Return the value of the  k th  character in  word  after performing all the operations. Note  that the character  'z'  can be changed to  'a'  in the second type of operation.   Example 1: Input:   k = 5, operations = [0,0,0] Output:   ""a"" Explanation: Initially,  word == ""a"" . Alice performs the three operations as follows: Appends  ""a""  to  ""a"" ,  word  becomes  ""aa"" . Appends  ""aa""  to  ""aa"" ,  word  becomes  ""aaaa"" . Appends  ""aaaa""  to  ""aaaa"" ,  word  becomes  ""aaaaaaaa"" . Example 2: Input:   k = 10, operations = [0,1,0,1] Output:   ""b"" Explanation: Initially,  word == ""a"" . Alice performs the four operations as follows: Appends  ""a""  to  ""a"" ,  word  becomes  ""aa"" . Appends  ""bb""  to  ""aa"" ,  word  becomes  ""aabb"" . Appends  ""aabb""  to  ""aabb"" ,  word  becomes  ""aabbaabb"" . Appends  ""bbccbbcc""  to  ""aabbaabb"" ,  word  becomes  ""aabbaabbbbccbbcc"" .   Constraints: 1 <= k <= 10 14 1 <= operations.length <= 100 operations[i]  is either 0 or 1. The input is generated such that  word  has  at least   k  characters after all operations.","['Math', 'Bit Manipulation', 'Recursion']",Difícil,Math,False
3317,find-the-number-of-possible-ways-for-an-event,https://leetcode.com/problems/find-the-number-of-possible-ways-for-an-event/,Find the Number of Possible Ways for an Event,"You are given three integers  n ,  x , and  y . An event is being held for  n  performers. When a performer arrives, they are  assigned  to one of the  x  stages. All performers assigned to the  same  stage will perform together as a band, though some stages  might  remain  empty . After all performances are completed, the jury will  award  each band a score in the range  [1, y] . Return the  total  number of possible ways the event can take place. Since the answer may be very large, return it  modulo   10 9  + 7 . Note  that two events are considered to have been held  differently  if  either  of the following conditions is satisfied: Any  performer is  assigned  a different stage. Any  band is  awarded  a different score.   Example 1: Input:   n = 1, x = 2, y = 3 Output:   6 Explanation: There are 2 ways to assign a stage to the performer. The jury can award a score of either 1, 2, or 3 to the only band. Example 2: Input:   n = 5, x = 2, y = 1 Output:  32 Explanation: Each performer will be assigned either stage 1 or stage 2. All bands will be awarded a score of 1. Example 3: Input:   n = 3, x = 3, y = 4 Output:  684   Constraints: 1 <= n, x, y <= 1000","['Math', 'Dynamic Programming', 'Combinatorics']",Difícil,Math,False
69,sqrtx,https://leetcode.com/problems/sqrtx/,Sqrt(x),"Given a non-negative integer  x , return  the square root of  x  rounded down to the nearest integer . The returned integer should be  non-negative  as well. You  must not use  any built-in exponent function or operator. For example, do not use  pow(x, 0.5)  in c++ or  x ** 0.5  in python.   Example 1: Input:  x = 4 Output:  2 Explanation:  The square root of 4 is 2, so we return 2. Example 2: Input:  x = 8 Output:  2 Explanation:  The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.   Constraints: 0 <= x <= 2 31  - 1","['Math', 'Binary Search']",Fácil,Math,False
342,power-of-four,https://leetcode.com/problems/power-of-four/,Power of Four,"Given an integer  n , return  true  if it is a power of four. Otherwise, return  false . An integer  n  is a power of four, if there exists an integer  x  such that  n == 4 x .   Example 1: Input:  n = 16 Output:  true Example 2: Input:  n = 5 Output:  false Example 3: Input:  n = 1 Output:  true   Constraints: -2 31  <= n <= 2 31  - 1   Follow up:  Could you solve it without loops/recursion?","['Math', 'Bit Manipulation', 'Recursion']",Fácil,Math,False
415,add-strings,https://leetcode.com/problems/add-strings/,Add Strings,"Given two non-negative integers,  num1  and  num2  represented as string, return  the sum of   num1   and   num2   as a string . You must solve the problem without using any built-in library for handling large integers (such as  BigInteger ). You must also not convert the inputs to integers directly.   Example 1: Input:  num1 = ""11"", num2 = ""123"" Output:  ""134"" Example 2: Input:  num1 = ""456"", num2 = ""77"" Output:  ""533"" Example 3: Input:  num1 = ""0"", num2 = ""0"" Output:  ""0""   Constraints: 1 <= num1.length, num2.length <= 10 4 num1  and  num2  consist of only digits. num1  and  num2  don't have any leading zeros except for the zero itself.","['Math', 'String', 'Simulation']",Fácil,Math,False
509,fibonacci-number,https://leetcode.com/problems/fibonacci-number/,Fibonacci Number,"The  Fibonacci numbers , commonly denoted  F(n)  form a sequence, called the  Fibonacci sequence , such that each number is the sum of the two preceding ones, starting from  0  and  1 . That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1. Given  n , calculate  F(n) .   Example 1: Input:  n = 2 Output:  1 Explanation:  F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input:  n = 3 Output:  2 Explanation:  F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input:  n = 4 Output:  3 Explanation:  F(4) = F(3) + F(2) = 2 + 1 = 3.   Constraints: 0 <= n <= 30","['Math', 'Dynamic Programming', 'Recursion', 'Memoization']",Fácil,Math,False
836,rectangle-overlap,https://leetcode.com/problems/rectangle-overlap/,Rectangle Overlap,"An axis-aligned rectangle is represented as a list  [x1, y1, x2, y2] , where  (x1, y1)  is the coordinate of its bottom-left corner, and  (x2, y2)  is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis. Two rectangles overlap if the area of their intersection is  positive . To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two axis-aligned rectangles  rec1  and  rec2 , return  true  if they overlap, otherwise return  false .   Example 1: Input:  rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output:  true Example 2: Input:  rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output:  false Example 3: Input:  rec1 = [0,0,1,1], rec2 = [2,2,3,3] Output:  false   Constraints: rec1.length == 4 rec2.length == 4 -10 9  <= rec1[i], rec2[i] <= 10 9 rec1  and  rec2  represent a valid rectangle with a non-zero area.","['Math', 'Geometry']",Fácil,Math,False
1071,greatest-common-divisor-of-strings,https://leetcode.com/problems/greatest-common-divisor-of-strings/,Greatest Common Divisor of Strings,"For two strings  s  and  t , we say "" t  divides  s "" if and only if  s = t + t + t + ... + t + t  (i.e.,  t  is concatenated with itself one or more times). Given two strings  str1  and  str2 , return  the largest string  x  such that  x  divides both  str1  and  str2 .   Example 1: Input:  str1 = ""ABCABC"", str2 = ""ABC"" Output:  ""ABC"" Example 2: Input:  str1 = ""ABABAB"", str2 = ""ABAB"" Output:  ""AB"" Example 3: Input:  str1 = ""LEET"", str2 = ""CODE"" Output:  """"   Constraints: 1 <= str1.length, str2.length <= 1000 str1  and  str2  consist of English uppercase letters.","['Math', 'String']",Fácil,Math,False
1952,three-divisors,https://leetcode.com/problems/three-divisors/,Three Divisors,"Given an integer  n , return  true  if  n  has  exactly three positive divisors . Otherwise, return  false . An integer  m  is a  divisor  of  n  if there exists an integer  k  such that  n = k * m .   Example 1: Input:  n = 2 Output:  false Explantion:  2 has only two divisors: 1 and 2. Example 2: Input:  n = 4 Output:  true Explantion:  4 has three divisors: 1, 2, and 4.   Constraints: 1 <= n <= 10 4","['Math', 'Enumeration', 'Number Theory']",Fácil,Math,False
2119,a-number-after-a-double-reversal,https://leetcode.com/problems/a-number-after-a-double-reversal/,A Number After a Double Reversal,"Reversing  an integer means to reverse all its digits. For example, reversing  2021  gives  1202 . Reversing  12300  gives  321  as the  leading zeros are not retained . Given an integer  num ,  reverse   num  to get  reversed1 ,  then reverse   reversed1  to get  reversed2 . Return  true   if   reversed2   equals   num . Otherwise return  false .   Example 1: Input:  num = 526 Output:  true Explanation:  Reverse num to get 625, then reverse 625 to get 526, which equals num. Example 2: Input:  num = 1800 Output:  false Explanation:  Reverse num to get 81, then reverse 81 to get 18, which does not equal num. Example 3: Input:  num = 0 Output:  true Explanation:  Reverse num to get 0, then reverse 0 to get 0, which equals num.   Constraints: 0 <= num <= 10 6",['Math'],Fácil,Math,False
2469,convert-the-temperature,https://leetcode.com/problems/convert-the-temperature/,Convert the Temperature,"You are given a non-negative floating point number rounded to two decimal places  celsius , that denotes the  temperature in Celsius . You should convert Celsius into  Kelvin  and  Fahrenheit  and return it as an array  ans = [kelvin, fahrenheit] . Return  the array  ans .  Answers within  10 -5  of the actual answer will be accepted. Note that: Kelvin = Celsius + 273.15 Fahrenheit = Celsius * 1.80 + 32.00   Example 1: Input:  celsius = 36.50 Output:  [309.65000,97.70000] Explanation:  Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Example 2: Input:  celsius = 122.11 Output:  [395.26000,251.79800] Explanation:  Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.   Constraints: 0 <= celsius <= 1000",['Math'],Fácil,Math,False
2485,find-the-pivot-integer,https://leetcode.com/problems/find-the-pivot-integer/,Find the Pivot Integer,"Given a positive integer  n , find the  pivot integer   x  such that: The sum of all elements between  1  and  x  inclusively equals the sum of all elements between  x  and  n  inclusively. Return  the pivot integer  x . If no such integer exists, return  -1 . It is guaranteed that there will be at most one pivot index for the given input.   Example 1: Input:  n = 8 Output:  6 Explanation:  6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21. Example 2: Input:  n = 1 Output:  1 Explanation:  1 is the pivot integer since: 1 = 1. Example 3: Input:  n = 4 Output:  -1 Explanation:  It can be proved that no such integer exist.   Constraints: 1 <= n <= 1000","['Math', 'Prefix Sum']",Fácil,Math,False
2520,count-the-digits-that-divide-a-number,https://leetcode.com/problems/count-the-digits-that-divide-a-number/,Count the Digits That Divide a Number,"Given an integer  num , return  the number of digits in  num  that divide  num . An integer  val  divides  nums  if  nums % val == 0 .   Example 1: Input:  num = 7 Output:  1 Explanation:  7 divides itself, hence the answer is 1. Example 2: Input:  num = 121 Output:  2 Explanation:  121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2. Example 3: Input:  num = 1248 Output:  4 Explanation:  1248 is divisible by all of its digits, hence the answer is 4.   Constraints: 1 <= num <= 10 9 num  does not contain  0  as one of its digits.",['Math'],Fácil,Math,False
2652,sum-multiples,https://leetcode.com/problems/sum-multiples/,Sum Multiples,"Given a positive integer  n , find the sum of all integers in the range  [1, n]   inclusive  that are divisible by  3 ,  5 , or  7 . Return  an integer denoting the sum of all numbers in the given range satisfying the constraint.   Example 1: Input:  n = 7 Output:  21 Explanation:  Numbers in the range  [1, 7]  that are divisible by  3 ,  5,  or  7  are  3, 5, 6, 7 . The sum of these numbers is  21 . Example 2: Input:  n = 10 Output:  40 Explanation:  Numbers in the range  [1, 10] that are  divisible by  3 ,  5,  or  7  are  3, 5, 6, 7, 9, 10 . The sum of these numbers is 40. Example 3: Input:  n = 9 Output:  30 Explanation:  Numbers in the range  [1, 9]  that are divisible by  3 ,  5 , or  7  are  3, 5, 6, 7, 9 . The sum of these numbers is  30 .   Constraints: 1 <= n <= 10 3",['Math'],Fácil,Math,False
2769,find-the-maximum-achievable-number,https://leetcode.com/problems/find-the-maximum-achievable-number/,Find the Maximum Achievable Number,"Given two integers,  num  and  t . A  number  x   is  achievable  if it can become equal to  num  after applying the following operation  at most   t  times: Increase or decrease  x  by  1 , and  simultaneously  increase or decrease  num  by  1 . Return the  maximum  possible value of  x .   Example 1: Input:   num = 4, t = 1 Output:   6 Explanation: Apply the following operation once to make the maximum achievable number equal to  num : Decrease the maximum achievable number by 1, and increase  num  by 1. Example 2: Input:   num = 3, t = 2 Output:   7 Explanation: Apply the following operation twice to make the maximum achievable number equal to  num : Decrease the maximum achievable number by 1, and increase  num  by 1.   Constraints: 1 <= num, t <= 50",['Math'],Fácil,Math,False
2894,divisible-and-non-divisible-sums-difference,https://leetcode.com/problems/divisible-and-non-divisible-sums-difference/,Divisible and Non-divisible Sums Difference,"You are given positive integers  n  and  m . Define two integers as follows: num1 : The sum of all integers in the range  [1, n]  (both  inclusive ) that are  not divisible  by  m . num2 : The sum of all integers in the range  [1, n]  (both  inclusive ) that are  divisible  by  m . Return  the integer   num1 - num2 .   Example 1: Input:  n = 10, m = 3 Output:  19 Explanation:  In the given example: - Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37. - Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18. We return 37 - 18 = 19 as the answer. Example 2: Input:  n = 5, m = 6 Output:  15 Explanation:  In the given example: - Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15. - Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0. We return 15 - 0 = 15 as the answer. Example 3: Input:  n = 5, m = 1 Output:  -15 Explanation:  In the given example: - Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0. - Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15. We return 0 - 15 = -15 as the answer.   Constraints: 1 <= n, m <= 1000",['Math'],Fácil,Math,False
3536,maximum-product-of-two-digits,https://leetcode.com/problems/maximum-product-of-two-digits/,Maximum Product of Two Digits,"You are given a positive integer  n . Return the  maximum  product of any two digits in  n . Note:  You may use the  same  digit twice if it appears more than once in  n .   Example 1: Input:   n = 31 Output:   3 Explanation: The digits of  n  are  [3, 1] . The possible products of any two digits are:  3 * 1 = 3 . The maximum product is 3. Example 2: Input:   n = 22 Output:   4 Explanation: The digits of  n  are  [2, 2] . The possible products of any two digits are:  2 * 2 = 4 . The maximum product is 4. Example 3: Input:   n = 124 Output:   8 Explanation: The digits of  n  are  [1, 2, 4] . The possible products of any two digits are:  1 * 2 = 2 ,  1 * 4 = 4 ,  2 * 4 = 8 . The maximum product is 8.   Constraints: 10 <= n <= 10 9","['Math', 'Sorting']",Fácil,Math,False
7,reverse-integer,https://leetcode.com/problems/reverse-integer/,Reverse Integer,"Given a signed 32-bit integer  x , return  x  with its digits reversed . If reversing  x  causes the value to go outside the signed 32-bit integer range  [-2 31 , 2 31  - 1] , then return  0 . Assume the environment does not allow you to store 64-bit integers (signed or unsigned).   Example 1: Input:  x = 123 Output:  321 Example 2: Input:  x = -123 Output:  -321 Example 3: Input:  x = 120 Output:  21   Constraints: -2 31  <= x <= 2 31  - 1",['Math'],Média,Math,False
43,multiply-strings,https://leetcode.com/problems/multiply-strings/,Multiply Strings,"Given two non-negative integers  num1  and  num2  represented as strings, return the product of  num1  and  num2 , also represented as a string. Note:  You must not use any built-in BigInteger library or convert the inputs to integer directly.   Example 1: Input:  num1 = ""2"", num2 = ""3"" Output:  ""6"" Example 2: Input:  num1 = ""123"", num2 = ""456"" Output:  ""56088""   Constraints: 1 <= num1.length, num2.length <= 200 num1  and  num2  consist of digits only. Both  num1  and  num2  do not contain any leading zero, except the number  0  itself.","['Math', 'String', 'Simulation']",Média,Math,False
89,gray-code,https://leetcode.com/problems/gray-code/,Gray Code,"An  n-bit gray code sequence  is a sequence of  2 n  integers where: Every integer is in the  inclusive  range  [0, 2 n  - 1] , The first integer is  0 , An integer appears  no more than once  in the sequence, The binary representation of every pair of  adjacent  integers differs by  exactly one bit , and The binary representation of the  first  and  last  integers differs by  exactly one bit . Given an integer  n , return  any valid  n-bit gray code sequence .   Example 1: Input:  n = 2 Output:  [0,1,3,2] Explanation: The binary representation of [0,1,3,2] is [00,01,11,10]. - 0 0  and 0 1  differ by one bit -  0 1 and  1 1 differ by one bit - 1 1  and 1 0  differ by one bit -  1 0 and  0 0 differ by one bit [0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01]. -  0 0 and  1 0 differ by one bit - 1 0  and 1 1  differ by one bit -  1 1 and  0 1 differ by one bit - 0 1  and 0 0  differ by one bit Example 2: Input:  n = 1 Output:  [0,1]   Constraints: 1 <= n <= 16","['Math', 'Backtracking', 'Bit Manipulation']",Média,Math,False
172,factorial-trailing-zeroes,https://leetcode.com/problems/factorial-trailing-zeroes/,Factorial Trailing Zeroes,"Given an integer  n , return  the number of trailing zeroes in  n! . Note that  n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1 .   Example 1: Input:  n = 3 Output:  0 Explanation:  3! = 6, no trailing zero. Example 2: Input:  n = 5 Output:  1 Explanation:  5! = 120, one trailing zero. Example 3: Input:  n = 0 Output:  0   Constraints: 0 <= n <= 10 4   Follow up:  Could you write a solution that works in logarithmic time complexity?",['Math'],Média,Math,False
227,basic-calculator-ii,https://leetcode.com/problems/basic-calculator-ii/,Basic Calculator II,"Given a string  s  which represents an expression,  evaluate this expression and return its value .  The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of  [-2 31 , 2 31  - 1] . Note:  You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as  eval() .   Example 1: Input:  s = ""3+2*2"" Output:  7 Example 2: Input:  s = "" 3/2 "" Output:  1 Example 3: Input:  s = "" 3+5 / 2 "" Output:  5   Constraints: 1 <= s.length <= 3 * 10 5 s  consists of integers and operators  ('+', '-', '*', '/')  separated by some number of spaces. s  represents  a valid expression . All the integers in the expression are non-negative integers in the range  [0, 2 31  - 1] . The answer is  guaranteed  to fit in a  32-bit integer .","['Math', 'String', 'Stack']",Média,Math,False
241,different-ways-to-add-parentheses,https://leetcode.com/problems/different-ways-to-add-parentheses/,Different Ways to Add Parentheses,"Given a string  expression  of numbers and operators, return  all possible results from computing all the different possible ways to group numbers and operators . You may return the answer in  any order . The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed  10 4 .   Example 1: Input:  expression = ""2-1-1"" Output:  [0,2] Explanation: ((2-1)-1) = 0  (2-(1-1)) = 2 Example 2: Input:  expression = ""2*3-4*5"" Output:  [-34,-14,-10,-10,10] Explanation: (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10   Constraints: 1 <= expression.length <= 20 expression  consists of digits and the operator  '+' ,  '-' , and  '*' . All the integer values in the input expression are in the range  [0, 99] . The integer values in the input expression do not have a leading  '-'  or  '+'  denoting the sign.","['Math', 'String', 'Dynamic Programming', 'Recursion', 'Memoization']",Média,Math,False
365,water-and-jug-problem,https://leetcode.com/problems/water-and-jug-problem/,Water and Jug Problem,"You are given two jugs with capacities  x  liters and  y  liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach  target  using the following operations: Fill either jug completely with water. Completely empty either jug. Pour water from one jug into another until the receiving jug is full, or the transferring jug is empty.   Example 1:  Input:     x = 3, y = 5, target = 4  Output:     true  Explanation: Follow these steps to reach a total of 4 liters: Fill the 5-liter jug (0, 5). Pour from the 5-liter jug into the 3-liter jug, leaving 2 liters (3, 2). Empty the 3-liter jug (0, 2). Transfer the 2 liters from the 5-liter jug to the 3-liter jug (2, 0). Fill the 5-liter jug again (2, 5). Pour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves 4 liters in the 5-liter jug (3, 4). Empty the 3-liter jug. Now, you have exactly 4 liters in the 5-liter jug (0, 4). Reference: The  Die Hard  example. Example 2:  Input:     x = 2, y = 6, target = 5  Output:     false  Example 3:  Input:     x = 1, y = 2, target = 3  Output:     true  Explanation:  Fill both jugs. The total amount of water in both jugs is equal to 3 now.   Constraints: 1 <= x, y, target <= 10 3","['Math', 'Depth-First Search', 'Breadth-First Search']",Média,Math,False
400,nth-digit,https://leetcode.com/problems/nth-digit/,Nth Digit,"Given an integer  n , return the  n th  digit of the infinite integer sequence  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] .   Example 1: Input:  n = 3 Output:  3 Example 2: Input:  n = 11 Output:  0 Explanation:  The 11 th  digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.   Constraints: 1 <= n <= 2 31  - 1","['Math', 'Binary Search']",Média,Math,False
464,can-i-win,https://leetcode.com/problems/can-i-win/,Can I Win,"In the ""100 game"" two players take turns adding, to a running total, any integer from  1  to  10 . The player who first causes the running total to  reach or exceed  100 wins. What if we change the game so that players  cannot  re-use integers? For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100. Given two integers  maxChoosableInteger  and  desiredTotal , return  true  if the first player to move can force a win, otherwise, return  false . Assume both players play  optimally .   Example 1: Input:  maxChoosableInteger = 10, desiredTotal = 11 Output:  false Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win. Example 2: Input:  maxChoosableInteger = 10, desiredTotal = 0 Output:  true Example 3: Input:  maxChoosableInteger = 10, desiredTotal = 1 Output:  true   Constraints: 1 <= maxChoosableInteger <= 20 0 <= desiredTotal <= 300","['Math', 'Dynamic Programming', 'Bit Manipulation', 'Memoization', 'Game Theory', 'Bitmask']",Média,Math,False
470,implement-rand10-using-rand7,https://leetcode.com/problems/implement-rand10-using-rand7/,Implement Rand10() Using Rand7(),"Given the  API   rand7()  that generates a uniform random integer in the range  [1, 7] , write a function  rand10()  that generates a uniform random integer in the range  [1, 10] . You can only call the API  rand7() , and you shouldn't call any other API. Please  do not  use a language's built-in random API. Each test case will have one  internal  argument  n , the number of times that your implemented function  rand10()  will be called while testing. Note that this is  not an argument  passed to  rand10() .   Example 1: Input:  n = 1 Output:  [2] Example 2: Input:  n = 2 Output:  [2,8] Example 3: Input:  n = 3 Output:  [3,8,10]   Constraints: 1 <= n <= 10 5   Follow up: What is the  expected value  for the number of calls to  rand7()  function? Could you minimize the number of calls to  rand7() ?","['Math', 'Rejection Sampling', 'Randomized', 'Probability and Statistics']",Média,Math,False
478,generate-random-point-in-a-circle,https://leetcode.com/problems/generate-random-point-in-a-circle/,Generate Random Point in a Circle,"Given the radius and the position of the center of a circle, implement the function  randPoint  which generates a uniform random point inside the circle. Implement the  Solution  class: Solution(double radius, double x_center, double y_center)  initializes the object with the radius of the circle  radius  and the position of the center  (x_center, y_center) . randPoint()  returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array  [x, y] .   Example 1: Input [""Solution"", ""randPoint"", ""randPoint"", ""randPoint""] [[1.0, 0.0, 0.0], [], [], []] Output [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]] Explanation Solution solution = new Solution(1.0, 0.0, 0.0); solution.randPoint(); // return [-0.02493, -0.38077] solution.randPoint(); // return [0.82314, 0.38945] solution.randPoint(); // return [0.36572, 0.17248]   Constraints: 0 < radius <= 10 8 -10 7  <= x_center, y_center <= 10 7 At most  3 * 10 4  calls will be made to  randPoint .","['Math', 'Geometry', 'Rejection Sampling', 'Randomized']",Média,Math,False
640,solve-the-equation,https://leetcode.com/problems/solve-the-equation/,Solve the Equation,"Solve a given equation and return the value of  'x'  in the form of a string  ""x=#value"" . The equation contains only  '+' ,  '-'  operation, the variable  'x'  and its coefficient. You should return  ""No solution""  if there is no solution for the equation, or  ""Infinite solutions""  if there are infinite solutions for the equation. If there is exactly one solution for the equation, we ensure that the value of  'x'  is an integer.   Example 1: Input:  equation = ""x+5-3+x=6+x-2"" Output:  ""x=2"" Example 2: Input:  equation = ""x=x"" Output:  ""Infinite solutions"" Example 3: Input:  equation = ""2x=x"" Output:  ""x=0""   Constraints: 3 <= equation.length <= 1000 equation  has exactly one  '=' . equation  consists of integers with an absolute value in the range  [0, 100]  without any leading zeros, and the variable  'x' . The input is generated that if there is a single solution, it will be an integer.","['Math', 'String', 'Simulation']",Média,Math,False
650,2-keys-keyboard,https://leetcode.com/problems/2-keys-keyboard/,2 Keys Keyboard,"There is only one character  'A'  on the screen of a notepad. You can perform one of two operations on this notepad for each step: Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given an integer  n , return  the minimum number of operations to get the character   'A'   exactly   n   times on the screen .   Example 1: Input:  n = 3 Output:  3 Explanation:  Initially, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Example 2: Input:  n = 1 Output:  0   Constraints: 1 <= n <= 1000","['Math', 'Dynamic Programming']",Média,Math,False
672,bulb-switcher-ii,https://leetcode.com/problems/bulb-switcher-ii/,Bulb Switcher II,"There is a room with  n  bulbs labeled from  1  to  n  that all are turned on initially, and  four buttons  on the wall. Each of the four buttons has a different functionality where: Button 1:  Flips the status of all the bulbs. Button 2:  Flips the status of all the bulbs with even labels (i.e.,  2, 4, ... ). Button 3:  Flips the status of all the bulbs with odd labels (i.e.,  1, 3, ... ). Button 4:  Flips the status of all the bulbs with a label  j = 3k + 1  where  k = 0, 1, 2, ...  (i.e.,  1, 4, 7, 10, ... ). You must make  exactly   presses  button presses in total. For each press, you may pick  any  of the four buttons to press. Given the two integers  n  and  presses , return  the number of  different possible statuses  after performing all  presses  button presses .   Example 1: Input:  n = 1, presses = 1 Output:  2 Explanation:  Status can be: - [off] by pressing button 1 - [on] by pressing button 2 Example 2: Input:  n = 2, presses = 1 Output:  3 Explanation:  Status can be: - [off, off] by pressing button 1 - [on, off] by pressing button 2 - [off, on] by pressing button 3 Example 3: Input:  n = 3, presses = 1 Output:  4 Explanation:  Status can be: - [off, off, off] by pressing button 1 - [off, on, off] by pressing button 2 - [on, off, on] by pressing button 3 - [off, on, on] by pressing button 4   Constraints: 1 <= n <= 1000 0 <= presses <= 1000","['Math', 'Bit Manipulation', 'Depth-First Search', 'Breadth-First Search']",Média,Math,False
754,reach-a-number,https://leetcode.com/problems/reach-a-number/,Reach a Number,"You are standing at position  0  on an infinite number line. There is a destination at position  target . You can make some number of moves  numMoves  so that: On each move, you can either go left or right. During the  i th  move (starting from  i == 1  to  i == numMoves ), you take  i  steps in the chosen direction. Given the integer  target , return  the  minimum  number of moves required (i.e., the minimum  numMoves ) to reach the destination .   Example 1: Input:  target = 2 Output:  3 Explanation: On the 1 st  move, we step from 0 to 1 (1 step). On the 2 nd  move, we step from 1 to -1 (2 steps). On the 3 rd  move, we step from -1 to 2 (3 steps). Example 2: Input:  target = 3 Output:  2 Explanation: On the 1 st  move, we step from 0 to 1 (1 step). On the 2 nd  move, we step from 1 to 3 (2 steps).   Constraints: -10 9  <= target <= 10 9 target != 0","['Math', 'Binary Search']",Média,Math,False
837,new-21-game,https://leetcode.com/problems/new-21-game/,New 21 Game,"Alice plays the following game, loosely based on the card game  ""21"" . Alice starts with  0  points and draws numbers while she has less than  k  points. During each draw, she gains an integer number of points randomly from the range  [1, maxPts] , where  maxPts  is an integer. Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets  k   or more points . Return the probability that Alice has  n  or fewer points. Answers within  10 -5  of the actual answer are considered accepted.   Example 1: Input:  n = 10, k = 1, maxPts = 10 Output:  1.00000 Explanation:  Alice gets a single card, then stops. Example 2: Input:  n = 6, k = 1, maxPts = 10 Output:  0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of 10 possibilities, she is at or below 6 points. Example 3: Input:  n = 21, k = 17, maxPts = 10 Output:  0.73278   Constraints: 0 <= k <= n <= 10 4 1 <= maxPts <= 10 4","['Math', 'Dynamic Programming', 'Sliding Window', 'Probability and Statistics']",Média,Math,False
866,prime-palindrome,https://leetcode.com/problems/prime-palindrome/,Prime Palindrome,"Given an integer n, return  the smallest  prime palindrome  greater than or equal to  n . An integer is  prime  if it has exactly two divisors:  1  and itself. Note that  1  is not a prime number. For example,  2 ,  3 ,  5 ,  7 ,  11 , and  13  are all primes. An integer is a  palindrome  if it reads the same from left to right as it does from right to left. For example,  101  and  12321  are palindromes. The test cases are generated so that the answer always exists and is in the range  [2, 2 * 10 8 ] .   Example 1: Input:  n = 6 Output:  7 Example 2: Input:  n = 8 Output:  11 Example 3: Input:  n = 13 Output:  101   Constraints: 1 <= n <= 10 8","['Math', 'Number Theory']",Média,Math,False
991,broken-calculator,https://leetcode.com/problems/broken-calculator/,Broken Calculator,"There is a broken calculator that has the integer  startValue  on its display initially. In one operation, you can: multiply the number on display by  2 , or subtract  1  from the number on display. Given two integers  startValue  and  target , return  the minimum number of operations needed to display  target  on the calculator .   Example 1: Input:  startValue = 2, target = 3 Output:  2 Explanation:  Use double operation and then decrement operation {2 -> 4 -> 3}. Example 2: Input:  startValue = 5, target = 8 Output:  2 Explanation:  Use decrement and then double {5 -> 4 -> 8}. Example 3: Input:  startValue = 3, target = 10 Output:  3 Explanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.   Constraints: 1 <= startValue, target <= 10 9","['Math', 'Greedy']",Média,Math,False
1006,clumsy-factorial,https://leetcode.com/problems/clumsy-factorial/,Clumsy Factorial,"The  factorial  of a positive integer  n  is the product of all positive integers less than or equal to  n . For example,  factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 . We make a  clumsy factorial  using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply  '*' , divide  '/' , add  '+' , and subtract  '-'  in this order. For example,  clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 . However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right. Additionally, the division that we use is floor division such that  10 * 9 / 8 = 90 / 8 = 11 . Given an integer  n , return  the clumsy factorial of  n .   Example 1: Input:  n = 4 Output:  7 Explanation:  7 = 4 * 3 / 2 + 1 Example 2: Input:  n = 10 Output:  12 Explanation:  12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1   Constraints: 1 <= n <= 10 4","['Math', 'Stack', 'Simulation']",Média,Math,False
1017,convert-to-base-2,https://leetcode.com/problems/convert-to-base-2/,Convert to Base -2,"Given an integer  n , return  a binary string representing its representation in base   -2 . Note  that the returned string should not have leading zeros unless the string is  ""0"" .   Example 1: Input:  n = 2 Output:  ""110"" Explantion:  (-2) 2  + (-2) 1  = 2 Example 2: Input:  n = 3 Output:  ""111"" Explantion:  (-2) 2  + (-2) 1  + (-2) 0  = 3 Example 3: Input:  n = 4 Output:  ""100"" Explantion:  (-2) 2  = 4   Constraints: 0 <= n <= 10 9",['Math'],Média,Math,False
1492,the-kth-factor-of-n,https://leetcode.com/problems/the-kth-factor-of-n/,The kth Factor of n,"You are given two positive integers  n  and  k . A factor of an integer  n  is defined as an integer  i  where  n % i == 0 . Consider a list of all factors of  n  sorted in  ascending order , return  the  k th  factor  in this list or return  -1  if  n  has less than  k  factors.   Example 1: Input:  n = 12, k = 3 Output:  3 Explanation:  Factors list is [1, 2, 3, 4, 6, 12], the 3 rd  factor is 3. Example 2: Input:  n = 7, k = 2 Output:  7 Explanation:  Factors list is [1, 7], the 2 nd  factor is 7. Example 3: Input:  n = 4, k = 4 Output:  -1 Explanation:  Factors list is [1, 2, 4], there is only 3 factors. We should return -1.   Constraints: 1 <= k <= n <= 1000   Follow up: Could you solve this problem in less than O(n) complexity?","['Math', 'Number Theory']",Média,Math,False
1513,number-of-substrings-with-only-1s,https://leetcode.com/problems/number-of-substrings-with-only-1s/,Number of Substrings With Only 1s,"Given a binary string  s , return  the number of substrings with all characters   1 's . Since the answer may be too large, return it modulo  10 9  + 7 .   Example 1: Input:  s = ""0110111"" Output:  9 Explanation:  There are 9 substring in total with only 1's characters. ""1"" -> 5 times. ""11"" -> 3 times. ""111"" -> 1 time. Example 2: Input:  s = ""101"" Output:  2 Explanation:  Substring ""1"" is shown 2 times in s. Example 3: Input:  s = ""111111"" Output:  21 Explanation:  Each substring contains only 1's characters.   Constraints: 1 <= s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['Math', 'String']",Média,Math,False
1802,maximum-value-at-a-given-index-in-a-bounded-array,https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/,Maximum Value at a Given Index in a Bounded Array,"You are given three positive integers:  n ,  index , and  maxSum . You want to construct an array  nums  ( 0-indexed )   that satisfies the following conditions: nums.length == n nums[i]  is a  positive  integer where  0 <= i < n . abs(nums[i] - nums[i+1]) <= 1  where  0 <= i < n-1 . The sum of all the elements of  nums  does not exceed  maxSum . nums[index]  is  maximized . Return  nums[index]  of the constructed array . Note that  abs(x)  equals  x  if  x >= 0 , and  -x  otherwise.   Example 1: Input:  n = 4, index = 2,  maxSum = 6 Output:  2 Explanation:  nums = [1,2, 2 ,1] is one array that satisfies all the conditions. There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2]. Example 2: Input:  n = 6, index = 1,  maxSum = 10 Output:  3   Constraints: 1 <= n <= maxSum <= 10 9 0 <= index < n","['Math', 'Binary Search', 'Greedy']",Média,Math,False
1860,incremental-memory-leak,https://leetcode.com/problems/incremental-memory-leak/,Incremental Memory Leak,"You are given two integers  memory1  and  memory2  representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second. At the  i th  second (starting from 1),  i  bits of memory are allocated to the stick with  more available memory  (or from the first memory stick if both have the same available memory). If neither stick has at least  i  bits of available memory, the program  crashes . Return  an array containing  [crashTime, memory1 crash , memory2 crash ] , where  crashTime  is the time (in seconds) when the program crashed and  memory1 crash  and  memory2 crash  are the available bits of memory in the first and second sticks respectively .   Example 1: Input:  memory1 = 2, memory2 = 2 Output:  [3,1,0] Explanation:  The memory is allocated as follows: - At the 1 st  second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory. - At the 2 nd  second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory. - At the 3 rd  second, the program crashes. The sticks have 1 and 0 bits available respectively. Example 2: Input:  memory1 = 8, memory2 = 11 Output:  [6,0,4] Explanation:  The memory is allocated as follows: - At the 1 st  second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory. - At the 2 nd  second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory. - At the 3 rd  second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory. - At the 4 th  second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory. - At the 5 th  second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory. - At the 6 th  second, the program crashes. The sticks have 0 and 4 bits available respectively.   Constraints: 0 <= memory1, memory2 <= 2 31  - 1","['Math', 'Simulation']",Média,Math,False
2165,smallest-value-of-the-rearranged-number,https://leetcode.com/problems/smallest-value-of-the-rearranged-number/,Smallest Value of the Rearranged Number,"You are given an integer  num.   Rearrange  the digits of  num  such that its value is  minimized  and it does not contain  any  leading zeros. Return  the rearranged number with minimal value . Note that the sign of the number does not change after rearranging the digits.   Example 1: Input:  num = 310 Output:  103 Explanation:  The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310.  The arrangement with the smallest value that does not contain any leading zeros is 103. Example 2: Input:  num = -7605 Output:  -7650 Explanation:  Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567. The arrangement with the smallest value that does not contain any leading zeros is -7650.   Constraints: -10 15  <= num <= 10 15","['Math', 'Sorting']",Média,Math,False
2178,maximum-split-of-positive-even-integers,https://leetcode.com/problems/maximum-split-of-positive-even-integers/,Maximum Split of Positive Even Integers,"You are given an integer  finalSum . Split it into a sum of a  maximum  number of  unique  positive even integers. For example, given  finalSum = 12 , the following splits are  valid  (unique positive even integers summing up to  finalSum ):  (12) ,  (2 + 10) ,  (2 + 4 + 6) , and  (4 + 8) . Among them,  (2 + 4 + 6)  contains the maximum number of integers. Note that  finalSum  cannot be split into  (2 + 2 + 4 + 4)  as all the numbers should be unique. Return  a list of integers that represent a valid split containing a  maximum  number of integers . If no valid split exists for  finalSum , return  an  empty  list . You may return the integers in  any  order.   Example 1: Input:  finalSum = 12 Output:  [2,4,6] Explanation:  The following are valid splits:  (12) ,  (2 + 10) ,  (2 + 4 + 6) , and  (4 + 8) . (2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6]. Note that [2,6,4], [6,2,4], etc. are also accepted. Example 2: Input:  finalSum = 7 Output:  [] Explanation:  There are no valid splits for the given finalSum. Thus, we return an empty array. Example 3: Input:  finalSum = 28 Output:  [6,8,2,12] Explanation:  The following are valid splits:  (2 + 26) ,  (6 + 8 + 2 + 12) , and  (4 + 24) .  (6 + 8 + 2 + 12)  has the maximum number of integers, which is 4. Thus, we return [6,8,2,12]. Note that [10,2,4,12], [6,2,4,16], etc. are also accepted.   Constraints: 1 <= finalSum <= 10 10","['Math', 'Backtracking', 'Greedy']",Média,Math,False
2240,number-of-ways-to-buy-pens-and-pencils,https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/,Number of Ways to Buy Pens and Pencils,"You are given an integer  total  indicating the amount of money you have. You are also given two integers  cost1  and  cost2  indicating the price of a pen and pencil respectively. You can spend  part or all  of your money to buy multiple quantities (or none) of each kind of writing utensil. Return  the  number of distinct ways  you can buy some number of pens and pencils.   Example 1: Input:  total = 20, cost1 = 10, cost2 = 5 Output:  9 Explanation:  The price of a pen is 10 and the price of a pencil is 5. - If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils. - If you buy 1 pen, you can buy 0, 1, or 2 pencils. - If you buy 2 pens, you cannot buy any pencils. The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9. Example 2: Input:  total = 5, cost1 = 10, cost2 = 10 Output:  1 Explanation:  The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.   Constraints: 1 <= total, cost1, cost2 <= 10 6","['Math', 'Enumeration']",Média,Math,False
2507,smallest-value-after-replacing-with-sum-of-prime-factors,https://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/,Smallest Value After Replacing With Sum of Prime Factors,"You are given a positive integer  n . Continuously replace  n  with the sum of its  prime factors . Note that if a prime factor divides  n  multiple times, it should be included in the sum as many times as it divides  n . Return  the smallest value  n  will take on.   Example 1: Input:  n = 15 Output:  5 Explanation:  Initially, n = 15. 15 = 3 * 5, so replace n with 3 + 5 = 8. 8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6. 6 = 2 * 3, so replace n with 2 + 3 = 5. 5 is the smallest value n will take on. Example 2: Input:  n = 3 Output:  3 Explanation:  Initially, n = 3. 3 is the smallest value n will take on.   Constraints: 2 <= n <= 10 5","['Math', 'Simulation', 'Number Theory']",Média,Math,False
3227,vowels-game-in-a-string,https://leetcode.com/problems/vowels-game-in-a-string/,Vowels Game in a String,"Alice and Bob are playing a game on a string. You are given a string  s , Alice and Bob will take turns playing the following game where Alice starts  first : On Alice's turn, she has to remove any  non-empty   substring  from  s  that contains an  odd  number of vowels. On Bob's turn, he has to remove any  non-empty   substring  from  s  that contains an  even  number of vowels. The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play  optimally . Return  true  if Alice wins the game, and  false  otherwise. The English vowels are:  a ,  e ,  i ,  o , and  u .   Example 1: Input:   s = ""leetcoder"" Output:   true Explanation: Alice can win the game as follows: Alice plays first, she can delete the underlined substring in  s = "" leetco der""  which contains 3 vowels. The resulting string is  s = ""der"" . Bob plays second, he can delete the underlined substring in  s = "" d er""  which contains 0 vowels. The resulting string is  s = ""er"" . Alice plays third, she can delete the whole string  s = "" er ""  which contains 1 vowel. Bob plays fourth, since the string is empty, there is no valid play for Bob. So Alice wins the game. Example 2: Input:   s = ""bbcd"" Output:   false Explanation: There is no valid play for Alice in her first turn, so Alice loses the game.   Constraints: 1 <= s.length <= 10 5 s  consists only of lowercase English letters.","['Math', 'String', 'Brainteaser', 'Game Theory']",Média,Math,False
2231,largest-number-after-digit-swaps-by-parity,https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/,Largest Number After Digit Swaps by Parity,"You are given a positive integer  num . You may swap any two digits of  num  that have the same  parity  (i.e. both odd digits or both even digits). Return  the  largest  possible value of  num  after  any  number of swaps.   Example 1: Input:  num = 1234 Output:  3412 Explanation:  Swap the digit 3 with the digit 1, this results in the number 3214. Swap the digit 2 with the digit 4, this results in the number 3412. Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number. Also note that we may not swap the digit 4 with the digit 1 since they are of different parities. Example 2: Input:  num = 65875 Output:  87655 Explanation:  Swap the digit 8 with the digit 6, this results in the number 85675. Swap the first digit 5 with the digit 7, this results in the number 87655. Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.   Constraints: 1 <= num <= 10 9","['Sorting', 'Heap (Priority Queue)']",Fácil,Sorting,False
225,implement-stack-using-queues,https://leetcode.com/problems/implement-stack-using-queues/,Implement Stack using Queues,"Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack ( push ,  top ,  pop , and  empty ). Implement the  MyStack  class: void push(int x)  Pushes element x to the top of the stack. int pop()  Removes the element on the top of the stack and returns it. int top()  Returns the element on the top of the stack. boolean empty()  Returns  true  if the stack is empty,  false  otherwise. Notes: You must use  only  standard operations of a queue, which means that only  push to back ,  peek/pop from front ,  size  and  is empty  operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.   Example 1: Input [""MyStack"", ""push"", ""push"", ""top"", ""pop"", ""empty""] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False   Constraints: 1 <= x <= 9 At most  100  calls will be made to  push ,  pop ,  top , and  empty . All the calls to  pop  and  top  are valid.   Follow-up:  Can you implement the stack using only one queue?","['Stack', 'Design', 'Queue']",Fácil,Stack,False
232,implement-queue-using-stacks,https://leetcode.com/problems/implement-queue-using-stacks/,Implement Queue using Stacks,"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue ( push ,  peek ,  pop , and  empty ). Implement the  MyQueue  class: void push(int x)  Pushes element x to the back of the queue. int pop()  Removes the element from the front of the queue and returns it. int peek()  Returns the element at the front of the queue. boolean empty()  Returns  true  if the queue is empty,  false  otherwise. Notes: You must use  only  standard operations of a stack, which means only  push to top ,  peek/pop from top ,  size , and  is empty  operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.   Example 1: Input [""MyQueue"", ""push"", ""push"", ""peek"", ""pop"", ""empty""] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false   Constraints: 1 <= x <= 9 At most  100  calls will be made to  push ,  pop ,  peek , and  empty . All the calls to  pop  and  peek  are valid.   Follow-up:  Can you implement the queue such that each operation is  amortized   O(1)  time complexity? In other words, performing  n  operations will take overall  O(n)  time even if one of those operations may take longer.","['Stack', 'Design', 'Queue']",Fácil,Stack,False
155,min-stack,https://leetcode.com/problems/min-stack/,Min Stack,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the  MinStack  class: MinStack()  initializes the stack object. void push(int val)  pushes the element  val  onto the stack. void pop()  removes the element on the top of the stack. int top()  gets the top element of the stack. int getMin()  retrieves the minimum element in the stack. You must implement a solution with  O(1)  time complexity for each function.   Example 1: Input [""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top();    // return 0 minStack.getMin(); // return -2   Constraints: -2 31  <= val <= 2 31  - 1 Methods  pop ,  top  and  getMin  operations will always be called on  non-empty  stacks. At most  3 * 10 4  calls will be made to  push ,  pop ,  top , and  getMin .","['Stack', 'Design']",Média,Stack,False
341,flatten-nested-list-iterator,https://leetcode.com/problems/flatten-nested-list-iterator/,Flatten Nested List Iterator,"You are given a nested list of integers  nestedList . Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the  NestedIterator  class: NestedIterator(List<NestedInteger> nestedList)  Initializes the iterator with the nested list  nestedList . int next()  Returns the next integer in the nested list. boolean hasNext()  Returns  true  if there are still some integers in the nested list and  false  otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedList res = [] while iterator.hasNext()     append iterator.next() to the end of res return res If  res  matches the expected flattened list, then your code will be judged as correct.   Example 1: Input:  nestedList = [[1,1],2,[1,1]] Output:  [1,1,2,1,1] Explanation:  By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Input:  nestedList = [1,[4,[6]]] Output:  [1,4,6] Explanation:  By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].   Constraints: 1 <= nestedList.length <= 500 The values of the integers in the nested list is in the range  [-10 6 , 10 6 ] .","['Stack', 'Tree', 'Depth-First Search', 'Design', 'Queue', 'Iterator']",Média,Stack,False
901,online-stock-span,https://leetcode.com/problems/online-stock-span/,Online Stock Span,"Design an algorithm that collects daily price quotes for some stock and returns  the span  of that stock's price for the current day. The  span  of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day. For example, if the prices of the stock in the last four days is  [7,2,1,2]  and the price of the stock today is  2 , then the span of today is  4  because starting from today, the price of the stock was less than or equal  2  for  4  consecutive days. Also, if the prices of the stock in the last four days is  [7,34,1,2]  and the price of the stock today is  8 , then the span of today is  3  because starting from today, the price of the stock was less than or equal  8  for  3  consecutive days. Implement the  StockSpanner  class: StockSpanner()  Initializes the object of the class. int next(int price)  Returns the  span  of the stock's price given that today's price is  price .   Example 1: Input [""StockSpanner"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next""] [[], [100], [80], [60], [70], [60], [75], [85]] Output [null, 1, 1, 1, 2, 1, 4, 6] Explanation StockSpanner stockSpanner = new StockSpanner(); stockSpanner.next(100); // return 1 stockSpanner.next(80);  // return 1 stockSpanner.next(60);  // return 1 stockSpanner.next(70);  // return 2 stockSpanner.next(60);  // return 1 stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. stockSpanner.next(85);  // return 6   Constraints: 1 <= price <= 10 5 At most  10 4  calls will be made to  next .","['Stack', 'Design', 'Monotonic Stack', 'Data Stream']",Média,Stack,False
214,shortest-palindrome,https://leetcode.com/problems/shortest-palindrome/,Shortest Palindrome,"You are given a string  s . You can convert  s  to a  palindrome  by adding characters in front of it. Return  the shortest palindrome you can find by performing this transformation .   Example 1: Input:  s = ""aacecaaa"" Output:  ""aaacecaaa"" Example 2: Input:  s = ""abcd"" Output:  ""dcbabcd""   Constraints: 0 <= s.length <= 5 * 10 4 s  consists of lowercase English letters only.","['String', 'Rolling Hash', 'String Matching', 'Hash Function']",Difícil,String,False
301,remove-invalid-parentheses,https://leetcode.com/problems/remove-invalid-parentheses/,Remove Invalid Parentheses,"Given a string  s  that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return  a list of  unique strings  that are valid with the minimum number of removals . You may return the answer in  any order .   Example 1: Input:  s = ""()())()"" Output:  [""(())()"",""()()()""] Example 2: Input:  s = ""(a)())()"" Output:  [""(a())()"",""(a)()()""] Example 3: Input:  s = "")("" Output:  [""""]   Constraints: 1 <= s.length <= 25 s  consists of lowercase English letters and parentheses  '('  and  ')' . There will be at most  20  parentheses in  s .","['String', 'Backtracking', 'Breadth-First Search']",Difícil,String,False
420,strong-password-checker,https://leetcode.com/problems/strong-password-checker/,Strong Password Checker,"A password is considered strong if the below conditions are all met: It has at least  6  characters and at most  20  characters. It contains at least  one lowercase  letter, at least  one uppercase  letter, and at least  one digit . It does not contain three repeating characters in a row (i.e.,  ""B aaa bb0""  is weak, but  ""B aa b a 0""  is strong). Given a string  password , return  the minimum number of steps required to make  password  strong. if  password  is already strong, return  0 . In one step, you can: Insert one character to  password , Delete one character from  password , or Replace one character of  password  with another character.   Example 1: Input:  password = ""a"" Output:  5 Example 2: Input:  password = ""aA1"" Output:  3 Example 3: Input:  password = ""1337C0d3"" Output:  0   Constraints: 1 <= password.length <= 50 password  consists of letters, digits, dot  '.'  or exclamation mark  '!' .","['String', 'Greedy', 'Heap (Priority Queue)']",Difícil,String,False
466,count-the-repetitions,https://leetcode.com/problems/count-the-repetitions/,Count The Repetitions,"We define  str = [s, n]  as the string  str  which consists of the string  s  concatenated  n  times. For example,  str == [""abc"", 3] ==""abcabcabc"" . We define that string  s1  can be obtained from string  s2  if we can remove some characters from  s2  such that it becomes  s1 . For example,  s1 = ""abc""  can be obtained from  s2 = ""ab dbe c""  based on our definition by removing the bolded underlined characters. You are given two strings  s1  and  s2  and two integers  n1  and  n2 . You have the two strings  str1 = [s1, n1]  and  str2 = [s2, n2] . Return  the maximum integer  m  such that  str = [str2, m]  can be obtained from  str1 .   Example 1: Input:  s1 = ""acb"", n1 = 4, s2 = ""ab"", n2 = 2 Output:  2 Example 2: Input:  s1 = ""acb"", n1 = 1, s2 = ""acb"", n2 = 1 Output:  1   Constraints: 1 <= s1.length, s2.length <= 100 s1  and  s2  consist of lowercase English letters. 1 <= n1, n2 <= 10 6","['String', 'Dynamic Programming']",Difícil,String,False
664,strange-printer,https://leetcode.com/problems/strange-printer/,Strange Printer,"There is a strange printer with the following two special properties: The printer can only print a sequence of  the same character  each time. At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters. Given a string  s , return  the minimum number of turns the printer needed to print it .   Example 1: Input:  s = ""aaabbb"" Output:  2 Explanation:  Print ""aaa"" first and then print ""bbb"". Example 2: Input:  s = ""aba"" Output:  2 Explanation:  Print ""aaa"" first and then print ""b"" from the second place of the string, which will cover the existing character 'a'.   Constraints: 1 <= s.length <= 100 s  consists of lowercase English letters.","['String', 'Dynamic Programming']",Difícil,String,False
1397,find-all-good-strings,https://leetcode.com/problems/find-all-good-strings/,Find All Good Strings,"Given the strings  s1  and  s2  of size  n  and the string  evil , return  the number of  good  strings . A  good  string has size  n , it is alphabetically greater than or equal to  s1 , it is alphabetically smaller than or equal to  s2 , and it does not contain the string  evil  as a substring. Since the answer can be a huge number, return this  modulo   10 9  + 7 .   Example 1: Input:  n = 2, s1 = ""aa"", s2 = ""da"", evil = ""b"" Output:  51  Explanation:  There are 25 good strings starting with 'a': ""aa"",""ac"",""ad"",...,""az"". Then there are 25 good strings starting with 'c': ""ca"",""cc"",""cd"",...,""cz"" and finally there is one good string starting with 'd': ""da"".  Example 2: Input:  n = 8, s1 = ""leetcode"", s2 = ""leetgoes"", evil = ""leet"" Output:  0  Explanation:  All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix ""leet"", therefore, there is not any good string. Example 3: Input:  n = 2, s1 = ""gx"", s2 = ""gz"", evil = ""x"" Output:  2   Constraints: s1.length == n s2.length == n s1 <= s2 1 <= n <= 500 1 <= evil.length <= 50 All strings consist of lowercase English letters.","['String', 'Dynamic Programming', 'String Matching']",Difícil,String,False
1960,maximum-product-of-the-length-of-two-palindromic-substrings,https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/,Maximum Product of the Length of Two Palindromic Substrings,"You are given a  0-indexed  string  s  and are tasked with finding two  non-intersecting palindromic  substrings of  odd  length such that the product of their lengths is maximized. More formally, you want to choose four integers  i ,  j ,  k ,  l  such that  0 <= i <= j < k <= l < s.length  and both the substrings  s[i...j]  and  s[k...l]  are palindromes and have odd lengths.  s[i...j]  denotes a substring from index  i  to index  j   inclusive . Return  the  maximum  possible product of the lengths of the two non-intersecting palindromic substrings. A  palindrome  is a string that is the same forward and backward. A  substring  is a contiguous sequence of characters in a string.   Example 1: Input:  s = ""ababbb"" Output:  9 Explanation:  Substrings ""aba"" and ""bbb"" are palindromes with odd length. product = 3 * 3 = 9. Example 2: Input:  s = ""zaaaxbbby"" Output:  9 Explanation:  Substrings ""aaa"" and ""bbb"" are palindromes with odd length. product = 3 * 3 = 9.   Constraints: 2 <= s.length <= 10 5 s  consists of lowercase English letters.","['String', 'Rolling Hash', 'Hash Function']",Difícil,String,False
3031,minimum-time-to-revert-word-to-initial-state-ii,https://leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-ii/,Minimum Time to Revert Word to Initial State II,"You are given a  0-indexed  string  word  and an integer  k . At every second, you must perform the following operations: Remove the first  k  characters of  word . Add any  k  characters to the end of  word . Note  that you do not necessarily need to add the same characters that you removed. However, you must perform  both  operations at every second. Return  the  minimum  time greater than zero required for   word   to revert to its  initial  state .   Example 1: Input:  word = ""abacaba"", k = 3 Output:  2 Explanation:  At the 1st second, we remove characters ""aba"" from the prefix of word, and add characters ""bac"" to the end of word. Thus, word becomes equal to ""cababac"". At the 2nd second, we remove characters ""cab"" from the prefix of word, and add ""aba"" to the end of word. Thus, word becomes equal to ""abacaba"" and reverts to its initial state. It can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state. Example 2: Input:  word = ""abacaba"", k = 4 Output:  1 Explanation:  At the 1st second, we remove characters ""abac"" from the prefix of word, and add characters ""caba"" to the end of word. Thus, word becomes equal to ""abacaba"" and reverts to its initial state. It can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state. Example 3: Input:  word = ""abcbabcd"", k = 2 Output:  4 Explanation:  At every second, we will remove the first 2 characters of word, and add the same characters to the end of word. After 4 seconds, word becomes equal to ""abcbabcd"" and reverts to its initial state. It can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.   Constraints: 1 <= word.length <= 10 6 1 <= k <= word.length word  consists only of lowercase English letters.","['String', 'Rolling Hash', 'String Matching', 'Hash Function']",Difícil,String,False
3303,find-the-occurrence-of-first-almost-equal-substring,https://leetcode.com/problems/find-the-occurrence-of-first-almost-equal-substring/,Find the Occurrence of First Almost Equal Substring,"You are given two strings  s  and  pattern . A string  x  is called  almost equal  to  y  if you can change  at most  one character in  x  to make it  identical  to  y . Return the  smallest   starting index  of a  substring  in  s  that is  almost equal  to  pattern . If no such index exists, return  -1 . A  substring  is a contiguous  non-empty  sequence of characters within a string.   Example 1: Input:   s = ""abcdefg"", pattern = ""bcdffg"" Output:   1 Explanation: The substring  s[1..6] == ""bcdefg""  can be converted to  ""bcdffg""  by changing  s[4]  to  ""f"" . Example 2: Input:   s = ""ababbababa"", pattern = ""bacaba"" Output:   4 Explanation: The substring  s[4..9] == ""bababa""  can be converted to  ""bacaba""  by changing  s[6]  to  ""c"" . Example 3: Input:   s = ""abcd"", pattern = ""dba"" Output:   -1 Example 4: Input:   s = ""dde"", pattern = ""d"" Output:   0   Constraints: 1 <= pattern.length < s.length <= 10 5 s  and  pattern  consist only of lowercase English letters.   Follow-up:  Could you solve the problem if  at most   k   consecutive  characters can be changed?","['String', 'String Matching']",Difícil,String,False
3320,count-the-number-of-winning-sequences,https://leetcode.com/problems/count-the-number-of-winning-sequences/,Count The Number of Winning Sequences,"Alice and Bob are playing a fantasy battle game consisting of  n  rounds where they summon one of three magical creatures each round: a Fire Dragon, a Water Serpent, or an Earth Golem. In each round, players  simultaneously  summon their creature and are awarded points as follows: If one player summons a Fire Dragon and the other summons an Earth Golem, the player who summoned the  Fire Dragon  is awarded a point. If one player summons a Water Serpent and the other summons a Fire Dragon, the player who summoned the  Water Serpent  is awarded a point. If one player summons an Earth Golem and the other summons a Water Serpent, the player who summoned the  Earth Golem  is awarded a point. If both players summon the same creature, no player is awarded a point. You are given a string  s  consisting of  n  characters  'F' ,  'W' , and  'E' , representing the sequence of creatures Alice will summon in each round: If  s[i] == 'F' , Alice summons a Fire Dragon. If  s[i] == 'W' , Alice summons a Water Serpent. If  s[i] == 'E' , Alice summons an Earth Golem. Bob’s sequence of moves is unknown, but it is guaranteed that Bob will never summon the same creature in two consecutive rounds. Bob  beats  Alice if the total number of points awarded to Bob after  n  rounds is  strictly greater  than the points awarded to Alice. Return the number of distinct sequences Bob can use to beat Alice. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:   s = ""FFF"" Output:   3 Explanation: Bob can beat Alice by making one of the following sequences of moves:  ""WFW"" ,  ""FWF"" , or  ""WEW"" . Note that other winning sequences like  ""WWE""  or  ""EWW""  are invalid since Bob cannot make the same move twice in a row. Example 2: Input:   s = ""FWEFW"" Output:   18 Explanation: Bob can beat Alice by making one of the following sequences of moves:  ""FWFWF"" ,  ""FWFWE"" ,  ""FWEFE"" ,  ""FWEWE"" ,  ""FEFWF"" ,  ""FEFWE"" ,  ""FEFEW"" ,  ""FEWFE"" ,  ""WFEFE"" ,  ""WFEWE"" ,  ""WEFWF"" ,  ""WEFWE"" ,  ""WEFEF"" ,  ""WEFEW"" ,  ""WEWFW"" ,  ""WEWFE"" ,  ""EWFWE"" , or  ""EWEWE"" .   Constraints: 1 <= s.length <= 1000 s[i]  is one of  'F' ,  'W' , or  'E' .","['String', 'Dynamic Programming']",Difícil,String,False
14,longest-common-prefix,https://leetcode.com/problems/longest-common-prefix/,Longest Common Prefix,"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string  """" .   Example 1: Input:  strs = [""flower"",""flow"",""flight""] Output:  ""fl"" Example 2: Input:  strs = [""dog"",""racecar"",""car""] Output:  """" Explanation:  There is no common prefix among the input strings.   Constraints: 1 <= strs.length <= 200 0 <= strs[i].length <= 200 strs[i]  consists of only lowercase English letters if it is non-empty.","['String', 'Trie']",Fácil,String,False
58,length-of-last-word,https://leetcode.com/problems/length-of-last-word/,Length of Last Word,"Given a string  s  consisting of words and spaces, return  the length of the  last  word in the string. A  word  is a maximal  substring  consisting of non-space characters only.   Example 1: Input:  s = ""Hello World"" Output:  5 Explanation:  The last word is ""World"" with length 5. Example 2: Input:  s = ""   fly me   to   the moon  "" Output:  4 Explanation:  The last word is ""moon"" with length 4. Example 3: Input:  s = ""luffy is still joyboy"" Output:  6 Explanation:  The last word is ""joyboy"" with length 6.   Constraints: 1 <= s.length <= 10 4 s  consists of only English letters and spaces  ' ' . There will be at least one word in  s .",['String'],Fácil,String,False
459,repeated-substring-pattern,https://leetcode.com/problems/repeated-substring-pattern/,Repeated Substring Pattern,"Given a string  s , check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.   Example 1: Input:  s = ""abab"" Output:  true Explanation:  It is the substring ""ab"" twice. Example 2: Input:  s = ""aba"" Output:  false Example 3: Input:  s = ""abcabcabcabc"" Output:  true Explanation:  It is the substring ""abc"" four times or the substring ""abcabc"" twice.   Constraints: 1 <= s.length <= 10 4 s  consists of lowercase English letters.","['String', 'String Matching']",Fácil,String,False
482,license-key-formatting,https://leetcode.com/problems/license-key-formatting/,License Key Formatting,"You are given a license key represented as a string  s  that consists of only alphanumeric characters and dashes. The string is separated into  n + 1  groups by  n  dashes. You are also given an integer  k . We want to reformat the string  s  such that each group contains exactly  k  characters, except for the first group, which could be shorter than  k  but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return  the reformatted license key .   Example 1: Input:  s = ""5F3Z-2e-9-w"", k = 4 Output:  ""5F3Z-2E9W"" Explanation:  The string s has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed. Example 2: Input:  s = ""2-5g-3-J"", k = 2 Output:  ""2-5G-3J"" Explanation:  The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Constraints: 1 <= s.length <= 10 5 s  consists of English letters, digits, and dashes  '-' . 1 <= k <= 10 4",['String'],Fácil,String,False
520,detect-capital,https://leetcode.com/problems/detect-capital/,Detect Capital,"We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like  ""USA"" . All letters in this word are not capitals, like  ""leetcode"" . Only the first letter in this word is capital, like  ""Google"" . Given a string  word , return  true  if the usage of capitals in it is right.   Example 1: Input:  word = ""USA"" Output:  true Example 2: Input:  word = ""FlaG"" Output:  false   Constraints: 1 <= word.length <= 100 word  consists of lowercase and uppercase English letters.",['String'],Fácil,String,False
521,longest-uncommon-subsequence-i,https://leetcode.com/problems/longest-uncommon-subsequence-i/,Longest Uncommon Subsequence I,"Given two strings  a  and  b , return  the length of the  longest uncommon subsequence  between  a   and   b .  If no such uncommon subsequence exists, return   -1 . An  uncommon subsequence  between two strings is a string that is a  subsequence  of exactly one of them .   Example 1: Input:  a = ""aba"", b = ""cdc"" Output:  3 Explanation:  One longest uncommon subsequence is ""aba"" because ""aba"" is a subsequence of ""aba"" but not ""cdc"". Note that ""cdc"" is also a longest uncommon subsequence. Example 2: Input:  a = ""aaa"", b = ""bbb"" Output:  3 Explanation:  The longest uncommon subsequences are ""aaa"" and ""bbb"". Example 3: Input:  a = ""aaa"", b = ""aaa"" Output:  -1 Explanation:  Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be  -1 .   Constraints: 1 <= a.length, b.length <= 100 a  and  b  consist of lower-case English letters.",['String'],Fácil,String,False
709,to-lower-case,https://leetcode.com/problems/to-lower-case/,To Lower Case,"Given a string  s , return  the string after replacing every uppercase letter with the same lowercase letter .   Example 1: Input:  s = ""Hello"" Output:  ""hello"" Example 2: Input:  s = ""here"" Output:  ""here"" Example 3: Input:  s = ""LOVELY"" Output:  ""lovely""   Constraints: 1 <= s.length <= 100 s  consists of printable ASCII characters.",['String'],Fácil,String,False
824,goat-latin,https://leetcode.com/problems/goat-latin/,Goat Latin,"You are given a string  sentence  that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to ""Goat Latin"" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel ( 'a' ,  'e' ,  'i' ,  'o' , or  'u' ), append  ""ma""  to the end of the word. 	 For example, the word  ""apple""  becomes  ""applema"" . If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add  ""ma"" . 	 For example, the word  ""goat""  becomes  ""oatgma"" . Add one letter  'a'  to the end of each word per its word index in the sentence, starting with  1 . 	 For example, the first word gets  ""a""  added to the end, the second word gets  ""aa""  added to the end, and so on. Return  the final sentence representing the conversion from sentence to Goat Latin .   Example 1: Input:  sentence = ""I speak Goat Latin"" Output:  ""Imaa peaksmaaa oatGmaaaa atinLmaaaaa"" Example 2: Input:  sentence = ""The quick brown fox jumped over the lazy dog"" Output:  ""heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa""   Constraints: 1 <= sentence.length <= 150 sentence  consists of English letters and spaces. sentence  has no leading or trailing spaces. All the words in  sentence  are separated by a single space.",['String'],Fácil,String,False
1078,occurrences-after-bigram,https://leetcode.com/problems/occurrences-after-bigram/,Occurrences After Bigram,"Given two strings  first  and  second , consider occurrences in some text of the form  ""first second third"" , where  second  comes immediately after  first , and  third  comes immediately after  second . Return  an array of all the words   third   for each occurrence of   ""first second third"" .   Example 1: Input:  text = ""alice is a good girl she is a good student"", first = ""a"", second = ""good"" Output:  [""girl"",""student""] Example 2: Input:  text = ""we will we will rock you"", first = ""we"", second = ""will"" Output:  [""we"",""rock""]   Constraints: 1 <= text.length <= 1000 text  consists of lowercase English letters and spaces. All the words in  text  are separated by  a single space . 1 <= first.length, second.length <= 10 first  and  second  consist of lowercase English letters. text  will not have any leading or trailing spaces.",['String'],Fácil,String,False
1417,reformat-the-string,https://leetcode.com/problems/reformat-the-string/,Reformat The String,"You are given an alphanumeric string  s . ( Alphanumeric string  is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return  the reformatted string  or return  an empty string  if it is impossible to reformat the string.   Example 1: Input:  s = ""a0b1c2"" Output:  ""0a1b2c"" Explanation:  No two adjacent characters have the same type in ""0a1b2c"". ""a0b1c2"", ""0a1b2c"", ""0c2a1b"" are also valid permutations. Example 2: Input:  s = ""leetcode"" Output:  """" Explanation:  ""leetcode"" has only characters so we cannot separate them by digits. Example 3: Input:  s = ""1229857369"" Output:  """" Explanation:  ""1229857369"" has only digits so we cannot separate them by characters.   Constraints: 1 <= s.length <= 500 s  consists of only lowercase English letters and/or digits.",['String'],Fácil,String,False
1678,goal-parser-interpretation,https://leetcode.com/problems/goal-parser-interpretation/,Goal Parser Interpretation,"You own a  Goal Parser  that can interpret a string  command . The  command  consists of an alphabet of  ""G"" ,  ""()""  and/or  ""(al)""  in some order. The Goal Parser will interpret  ""G""  as the string  ""G"" ,  ""()""  as the string  ""o"" , and  ""(al)""  as the string  ""al"" . The interpreted strings are then concatenated in the original order. Given the string  command , return  the  Goal Parser 's interpretation of  command .   Example 1: Input:  command = ""G()(al)"" Output:  ""Goal"" Explanation:  The Goal Parser interprets the command as follows: G -> G () -> o (al) -> al The final concatenated result is ""Goal"". Example 2: Input:  command = ""G()()()()(al)"" Output:  ""Gooooal"" Example 3: Input:  command = ""(al)G(al)()()G"" Output:  ""alGalooG""   Constraints: 1 <= command.length <= 100 command  consists of  ""G"" ,  ""()"" , and/or  ""(al)""  in some order.",['String'],Fácil,String,False
2490,circular-sentence,https://leetcode.com/problems/circular-sentence/,Circular Sentence,"A  sentence  is a list of words that are separated by a  single  space with no leading or trailing spaces. For example,  ""Hello World"" ,  ""HELLO"" ,  ""hello world hello world""  are all sentences. Words consist of  only  uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different. A sentence is  circular  if: The last character of each word in the sentence is equal to the first character of its next word. The last character of the last word is equal to the first character of the first word. For example,  ""leetcode exercises sound delightful"" ,  ""eetcode"" ,  ""leetcode eats soul""  are all circular sentences. However,  ""Leetcode is cool"" ,  ""happy Leetcode"" ,  ""Leetcode""  and  ""I like Leetcode""  are  not  circular sentences. Given a string  sentence , return  true  if it is circular . Otherwise, return  false .   Example 1: Input:  sentence = ""leetcode exercises sound delightful"" Output:  true Explanation:  The words in sentence are [""leetcode"", ""exercises"", ""sound"", ""delightful""]. - leetcod e 's last character is equal to  e xercises's first character. - exercise s 's last character is equal to  s ound's first character. - soun d 's last character is equal to  d elightful's first character. - delightfu l 's last character is equal to  l eetcode's first character. The sentence is circular. Example 2: Input:  sentence = ""eetcode"" Output:  true Explanation:  The words in sentence are [""eetcode""]. - eetcod e 's last character is equal to  e etcode's first character. The sentence is circular. Example 3: Input:  sentence = ""Leetcode is cool"" Output:  false Explanation:  The words in sentence are [""Leetcode"", ""is"", ""cool""]. - Leetcod e 's last character is  not  equal to  i s's first character. The sentence is  not  circular.   Constraints: 1 <= sentence.length <= 500 sentence  consist of only lowercase and uppercase English letters and spaces. The words in  sentence  are separated by a single space. There are no leading or trailing spaces.",['String'],Fácil,String,False
2609,find-the-longest-balanced-substring-of-a-binary-string,https://leetcode.com/problems/find-the-longest-balanced-substring-of-a-binary-string/,Find the Longest Balanced Substring of a Binary String,"You are given a binary string  s  consisting only of zeroes and ones. A substring of  s  is considered balanced if  all zeroes are before ones  and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring. Return  the length of the longest balanced substring of  s . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""01000111"" Output:  6 Explanation:  The longest balanced substring is ""000111"", which has length 6. Example 2: Input:  s = ""00111"" Output:  4 Explanation:  The longest balanced substring is ""0011"", which has length 4.  Example 3: Input:  s = ""111"" Output:  0 Explanation:  There is no balanced substring except the empty substring, so the answer is 0.   Constraints: 1 <= s.length <= 50 '0' <= s[i] <= '1'",['String'],Fácil,String,False
2833,furthest-point-from-origin,https://leetcode.com/problems/furthest-point-from-origin/,Furthest Point From Origin,"You are given a string  moves  of length  n  consisting only of characters  'L' ,  'R' , and  '_' . The string represents your movement on a number line starting from the origin  0 . In the  i th  move, you can choose one of the following directions: move to the left if  moves[i] = 'L'  or  moves[i] = '_' move to the right if  moves[i] = 'R'  or  moves[i] = '_' Return  the  distance from the origin  of the  furthest  point you can get to after  n  moves .   Example 1: Input:  moves = ""L_RL__R"" Output:  3 Explanation:  The furthest point we can reach from the origin 0 is point -3 through the following sequence of moves ""LLRLLLR"". Example 2: Input:  moves = ""_R__LL_"" Output:  5 Explanation:  The furthest point we can reach from the origin 0 is point -5 through the following sequence of moves ""LRLLLLL"". Example 3: Input:  moves = ""_______"" Output:  7 Explanation:  The furthest point we can reach from the origin 0 is point 7 through the following sequence of moves ""RRRRRRR"".   Constraints: 1 <= moves.length == n <= 50 moves  consists only of characters  'L' ,  'R'  and  '_' .","['String', 'Counting']",Fácil,String,False
3456,find-special-substring-of-length-k,https://leetcode.com/problems/find-special-substring-of-length-k/,Find Special Substring of Length K,"You are given a string  s  and an integer  k . Determine if there exists a  substring  of length  exactly   k  in  s  that satisfies the following conditions: The substring consists of  only one distinct character  (e.g.,  ""aaa""  or  ""bbb"" ). If there is a character  immediately before  the substring, it must be different from the character in the substring. If there is a character  immediately after  the substring, it must also be different from the character in the substring. Return  true  if such a substring exists. Otherwise, return  false .   Example 1: Input:   s = ""aaabaaa"", k = 3 Output:   true Explanation: The substring  s[4..6] == ""aaa""  satisfies the conditions. It has a length of 3. All characters are the same. The character before  ""aaa""  is  'b' , which is different from  'a' . There is no character after  ""aaa"" . Example 2: Input:   s = ""abc"", k = 2 Output:   false Explanation: There is no substring of length 2 that consists of one distinct character and satisfies the conditions.   Constraints: 1 <= k <= s.length <= 100 s  consists of lowercase English letters only.",['String'],Fácil,String,False
449,serialize-and-deserialize-bst,https://leetcode.com/problems/serialize-and-deserialize-bst/,Serialize and Deserialize BST,"Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a  binary search tree . There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible.   Example 1: Input:  root = [2,1,3] Output:  [2,1,3] Example 2: Input:  root = [] Output:  []   Constraints: The number of nodes in the tree is in the range  [0, 10 4 ] . 0 <= Node.val <= 10 4 The input tree is  guaranteed  to be a binary search tree.","['String', 'Tree', 'Depth-First Search', 'Breadth-First Search', 'Design', 'Binary Search Tree', 'Binary Tree']",Média,String,False
686,repeated-string-match,https://leetcode.com/problems/repeated-string-match/,Repeated String Match,"Given two strings  a  and  b , return  the minimum number of times you should repeat string  a  so that string   b   is a substring of it . If it is impossible for  b ​​​​​​ to be a substring of  a  after repeating it, return  -1 . Notice:  string  ""abc""  repeated 0 times is  """" , repeated 1 time is  ""abc""  and repeated 2 times is  ""abcabc"" .   Example 1: Input:  a = ""abcd"", b = ""cdabcdab"" Output:  3 Explanation:  We return 3 because by repeating a three times ""ab cdabcdab cd"", b is a substring of it. Example 2: Input:  a = ""a"", b = ""aa"" Output:  2   Constraints: 1 <= a.length, b.length <= 10 4 a  and  b  consist of lowercase English letters.","['String', 'String Matching']",Média,String,False
712,minimum-ascii-delete-sum-for-two-strings,https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/,Minimum ASCII Delete Sum for Two Strings,"Given two strings  s1  and  s2 , return  the lowest  ASCII  sum of deleted characters to make two strings equal .   Example 1: Input:  s1 = ""sea"", s2 = ""eat"" Output:  231 Explanation:  Deleting ""s"" from ""sea"" adds the ASCII value of ""s"" (115) to the sum. Deleting ""t"" from ""eat"" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this. Example 2: Input:  s1 = ""delete"", s2 = ""leet"" Output:  403 Explanation:  Deleting ""dee"" from ""delete"" to turn the string into ""let"", adds 100[d] + 101[e] + 101[e] to the sum. Deleting ""e"" from ""leet"" adds 101[e] to the sum. At the end, both strings are equal to ""let"", and the answer is 100+101+101+101 = 403. If instead we turned both strings into ""lee"" or ""eet"", we would get answers of 433 or 417, which are higher.   Constraints: 1 <= s1.length, s2.length <= 1000 s1  and  s2  consist of lowercase English letters.","['String', 'Dynamic Programming']",Média,String,False
842,split-array-into-fibonacci-sequence,https://leetcode.com/problems/split-array-into-fibonacci-sequence/,Split Array into Fibonacci Sequence,"You are given a string of digits  num , such as  ""123456579"" . We can split it into a Fibonacci-like sequence  [123, 456, 579] . Formally, a  Fibonacci-like  sequence is a list  f  of non-negative integers such that: 0 <= f[i] < 2 31 , (that is, each integer fits in a  32-bit  signed integer type), f.length >= 3 , and f[i] + f[i + 1] == f[i + 2]  for all  0 <= i < f.length - 2 . Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number  0  itself. Return any Fibonacci-like sequence split from  num , or return  []  if it cannot be done.   Example 1: Input:  num = ""1101111"" Output:  [11,0,11,11] Explanation:  The output [110, 1, 111] would also be accepted. Example 2: Input:  num = ""112358130"" Output:  [] Explanation:  The task is impossible. Example 3: Input:  num = ""0123"" Output:  [] Explanation:  Leading zeroes are not allowed, so ""01"", ""2"", ""3"" is not valid.   Constraints: 1 <= num.length <= 200 num  contains only digits.","['String', 'Backtracking']",Média,String,False
921,minimum-add-to-make-parentheses-valid,https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/,Minimum Add to Make Parentheses Valid,"A parentheses string is valid if and only if: It is the empty string, It can be written as  AB  ( A  concatenated with  B ), where  A  and  B  are valid strings, or It can be written as  (A) , where  A  is a valid string. You are given a parentheses string  s . In one move, you can insert a parenthesis at any position of the string. For example, if  s = ""()))"" , you can insert an opening parenthesis to be  ""( ( )))""  or a closing parenthesis to be  ""()) ) )"" . Return  the minimum number of moves required to make  s  valid .   Example 1: Input:  s = ""())"" Output:  1 Example 2: Input:  s = ""((("" Output:  3   Constraints: 1 <= s.length <= 1000 s[i]  is either  '('  or  ')' .","['String', 'Stack', 'Greedy']",Média,String,False
926,flip-string-to-monotone-increasing,https://leetcode.com/problems/flip-string-to-monotone-increasing/,Flip String to Monotone Increasing,"A binary string is monotone increasing if it consists of some number of  0 's (possibly none), followed by some number of  1 's (also possibly none). You are given a binary string  s . You can flip  s[i]  changing it from  0  to  1  or from  1  to  0 . Return  the minimum number of flips to make  s  monotone increasing .   Example 1: Input:  s = ""00110"" Output:  1 Explanation:  We flip the last digit to get 00111. Example 2: Input:  s = ""010110"" Output:  2 Explanation:  We flip to get 011111, or alternatively 000111. Example 3: Input:  s = ""00011000"" Output:  2 Explanation:  We flip to get 00000000.   Constraints: 1 <= s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['String', 'Dynamic Programming']",Média,String,False
984,string-without-aaa-or-bbb,https://leetcode.com/problems/string-without-aaa-or-bbb/,String Without AAA or BBB,"Given two integers  a  and  b , return  any  string  s  such that: s  has length  a + b  and contains exactly  a   'a'  letters, and exactly  b   'b'  letters, The substring  'aaa'  does not occur in  s , and The substring  'bbb'  does not occur in  s .   Example 1: Input:  a = 1, b = 2 Output:  ""abb"" Explanation:  ""abb"", ""bab"" and ""bba"" are all correct answers. Example 2: Input:  a = 4, b = 1 Output:  ""aabaa""   Constraints: 0 <= a, b <= 100 It is guaranteed such an  s  exists for the given  a  and  b .","['String', 'Greedy']",Média,String,False
1061,lexicographically-smallest-equivalent-string,https://leetcode.com/problems/lexicographically-smallest-equivalent-string/,Lexicographically Smallest Equivalent String,"You are given two strings of the same length  s1  and  s2  and a string  baseStr . We say  s1[i]  and  s2[i]  are equivalent characters. For example, if  s1 = ""abc""  and  s2 = ""cde"" , then we have  'a' == 'c' ,  'b' == 'd' , and  'c' == 'e' . Equivalent characters follow the usual rules of any equivalence relation: Reflexivity:   'a' == 'a' . Symmetry:   'a' == 'b'  implies  'b' == 'a' . Transitivity:   'a' == 'b'  and  'b' == 'c'  implies  'a' == 'c' . For example, given the equivalency information from  s1 = ""abc""  and  s2 = ""cde"" ,  ""acd""  and  ""aab""  are equivalent strings of  baseStr = ""eed"" , and  ""aab""  is the lexicographically smallest equivalent string of  baseStr . Return  the lexicographically smallest equivalent string of  baseStr  by using the equivalency information from  s1  and  s2 .   Example 1: Input:  s1 = ""parker"", s2 = ""morris"", baseStr = ""parser"" Output:  ""makkek"" Explanation:  Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i]. The characters in each group are equivalent and sorted in lexicographical order. So the answer is ""makkek"". Example 2: Input:  s1 = ""hello"", s2 = ""world"", baseStr = ""hold"" Output:  ""hdld"" Explanation:  Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r]. So only the second letter 'o' in baseStr is changed to 'd', the answer is ""hdld"". Example 3: Input:  s1 = ""leetcode"", s2 = ""programs"", baseStr = ""sourcecode"" Output:  ""aauaaaaada"" Explanation:  We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is ""aauaaaaada"".   Constraints: 1 <= s1.length, s2.length, baseStr <= 1000 s1.length == s2.length s1 ,  s2 , and  baseStr  consist of lowercase English letters.","['String', 'Union Find']",Média,String,False
1081,smallest-subsequence-of-distinct-characters,https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/,Smallest Subsequence of Distinct Characters,"Given a string  s , return  the  lexicographically smallest   subsequence  of   s   that contains all the distinct characters of   s   exactly once .   Example 1: Input:  s = ""bcabc"" Output:  ""abc"" Example 2: Input:  s = ""cbacdcbc"" Output:  ""acdb""   Constraints: 1 <= s.length <= 1000 s  consists of lowercase English letters.   Note:  This question is the same as 316:  https://leetcode.com/problems/remove-duplicate-letters/","['String', 'Stack', 'Greedy', 'Monotonic Stack']",Média,String,False
1111,maximum-nesting-depth-of-two-valid-parentheses-strings,https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/,Maximum Nesting Depth of Two Valid Parentheses Strings,"A string is a  valid parentheses string  (denoted VPS) if and only if it consists of  ""(""  and  "")""  characters only, and: It is the empty string, or It can be written as  AB  ( A  concatenated with  B ), where  A  and  B  are VPS's, or It can be written as  (A) , where  A  is a VPS. We can similarly define the  nesting depth   depth(S)  of any VPS  S  as follows: depth("""") = 0 depth(A + B) = max(depth(A), depth(B)) , where  A  and  B  are VPS's depth(""("" + A + "")"") = 1 + depth(A) , where  A  is a VPS. For example,   """" ,  ""()()"" , and  ""()(()())""  are VPS's (with nesting depths 0, 1, and 2), and  "")(""  and  ""(()""  are not VPS's.   Given a VPS  seq , split it into two disjoint subsequences  A  and  B , such that  A  and  B  are VPS's (and  A.length + B.length = seq.length ). Now choose  any  such  A  and  B  such that  max(depth(A), depth(B))  is the minimum possible value. Return an  answer  array (of length  seq.length ) that encodes such a choice of  A  and  B :   answer[i] = 0  if  seq[i]  is part of  A , else  answer[i] = 1 .  Note that even though multiple answers may exist, you may return any of them.   Example 1: Input:  seq = ""(()())"" Output:  [0,1,1,1,1,0] Example 2: Input:  seq = ""()(())()"" Output:  [0,0,0,1,1,0,1,1]   Constraints: 1 <= seq.size <= 10000","['String', 'Stack']",Média,String,False
1143,longest-common-subsequence,https://leetcode.com/problems/longest-common-subsequence/,Longest Common Subsequence,"Given two strings  text1  and  text2 , return  the length of their longest  common subsequence .  If there is no  common subsequence , return  0 . A  subsequence  of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example,  ""ace""  is a subsequence of  ""abcde"" . A  common subsequence  of two strings is a subsequence that is common to both strings.   Example 1: Input:  text1 = ""abcde"", text2 = ""ace""  Output:  3   Explanation:  The longest common subsequence is ""ace"" and its length is 3. Example 2: Input:  text1 = ""abc"", text2 = ""abc"" Output:  3 Explanation:  The longest common subsequence is ""abc"" and its length is 3. Example 3: Input:  text1 = ""abc"", text2 = ""def"" Output:  0 Explanation:  There is no such common subsequence, so the result is 0.   Constraints: 1 <= text1.length, text2.length <= 1000 text1  and  text2  consist of only lowercase English characters.","['String', 'Dynamic Programming']",Média,String,False
1190,reverse-substrings-between-each-pair-of-parentheses,https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/,Reverse Substrings Between Each Pair of Parentheses,"You are given a string  s  that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should  not  contain any brackets.   Example 1: Input:  s = ""(abcd)"" Output:  ""dcba"" Example 2: Input:  s = ""(u(love)i)"" Output:  ""iloveu"" Explanation:  The substring ""love"" is reversed first, then the whole string is reversed. Example 3: Input:  s = ""(ed(et(oc))el)"" Output:  ""leetcode"" Explanation:  First, we reverse the substring ""oc"", then ""etco"", and finally, the whole string.   Constraints: 1 <= s.length <= 2000 s  only contains lower case English characters and parentheses. It is guaranteed that all parentheses are balanced.","['String', 'Stack']",Média,String,False
1286,iterator-for-combination,https://leetcode.com/problems/iterator-for-combination/,Iterator for Combination,"Design the  CombinationIterator  class: CombinationIterator(string characters, int combinationLength)  Initializes the object with a string  characters  of  sorted distinct  lowercase English letters and a number  combinationLength  as arguments. next()  Returns the next combination of length  combinationLength  in  lexicographical order . hasNext()  Returns  true  if and only if there exists a next combination.   Example 1: Input [""CombinationIterator"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext""] [[""abc"", 2], [], [], [], [], [], []] Output [null, ""ab"", true, ""ac"", true, ""bc"", false] Explanation CombinationIterator itr = new CombinationIterator(""abc"", 2); itr.next();    // return ""ab"" itr.hasNext(); // return True itr.next();    // return ""ac"" itr.hasNext(); // return True itr.next();    // return ""bc"" itr.hasNext(); // return False   Constraints: 1 <= combinationLength <= characters.length <= 15 All the characters of  characters  are  unique . At most  10 4  calls will be made to  next  and  hasNext . It is guaranteed that all calls of the function  next  are valid.","['String', 'Backtracking', 'Design', 'Iterator']",Média,String,False
1328,break-a-palindrome,https://leetcode.com/problems/break-a-palindrome/,Break a Palindrome,"Given a palindromic string of lowercase English letters  palindrome , replace  exactly one  character with any lowercase English letter so that the resulting string is  not  a palindrome and that it is the  lexicographically smallest  one possible. Return  the resulting string. If there is no way to replace a character to make it not a palindrome, return an  empty string . A string  a  is lexicographically smaller than a string  b  (of the same length) if in the first position where  a  and  b  differ,  a  has a character strictly smaller than the corresponding character in  b . For example,  ""abcc""  is lexicographically smaller than  ""abcd""  because the first position they differ is at the fourth character, and  'c'  is smaller than  'd' .   Example 1: Input:  palindrome = ""abccba"" Output:  ""aaccba"" Explanation:  There are many ways to make ""abccba"" not a palindrome, such as "" z bccba"", ""a a ccba"", and ""ab a cba"". Of all the ways, ""aaccba"" is the lexicographically smallest. Example 2: Input:  palindrome = ""a"" Output:  """" Explanation:  There is no way to replace a single character to make ""a"" not a palindrome, so return an empty string.   Constraints: 1 <= palindrome.length <= 1000 palindrome  consists of only lowercase English letters.","['String', 'Greedy']",Média,String,False
1451,rearrange-words-in-a-sentence,https://leetcode.com/problems/rearrange-words-in-a-sentence/,Rearrange Words in a Sentence,"Given a sentence  text  (A  sentence  is a string of space-separated words) in the following format: First letter is in upper case. Each word in  text  are separated by a single space. Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above.   Example 1: Input:  text = ""Leetcode is cool"" Output:  ""Is cool leetcode"" Explanation:  There are 3 words, ""Leetcode"" of length 8, ""is"" of length 2 and ""cool"" of length 4. Output is ordered by length and the new first word starts with capital letter. Example 2: Input:  text = ""Keep calm and code on"" Output:  ""On and keep calm code"" Explanation:  Output is ordered as follows: ""On"" 2 letters. ""and"" 3 letters. ""keep"" 4 letters in case of tie order by position in original text. ""calm"" 4 letters. ""code"" 4 letters. Example 3: Input:  text = ""To be or not to be"" Output:  ""To be or to be not""   Constraints: text  begins with a capital letter and then contains lowercase letters and single space between words. 1 <= text.length <= 10^5","['String', 'Sorting']",Média,String,False
1456,maximum-number-of-vowels-in-a-substring-of-given-length,https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/,Maximum Number of Vowels in a Substring of Given Length,"Given a string  s  and an integer  k , return  the maximum number of vowel letters in any substring of  s  with length  k . Vowel letters  in English are  'a' ,  'e' ,  'i' ,  'o' , and  'u' .   Example 1: Input:  s = ""abciiidef"", k = 3 Output:  3 Explanation:  The substring ""iii"" contains 3 vowel letters. Example 2: Input:  s = ""aeiou"", k = 2 Output:  2 Explanation:  Any substring of length 2 contains 2 vowels. Example 3: Input:  s = ""leetcode"", k = 3 Output:  2 Explanation:  ""lee"", ""eet"" and ""ode"" contain 2 vowels.   Constraints: 1 <= s.length <= 10 5 s  consists of lowercase English letters. 1 <= k <= s.length","['String', 'Sliding Window']",Média,String,False
1541,minimum-insertions-to-balance-a-parentheses-string,https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/,Minimum Insertions to Balance a Parentheses String,"Given a parentheses string  s  containing only the characters  '('  and  ')' . A parentheses string is  balanced  if: Any left parenthesis  '('  must have a corresponding two consecutive right parenthesis  '))' . Left parenthesis  '('  must go before the corresponding two consecutive right parenthesis  '))' . In other words, we treat  '('  as an opening parenthesis and  '))'  as a closing parenthesis. For example,  ""())"" ,  ""())(())))""  and  ""(())())))""  are balanced,  "")()"" ,  ""()))""  and  ""(()))""  are not balanced. You can insert the characters  '('  and  ')'  at any position of the string to balance it if needed. Return  the minimum number of insertions  needed to make  s  balanced.   Example 1: Input:  s = ""(()))"" Output:  1 Explanation:  The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be ""(())))"" which is balanced. Example 2: Input:  s = ""())"" Output:  0 Explanation:  The string is already balanced. Example 3: Input:  s = ""))())("" Output:  3 Explanation:  Add '(' to match the first '))', Add '))' to match the last '('.   Constraints: 1 <= s.length <= 10 5 s  consists of  '('  and  ')'  only.","['String', 'Stack', 'Greedy']",Média,String,False
1689,partitioning-into-minimum-number-of-deci-binary-numbers,https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/,Partitioning Into Minimum Number Of Deci-Binary Numbers,"A decimal number is called  deci-binary  if each of its digits is either  0  or  1  without any leading zeros. For example,  101  and  1100  are  deci-binary , while  112  and  3001  are not. Given a string  n  that represents a positive decimal integer, return  the  minimum  number of positive  deci-binary  numbers needed so that they sum up to  n .   Example 1: Input:  n = ""32"" Output:  3 Explanation:  10 + 11 + 11 = 32 Example 2: Input:  n = ""82734"" Output:  8 Example 3: Input:  n = ""27346209830709182346"" Output:  9   Constraints: 1 <= n.length <= 10 5 n  consists of only digits. n  does not contain any leading zeros and represents a positive integer.","['String', 'Greedy']",Média,String,False
1702,maximum-binary-string-after-change,https://leetcode.com/problems/maximum-binary-string-after-change/,Maximum Binary String After Change,"You are given a binary string  binary  consisting of only  0 's or  1 's. You can apply each of the following operations any number of times: Operation 1: If the number contains the substring  ""00"" , you can replace it with  ""10"" . 	 For example,  "" 00 010"" -> "" 10 010 "" Operation 2: If the number contains the substring  ""10"" , you can replace it with  ""01"" . 	 For example,  ""000 10 "" -> ""000 01 "" Return the  maximum binary string  you can obtain after any number of operations. Binary string  x  is greater than binary string  y  if  x 's decimal representation is greater than  y 's decimal representation.   Example 1: Input:  binary = ""000110"" Output:  ""111011"" Explanation:  A valid transformation sequence can be: ""0001 10 "" -> ""0001 01 ""  "" 00 0101"" -> "" 10 0101""  ""1 00 101"" -> ""1 10 101""  ""110 10 1"" -> ""110 01 1""  ""11 00 11"" -> ""11 10 11"" Example 2: Input:  binary = ""01"" Output:  ""01"" Explanation:  ""01"" cannot be transformed any further.   Constraints: 1 <= binary.length <= 10 5 binary  consist of  '0'  and  '1' .","['String', 'Greedy']",Média,String,False
1910,remove-all-occurrences-of-a-substring,https://leetcode.com/problems/remove-all-occurrences-of-a-substring/,Remove All Occurrences of a Substring,"Given two strings  s  and  part , perform the following operation on  s  until  all  occurrences of the substring  part  are removed: Find the  leftmost  occurrence of the substring  part  and  remove  it from  s . Return  s  after removing all occurrences of  part . A  substring  is a contiguous sequence of characters in a string.   Example 1: Input:  s = ""daabcbaabcbc"", part = ""abc"" Output:  ""dab"" Explanation : The following operations are done: - s = ""da abc baabcbc"", remove ""abc"" starting at index 2, so s = ""dabaabcbc"". - s = ""daba abc bc"", remove ""abc"" starting at index 4, so s = ""dababc"". - s = ""dab abc "", remove ""abc"" starting at index 3, so s = ""dab"". Now s has no occurrences of ""abc"". Example 2: Input:  s = ""axxxxyyyyb"", part = ""xy"" Output:  ""ab"" Explanation : The following operations are done: - s = ""axxx xy yyyb"", remove ""xy"" starting at index 4 so s = ""axxxyyyb"". - s = ""axx xy yyb"", remove ""xy"" starting at index 3 so s = ""axxyyb"". - s = ""ax xy yb"", remove ""xy"" starting at index 2 so s = ""axyb"". - s = ""a xy b"", remove ""xy"" starting at index 1 so s = ""ab"". Now s has no occurrences of ""xy"".   Constraints: 1 <= s.length <= 1000 1 <= part.length <= 1000 s ​​​​​​ and  part  consists of lowercase English letters.","['String', 'Stack', 'Simulation']",Média,String,False
2024,maximize-the-confusion-of-an-exam,https://leetcode.com/problems/maximize-the-confusion-of-an-exam/,Maximize the Confusion of an Exam,"A teacher is writing a test with  n  true/false questions, with  'T'  denoting true and  'F'  denoting false. He wants to confuse the students by  maximizing  the number of  consecutive  questions with the  same  answer (multiple trues or multiple falses in a row). You are given a string  answerKey , where  answerKey[i]  is the original answer to the  i th  question. In addition, you are given an integer  k , the maximum number of times you may perform the following operation: Change the answer key for any question to  'T'  or  'F'  (i.e., set  answerKey[i]  to  'T'  or  'F' ). Return  the  maximum  number of consecutive   'T' s or  'F' s  in the answer key after performing the operation at most   k   times .   Example 1: Input:  answerKey = ""TTFF"", k = 2 Output:  4 Explanation:  We can replace both the 'F's with 'T's to make answerKey = "" TTTT "". There are four consecutive 'T's. Example 2: Input:  answerKey = ""TFFT"", k = 1 Output:  3 Explanation:  We can replace the first 'T' with an 'F' to make answerKey = "" FFF T"". Alternatively, we can replace the second 'T' with an 'F' to make answerKey = ""T FFF "". In both cases, there are three consecutive 'F's. Example 3: Input:  answerKey = ""TTFTTFTT"", k = 1 Output:  5 Explanation:  We can replace the first 'F' to make answerKey = "" TTTTT FTT"" Alternatively, we can replace the second 'F' to make answerKey = ""TTF TTTTT "".  In both cases, there are five consecutive 'T's.   Constraints: n == answerKey.length 1 <= n <= 5 * 10 4 answerKey[i]  is either  'T'  or  'F' 1 <= k <= n","['String', 'Binary Search', 'Sliding Window', 'Prefix Sum']",Média,String,False
2288,apply-discount-to-prices,https://leetcode.com/problems/apply-discount-to-prices/,Apply Discount to Prices,"A  sentence  is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign  '$' . A word represents a  price  if it is a sequence of digits preceded by a dollar sign. For example,  ""$100"" ,  ""$23"" , and  ""$6""  represent prices while  ""100"" ,  ""$"" , and  ""$1e5""  do not. You are given a string  sentence  representing a sentence and an integer  discount . For each word representing a price, apply a discount of  discount%  on the price and  update  the word in the sentence. All updated prices should be represented with  exactly two  decimal places. Return  a string representing the modified sentence . Note that all prices will contain  at most   10  digits.   Example 1: Input:  sentence = ""there are $1 $2 and 5$ candies in the shop"", discount = 50 Output:  ""there are $0.50 $1.00 and 5$ candies in the shop"" Explanation:   The words which represent prices are ""$1"" and ""$2"".  - A 50% discount on ""$1"" yields ""$0.50"", so ""$1"" is replaced by ""$0.50"". - A 50% discount on ""$2"" yields ""$1"". Since we need to have exactly 2 decimal places after a price, we replace ""$2"" with ""$1.00"". Example 2: Input:  sentence = ""1 2 $3 4 $5 $6 7 8$ $9 $10$"", discount = 100 Output:  ""1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$"" Explanation:   Applying a 100% discount on any price will result in 0. The words representing prices are ""$3"", ""$5"", ""$6"", and ""$9"". Each of them is replaced by ""$0.00"".   Constraints: 1 <= sentence.length <= 10 5 sentence  consists of lowercase English letters, digits,  ' ' , and  '$' . sentence  does not have leading or trailing spaces. All words in  sentence  are separated by a single space. All prices will be  positive  numbers without leading zeros. All prices will have  at most   10  digits. 0 <= discount <= 100",['String'],Média,String,False
2311,longest-binary-subsequence-less-than-or-equal-to-k,https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/,Longest Binary Subsequence Less Than or Equal to K,"You are given a binary string  s  and a positive integer  k . Return  the length of the  longest  subsequence of  s  that makes up a  binary  number less than or equal to   k . Note: The subsequence can contain  leading zeroes . The empty string is considered to be equal to  0 . A  subsequence  is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.   Example 1: Input:  s = ""1001010"", k = 5 Output:  5 Explanation:  The longest subsequence of s that makes up a binary number less than or equal to 5 is ""00010"", as this number is equal to 2 in decimal. Note that ""00100"" and ""00101"" are also possible, which are equal to 4 and 5 in decimal, respectively. The length of this subsequence is 5, so 5 is returned. Example 2: Input:  s = ""00101001"", k = 1 Output:  6 Explanation:  ""000001"" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal. The length of this subsequence is 6, so 6 is returned.   Constraints: 1 <= s.length <= 1000 s[i]  is either  '0'  or  '1' . 1 <= k <= 10 9","['String', 'Dynamic Programming', 'Greedy', 'Memoization']",Média,String,False
2483,minimum-penalty-for-a-shop,https://leetcode.com/problems/minimum-penalty-for-a-shop/,Minimum Penalty for a Shop,"You are given the customer visit log of a shop represented by a  0-indexed  string  customers  consisting only of characters  'N'  and  'Y' : if the  i th  character is  'Y' , it means that customers come at the  i th  hour whereas  'N'  indicates that no customers come at the  i th  hour. If the shop closes at the  j th  hour ( 0 <= j <= n ), the  penalty  is calculated as follows: For every hour when the shop is open and no customers come, the penalty increases by  1 . For every hour when the shop is closed and customers come, the penalty increases by  1 . Return  the  earliest  hour at which the shop must be closed to incur a  minimum  penalty. Note  that if a shop closes at the  j th  hour, it means the shop is closed at the hour  j .   Example 1: Input:  customers = ""YYNY"" Output:  2 Explanation:   - Closing the shop at the 0 th  hour incurs in 1+1+0+1 = 3 penalty. - Closing the shop at the 1 st  hour incurs in 0+1+0+1 = 2 penalty. - Closing the shop at the 2 nd  hour incurs in 0+0+0+1 = 1 penalty. - Closing the shop at the 3 rd  hour incurs in 0+0+1+1 = 2 penalty. - Closing the shop at the 4 th  hour incurs in 0+0+1+0 = 1 penalty. Closing the shop at 2 nd  or 4 th  hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2. Example 2: Input:  customers = ""NNNNN"" Output:  0 Explanation:  It is best to close the shop at the 0 th  hour as no customers arrive. Example 3: Input:  customers = ""YYYY"" Output:  4 Explanation:  It is best to close the shop at the 4 th  hour as customers arrive at each hour.   Constraints: 1 <= customers.length <= 10 5 customers  consists only of characters  'Y'  and  'N' .","['String', 'Prefix Sum']",Média,String,False
2522,partition-string-into-substrings-with-values-at-most-k,https://leetcode.com/problems/partition-string-into-substrings-with-values-at-most-k/,Partition String Into Substrings With Values at Most K,"You are given a string  s  consisting of digits from  1  to  9  and an integer  k . A partition of a string  s  is called  good  if: Each digit of  s  is part of  exactly  one substring. The value of each substring is less than or equal to  k . Return  the  minimum  number of substrings in a  good  partition of   s . If no  good  partition of  s  exists, return  -1 . Note  that: The  value  of a string is its result when interpreted as an integer. For example, the value of  ""123""  is  123  and the value of  ""1""  is  1 . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""165462"", k = 60 Output:  4 Explanation:  We can partition the string into substrings ""16"", ""54"", ""6"", and ""2"". Each substring has a value less than or equal to k = 60. It can be shown that we cannot partition the string into less than 4 substrings. Example 2: Input:  s = ""238182"", k = 5 Output:  -1 Explanation:  There is no good partition for this string.   Constraints: 1 <= s.length <= 10 5 s[i]  is a digit from  '1'  to  '9' . 1 <= k <= 10 9","['String', 'Dynamic Programming', 'Greedy']",Média,String,False
2546,apply-bitwise-operations-to-make-strings-equal,https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/,Apply Bitwise Operations to Make Strings Equal,"You are given two  0-indexed binary  strings  s  and  target  of the same length  n . You can do the following operation on  s   any  number of times: Choose two  different  indices  i  and  j  where  0 <= i, j < n . Simultaneously, replace  s[i]  with ( s[i]   OR   s[j] ) and  s[j]  with ( s[i]   XOR   s[j] ). For example, if  s = ""0110"" , you can choose  i = 0  and  j = 2 , then simultaneously replace  s[0]  with ( s[0]   OR   s[2]  =  0   OR   1  =  1 ), and  s[2]  with ( s[0]   XOR   s[2]  =  0   XOR   1  =  1 ), so we will have  s = ""1110"" . Return  true   if you can make the string  s  equal to  target , or  false  otherwise .   Example 1: Input:  s = ""1010"", target = ""0110"" Output:  true Explanation:  We can do the following operations: - Choose i = 2 and j = 0. We have now s = "" 0 0 1 0"". - Choose i = 2 and j = 1. We have now s = ""0 11 0"". Since we can make s equal to target, we return true. Example 2: Input:  s = ""11"", target = ""00"" Output:  false Explanation:  It is not possible to make s equal to target with any number of operations.   Constraints: n == s.length == target.length 2 <= n <= 10 5 s  and  target  consist of only the digits  0  and  1 .","['String', 'Bit Manipulation']",Média,String,False
2645,minimum-additions-to-make-valid-string,https://leetcode.com/problems/minimum-additions-to-make-valid-string/,Minimum Additions to Make Valid String,"Given a string  word  to which you can insert letters ""a"", ""b"" or ""c"" anywhere and any number of times, return  the minimum number of letters that must be inserted so that  word  becomes  valid . A string is called  valid  if it can be formed by concatenating the string ""abc"" several times.   Example 1: Input:  word = ""b"" Output:  2 Explanation:  Insert the letter ""a"" right before ""b"", and the letter ""c"" right next to ""b"" to obtain the valid string "" a b c "". Example 2: Input:  word = ""aaa"" Output:  6 Explanation:  Insert letters ""b"" and ""c"" next to each ""a"" to obtain the valid string ""a bc a bc a bc "". Example 3: Input:  word = ""abc"" Output:  0 Explanation:  word is already valid. No modifications are needed.    Constraints: 1 <= word.length <= 50 word  consists of letters ""a"", ""b"" and ""c"" only.","['String', 'Dynamic Programming', 'Stack', 'Greedy']",Média,String,False
2730,find-the-longest-semi-repetitive-substring,https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/,Find the Longest Semi-Repetitive Substring,"You are given a digit string  s  that consists of digits from 0 to 9. A string is called  semi-repetitive  if there is  at most  one adjacent pair of the same digit. For example,  ""0010"" ,  ""002020"" ,  ""0123"" ,  ""2002"" , and  ""54944""  are semi-repetitive while the following are not:  ""00101022""  (adjacent same digit pairs are 00 and 22), and  ""1101234883""  (adjacent same digit pairs are 11 and 88). Return the length of the  longest semi-repetitive  substring  of  s .   Example 1: Input:   s = ""52233"" Output:   4 Explanation: The longest semi-repetitive substring is ""5223"". Picking the whole string ""52233"" has two adjacent same digit pairs 22 and 33, but at most one is allowed. Example 2: Input:   s = ""5494"" Output:   4 Explanation: s  is a semi-repetitive string. Example 3: Input:   s = ""1111111"" Output:   2 Explanation: The longest semi-repetitive substring is ""11"". Picking the substring ""111"" has two adjacent same digit pairs, but at most one is allowed.   Constraints: 1 <= s.length <= 50 '0' <= s[i] <= '9'","['String', 'Sliding Window']",Média,String,False
3517,smallest-palindromic-rearrangement-i,https://leetcode.com/problems/smallest-palindromic-rearrangement-i/,Smallest Palindromic Rearrangement I,"You are given a  palindromic  string  s . Return the  lexicographically smallest  palindromic  permutation  of  s .   Example 1: Input:   s = ""z"" Output:   ""z"" Explanation: A string of only one character is already the lexicographically smallest palindrome. Example 2: Input:   s = ""babab"" Output:   ""abbba"" Explanation: Rearranging  ""babab""  →  ""abbba""  gives the smallest lexicographic palindrome. Example 3: Input:   s = ""daccad"" Output:   ""acddca"" Explanation: Rearranging  ""daccad""  →  ""acddca""  gives the smallest lexicographic palindrome.   Constraints: 1 <= s.length <= 10 5 s  consists of lowercase English letters. s  is guaranteed to be palindromic.","['String', 'Sorting', 'Counting Sort']",Média,String,False
703,kth-largest-element-in-a-stream,https://leetcode.com/problems/kth-largest-element-in-a-stream/,Kth Largest Element in a Stream,"You are part of a university admissions office and need to keep track of the  kth  highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores. You are tasked to implement a class which, for a given integer  k , maintains a stream of test scores and continuously returns the  k th highest test score  after  a new score has been submitted. More specifically, we are looking for the  k th highest score in the sorted list of all scores. Implement the  KthLargest  class: KthLargest(int k, int[] nums)  Initializes the object with the integer  k  and the stream of test scores  nums . int add(int val)  Adds a new test score  val  to the stream and returns the element representing the  k th  largest element in the pool of test scores so far.   Example 1: Input: [""KthLargest"", ""add"", ""add"", ""add"", ""add"", ""add""] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output:   [null, 4, 5, 5, 8, 8] Explanation: KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 Example 2: Input: [""KthLargest"", ""add"", ""add"", ""add"", ""add""] [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]] Output:   [null, 7, 7, 7, 8] Explanation: KthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]); kthLargest.add(2); // return 7 kthLargest.add(10); // return 7 kthLargest.add(9); // return 7 kthLargest.add(9); // return 8   Constraints: 0 <= nums.length <= 10 4 1 <= k <= nums.length + 1 -10 4  <= nums[i] <= 10 4 -10 4  <= val <= 10 4 At most  10 4  calls will be made to  add .","['Tree', 'Design', 'Binary Search Tree', 'Heap (Priority Queue)', 'Binary Tree', 'Data Stream']",Fácil,Tree,False
440,k-th-smallest-in-lexicographical-order,https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/,K-th Smallest in Lexicographical Order,"Given two integers  n  and  k , return  the   k th   lexicographically smallest integer in the range   [1, n] .   Example 1: Input:  n = 13, k = 2 Output:  10 Explanation:  The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10. Example 2: Input:  n = 1, k = 1 Output:  1   Constraints: 1 <= k <= n <= 10 9",['Trie'],Difícil,Trie,False
295,find-median-from-data-stream,https://leetcode.com/problems/find-median-from-data-stream/,Find Median from Data Stream,"The  median  is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. For example, for  arr = [2,3,4] , the median is  3 . For example, for  arr = [2,3] , the median is  (2 + 3) / 2 = 2.5 . Implement the MedianFinder class: MedianFinder()  initializes the  MedianFinder  object. void addNum(int num)  adds the integer  num  from the data stream to the data structure. double findMedian()  returns the median of all elements so far. Answers within  10 -5  of the actual answer will be accepted.   Example 1: Input [""MedianFinder"", ""addNum"", ""addNum"", ""findMedian"", ""addNum"", ""findMedian""] [[], [1], [2], [], [3], []] Output [null, null, null, 1.5, null, 2.0] Explanation MedianFinder medianFinder = new MedianFinder(); medianFinder.addNum(1);    // arr = [1] medianFinder.addNum(2);    // arr = [1, 2] medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2) medianFinder.addNum(3);    // arr[1, 2, 3] medianFinder.findMedian(); // return 2.0   Constraints: -10 5  <= num <= 10 5 There will be at least one element in the data structure before calling  findMedian . At most  5 * 10 4  calls will be made to  addNum  and  findMedian .   Follow up: If all integer numbers from the stream are in the range  [0, 100] , how would you optimize your solution? If  99%  of all integer numbers from the stream are in the range  [0, 100] , how would you optimize your solution?","['Two Pointers', 'Design', 'Sorting', 'Heap (Priority Queue)', 'Data Stream']",Difícil,Two Pointers,False
1147,longest-chunked-palindrome-decomposition,https://leetcode.com/problems/longest-chunked-palindrome-decomposition/,Longest Chunked Palindrome Decomposition,"You are given a string  text . You should split it to k substrings  (subtext 1 , subtext 2 , ..., subtext k )  such that: subtext i  is a  non-empty  string. The concatenation of all the substrings is equal to  text  (i.e.,  subtext 1  + subtext 2  + ... + subtext k  == text ). subtext i  == subtext k - i + 1  for all valid values of  i  (i.e.,  1 <= i <= k ). Return the largest possible value of  k .   Example 1: Input:  text = ""ghiabcdefhelloadamhelloabcdefghi"" Output:  7 Explanation:  We can split the string on ""(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"". Example 2: Input:  text = ""merchant"" Output:  1 Explanation:  We can split the string on ""(merchant)"". Example 3: Input:  text = ""antaprezatepzapreanta"" Output:  11 Explanation:  We can split the string on ""(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)"".   Constraints: 1 <= text.length <= 1000 text  consists only of lowercase English characters.","['Two Pointers', 'String', 'Dynamic Programming', 'Greedy', 'Rolling Hash', 'Hash Function']",Difícil,Two Pointers,False
1163,last-substring-in-lexicographical-order,https://leetcode.com/problems/last-substring-in-lexicographical-order/,Last Substring in Lexicographical Order,"Given a string  s , return  the last substring of   s   in lexicographical order .   Example 1: Input:  s = ""abab"" Output:  ""bab"" Explanation:  The substrings are [""a"", ""ab"", ""aba"", ""abab"", ""b"", ""ba"", ""bab""]. The lexicographically maximum substring is ""bab"". Example 2: Input:  s = ""leetcode"" Output:  ""tcode""   Constraints: 1 <= s.length <= 4 * 10 5 s  contains only lowercase English letters.","['Two Pointers', 'String']",Difícil,Two Pointers,False
2193,minimum-number-of-moves-to-make-palindrome,https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/,Minimum Number of Moves to Make Palindrome,"You are given a string  s  consisting only of lowercase English letters. In one  move , you can select any two  adjacent  characters of  s  and swap them. Return  the  minimum number of moves  needed to make   s   a palindrome . Note  that the input will be generated such that  s  can always be converted to a palindrome.   Example 1: Input:  s = ""aabb"" Output:  2 Explanation: We can obtain two palindromes from s, ""abba"" and ""baab"".  - We can obtain ""abba"" from s in 2 moves: ""a ab b"" -> ""ab ab "" -> ""abba"". - We can obtain ""baab"" from s in 2 moves: ""a ab b"" -> "" ab ab"" -> ""baab"". Thus, the minimum number of moves needed to make s a palindrome is 2. Example 2: Input:  s = ""letelt"" Output:  2 Explanation: One of the palindromes we can obtain from s in 2 moves is ""lettel"". One of the ways we can obtain it is ""lete lt "" -> ""let et l"" -> ""lettel"". Other palindromes such as ""tleelt"" can also be obtained in 2 moves. It can be shown that it is not possible to obtain a palindrome in less than 2 moves.   Constraints: 1 <= s.length <= 2000 s  consists only of lowercase English letters. s  can be converted to a palindrome using a finite number of moves.","['Two Pointers', 'String', 'Greedy', 'Binary Indexed Tree']",Difícil,Two Pointers,False
2472,maximum-number-of-non-overlapping-palindrome-substrings,https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/,Maximum Number of Non-overlapping Palindrome Substrings,"You are given a string  s  and a  positive  integer  k . Select a set of  non-overlapping  substrings from the string  s  that satisfy the following conditions: The  length  of each substring is  at least   k . Each substring is a  palindrome . Return  the  maximum  number of substrings in an optimal selection . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""abaccdbbd"", k = 3 Output:  2 Explanation:  We can select the substrings underlined in s = "" aba cc dbbd "". Both ""aba"" and ""dbbd"" are palindromes and have a length of at least k = 3. It can be shown that we cannot find a selection with more than two valid substrings. Example 2: Input:  s = ""adbcda"", k = 2 Output:  0 Explanation:  There is no palindrome substring of length at least 2 in the string.   Constraints: 1 <= k <= s.length <= 2000 s  consists of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming', 'Greedy']",Difícil,Two Pointers,False
2565,subsequence-with-the-minimum-score,https://leetcode.com/problems/subsequence-with-the-minimum-score/,Subsequence With the Minimum Score,"You are given two strings  s  and  t . You are allowed to remove any number of characters from the string  t . The score of the string is  0  if no characters are removed from the string  t , otherwise: Let  left  be the minimum index among all removed characters. Let  right  be the maximum index among all removed characters. Then the score of the string is  right - left + 1 . Return  the minimum possible score to make  t  a subsequence of  s . A  subsequence  of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,  ""ace""  is a subsequence of  "" a b c d e ""  while  ""aec""  is not).   Example 1: Input:  s = ""abacaba"", t = ""bzaa"" Output:  1 Explanation:  In this example, we remove the character ""z"" at index 1 (0-indexed). The string t becomes ""baa"" which is a subsequence of the string ""abacaba"" and the score is 1 - 1 + 1 = 1. It can be proven that 1 is the minimum score that we can achieve. Example 2: Input:  s = ""cde"", t = ""xyz"" Output:  3 Explanation:  In this example, we remove characters ""x"", ""y"" and ""z"" at indices 0, 1, and 2 (0-indexed). The string t becomes """" which is a subsequence of the string ""cde"" and the score is 2 - 0 + 1 = 3. It can be proven that 3 is the minimum score that we can achieve.   Constraints: 1 <= s.length, t.length <= 10 5 s  and  t  consist of only lowercase English letters.","['Two Pointers', 'String', 'Binary Search']",Difícil,Two Pointers,False
2911,minimum-changes-to-make-k-semi-palindromes,https://leetcode.com/problems/minimum-changes-to-make-k-semi-palindromes/,Minimum Changes to Make K Semi-palindromes,"Given a string  s  and an integer  k , partition  s  into  k   substrings  such that the letter changes needed to make each substring a  semi-palindrome  are minimized. Return the  minimum  number of letter changes  required . A  semi-palindrome  is a special type of string that can be divided into  palindromes  based on a repeating pattern. To check if a string is a semi-palindrome:​ Choose a positive divisor  d  of the string's length.  d  can range from  1  up to, but not including, the string's length. For a string of length  1 , it does not have a valid divisor as per this definition, since the only divisor is its length, which is not allowed. For a given divisor  d , divide the string into groups where each group contains characters from the string that follow a repeating pattern of length  d . Specifically, the first group consists of characters at positions  1 ,  1 + d ,  1 + 2d , and so on; the second group includes characters at positions  2 ,  2 + d ,  2 + 2d , etc. The string is considered a semi-palindrome if each of these groups forms a palindrome. Consider the string  ""abcabc"" : The length of  ""abcabc""  is  6 . Valid divisors are  1 ,  2 , and  3 . For  d = 1 : The entire string  ""abcabc""  forms one group. Not a palindrome. For  d = 2 : 	 Group 1 (positions  1, 3, 5 ):  ""acb"" Group 2 (positions  2, 4, 6 ):  ""bac"" Neither group forms a palindrome. For  d = 3 : 	 Group 1 (positions  1, 4 ):  ""aa"" Group 2 (positions  2, 5 ):  ""bb"" Group 3 (positions  3, 6 ):  ""cc"" All groups form palindromes. Therefore,  ""abcabc""  is a semi-palindrome.   Example 1:  Input:     s = ""abcac"", k = 2  Output:     1  Explanation:   Divide  s  into  ""ab""  and  ""cac"" .  ""cac""  is already semi-palindrome. Change  ""ab""  to  ""aa"" , it becomes semi-palindrome with  d = 1 . Example 2:  Input:     s = ""abcdef"", k = 2  Output:     2  Explanation:   Divide  s  into substrings  ""abc""  and  ""def"" . Each needs one change to become semi-palindrome. Example 3:  Input:     s = ""aabbaa"", k = 3  Output:     0  Explanation:   Divide  s  into substrings  ""aa"" ,  ""bb""  and  ""aa"" . All are already semi-palindromes.   Constraints: 2 <= s.length <= 200 1 <= k <= s.length / 2 s  contains only lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming']",Difícil,Two Pointers,False
3008,find-beautiful-indices-in-the-given-array-ii,https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/,Find Beautiful Indices in the Given Array II,"You are given a  0-indexed  string  s , a string  a , a string  b , and an integer  k . An index  i  is  beautiful  if: 0 <= i <= s.length - a.length s[i..(i + a.length - 1)] == a There exists an index  j  such that: 	 0 <= j <= s.length - b.length s[j..(j + b.length - 1)] == b |j - i| <= k Return  the array that contains beautiful indices in  sorted order from smallest to largest .   Example 1: Input:  s = ""isawsquirrelnearmysquirrelhouseohmy"", a = ""my"", b = ""squirrel"", k = 15 Output:  [16,33] Explanation:  There are 2 beautiful indices: [16,33]. - The index 16 is beautiful as s[16..17] == ""my"" and there exists an index 4 with s[4..11] == ""squirrel"" and |16 - 4| <= 15. - The index 33 is beautiful as s[33..34] == ""my"" and there exists an index 18 with s[18..25] == ""squirrel"" and |33 - 18| <= 15. Thus we return [16,33] as the result. Example 2: Input:  s = ""abcd"", a = ""a"", b = ""a"", k = 4 Output:  [0] Explanation:  There is 1 beautiful index: [0]. - The index 0 is beautiful as s[0..0] == ""a"" and there exists an index 0 with s[0..0] == ""a"" and |0 - 0| <= 4. Thus we return [0] as the result.   Constraints: 1 <= k <= s.length <= 5 * 10 5 1 <= a.length, b.length <= 5 * 10 5 s ,  a , and  b  contain only lowercase English letters.","['Two Pointers', 'String', 'Binary Search', 'Rolling Hash', 'String Matching', 'Hash Function']",Difícil,Two Pointers,False
3455,shortest-matching-substring,https://leetcode.com/problems/shortest-matching-substring/,Shortest Matching Substring,"You are given a string  s  and a pattern string  p , where  p  contains  exactly two   '*'  characters. The  '*'  in  p  matches any sequence of zero or more characters. Return the length of the  shortest   substring  in  s  that matches  p . If there is no such substring, return -1. Note:  The empty substring is considered valid.   Example 1: Input:   s = ""abaacbaecebce"", p = ""ba*c*ce"" Output:   8 Explanation: The shortest matching substring of  p  in  s  is  "" ba e c eb ce "" . Example 2: Input:   s = ""baccbaadbc"", p = ""cc*baa*adb"" Output:   -1 Explanation: There is no matching substring in  s . Example 3: Input:   s = ""a"", p = ""**"" Output:   0 Explanation: The empty substring is the shortest matching substring. Example 4: Input:   s = ""madlogic"", p = ""*adlogi*"" Output:   6 Explanation: The shortest matching substring of  p  in  s  is  "" adlogi "" .   Constraints: 1 <= s.length <= 10 5 2 <= p.length <= 10 5 s  contains only lowercase English letters. p  contains only lowercase English letters and exactly two  '*' .","['Two Pointers', 'String', 'Binary Search', 'String Matching']",Difícil,Two Pointers,False
3504,longest-palindrome-after-substring-concatenation-ii,https://leetcode.com/problems/longest-palindrome-after-substring-concatenation-ii/,Longest Palindrome After Substring Concatenation II,"You are given two strings,  s  and  t . You can create a new string by selecting a  substring  from  s  (possibly empty) and a substring from  t  (possibly empty), then concatenating them  in order . Return the length of the  longest   palindrome  that can be formed this way.   Example 1: Input:   s = ""a"", t = ""a"" Output:   2 Explanation: Concatenating  ""a""  from  s  and  ""a""  from  t  results in  ""aa"" , which is a palindrome of length 2. Example 2: Input:   s = ""abc"", t = ""def"" Output:   1 Explanation: Since all characters are different, the longest palindrome is any single character, so the answer is 1. Example 3: Input:   s = ""b"", t = ""aaaa"" Output:   4 Explanation: Selecting "" aaaa "" from  t  is the longest palindrome, so the answer is 4. Example 4: Input:   s = ""abcde"", t = ""ecdba"" Output:   5 Explanation: Concatenating  ""abc""  from  s  and  ""ba""  from  t  results in  ""abcba"" , which is a palindrome of length 5.   Constraints: 1 <= s.length, t.length <= 1000 s  and  t  consist of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming']",Difícil,Two Pointers,False
125,valid-palindrome,https://leetcode.com/problems/valid-palindrome/,Valid Palindrome,"A phrase is a  palindrome  if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string  s , return  true  if it is a  palindrome , or  false  otherwise .   Example 1: Input:  s = ""A man, a plan, a canal: Panama"" Output:  true Explanation:  ""amanaplanacanalpanama"" is a palindrome. Example 2: Input:  s = ""race a car"" Output:  false Explanation:  ""raceacar"" is not a palindrome. Example 3: Input:  s = "" "" Output:  true Explanation:  s is an empty string """" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome.   Constraints: 1 <= s.length <= 2 * 10 5 s  consists only of printable ASCII characters.","['Two Pointers', 'String']",Fácil,Two Pointers,False
344,reverse-string,https://leetcode.com/problems/reverse-string/,Reverse String,"Write a function that reverses a string. The input string is given as an array of characters  s . You must do this by modifying the input array  in-place  with  O(1)  extra memory.   Example 1: Input:  s = [""h"",""e"",""l"",""l"",""o""] Output:  [""o"",""l"",""l"",""e"",""h""] Example 2: Input:  s = [""H"",""a"",""n"",""n"",""a"",""h""] Output:  [""h"",""a"",""n"",""n"",""a"",""H""]   Constraints: 1 <= s.length <= 10 5 s[i]  is a  printable ascii character .","['Two Pointers', 'String']",Fácil,Two Pointers,False
345,reverse-vowels-of-a-string,https://leetcode.com/problems/reverse-vowels-of-a-string/,Reverse Vowels of a String,"Given a string  s , reverse only all the vowels in the string and return it. The vowels are  'a' ,  'e' ,  'i' ,  'o' , and  'u' , and they can appear in both lower and upper cases, more than once.   Example 1: Input:   s = ""IceCreAm"" Output:   ""AceCreIm"" Explanation: The vowels in  s  are  ['I', 'e', 'e', 'A'] . On reversing the vowels, s becomes  ""AceCreIm"" . Example 2: Input:   s = ""leetcode"" Output:   ""leotcede""   Constraints: 1 <= s.length <= 3 * 10 5 s  consist of  printable ASCII  characters.","['Two Pointers', 'String']",Fácil,Two Pointers,False
392,is-subsequence,https://leetcode.com/problems/is-subsequence/,Is Subsequence,"Given two strings  s  and  t , return  true  if  s  is a  subsequence  of  t , or  false  otherwise . A  subsequence  of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,  ""ace""  is a subsequence of  "" a b c d e ""  while  ""aec""  is not).   Example 1: Input:  s = ""abc"", t = ""ahbgdc"" Output:  true Example 2: Input:  s = ""axc"", t = ""ahbgdc"" Output:  false   Constraints: 0 <= s.length <= 100 0 <= t.length <= 10 4 s  and  t  consist only of lowercase English letters.   Follow up:  Suppose there are lots of incoming  s , say  s 1 , s 2 , ..., s k  where  k >= 10 9 , and you want to check one by one to see if  t  has its subsequence. In this scenario, how would you change your code?","['Two Pointers', 'String', 'Dynamic Programming']",Fácil,Two Pointers,False
541,reverse-string-ii,https://leetcode.com/problems/reverse-string-ii/,Reverse String II,"Given a string  s  and an integer  k , reverse the first  k  characters for every  2k  characters counting from the start of the string. If there are fewer than  k  characters left, reverse all of them. If there are less than  2k  but greater than or equal to  k  characters, then reverse the first  k  characters and leave the other as original.   Example 1: Input:  s = ""abcdefg"", k = 2 Output:  ""bacdfeg"" Example 2: Input:  s = ""abcd"", k = 2 Output:  ""bacd""   Constraints: 1 <= s.length <= 10 4 s  consists of only lowercase English letters. 1 <= k <= 10 4","['Two Pointers', 'String']",Fácil,Two Pointers,False
557,reverse-words-in-a-string-iii,https://leetcode.com/problems/reverse-words-in-a-string-iii/,Reverse Words in a String III,"Given a string  s , reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.   Example 1: Input:  s = ""Let's take LeetCode contest"" Output:  ""s'teL ekat edoCteeL tsetnoc"" Example 2: Input:  s = ""Mr Ding"" Output:  ""rM gniD""   Constraints: 1 <= s.length <= 5 * 10 4 s  contains printable  ASCII  characters. s  does not contain any leading or trailing spaces. There is  at least one  word in  s . All the words in  s  are separated by a single space.","['Two Pointers', 'String']",Fácil,Two Pointers,False
680,valid-palindrome-ii,https://leetcode.com/problems/valid-palindrome-ii/,Valid Palindrome II,"Given a string  s , return  true   if the  s  can be palindrome after deleting  at most one  character from it .   Example 1: Input:  s = ""aba"" Output:  true Example 2: Input:  s = ""abca"" Output:  true Explanation:  You could delete the character 'c'. Example 3: Input:  s = ""abc"" Output:  false   Constraints: 1 <= s.length <= 10 5 s  consists of lowercase English letters.","['Two Pointers', 'String', 'Greedy']",Fácil,Two Pointers,False
696,count-binary-substrings,https://leetcode.com/problems/count-binary-substrings/,Count Binary Substrings,"Given a binary string  s , return the number of non-empty substrings that have the same number of  0 's and  1 's, and all the  0 's and all the  1 's in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.   Example 1: Input:  s = ""00110011"" Output:  6 Explanation:  There are 6 substrings that have equal number of consecutive 1's and 0's: ""0011"", ""01"", ""1100"", ""10"", ""0011"", and ""01"". Notice that some of these substrings repeat and are counted the number of times they occur. Also, ""00110011"" is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: Input:  s = ""10101"" Output:  4 Explanation:  There are 4 substrings: ""10"", ""01"", ""10"", ""01"" that have equal number of consecutive 1's and 0's.   Constraints: 1 <= s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['Two Pointers', 'String']",Fácil,Two Pointers,False
844,backspace-string-compare,https://leetcode.com/problems/backspace-string-compare/,Backspace String Compare,"Given two strings  s  and  t , return  true   if they are equal when both are typed into empty text editors .  '#'  means a backspace character. Note that after backspacing an empty text, the text will continue empty.   Example 1: Input:  s = ""ab#c"", t = ""ad#c"" Output:  true Explanation:  Both s and t become ""ac"". Example 2: Input:  s = ""ab##"", t = ""c#d#"" Output:  true Explanation:  Both s and t become """". Example 3: Input:  s = ""a#c"", t = ""b"" Output:  false Explanation:  s becomes ""c"" while t becomes ""b"".   Constraints: 1 <= s.length, t.length <= 200 s  and  t  only contain lowercase letters and  '#'  characters.   Follow up:  Can you solve it in  O(n)  time and  O(1)  space?","['Two Pointers', 'String', 'Stack', 'Simulation']",Fácil,Two Pointers,False
917,reverse-only-letters,https://leetcode.com/problems/reverse-only-letters/,Reverse Only Letters,"Given a string  s , reverse the string according to the following rules: All the characters that are not English letters remain in the same position. All the English letters (lowercase or uppercase) should be reversed. Return  s  after reversing it .   Example 1: Input:  s = ""ab-cd"" Output:  ""dc-ba"" Example 2: Input:  s = ""a-bC-dEf-ghIj"" Output:  ""j-Ih-gfE-dCba"" Example 3: Input:  s = ""Test1ng-Leet=code-Q!"" Output:  ""Qedo1ct-eeLg=ntse-T!""   Constraints: 1 <= s.length <= 100 s  consists of characters with ASCII values in the range  [33, 122] . s  does not contain  '\""'  or  '\\' .","['Two Pointers', 'String']",Fácil,Two Pointers,False
925,long-pressed-name,https://leetcode.com/problems/long-pressed-name/,Long Pressed Name,"Your friend is typing his  name  into a keyboard. Sometimes, when typing a character  c , the key might get  long pressed , and the character will be typed 1 or more times. You examine the  typed  characters of the keyboard. Return  True  if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input:  name = ""alex"", typed = ""aaleex"" Output:  true Explanation:  'a' and 'e' in 'alex' were long pressed. Example 2: Input:  name = ""saeed"", typed = ""ssaaedd"" Output:  false Explanation:  'e' must have been pressed twice, but it was not in the typed output.   Constraints: 1 <= name.length, typed.length <= 1000 name  and  typed  consist of only lowercase English letters.","['Two Pointers', 'String']",Fácil,Two Pointers,False
1332,remove-palindromic-subsequences,https://leetcode.com/problems/remove-palindromic-subsequences/,Remove Palindromic Subsequences,"You are given a string  s  consisting  only  of letters  'a'  and  'b' . In a single step you can remove one  palindromic subsequence  from  s . Return  the  minimum  number of steps to make the given string empty . A string is a  subsequence  of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does  not  necessarily need to be contiguous. A string is called  palindrome  if is one that reads the same backward as well as forward.   Example 1: Input:  s = ""ababa"" Output:  1 Explanation:  s is already a palindrome, so its entirety can be removed in a single step. Example 2: Input:  s = ""abb"" Output:  2 Explanation:  "" a bb"" -> "" bb "" -> """".  Remove palindromic subsequence ""a"" then ""bb"". Example 3: Input:  s = ""baabb"" Output:  2 Explanation:  "" baa b b "" -> "" b "" -> """".  Remove palindromic subsequence ""baab"" then ""b"".   Constraints: 1 <= s.length <= 1000 s[i]  is either  'a'  or  'b' .","['Two Pointers', 'String']",Fácil,Two Pointers,False
1455,check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence,https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/,Check If a Word Occurs As a Prefix of Any Word in a Sentence,"Given a  sentence  that consists of some words separated by a  single space , and a  searchWord , check if  searchWord  is a prefix of any word in  sentence . Return  the index of the word in  sentence  ( 1-indexed ) where  searchWord  is a prefix of this word . If  searchWord  is a prefix of more than one word, return the index of the first word  (minimum index) . If there is no such word return  -1 . A  prefix  of a string  s  is any leading contiguous substring of  s .   Example 1: Input:  sentence = ""i love eating burger"", searchWord = ""burg"" Output:  4 Explanation:  ""burg"" is prefix of ""burger"" which is the 4th word in the sentence. Example 2: Input:  sentence = ""this problem is an easy problem"", searchWord = ""pro"" Output:  2 Explanation:  ""pro"" is prefix of ""problem"" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. Example 3: Input:  sentence = ""i am tired"", searchWord = ""you"" Output:  -1 Explanation:  ""you"" is not a prefix of any word in the sentence.   Constraints: 1 <= sentence.length <= 100 1 <= searchWord.length <= 10 sentence  consists of lowercase English letters and spaces. searchWord  consists of lowercase English letters.","['Two Pointers', 'String', 'String Matching']",Fácil,Two Pointers,False
1768,merge-strings-alternately,https://leetcode.com/problems/merge-strings-alternately/,Merge Strings Alternately,"You are given two strings  word1  and  word2 . Merge the strings by adding letters in alternating order, starting with  word1 . If a string is longer than the other, append the additional letters onto the end of the merged string. Return  the merged string.   Example 1: Input:  word1 = ""abc"", word2 = ""pqr"" Output:  ""apbqcr"" Explanation:  The merged string will be merged as so: word1:  a   b   c word2:    p   q   r merged: a p b q c r Example 2: Input:  word1 = ""ab"", word2 = ""pqrs"" Output:  ""apbqrs"" Explanation:  Notice that as word2 is longer, ""rs"" is appended to the end. word1:  a   b  word2:    p   q   r   s merged: a p b q   r   s Example 3: Input:  word1 = ""abcd"", word2 = ""pq"" Output:  ""apbqcd"" Explanation:  Notice that as word1 is longer, ""cd"" is appended to the end. word1:  a   b   c   d word2:    p   q  merged: a p b q c   d   Constraints: 1 <= word1.length, word2.length <= 100 word1  and  word2  consist of lowercase English letters.","['Two Pointers', 'String']",Fácil,Two Pointers,False
2000,reverse-prefix-of-word,https://leetcode.com/problems/reverse-prefix-of-word/,Reverse Prefix of Word,"Given a  0-indexed  string  word  and a character  ch ,  reverse  the segment of  word  that starts at index  0  and ends at the index of the  first occurrence  of  ch  ( inclusive ). If the character  ch  does not exist in  word , do nothing. For example, if  word = ""abcdefd""  and  ch = ""d"" , then you should  reverse  the segment that starts at  0  and ends at  3  ( inclusive ). The resulting string will be  "" dcba efd"" . Return  the resulting string .   Example 1: Input:  word = "" abcd efd"", ch = ""d"" Output:  "" dcba efd"" Explanation:  The first occurrence of ""d"" is at index 3.  Reverse the part of word from 0 to 3 (inclusive), the resulting string is ""dcbaefd"". Example 2: Input:  word = "" xyxz xe"", ch = ""z"" Output:  "" zxyx xe"" Explanation:  The first and only occurrence of ""z"" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is ""zxyxxe"". Example 3: Input:  word = ""abcd"", ch = ""z"" Output:  ""abcd"" Explanation:  ""z"" does not exist in word. You should not do any reverse operation, the resulting string is ""abcd"".   Constraints: 1 <= word.length <= 250 word  consists of lowercase English letters. ch  is a lowercase English letter.","['Two Pointers', 'String', 'Stack']",Fácil,Two Pointers,False
5,longest-palindromic-substring,https://leetcode.com/problems/longest-palindromic-substring/,Longest Palindromic Substring,"Given a string  s , return  the longest   palindromic   substring  in  s .   Example 1: Input:  s = ""babad"" Output:  ""bab"" Explanation:  ""aba"" is also a valid answer. Example 2: Input:  s = ""cbbd"" Output:  ""bb""   Constraints: 1 <= s.length <= 1000 s  consist of only digits and English letters.","['Two Pointers', 'String', 'Dynamic Programming']",Média,Two Pointers,False
151,reverse-words-in-a-string,https://leetcode.com/problems/reverse-words-in-a-string/,Reverse Words in a String,"Given an input string  s , reverse the order of the  words . A  word  is defined as a sequence of non-space characters. The  words  in  s  will be separated by at least one space. Return  a string of the words in reverse order concatenated by a single space. Note  that  s  may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.   Example 1: Input:  s = ""the sky is blue"" Output:  ""blue is sky the"" Example 2: Input:  s = ""  hello world  "" Output:  ""world hello"" Explanation:  Your reversed string should not contain leading or trailing spaces. Example 3: Input:  s = ""a good   example"" Output:  ""example good a"" Explanation:  You need to reduce multiple spaces between two words to a single space in the reversed string.   Constraints: 1 <= s.length <= 10 4 s  contains English letters (upper-case and lower-case), digits, and spaces  ' ' . There is  at least one  word in  s .   Follow-up:  If the string data type is mutable in your language, can you solve it  in-place  with  O(1)  extra space?","['Two Pointers', 'String']",Média,Two Pointers,False
165,compare-version-numbers,https://leetcode.com/problems/compare-version-numbers/,Compare Version Numbers,"Given two  version strings ,  version1  and  version2 , compare them. A version string consists of  revisions  separated by dots  '.' . The  value of the revision  is its  integer conversion  ignoring leading zeros. To compare version strings, compare their revision values in  left-to-right order . If one of the version strings has fewer revisions, treat the missing revision values as  0 . Return the following: If  version1 < version2 , return -1. If  version1 > version2 , return 1. Otherwise, return 0.   Example 1: Input:   version1 = ""1.2"", version2 = ""1.10"" Output:   -1 Explanation: version1's second revision is ""2"" and version2's second revision is ""10"": 2 < 10, so version1 < version2. Example 2: Input:   version1 = ""1.01"", version2 = ""1.001"" Output:   0 Explanation: Ignoring leading zeroes, both ""01"" and ""001"" represent the same integer ""1"". Example 3: Input:   version1 = ""1.0"", version2 = ""1.0.0.0"" Output:   0 Explanation: version1 has less revisions, which means every missing revision are treated as ""0"".   Constraints: 1 <= version1.length, version2.length <= 500 version1  and  version2  only contain digits and  '.' . version1  and  version2   are valid version numbers . All the given revisions in  version1  and  version2  can be stored in a  32-bit integer .","['Two Pointers', 'String']",Média,Two Pointers,False
443,string-compression,https://leetcode.com/problems/string-compression/,String Compression,"Given an array of characters  chars , compress it using the following algorithm: Begin with an empty string  s . For each group of  consecutive repeating characters  in  chars : If the group's length is  1 , append the character to  s . Otherwise, append the character followed by the group's length. The compressed string  s   should not be returned separately , but instead, be stored  in the input character array  chars . Note that group lengths that are  10  or longer will be split into multiple characters in  chars . After you are done  modifying the input array,  return  the new length of the array . You must write an algorithm that uses only constant extra space.   Example 1: Input:  chars = [""a"",""a"",""b"",""b"",""c"",""c"",""c""] Output:  Return 6, and the first 6 characters of the input array should be: [""a"",""2"",""b"",""2"",""c"",""3""] Explanation:  The groups are ""aa"", ""bb"", and ""ccc"". This compresses to ""a2b2c3"". Example 2: Input:  chars = [""a""] Output:  Return 1, and the first character of the input array should be: [""a""] Explanation:  The only group is ""a"", which remains uncompressed since it's a single character. Example 3: Input:  chars = [""a"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b""] Output:  Return 4, and the first 4 characters of the input array should be: [""a"",""b"",""1"",""2""]. Explanation:  The groups are ""a"" and ""bbbbbbbbbbbb"". This compresses to ""ab12"".   Constraints: 1 <= chars.length <= 2000 chars[i]  is a lowercase English letter, uppercase English letter, digit, or symbol.","['Two Pointers', 'String']",Média,Two Pointers,False
481,magical-string,https://leetcode.com/problems/magical-string/,Magical String,"A magical string  s  consists of only  '1'  and  '2'  and obeys the following rules: The string s is magical because concatenating the number of contiguous occurrences of characters  '1'  and  '2'  generates the string  s  itself. The first few elements of  s  is  s = ""1221121221221121122……"" . If we group the consecutive  1 's and  2 's in  s , it will be  ""1 22 11 2 1 22 1 22 11 2 11 22 ......""  and the occurrences of  1 's or  2 's in each group are  ""1 2 2 1 1 2 1 2 2 1 2 2 ......"" . You can see that the occurrence sequence is  s  itself. Given an integer  n , return the number of  1 's in the first  n  number in the magical string  s .   Example 1: Input:  n = 6 Output:  3 Explanation:  The first 6 elements of magical string s is ""122112"" and it contains three 1's, so return 3. Example 2: Input:  n = 1 Output:  1   Constraints: 1 <= n <= 10 5","['Two Pointers', 'String']",Média,Two Pointers,False
647,palindromic-substrings,https://leetcode.com/problems/palindromic-substrings/,Palindromic Substrings,"Given a string  s , return  the number of  palindromic substrings  in it . A string is a  palindrome  when it reads the same backward as forward. A  substring  is a contiguous sequence of characters within the string.   Example 1: Input:  s = ""abc"" Output:  3 Explanation:  Three palindromic strings: ""a"", ""b"", ""c"". Example 2: Input:  s = ""aaa"" Output:  6 Explanation:  Six palindromic strings: ""a"", ""a"", ""a"", ""aa"", ""aa"", ""aaa"".   Constraints: 1 <= s.length <= 1000 s  consists of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming']",Média,Two Pointers,False
777,swap-adjacent-in-lr-string,https://leetcode.com/problems/swap-adjacent-in-lr-string/,Swap Adjacent in LR String,"In a string composed of  'L' ,  'R' , and  'X'  characters, like  ""RXXLRXRXL"" , a move consists of either replacing one occurrence of  ""XL""  with  ""LX"" , or replacing one occurrence of  ""RX""  with  ""XR"" . Given the starting string  start  and the ending string  result , return  True  if and only if there exists a sequence of moves to transform  start  to  result .   Example 1: Input:  start = ""RXXLRXRXL"", result = ""XRLXXRRLX"" Output:  true Explanation:  We can transform start to result following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX Example 2: Input:  start = ""X"", result = ""L"" Output:  false   Constraints: 1 <= start.length <= 10 4 start.length == result.length Both  start  and  result  will only consist of characters in  'L' ,  'R' , and  'X' .","['Two Pointers', 'String']",Média,Two Pointers,False
1616,split-two-strings-to-make-palindrome,https://leetcode.com/problems/split-two-strings-to-make-palindrome/,Split Two Strings to Make Palindrome,"You are given two strings  a  and  b  of the same length. Choose an index and split both strings  at the same index , splitting  a  into two strings:  a prefix  and  a suffix  where  a = a prefix  + a suffix , and splitting  b  into two strings:  b prefix  and  b suffix  where  b = b prefix  + b suffix . Check if  a prefix  + b suffix  or  b prefix  + a suffix  forms a palindrome. When you split a string  s  into  s prefix  and  s suffix , either  s suffix  or  s prefix  is allowed to be empty. For example, if  s = ""abc"" , then  """" + ""abc"" ,  ""a"" + ""bc"" ,  ""ab"" + ""c""  , and  ""abc"" + """"  are valid splits. Return  true  if it is possible to form  a palindrome string, otherwise return  false . Notice  that  x + y  denotes the concatenation of strings  x  and  y .   Example 1: Input:  a = ""x"", b = ""y"" Output:  true Explaination:  If either a or b are palindromes the answer is true since you can split in the following way: a prefix  = """", a suffix  = ""x"" b prefix  = """", b suffix  = ""y"" Then, a prefix  + b suffix  = """" + ""y"" = ""y"", which is a palindrome. Example 2: Input:  a = ""xbdef"", b = ""xecab"" Output:  false Example 3: Input:  a = ""ulacfd"", b = ""jizalu"" Output:  true Explaination:  Split them at index 3: a prefix  = ""ula"", a suffix  = ""cfd"" b prefix  = ""jiz"", b suffix  = ""alu"" Then, a prefix  + b suffix  = ""ula"" + ""alu"" = ""ulaalu"", which is a palindrome.   Constraints: 1 <= a.length, b.length <= 10 5 a.length == b.length a  and  b  consist of lowercase English letters","['Two Pointers', 'String']",Média,Two Pointers,False
1750,minimum-length-of-string-after-deleting-similar-ends,https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/,Minimum Length of String After Deleting Similar Ends,"Given a string  s  consisting only of characters  'a' ,  'b' , and  'c' . You are asked to apply the following algorithm on the string any number of times: Pick a  non-empty  prefix from the string  s  where all the characters in the prefix are equal. Pick a  non-empty  suffix from the string  s  where all the characters in this suffix are equal. The prefix and the suffix should not intersect at any index. The characters from the prefix and suffix must be the same. Delete both the prefix and the suffix. Return  the  minimum length  of  s   after performing the above operation any number of times (possibly zero times) .   Example 1: Input:  s = ""ca"" Output:  2 Explanation:  You can't remove any characters, so the string stays as is. Example 2: Input:  s = ""cabaabac"" Output:  0 Explanation:  An optimal sequence of operations is: - Take prefix = ""c"" and suffix = ""c"" and remove them, s = ""abaaba"". - Take prefix = ""a"" and suffix = ""a"" and remove them, s = ""baab"". - Take prefix = ""b"" and suffix = ""b"" and remove them, s = ""aa"". - Take prefix = ""a"" and suffix = ""a"" and remove them, s = """". Example 3: Input:  s = ""aabccabba"" Output:  3 Explanation:  An optimal sequence of operations is: - Take prefix = ""aa"" and suffix = ""a"" and remove them, s = ""bccabb"". - Take prefix = ""b"" and suffix = ""bb"" and remove them, s = ""cca"".   Constraints: 1 <= s.length <= 10 5 s  only consists of characters  'a' ,  'b' , and  'c' .","['Two Pointers', 'String']",Média,Two Pointers,False
1754,largest-merge-of-two-strings,https://leetcode.com/problems/largest-merge-of-two-strings/,Largest Merge Of Two Strings,"You are given two strings  word1  and  word2 . You want to construct a string  merge  in the following way: while either  word1  or  word2  are non-empty, choose  one  of the following options: If  word1  is non-empty, append the  first  character in  word1  to  merge  and delete it from  word1 . 	 For example, if  word1 = ""abc""  and  merge = ""dv"" , then after choosing this operation,  word1 = ""bc""  and  merge = ""dva"" . If  word2  is non-empty, append the  first  character in  word2  to  merge  and delete it from  word2 . 	 For example, if  word2 = ""abc""  and  merge = """" , then after choosing this operation,  word2 = ""bc""  and  merge = ""a"" . Return  the lexicographically  largest   merge  you can construct . A string  a  is lexicographically larger than a string  b  (of the same length) if in the first position where  a  and  b  differ,  a  has a character strictly larger than the corresponding character in  b . For example,  ""abcd""  is lexicographically larger than  ""abcc""  because the first position they differ is at the fourth character, and  d  is greater than  c .   Example 1: Input:  word1 = ""cabaa"", word2 = ""bcaaa"" Output:  ""cbcabaaaaa"" Explanation:  One way to get the lexicographically largest merge is: - Take from word1: merge = ""c"", word1 = ""abaa"", word2 = ""bcaaa"" - Take from word2: merge = ""cb"", word1 = ""abaa"", word2 = ""caaa"" - Take from word2: merge = ""cbc"", word1 = ""abaa"", word2 = ""aaa"" - Take from word1: merge = ""cbca"", word1 = ""baa"", word2 = ""aaa"" - Take from word1: merge = ""cbcab"", word1 = ""aa"", word2 = ""aaa"" - Append the remaining 5 a's from word1 and word2 at the end of merge. Example 2: Input:  word1 = ""abcabc"", word2 = ""abdcaba"" Output:  ""abdcabcabcaba""   Constraints: 1 <= word1.length, word2.length <= 3000 word1  and  word2  consist only of lowercase English letters.","['Two Pointers', 'String', 'Greedy']",Média,Two Pointers,False
1850,minimum-adjacent-swaps-to-reach-the-kth-smallest-number,https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/,Minimum Adjacent Swaps to Reach the Kth Smallest Number,"You are given a string  num , representing a large integer, and an integer  k . We call some integer  wonderful  if it is a  permutation  of the digits in  num  and is  greater in value  than  num . There can be many wonderful integers. However, we only care about the  smallest-valued  ones. For example, when  num = ""5489355142"" : 	 The 1 st  smallest wonderful integer is  ""5489355214"" . The 2 nd  smallest wonderful integer is  ""5489355241"" . The 3 rd  smallest wonderful integer is  ""5489355412"" . The 4 th  smallest wonderful integer is  ""5489355421"" . Return  the  minimum number of adjacent digit swaps  that needs to be applied to  num  to reach the  k th  smallest wonderful  integer . The tests are generated in such a way that  k th  smallest wonderful integer exists.   Example 1: Input:  num = ""5489355142"", k = 4 Output:  2 Explanation:  The 4 th  smallest wonderful number is ""5489355421"". To get this number: - Swap index 7 with index 8: ""5489355 14 2"" -> ""5489355 41 2"" - Swap index 8 with index 9: ""54893554 12 "" -> ""54893554 21 "" Example 2: Input:  num = ""11112"", k = 4 Output:  4 Explanation:  The 4 th  smallest wonderful number is ""21111"". To get this number: - Swap index 3 with index 4: ""111 12 "" -> ""111 21 "" - Swap index 2 with index 3: ""11 12 1"" -> ""11 21 1"" - Swap index 1 with index 2: ""1 12 11"" -> ""1 21 11"" - Swap index 0 with index 1: "" 12 111"" -> "" 21 111"" Example 3: Input:  num = ""00123"", k = 1 Output:  1 Explanation:  The 1 st  smallest wonderful number is ""00132"". To get this number: - Swap index 3 with index 4: ""001 23 "" -> ""001 32 ""   Constraints: 2 <= num.length <= 1000 1 <= k <= 1000 num  only consists of digits.","['Two Pointers', 'String', 'Greedy']",Média,Two Pointers,False
1963,minimum-number-of-swaps-to-make-the-string-balanced,https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/,Minimum Number of Swaps to Make the String Balanced,"You are given a  0-indexed  string  s  of  even  length  n . The string consists of  exactly   n / 2  opening brackets  '['  and  n / 2  closing brackets  ']' . A string is called  balanced  if and only if: It is the empty string, or It can be written as  AB , where both  A  and  B  are  balanced  strings, or It can be written as  [C] , where  C  is a  balanced  string. You may swap the brackets at  any  two indices  any  number of times. Return  the  minimum  number of swaps to make  s   balanced .   Example 1: Input:  s = ""][]["" Output:  1 Explanation:  You can make the string balanced by swapping index 0 with index 3. The resulting string is ""[[]]"". Example 2: Input:  s = ""]]][[["" Output:  2 Explanation:  You can do the following to make the string balanced: - Swap index 0 with index 4. s = ""[]][]["". - Swap index 1 with index 5. s = ""[[][]]"". The resulting string is ""[[][]]"". Example 3: Input:  s = ""[]"" Output:  0 Explanation:  The string is already balanced.   Constraints: n == s.length 2 <= n <= 10 6 n  is even. s[i]  is either  '['  or  ']' . The number of opening brackets  '['  equals  n / 2 , and the number of closing brackets  ']'  equals  n / 2 .","['Two Pointers', 'String', 'Stack', 'Greedy']",Média,Two Pointers,False
2337,move-pieces-to-obtain-a-string,https://leetcode.com/problems/move-pieces-to-obtain-a-string/,Move Pieces to Obtain a String,"You are given two strings  start  and  target , both of length  n . Each string consists  only  of the characters  'L' ,  'R' , and  '_'  where: The characters  'L'  and  'R'  represent pieces, where a piece  'L'  can move to the  left  only if there is a  blank  space directly to its left, and a piece  'R'  can move to the  right  only if there is a  blank  space directly to its right. The character  '_'  represents a blank space that can be occupied by  any  of the  'L'  or  'R'  pieces. Return  true   if it is possible to obtain the string   target  by moving the pieces of the string  start   any  number of times . Otherwise, return  false .   Example 1: Input:  start = ""_L__R__R_"", target = ""L______RR"" Output:  true Explanation:  We can obtain the string target from start by doing the following moves: - Move the first piece one step to the left, start becomes equal to "" L ___R__R_"". - Move the last piece one step to the right, start becomes equal to ""L___R___ R "". - Move the second piece three steps to the right, start becomes equal to ""L______ R R"". Since it is possible to get the string target from start, we return true. Example 2: Input:  start = ""R_L_"", target = ""__LR"" Output:  false Explanation:  The 'R' piece in the string start can move one step to the right to obtain ""_ R L_"". After that, no pieces can move anymore, so it is impossible to obtain the string target from start. Example 3: Input:  start = ""_R"", target = ""R_"" Output:  false Explanation:  The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.   Constraints: n == start.length == target.length 1 <= n <= 10 5 start  and  target  consist of the characters  'L' ,  'R' , and  '_' .","['Two Pointers', 'String']",Média,Two Pointers,False
2486,append-characters-to-string-to-make-subsequence,https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/,Append Characters to String to Make Subsequence,"You are given two strings  s  and  t  consisting of only lowercase English letters. Return  the minimum number of characters that need to be appended to the end of  s  so that  t  becomes a  subsequence  of  s . A  subsequence  is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.   Example 1: Input:  s = ""coaching"", t = ""coding"" Output:  4 Explanation:  Append the characters ""ding"" to the end of s so that s = ""coachingding"". Now, t is a subsequence of s ("" co aching ding ""). It can be shown that appending any 3 characters to the end of s will never make t a subsequence. Example 2: Input:  s = ""abcde"", t = ""a"" Output:  0 Explanation:  t is already a subsequence of s ("" a bcde""). Example 3: Input:  s = ""z"", t = ""abcde"" Output:  5 Explanation:  Append the characters ""abcde"" to the end of s so that s = ""zabcde"". Now, t is a subsequence of s (""z abcde ""). It can be shown that appending any 4 characters to the end of s will never make t a subsequence.   Constraints: 1 <= s.length, t.length <= 10 5 s  and  t  consist only of lowercase English letters.","['Two Pointers', 'String', 'Greedy']",Média,Two Pointers,False
2825,make-string-a-subsequence-using-cyclic-increments,https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/,Make String a Subsequence Using Cyclic Increments,"You are given two  0-indexed  strings  str1  and  str2 . In an operation, you select a  set  of indices in  str1 , and for each index  i  in the set, increment  str1[i]  to the next character  cyclically . That is  'a'  becomes  'b' ,  'b'  becomes  'c' , and so on, and  'z'  becomes  'a' . Return  true   if it is possible to make  str2   a subsequence of  str1   by performing the operation  at most once ,  and   false   otherwise . Note:  A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.   Example 1: Input:  str1 = ""abc"", str2 = ""ad"" Output:  true Explanation:  Select index 2 in str1. Increment str1[2] to become 'd'.  Hence, str1 becomes ""abd"" and str2 is now a subsequence. Therefore, true is returned. Example 2: Input:  str1 = ""zc"", str2 = ""ad"" Output:  true Explanation:  Select indices 0 and 1 in str1.  Increment str1[0] to become 'a'.  Increment str1[1] to become 'd'.  Hence, str1 becomes ""ad"" and str2 is now a subsequence. Therefore, true is returned. Example 3: Input:  str1 = ""ab"", str2 = ""d"" Output:  false Explanation:  In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once.  Therefore, false is returned.   Constraints: 1 <= str1.length <= 10 5 1 <= str2.length <= 10 5 str1  and  str2  consist of only lowercase English letters.","['Two Pointers', 'String']",Média,Two Pointers,False
2938,separate-black-and-white-balls,https://leetcode.com/problems/separate-black-and-white-balls/,Separate Black and White Balls,"There are  n  balls on a table, each ball has a color black or white. You are given a  0-indexed  binary string  s  of length  n , where  1  and  0  represent black and white balls, respectively. In each step, you can choose two adjacent balls and swap them. Return  the  minimum  number of steps to group all the black balls to the right and all the white balls to the left .   Example 1: Input:  s = ""101"" Output:  1 Explanation:  We can group all the black balls to the right in the following way: - Swap s[0] and s[1], s = ""011"". Initially, 1s are not grouped together, requiring at least 1 step to group them to the right. Example 2: Input:  s = ""100"" Output:  2 Explanation:  We can group all the black balls to the right in the following way: - Swap s[0] and s[1], s = ""010"". - Swap s[1] and s[2], s = ""001"". It can be proven that the minimum number of steps needed is 2. Example 3: Input:  s = ""0111"" Output:  0 Explanation:  All the black balls are already grouped to the right.   Constraints: 1 <= n == s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['Two Pointers', 'String', 'Greedy']",Média,Two Pointers,False
3006,find-beautiful-indices-in-the-given-array-i,https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/,Find Beautiful Indices in the Given Array I,"You are given a  0-indexed  string  s , a string  a , a string  b , and an integer  k . An index  i  is  beautiful  if: 0 <= i <= s.length - a.length s[i..(i + a.length - 1)] == a There exists an index  j  such that: 	 0 <= j <= s.length - b.length s[j..(j + b.length - 1)] == b |j - i| <= k Return  the array that contains beautiful indices in  sorted order from smallest to largest .   Example 1: Input:  s = ""isawsquirrelnearmysquirrelhouseohmy"", a = ""my"", b = ""squirrel"", k = 15 Output:  [16,33] Explanation:  There are 2 beautiful indices: [16,33]. - The index 16 is beautiful as s[16..17] == ""my"" and there exists an index 4 with s[4..11] == ""squirrel"" and |16 - 4| <= 15. - The index 33 is beautiful as s[33..34] == ""my"" and there exists an index 18 with s[18..25] == ""squirrel"" and |33 - 18| <= 15. Thus we return [16,33] as the result. Example 2: Input:  s = ""abcd"", a = ""a"", b = ""a"", k = 4 Output:  [0] Explanation:  There is 1 beautiful index: [0]. - The index 0 is beautiful as s[0..0] == ""a"" and there exists an index 0 with s[0..0] == ""a"" and |0 - 0| <= 4. Thus we return [0] as the result.   Constraints: 1 <= k <= s.length <= 10 5 1 <= a.length, b.length <= 10 s ,  a , and  b  contain only lowercase English letters.","['Two Pointers', 'String', 'Binary Search', 'Rolling Hash', 'String Matching', 'Hash Function']",Média,Two Pointers,False
3302,find-the-lexicographically-smallest-valid-sequence,https://leetcode.com/problems/find-the-lexicographically-smallest-valid-sequence/,Find the Lexicographically Smallest Valid Sequence,"You are given two strings  word1  and  word2 . A string  x  is called  almost equal  to  y  if you can change  at most  one character in  x  to make it  identical  to  y . A sequence of indices  seq  is called  valid  if: The indices are sorted in  ascending  order. Concatenating  the characters at these indices in  word1  in  the same  order results in a string that is  almost equal  to  word2 . Return an array of size  word2.length  representing the  lexicographically smallest   valid  sequence of indices. If no such sequence of indices exists, return an  empty  array. Note  that the answer must represent the  lexicographically smallest array ,  not  the corresponding string formed by those indices.   Example 1: Input:   word1 = ""vbcca"", word2 = ""abc"" Output:   [0,1,2] Explanation: The lexicographically smallest valid sequence of indices is  [0, 1, 2] : Change  word1[0]  to  'a' . word1[1]  is already  'b' . word1[2]  is already  'c' . Example 2: Input:   word1 = ""bacdc"", word2 = ""abc"" Output:   [1,2,4] Explanation: The lexicographically smallest valid sequence of indices is  [1, 2, 4] : word1[1]  is already  'a' . Change  word1[2]  to  'b' . word1[4]  is already  'c' . Example 3: Input:   word1 = ""aaaaaa"", word2 = ""aaabc"" Output:   [] Explanation: There is no valid sequence of indices. Example 4: Input:   word1 = ""abc"", word2 = ""ab"" Output:   [0,1]   Constraints: 1 <= word2.length < word1.length <= 3 * 10 5 word1  and  word2  consist only of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming', 'Greedy']",Média,Two Pointers,False
3403,find-the-lexicographically-largest-string-from-the-box-i,https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i/,Find the Lexicographically Largest String From the Box I,"You are given a string  word , and an integer  numFriends . Alice is organizing a game for her  numFriends  friends. There are multiple rounds in the game, where in each round: word  is split into  numFriends   non-empty  strings, such that no previous round has had the  exact  same split. All the split words are put into a box. Find the  lexicographically largest  string from the box after all the rounds are finished.   Example 1: Input:   word = ""dbca"", numFriends = 2 Output:   ""dbc"" Explanation:   All possible splits are: ""d""  and  ""bca"" . ""db""  and  ""ca"" . ""dbc""  and  ""a"" . Example 2: Input:   word = ""gggg"", numFriends = 4 Output:   ""g"" Explanation:   The only possible split is:  ""g"" ,  ""g"" ,  ""g"" , and  ""g"" .   Constraints: 1 <= word.length <= 5 * 10 3 word  consists only of lowercase English letters. 1 <= numFriends <= word.length","['Two Pointers', 'String', 'Enumeration']",Média,Two Pointers,False
3503,longest-palindrome-after-substring-concatenation-i,https://leetcode.com/problems/longest-palindrome-after-substring-concatenation-i/,Longest Palindrome After Substring Concatenation I,"You are given two strings,  s  and  t . You can create a new string by selecting a  substring  from  s  (possibly empty) and a substring from  t  (possibly empty), then concatenating them  in order . Return the length of the  longest   palindrome  that can be formed this way.   Example 1: Input:   s = ""a"", t = ""a"" Output:   2 Explanation: Concatenating  ""a""  from  s  and  ""a""  from  t  results in  ""aa"" , which is a palindrome of length 2. Example 2: Input:   s = ""abc"", t = ""def"" Output:   1 Explanation: Since all characters are different, the longest palindrome is any single character, so the answer is 1. Example 3: Input:   s = ""b"", t = ""aaaa"" Output:  4 Explanation: Selecting "" aaaa "" from  t  is the longest palindrome, so the answer is 4. Example 4: Input:   s = ""abcde"", t = ""ecdba"" Output:  5 Explanation: Concatenating  ""abc""  from  s  and  ""ba""  from  t  results in  ""abcba"" , which is a palindrome of length 5.   Constraints: 1 <= s.length, t.length <= 30 s  and  t  consist of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming', 'Enumeration']",Média,Two Pointers,False
2076,process-restricted-friend-requests,https://leetcode.com/problems/process-restricted-friend-requests/,Process Restricted Friend Requests,"You are given an integer  n  indicating the number of people in a network. Each person is labeled from  0  to  n - 1 . You are also given a  0-indexed  2D integer array  restrictions , where  restrictions[i] = [x i , y i ]  means that person  x i  and person  y i   cannot  become  friends ,   either  directly  or  indirectly  through other people. Initially, no one is friends with each other. You are given a list of friend requests as a  0-indexed  2D integer array  requests , where  requests[j] = [u j , v j ]  is a friend request between person  u j  and person  v j . A friend request is  successful  if  u j  and  v j  can be  friends . Each friend request is processed in the given order (i.e.,  requests[j]  occurs before  requests[j + 1] ), and upon a successful request,  u j  and  v j   become direct friends  for all future friend requests. Return  a  boolean array   result ,  where each  result[j]  is  true  if the  j th  friend request is  successful  or  false  if it is not . Note:  If  u j  and  v j  are already direct friends, the request is still  successful .   Example 1: Input:  n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] Output:  [true,false] Explanation: Request 0: Person 0 and person 2 can be friends, so they become direct friends.  Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0). Example 2: Input:  n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] Output:  [true,false] Explanation: Request 0: Person 1 and person 2 can be friends, so they become direct friends. Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1). Example 3: Input:  n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] Output:  [true,false,true,false] Explanation: Request 0: Person 0 and person 4 can be friends, so they become direct friends. Request 1: Person 1 and person 2 cannot be friends since they are directly restricted. Request 2: Person 3 and person 1 can be friends, so they become direct friends. Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).   Constraints: 2 <= n <= 1000 0 <= restrictions.length <= 1000 restrictions[i].length == 2 0 <= x i , y i  <= n - 1 x i  != y i 1 <= requests.length <= 1000 requests[j].length == 2 0 <= u j , v j  <= n - 1 u j  != v j","['Union Find', 'Graph']",Difícil,Union Find,False
