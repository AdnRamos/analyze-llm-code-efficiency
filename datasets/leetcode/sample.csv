id,slug,url,titulo,enunciado,temas,dificuldade,tema_principal
924,minimize-malware-spread,https://leetcode.com/problems/minimize-malware-spread/,Minimize Malware Spread,"You are given a network of  n  nodes represented as an  n x n  adjacency matrix  graph , where the  i th  node is directly connected to the  j th  node if  graph[i][j] == 1 . Some nodes  initial  are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose  M(initial)  is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove  exactly one node  from  initial . Return the node that, if removed, would minimize  M(initial) . If multiple nodes could be removed to minimize  M(initial) , return such a node with  the smallest index . Note that if a node was removed from the  initial  list of infected nodes, it might still be infected later due to the malware spread.   Example 1: Input:  graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output:  0 Example 2: Input:  graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output:  0 Example 3: Input:  graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output:  1   Constraints: n == graph.length n == graph[i].length 2 <= n <= 300 graph[i][j]  is  0  or  1 . graph[i][j] == graph[j][i] graph[i][i] == 1 1 <= initial.length <= n 0 <= initial[i] <= n - 1 All the integers in  initial  are  unique .","['Array', 'Hash Table', 'Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Difícil,Array
1178,number-of-valid-words-for-each-puzzle,https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/,Number of Valid Words for Each Puzzle,"With respect to a given  puzzle  string, a  word  is  valid  if both the following conditions are satisfied: word  contains the first letter of  puzzle . For each letter in  word , that letter is in  puzzle . 	 For example, if the puzzle is  ""abcdefg"" , then valid words are  ""faced"" ,  ""cabbage"" , and  ""baggage"" , while invalid words are  ""beefed""  (does not include  'a' ) and  ""based""  (includes  's'  which is not in the puzzle). Return  an array  answer , where  answer[i]  is the number of words in the given word list  words  that is valid with respect to the puzzle  puzzles[i] .   Example 1: Input:  words = [""aaaa"",""asas"",""able"",""ability"",""actt"",""actor"",""access""], puzzles = [""aboveyz"",""abrodyz"",""abslute"",""absoryz"",""actresz"",""gaswxyz""] Output:  [1,1,3,2,4,0] Explanation:   1 valid word for ""aboveyz"" : ""aaaa""  1 valid word for ""abrodyz"" : ""aaaa"" 3 valid words for ""abslute"" : ""aaaa"", ""asas"", ""able"" 2 valid words for ""absoryz"" : ""aaaa"", ""asas"" 4 valid words for ""actresz"" : ""aaaa"", ""asas"", ""actt"", ""access"" There are no valid words for ""gaswxyz"" cause none of the words in the list contains letter 'g'. Example 2: Input:  words = [""apple"",""pleas"",""please""], puzzles = [""aelwxyz"",""aelpxyz"",""aelpsxy"",""saelpxy"",""xaelpsy""] Output:  [0,1,3,2,0]   Constraints: 1 <= words.length <= 10 5 4 <= words[i].length <= 50 1 <= puzzles.length <= 10 4 puzzles[i].length == 7 words[i]  and  puzzles[i]  consist of lowercase English letters. Each  puzzles[i]  does not contain repeated characters.","['Array', 'Hash Table', 'String', 'Bit Manipulation', 'Trie']",Difícil,Array
1425,constrained-subsequence-sum,https://leetcode.com/problems/constrained-subsequence-sum/,Constrained Subsequence Sum,"Given an integer array  nums  and an integer  k , return the maximum sum of a  non-empty  subsequence of that array such that for every two  consecutive  integers in the subsequence,  nums[i]  and  nums[j] , where  i < j , the condition  j - i <= k  is satisfied. A  subsequence  of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.   Example 1: Input:  nums = [10,2,-10,5,20], k = 2 Output:  37 Explanation:  The subsequence is [10, 2, 5, 20]. Example 2: Input:  nums = [-1,-2,-3], k = 1 Output:  -1 Explanation:  The subsequence must be non-empty, so we choose the largest number. Example 3: Input:  nums = [10,-2,-10,-5,20], k = 2 Output:  23 Explanation:  The subsequence is [10, -2, -5, 20].   Constraints: 1 <= k <= nums.length <= 10 5 -10 4  <= nums[i] <= 10 4","['Array', 'Dynamic Programming', 'Queue', 'Sliding Window', 'Heap (Priority Queue)', 'Monotonic Queue']",Difícil,Array
1439,find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows,https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/,Find the Kth Smallest Sum of a Matrix With Sorted Rows,"You are given an  m x n  matrix  mat  that has its rows sorted in non-decreasing order and an integer  k . You are allowed to choose  exactly one element  from each row to form an array. Return  the  k th  smallest array sum among all possible arrays .   Example 1: Input:  mat = [[1,3,11],[2,4,6]], k = 5 Output:  7 Explanation:  Choosing one element from each row, the first k smallest sum are: [1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7. Example 2: Input:  mat = [[1,3,11],[2,4,6]], k = 9 Output:  17 Example 3: Input:  mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7 Output:  9 Explanation:  Choosing one element from each row, the first k smallest sum are: [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.     Constraints: m == mat.length n == mat.length[i] 1 <= m, n <= 40 1 <= mat[i][j] <= 5000 1 <= k <= min(200, n m ) mat[i]  is a non-decreasing array.","['Array', 'Binary Search', 'Heap (Priority Queue)', 'Matrix']",Difícil,Array
1681,minimum-incompatibility,https://leetcode.com/problems/minimum-incompatibility/,Minimum Incompatibility,"You are given an integer array  nums ​​​ and an integer  k . You are asked to distribute this array into  k  subsets of  equal size  such that there are no two equal elements in the same subset. A subset's  incompatibility  is the difference between the maximum and minimum elements in that array. Return  the  minimum possible sum of incompatibilities  of the  k   subsets after distributing the array optimally, or return  -1  if it is not possible. A subset is a group integers that appear in the array with no particular order.   Example 1: Input:  nums = [1,2,1,4], k = 2 Output:  4 Explanation:  The optimal distribution of subsets is [1,2] and [1,4]. The incompatibility is (2-1) + (4-1) = 4. Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements. Example 2: Input:  nums = [6,3,8,1,3,1,2,2], k = 4 Output:  6 Explanation:  The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3]. The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6. Example 3: Input:  nums = [5,3,3,6,3,3], k = 3 Output:  -1 Explanation:  It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.   Constraints: 1 <= k <= nums.length <= 16 nums.length  is divisible by  k 1 <= nums[i] <= nums.length","['Array', 'Dynamic Programming', 'Bit Manipulation', 'Bitmask']",Difícil,Array
2132,stamping-the-grid,https://leetcode.com/problems/stamping-the-grid/,Stamping the Grid,"You are given an  m x n  binary matrix  grid  where each cell is either  0  (empty) or  1  (occupied). You are then given stamps of size  stampHeight x stampWidth . We want to fit the stamps such that they follow the given  restrictions  and  requirements : Cover all the  empty  cells. Do not cover any of the  occupied  cells. We can put as  many  stamps as we want. Stamps can  overlap  with each other. Stamps are not allowed to be  rotated . Stamps must stay completely  inside  the grid. Return  true   if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return   false .   Example 1: Input:  grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 Output:  true Explanation:  We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. Example 2: Input:  grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2  Output:  false  Explanation:  There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.   Constraints: m == grid.length n == grid[r].length 1 <= m, n <= 10 5 1 <= m * n <= 2 * 10 5 grid[r][c]  is either  0  or  1 . 1 <= stampHeight, stampWidth <= 10 5","['Array', 'Greedy', 'Matrix', 'Prefix Sum']",Difícil,Array
2306,naming-a-company,https://leetcode.com/problems/naming-a-company/,Naming a Company,"You are given an array of strings  ideas  that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows: Choose 2  distinct  names from  ideas , call them  idea A  and  idea B . Swap the first letters of  idea A  and  idea B  with each other. If  both  of the new names are not found in the original  ideas , then the name  idea A  idea B  (the  concatenation  of  idea A  and  idea B , separated by a space) is a valid company name. Otherwise, it is not a valid name. Return  the number of  distinct  valid names for the company .   Example 1: Input:  ideas = [""coffee"",""donuts"",""time"",""toffee""] Output:  6 Explanation:  The following selections are valid: - (""coffee"", ""donuts""): The company name created is ""doffee conuts"". - (""donuts"", ""coffee""): The company name created is ""conuts doffee"". - (""donuts"", ""time""): The company name created is ""tonuts dime"". - (""donuts"", ""toffee""): The company name created is ""tonuts doffee"". - (""time"", ""donuts""): The company name created is ""dime tonuts"". - (""toffee"", ""donuts""): The company name created is ""doffee tonuts"". Therefore, there are a total of 6 distinct company names. The following are some examples of invalid selections: - (""coffee"", ""time""): The name ""toffee"" formed after swapping already exists in the original array. - (""time"", ""toffee""): Both names are still the same after swapping and exist in the original array. - (""coffee"", ""toffee""): Both names formed after swapping already exist in the original array. Example 2: Input:  ideas = [""lack"",""back""] Output:  0 Explanation:  There are no valid selections. Therefore, 0 is returned.   Constraints: 2 <= ideas.length <= 5 * 10 4 1 <= ideas[i].length <= 10 ideas[i]  consists of lowercase English letters. All the strings in  ideas  are  unique .","['Array', 'Hash Table', 'String', 'Bit Manipulation', 'Enumeration']",Difícil,Array
2449,minimum-number-of-operations-to-make-arrays-similar,https://leetcode.com/problems/minimum-number-of-operations-to-make-arrays-similar/,Minimum Number of Operations to Make Arrays Similar,"You are given two positive integer arrays  nums  and  target , of the same length. In one operation, you can choose any two  distinct  indices  i  and  j  where  0 <= i, j < nums.length  and: set  nums[i] = nums[i] + 2  and set  nums[j] = nums[j] - 2 . Two arrays are considered to be  similar  if the frequency of each element is the same. Return  the minimum number of operations required to make  nums  similar to  target . The test cases are generated such that  nums  can always be similar to  target .   Example 1: Input:  nums = [8,12,6], target = [2,14,10] Output:  2 Explanation:  It is possible to make nums similar to target in two operations: - Choose i = 0 and j = 2, nums = [10,12,4]. - Choose i = 1 and j = 2, nums = [10,14,2]. It can be shown that 2 is the minimum number of operations needed. Example 2: Input:  nums = [1,2,5], target = [4,1,3] Output:  1 Explanation:  We can make nums similar to target in one operation: - Choose i = 1 and j = 2, nums = [1,4,3]. Example 3: Input:  nums = [1,1,1,1,1], target = [1,1,1,1,1] Output:  0 Explanation:  The array nums is already similiar to target.   Constraints: n == nums.length == target.length 1 <= n <= 10 5 1 <= nums[i], target[i] <= 10 6 It is possible to make  nums  similar to  target .","['Array', 'Greedy', 'Sorting']",Difícil,Array
26,remove-duplicates-from-sorted-array,https://leetcode.com/problems/remove-duplicates-from-sorted-array/,Remove Duplicates from Sorted Array,"Given an integer array  nums  sorted in  non-decreasing order , remove the duplicates  in-place  such that each unique element appears only  once . The  relative order  of the elements should be kept the  same . Then return  the number of unique elements in  nums . Consider the number of unique elements of  nums  to be  k , to get accepted, you need to do the following things: Change the array  nums  such that the first  k  elements of  nums  contain the unique elements in the order they were present in  nums  initially. The remaining elements of  nums  are not important as well as the size of  nums . Return  k . Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) {     assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be  accepted .   Example 1: Input:  nums = [1,1,2] Output:  2, nums = [1,2,_] Explanation:  Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input:  nums = [0,0,1,1,1,2,2,3,3,4] Output:  5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation:  Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).   Constraints: 1 <= nums.length <= 3 * 10 4 -100 <= nums[i] <= 100 nums  is sorted in  non-decreasing  order.","['Array', 'Two Pointers']",Fácil,Array
27,remove-element,https://leetcode.com/problems/remove-element/,Remove Element,"Given an integer array  nums  and an integer  val , remove all occurrences of  val  in  nums   in-place . The order of the elements may be changed. Then return  the number of elements in  nums  which are not equal to  val . Consider the number of elements in  nums  which are not equal to  val  be  k , to get accepted, you need to do the following things: Change the array  nums  such that the first  k  elements of  nums  contain the elements which are not equal to  val . The remaining elements of  nums  are not important as well as the size of  nums . Return  k . Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length.                             // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i < actualLength; i++) {     assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be  accepted .   Example 1: Input:  nums = [3,2,2,3], val = 3 Output:  2, nums = [2,2,_,_] Explanation:  Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input:  nums = [0,1,2,2,3,0,4,2], val = 2 Output:  5, nums = [0,1,4,0,3,_,_,_] Explanation:  Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores).   Constraints: 0 <= nums.length <= 100 0 <= nums[i] <= 50 0 <= val <= 100","['Array', 'Two Pointers']",Fácil,Array
944,delete-columns-to-make-sorted,https://leetcode.com/problems/delete-columns-to-make-sorted/,Delete Columns to Make Sorted,"You are given an array of  n  strings  strs , all of the same length. The strings can be arranged such that there is one on each line, making a grid. For example,  strs = [""abc"", ""bce"", ""cae""]  can be arranged as follows: abc bce cae You want to  delete  the columns that are  not sorted lexicographically . In the above example ( 0-indexed ), columns 0 ( 'a' ,  'b' ,  'c' ) and 2 ( 'c' ,  'e' ,  'e' ) are sorted, while column 1 ( 'b' ,  'c' ,  'a' ) is not, so you would delete column 1. Return  the number of columns that you will delete .   Example 1: Input:  strs = [""cba"",""daf"",""ghi""] Output:  1 Explanation:  The grid looks as follows:   cba   daf   ghi Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column. Example 2: Input:  strs = [""a"",""b""] Output:  0 Explanation:  The grid looks as follows:   a   b Column 0 is the only column and is sorted, so you will not delete any columns. Example 3: Input:  strs = [""zyx"",""wvu"",""tsr""] Output:  3 Explanation:  The grid looks as follows:   zyx   wvu   tsr All 3 columns are not sorted, so you will delete all 3.   Constraints: n == strs.length 1 <= n <= 100 1 <= strs[i].length <= 1000 strs[i]  consists of lowercase English letters.","['Array', 'String']",Fácil,Array
953,verifying-an-alien-dictionary,https://leetcode.com/problems/verifying-an-alien-dictionary/,Verifying an Alien Dictionary,"In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different  order . The  order  of the alphabet is some permutation of lowercase letters. Given a sequence of  words  written in the alien language, and the  order  of the alphabet, return  true  if and only if the given  words  are sorted lexicographically in this alien language.   Example 1: Input:  words = [""hello"",""leetcode""], order = ""hlabcdefgijkmnopqrstuvwxyz"" Output:  true Explanation:  As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input:  words = [""word"",""world"",""row""], order = ""worldabcefghijkmnpqstuvxyz"" Output:  false Explanation:  As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted. Example 3: Input:  words = [""apple"",""app""], order = ""abcdefghijklmnopqrstuvwxyz"" Output:  false Explanation:  The first three characters ""app"" match, and the second string is shorter (in size.) According to lexicographical rules ""apple"" > ""app"", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character ( More info ).   Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 20 order.length == 26 All characters in  words[i]  and  order  are English lowercase letters.","['Array', 'Hash Table', 'String']",Fácil,Array
1480,running-sum-of-1d-array,https://leetcode.com/problems/running-sum-of-1d-array/,Running Sum of 1d Array,"Given an array  nums . We define a running sum of an array as  runningSum[i] = sum(nums[0]…nums[i]) . Return the running sum of  nums .   Example 1: Input:  nums = [1,2,3,4] Output:  [1,3,6,10] Explanation:  Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2: Input:  nums = [1,1,1,1,1] Output:  [1,2,3,4,5] Explanation:  Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3: Input:  nums = [3,1,2,10,1] Output:  [3,4,6,16,17]   Constraints: 1 <= nums.length <= 1000 -10^6 <= nums[i] <= 10^6","['Array', 'Prefix Sum']",Fácil,Array
1491,average-salary-excluding-the-minimum-and-maximum-salary,https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/,Average Salary Excluding the Minimum and Maximum Salary,"You are given an array of  unique  integers  salary  where  salary[i]  is the salary of the  i th  employee. Return  the average salary of employees excluding the minimum and maximum salary . Answers within  10 -5  of the actual answer will be accepted.   Example 1: Input:  salary = [4000,3000,1000,2000] Output:  2500.00000 Explanation:  Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 Example 2: Input:  salary = [1000,2000,3000] Output:  2000.00000 Explanation:  Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000   Constraints: 3 <= salary.length <= 100 1000 <= salary[i] <= 10 6 All the integers of  salary  are  unique .","['Array', 'Sorting']",Fácil,Array
1502,can-make-arithmetic-progression-from-sequence,https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/,Can Make Arithmetic Progression From Sequence,"A sequence of numbers is called an  arithmetic progression  if the difference between any two consecutive elements is the same. Given an array of numbers  arr , return  true   if the array can be rearranged to form an  arithmetic progression . Otherwise, return   false .   Example 1: Input:  arr = [3,5,1] Output:  true Explanation:  We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements. Example 2: Input:  arr = [1,2,4] Output:  false Explanation:  There is no way to reorder the elements to obtain an arithmetic progression.   Constraints: 2 <= arr.length <= 1000 -10 6  <= arr[i] <= 10 6","['Array', 'Sorting']",Fácil,Array
1512,number-of-good-pairs,https://leetcode.com/problems/number-of-good-pairs/,Number of Good Pairs,"Given an array of integers  nums , return  the number of  good pairs . A pair  (i, j)  is called  good  if  nums[i] == nums[j]  and  i  <  j .   Example 1: Input:  nums = [1,2,3,1,1,3] Output:  4 Explanation:  There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2: Input:  nums = [1,1,1,1] Output:  6 Explanation:  Each pair in the array are  good . Example 3: Input:  nums = [1,2,3] Output:  0   Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100","['Array', 'Hash Table', 'Math', 'Counting']",Fácil,Array
78,subsets,https://leetcode.com/problems/subsets/,Subsets,"Given an integer array  nums  of  unique  elements, return  all possible   subsets   (the power set) . The solution set  must not  contain duplicate subsets. Return the solution in  any order .   Example 1: Input:  nums = [1,2,3] Output:  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2: Input:  nums = [0] Output:  [[],[0]]   Constraints: 1 <= nums.length <= 10 -10 <= nums[i] <= 10 All the numbers of  nums  are  unique .","['Array', 'Backtracking', 'Bit Manipulation']",Média,Array
1040,moving-stones-until-consecutive-ii,https://leetcode.com/problems/moving-stones-until-consecutive-ii/,Moving Stones Until Consecutive II,"There are some stones in different positions on the X-axis. You are given an integer array  stones , the positions of the stones. Call a stone an  endpoint stone  if it has the smallest or largest position. In one move, you pick up an  endpoint stone  and move it to an unoccupied position so that it is no longer an  endpoint stone . In particular, if the stones are at say,  stones = [1,2,5] , you cannot move the endpoint stone at position  5 , since moving it to any position (such as  0 , or  3 ) will still keep that stone as an endpoint stone. The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions). Return  an integer array  answer  of length  2  where : answer[0]   is the minimum number of moves you can play, and answer[1]   is the maximum number of moves you can play .   Example 1: Input:  stones = [7,4,9] Output:  [1,2] Explanation:  We can move 4 -> 8 for one move to finish the game. Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game. Example 2: Input:  stones = [6,5,4,3,10] Output:  [2,3] Explanation:  We can move 3 -> 8 then 10 -> 7 to finish the game. Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game. Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.   Constraints: 3 <= stones.length <= 10 4 1 <= stones[i] <= 10 9 All the values of  stones  are  unique .","['Array', 'Math', 'Sliding Window', 'Sorting']",Média,Array
1162,as-far-from-land-as-possible,https://leetcode.com/problems/as-far-from-land-as-possible/,As Far from Land as Possible,"Given an  n x n   grid  containing only values  0  and  1 , where  0  represents water and  1  represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return  -1 . The distance used in this problem is the Manhattan distance: the distance between two cells  (x0, y0)  and  (x1, y1)  is  |x0 - x1| + |y0 - y1| .   Example 1: Input:  grid = [[1,0,1],[0,0,0],[1,0,1]] Output:  2 Explanation:  The cell (1, 1) is as far as possible from all the land with distance 2. Example 2: Input:  grid = [[1,0,0],[0,0,0],[0,0,0]] Output:  4 Explanation:  The cell (2, 2) is as far as possible from all the land with distance 4.   Constraints: n == grid.length n == grid[i].length 1 <= n <= 100 grid[i][j]  is  0  or  1","['Array', 'Dynamic Programming', 'Breadth-First Search', 'Matrix']",Média,Array
1705,maximum-number-of-eaten-apples,https://leetcode.com/problems/maximum-number-of-eaten-apples/,Maximum Number of Eaten Apples,"There is a special kind of apple tree that grows apples every day for  n  days. On the  i th  day, the tree grows  apples[i]  apples that will rot after  days[i]  days, that is on day  i + days[i]  the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by  apples[i] == 0  and  days[i] == 0 . You decided to eat  at most  one apple a day (to keep the doctors away). Note that you can keep eating after the first  n  days. Given two integer arrays  days  and  apples  of length  n , return  the maximum number of apples you can eat.   Example 1: Input:  apples = [1,2,3,5,2], days = [3,2,1,4,2] Output:  7 Explanation:  You can eat 7 apples: - On the first day, you eat an apple that grew on the first day. - On the second day, you eat an apple that grew on the second day. - On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot. - On the fourth to the seventh days, you eat apples that grew on the fourth day. Example 2: Input:  apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] Output:  5 Explanation:  You can eat 5 apples: - On the first to the third day you eat apples that grew on the first day. - Do nothing on the fouth and fifth days. - On the sixth and seventh days you eat apples that grew on the sixth day.   Constraints: n == apples.length == days.length 1 <= n <= 2 * 10 4 0 <= apples[i], days[i] <= 2 * 10 4 days[i] = 0  if and only if  apples[i] = 0 .","['Array', 'Greedy', 'Heap (Priority Queue)']",Média,Array
1711,count-good-meals,https://leetcode.com/problems/count-good-meals/,Count Good Meals,"A  good meal  is a meal that contains  exactly two different food items  with a sum of deliciousness equal to a power of two. You can pick  any  two different foods to make a good meal. Given an array of integers  deliciousness  where  deliciousness[i]  is the deliciousness of the  i ​​​​​​th ​​​​ ​​​​ item of food, return  the number of different  good meals  you can make from this list modulo   10 9  + 7 . Note that items with different indices are considered different even if they have the same deliciousness value.   Example 1: Input:  deliciousness = [1,3,5,7,9] Output:  4 Explanation:  The good meals are (1,3), (1,7), (3,5) and, (7,9). Their respective sums are 4, 8, 8, and 16, all of which are powers of 2. Example 2: Input:  deliciousness = [1,1,1,3,3,3,7] Output:  15 Explanation:  The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.   Constraints: 1 <= deliciousness.length <= 10 5 0 <= deliciousness[i] <= 2 20","['Array', 'Hash Table']",Média,Array
1712,ways-to-split-array-into-three-subarrays,https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/,Ways to Split Array Into Three Subarrays,"A split of an integer array is  good  if: The array is split into three  non-empty  contiguous subarrays - named  left ,  mid ,  right  respectively from left to right. The sum of the elements in  left  is less than or equal to the sum of the elements in  mid , and the sum of the elements in  mid  is less than or equal to the sum of the elements in  right . Given  nums , an array of  non-negative  integers, return  the number of  good  ways to split   nums . As the number may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:  nums = [1,1,1] Output:  1 Explanation:  The only good way to split nums is [1] [1] [1]. Example 2: Input:  nums = [1,2,2,2,5,0] Output:  3 Explanation:  There are three good ways of splitting nums: [1] [2] [2,2,5,0] [1] [2,2] [2,5,0] [1,2] [2,2] [5,0] Example 3: Input:  nums = [3,2,1] Output:  0 Explanation:  There is no good way to split nums.   Constraints: 3 <= nums.length <= 10 5 0 <= nums[i] <= 10 4","['Array', 'Two Pointers', 'Binary Search', 'Prefix Sum']",Média,Array
1722,minimize-hamming-distance-after-swap-operations,https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/,Minimize Hamming Distance After Swap Operations,"You are given two integer arrays,  source  and  target , both of length  n . You are also given an array  allowedSwaps  where each  allowedSwaps[i] = [a i , b i ]  indicates that you are allowed to swap the elements at index  a i  and index  b i   (0-indexed)  of array  source . Note that you can swap elements at a specific pair of indices  multiple  times and in  any  order. The  Hamming distance  of two arrays of the same length,  source  and  target , is the number of positions where the elements are different. Formally, it is the number of indices  i  for  0 <= i <= n-1  where  source[i] != target[i]   (0-indexed) . Return  the  minimum Hamming distance  of  source  and  target  after performing  any  amount of swap operations on array  source .   Example 1: Input:  source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output:  1 Explanation:  source can be transformed the following way: - Swap indices 0 and 1: source = [ 2 , 1 ,3,4] - Swap indices 2 and 3: source = [2,1, 4 , 3 ] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example 2: Input:  source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output:  2 Explanation:  There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. Example 3: Input:  source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] Output:  0   Constraints: n == source.length == target.length 1 <= n <= 10 5 1 <= source[i], target[i] <= 10 5 0 <= allowedSwaps.length <= 10 5 allowedSwaps[i].length == 2 0 <= a i , b i  <= n - 1 a i  != b i","['Array', 'Depth-First Search', 'Union Find']",Média,Array
1936,add-minimum-number-of-rungs,https://leetcode.com/problems/add-minimum-number-of-rungs/,Add Minimum Number of Rungs,"You are given a  strictly increasing  integer array  rungs  that represents the  height  of rungs on a ladder. You are currently on the  floor  at height  0 , and you want to reach the last rung. You are also given an integer  dist . You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is  at most   dist . You are able to insert rungs at any positive  integer  height if a rung is not already there. Return  the  minimum  number of rungs that must be added to the ladder in order for you to climb to the last rung.   Example 1: Input:  rungs = [1,3,5,10], dist = 2 Output:  2 Explanation: You currently cannot reach the last rung. Add rungs at heights 7 and 8 to climb this ladder.  The ladder will now have rungs at [1,3,5, 7 , 8 ,10]. Example 2: Input:  rungs = [3,6,8,10], dist = 3 Output:  0 Explanation: This ladder can be climbed without adding additional rungs. Example 3: Input:  rungs = [3,4,6,7], dist = 2 Output:  1 Explanation: You currently cannot reach the first rung from the ground. Add a rung at height 1 to climb this ladder. The ladder will now have rungs at [ 1 ,3,4,6,7].   Constraints: 1 <= rungs.length <= 10 5 1 <= rungs[i] <= 10 9 1 <= dist <= 10 9 rungs  is  strictly increasing .","['Array', 'Greedy']",Média,Array
1937,maximum-number-of-points-with-cost,https://leetcode.com/problems/maximum-number-of-points-with-cost/,Maximum Number of Points with Cost,"You are given an  m x n  integer matrix  points  ( 0-indexed ). Starting with  0  points, you want to  maximize  the number of points you can get from the matrix. To gain points, you must pick one cell in  each row . Picking the cell at coordinates  (r, c)  will  add   points[r][c]  to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows  r  and  r + 1  (where  0 <= r < m - 1 ), picking cells at coordinates  (r, c 1 )  and  (r + 1, c 2 )  will  subtract   abs(c 1  - c 2 )  from your score. Return  the  maximum  number of points you can achieve . abs(x)  is defined as: x  for  x >= 0 . -x  for  x < 0 .   Example 1:   Input:  points = [[1,2,3],[1,5,1],[3,1,1]] Output:  9 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9. Example 2: Input:  points = [[1,5],[2,3],[4,2]] Output:  11 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12 to your score. However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score. Your final score is 12 - 1 = 11.   Constraints: m == points.length n == points[r].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 0 <= points[r][c] <= 10 5","['Array', 'Dynamic Programming', 'Matrix']",Média,Array
2212,maximum-points-in-an-archery-competition,https://leetcode.com/problems/maximum-points-in-an-archery-competition/,Maximum Points in an Archery Competition,"Alice and Bob are opponents in an archery competition. The competition has set the following rules: Alice first shoots  numArrows  arrows and then Bob shoots  numArrows  arrows. The points are then calculated as follows: 	 The target has integer scoring sections ranging from  0  to  11   inclusive . For  each  section of the target with score  k  (in between  0  to  11 ), say Alice and Bob have shot  a k  and  b k  arrows on that section respectively. If  a k  >= b k , then Alice takes  k  points. If  a k  < b k , then Bob takes  k  points. However, if  a k  == b k  == 0 , then  nobody  takes  k  points. For example, if Alice and Bob both shot  2  arrows on the section with score  11 , then Alice takes  11  points. On the other hand, if Alice shot  0  arrows on the section with score  11  and Bob shot  2  arrows on that same section, then Bob takes  11  points. You are given the integer  numArrows  and an integer array  aliceArrows  of size  12 , which represents the number of arrows Alice shot on each scoring section from  0  to  11 . Now, Bob wants to  maximize  the total number of points he can obtain. Return  the array  bobArrows  which represents the number of arrows Bob shot on  each  scoring section from  0  to  11 . The sum of the values in  bobArrows  should equal  numArrows . If there are multiple ways for Bob to earn the maximum total points, return  any  one of them.   Example 1: Input:  numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0] Output:  [0,0,0,0,1,1,0,0,1,2,3,1] Explanation:  The table above shows how the competition is scored.  Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47. It can be shown that Bob cannot obtain a score higher than 47 points. Example 2: Input:  numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2] Output:  [0,0,0,0,0,0,0,0,1,1,1,0] Explanation:  The table above shows how the competition is scored. Bob earns a total point of 8 + 9 + 10 = 27. It can be shown that Bob cannot obtain a score higher than 27 points.   Constraints: 1 <= numArrows <= 10 5 aliceArrows.length == bobArrows.length == 12 0 <= aliceArrows[i], bobArrows[i] <= numArrows sum(aliceArrows[i]) == numArrows","['Array', 'Backtracking', 'Bit Manipulation', 'Enumeration']",Média,Array
2233,maximum-product-after-k-increments,https://leetcode.com/problems/maximum-product-after-k-increments/,Maximum Product After K Increments,"You are given an array of non-negative integers  nums  and an integer  k . In one operation, you may choose  any  element from  nums  and  increment  it by  1 . Return  the  maximum   product  of  nums  after  at most   k  operations.  Since the answer may be very large, return it  modulo   10 9  + 7 . Note that you should maximize the product before taking the modulo.    Example 1: Input:  nums = [0,4], k = 5 Output:  20 Explanation:  Increment the first number 5 times. Now nums = [5, 4], with a product of 5 * 4 = 20. It can be shown that 20 is maximum product possible, so we return 20. Note that there may be other ways to increment nums to have the maximum product. Example 2: Input:  nums = [6,3,3,2], k = 2 Output:  216 Explanation:  Increment the second number 1 time and increment the fourth number 1 time. Now nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216. It can be shown that 216 is maximum product possible, so we return 216. Note that there may be other ways to increment nums to have the maximum product.   Constraints: 1 <= nums.length, k <= 10 5 0 <= nums[i] <= 10 6","['Array', 'Greedy', 'Heap (Priority Queue)']",Média,Array
2249,count-lattice-points-inside-a-circle,https://leetcode.com/problems/count-lattice-points-inside-a-circle/,Count Lattice Points Inside a Circle,"Given a 2D integer array  circles  where  circles[i] = [x i , y i , r i ]  represents the center  (x i , y i )  and radius  r i  of the  i th  circle drawn on a grid, return  the  number of lattice points   that are present inside  at least one  circle . Note: A  lattice point  is a point with integer coordinates. Points that lie  on the circumference of a circle  are also considered to be inside it.   Example 1: Input:  circles = [[2,2,1]] Output:  5 Explanation: The figure above shows the given circle. The lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green. Other points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle. Hence, the number of lattice points present inside at least one circle is 5. Example 2: Input:  circles = [[2,2,2],[3,4,1]] Output:  16 Explanation: The figure above shows the given circles. There are exactly 16 lattice points which are present inside at least one circle.  Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).   Constraints: 1 <= circles.length <= 200 circles[i].length == 3 1 <= x i , y i  <= 100 1 <= r i  <= min(x i , y i )","['Array', 'Hash Table', 'Math', 'Geometry', 'Enumeration']",Média,Array
2250,count-number-of-rectangles-containing-each-point,https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/,Count Number of Rectangles Containing Each Point,"You are given a 2D integer array  rectangles  where  rectangles[i] = [l i , h i ]  indicates that  i th  rectangle has a length of  l i  and a height of  h i . You are also given a 2D integer array  points  where  points[j] = [x j , y j ]  is a point with coordinates  (x j , y j ) . The  i th  rectangle has its  bottom-left corner  point at the coordinates  (0, 0)  and its  top-right corner  point at  (l i , h i ) . Return  an integer array  count  of length  points.length  where  count[j]  is the number of rectangles that  contain  the  j th  point. The  i th  rectangle  contains  the  j th  point if  0 <= x j  <= l i  and  0 <= y j  <= h i . Note that points that lie on the  edges  of a rectangle are also considered to be contained by that rectangle.   Example 1: Input:  rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]] Output:  [2,1] Explanation:   The first rectangle contains no points. The second rectangle contains only the point (2, 1). The third rectangle contains the points (2, 1) and (1, 4). The number of rectangles that contain the point (2, 1) is 2. The number of rectangles that contain the point (1, 4) is 1. Therefore, we return [2, 1]. Example 2: Input:  rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]] Output:  [1,3] Explanation: The first rectangle contains only the point (1, 1). The second rectangle contains only the point (1, 1). The third rectangle contains the points (1, 3) and (1, 1). The number of rectangles that contain the point (1, 3) is 1. The number of rectangles that contain the point (1, 1) is 3. Therefore, we return [1, 3].   Constraints: 1 <= rectangles.length, points.length <= 5 * 10 4 rectangles[i].length == points[j].length == 2 1 <= l i , x j  <= 10 9 1 <= h i , y j  <= 100 All the  rectangles  are  unique . All the  points  are  unique .","['Array', 'Hash Table', 'Binary Search', 'Binary Indexed Tree', 'Sorting']",Média,Array
2861,maximum-number-of-alloys,https://leetcode.com/problems/maximum-number-of-alloys/,Maximum Number of Alloys,"You are the owner of a company that creates alloys using various types of metals. There are  n  different types of metals available, and you have access to  k  machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy. For the  i th  machine to create an alloy, it needs  composition[i][j]  units of metal of type  j . Initially, you have  stock[i]  units of metal type  i , and purchasing one unit of metal type  i  costs  cost[i]  coins. Given integers  n ,  k ,  budget , a  1-indexed  2D array  composition , and  1-indexed  arrays  stock  and  cost , your goal is to  maximize  the number of alloys the company can create while staying within the budget of  budget  coins. All alloys must be created with the same machine. Return  the maximum number of alloys that the company can create .   Example 1: Input:  n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3] Output:  2 Explanation:  It is optimal to use the 1 st  machine to create alloys. To create 2 alloys we need to buy the: - 2 units of metal of the 1 st  type. - 2 units of metal of the 2 nd  type. - 2 units of metal of the 3 rd  type. In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is smaller than or equal to budget = 15. Notice that we have 0 units of metal of each type and we have to buy all the required units of metal. It can be proven that we can create at most 2 alloys. Example 2: Input:  n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3] Output:  5 Explanation:  It is optimal to use the 2 nd  machine to create alloys. To create 5 alloys we need to buy: - 5 units of metal of the 1 st  type. - 5 units of metal of the 2 nd  type. - 0 units of metal of the 3 rd  type. In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is smaller than or equal to budget = 15. It can be proven that we can create at most 5 alloys. Example 3: Input:  n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5] Output:  2 Explanation:  It is optimal to use the 3 rd  machine to create alloys. To create 2 alloys we need to buy the: - 1 unit of metal of the 1 st  type. - 1 unit of metal of the 2 nd  type. In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller than or equal to budget = 10. It can be proven that we can create at most 2 alloys.   Constraints: 1 <= n, k <= 100 0 <= budget <= 10 8 composition.length == k composition[i].length == n 1 <= composition[i][j] <= 100 stock.length == cost.length == n 0 <= stock[i] <= 10 8 1 <= cost[i] <= 100","['Array', 'Binary Search']",Média,Array
2918,minimum-equal-sum-of-two-arrays-after-replacing-zeros,https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/,Minimum Equal Sum of Two Arrays After Replacing Zeros,"You are given two arrays  nums1  and  nums2  consisting of positive integers. You have to replace  all  the  0 's in both arrays with  strictly  positive integers such that the sum of elements of both arrays becomes  equal . Return  the  minimum  equal sum you can obtain, or  -1  if it is impossible .   Example 1: Input:  nums1 = [3,2,0,1,0], nums2 = [6,5,0] Output:  12 Explanation:  We can replace 0's in the following way: - Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4]. - Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1]. Both arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain. Example 2: Input:  nums1 = [2,0,2,0], nums2 = [1,4] Output:  -1 Explanation:  It is impossible to make the sum of both arrays equal.   Constraints: 1 <= nums1.length, nums2.length <= 10 5 0 <= nums1[i], nums2[i] <= 10 6","['Array', 'Greedy']",Média,Array
2919,minimum-increment-operations-to-make-array-beautiful,https://leetcode.com/problems/minimum-increment-operations-to-make-array-beautiful/,Minimum Increment Operations to Make Array Beautiful,"You are given a  0-indexed  integer array  nums  having length  n , and an integer  k . You can perform the following  increment  operation  any  number of times ( including zero ): Choose an index  i  in the range  [0, n - 1] , and increase  nums[i]  by  1 . An array is considered  beautiful  if, for any  subarray  with a size of  3  or  more , its  maximum  element is  greater than or equal  to  k . Return  an integer denoting the  minimum  number of increment operations needed to make  nums   beautiful . A subarray is a contiguous  non-empty  sequence of elements within an array.   Example 1: Input:  nums = [2,3,0,0,2], k = 4 Output:  3 Explanation:  We can perform the following increment operations to make nums beautiful: Choose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2]. Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3]. Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4]. The subarrays with a size of 3 or more are: [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4]. In all the subarrays, the maximum element is equal to k = 4, so nums is now beautiful. It can be shown that nums cannot be made beautiful with fewer than 3 increment operations. Hence, the answer is 3. Example 2: Input:  nums = [0,1,3,3], k = 5 Output:  2 Explanation:  We can perform the following increment operations to make nums beautiful: Choose index i = 2 and increase nums[2] by 1 -> [0,1,4,3]. Choose index i = 2 and increase nums[2] by 1 -> [0,1,5,3]. The subarrays with a size of 3 or more are: [0,1,5], [1,5,3], [0,1,5,3]. In all the subarrays, the maximum element is equal to k = 5, so nums is now beautiful. It can be shown that nums cannot be made beautiful with fewer than 2 increment operations. Hence, the answer is 2. Example 3: Input:  nums = [1,1,2], k = 1 Output:  0 Explanation:  The only subarray with a size of 3 or more in this example is [1,1,2]. The maximum element, 2, is already greater than k = 1, so we don't need any increment operation. Hence, the answer is 0.   Constraints: 3 <= n == nums.length <= 10 5 0 <= nums[i] <= 10 9 0 <= k <= 10 9","['Array', 'Dynamic Programming']",Média,Array
52,n-queens-ii,https://leetcode.com/problems/n-queens-ii/,N-Queens II,"The  n-queens  puzzle is the problem of placing  n  queens on an  n x n  chessboard such that no two queens attack each other. Given an integer  n , return  the number of distinct solutions to the  n-queens puzzle .   Example 1: Input:  n = 4 Output:  2 Explanation:  There are two distinct solutions to the 4-queens puzzle as shown. Example 2: Input:  n = 1 Output:  1   Constraints: 1 <= n <= 9",['Backtracking'],Difícil,Backtracking
1240,tiling-a-rectangle-with-the-fewest-squares,https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/,Tiling a Rectangle with the Fewest Squares,"Given a rectangle of size  n  x  m , return  the minimum number of integer-sided squares that tile the rectangle .   Example 1: Input:  n = 2, m = 3 Output:  3 Explanation:   3  squares are necessary to cover the rectangle. 2  (squares of  1x1 ) 1  (square of  2x2 ) Example 2: Input:  n = 5, m = 8 Output:  5 Example 3: Input:  n = 11, m = 13 Output:  6   Constraints: 1 <= n, m <= 13",['Backtracking'],Difícil,Backtracking
401,binary-watch,https://leetcode.com/problems/binary-watch/,Binary Watch,"A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the below binary watch reads  ""4:51"" . Given an integer  turnedOn  which represents the number of LEDs that are currently on (ignoring the PM), return  all possible times the watch could represent . You may return the answer in  any order . The hour must not contain a leading zero. For example,  ""01:00""  is not valid. It should be  ""1:00"" . The minute must consist of two digits and may contain a leading zero. For example,  ""10:2""  is not valid. It should be  ""10:02"" .   Example 1: Input:  turnedOn = 1 Output:  [""0:01"",""0:02"",""0:04"",""0:08"",""0:16"",""0:32"",""1:00"",""2:00"",""4:00"",""8:00""] Example 2: Input:  turnedOn = 9 Output:  []   Constraints: 0 <= turnedOn <= 10","['Backtracking', 'Bit Manipulation']",Fácil,Backtracking
77,combinations,https://leetcode.com/problems/combinations/,Combinations,"Given two integers  n  and  k , return  all possible combinations of   k   numbers chosen from the range   [1, n] . You may return the answer in  any order .   Example 1: Input:  n = 4, k = 2 Output:  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Explanation:  There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination. Example 2: Input:  n = 1, k = 1 Output:  [[1]] Explanation:  There is 1 choose 1 = 1 total combination.   Constraints: 1 <= n <= 20 1 <= k <= n",['Backtracking'],Média,Backtracking
113,path-sum-ii,https://leetcode.com/problems/path-sum-ii/,Path Sum II,"Given the  root  of a binary tree and an integer  targetSum , return  all  root-to-leaf  paths where the sum of the node values in the path equals  targetSum . Each path should be returned as a list of the node  values , not node references . A  root-to-leaf  path is a path starting from the root and ending at any leaf node. A  leaf  is a node with no children.   Example 1: Input:  root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output:  [[5,4,11,2],[5,8,4,5]] Explanation:  There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 Example 2: Input:  root = [1,2,3], targetSum = 5 Output:  [] Example 3: Input:  root = [1,2], targetSum = 0 Output:  []   Constraints: The number of nodes in the tree is in the range  [0, 5000] . -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000","['Backtracking', 'Tree', 'Depth-First Search', 'Binary Tree']",Média,Backtracking
797,all-paths-from-source-to-target,https://leetcode.com/problems/all-paths-from-source-to-target/,All Paths From Source to Target,"Given a directed acyclic graph ( DAG ) of  n  nodes labeled from  0  to  n - 1 , find all possible paths from node  0  to node  n - 1  and return them in  any order . The graph is given as follows:  graph[i]  is a list of all nodes you can visit from node  i  (i.e., there is a directed edge from node  i  to node  graph[i][j] ).   Example 1: Input:  graph = [[1,2],[3],[3],[]] Output:  [[0,1,3],[0,2,3]] Explanation:  There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3. Example 2: Input:  graph = [[4,3,1],[3,2,4],[3],[4],[]] Output:  [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]   Constraints: n == graph.length 2 <= n <= 15 0 <= graph[i][j] < n graph[i][j] != i  (i.e., there will be no self-loops). All the elements of  graph[i]  are  unique . The input graph is  guaranteed  to be a  DAG .","['Backtracking', 'Depth-First Search', 'Breadth-First Search', 'Graph']",Média,Backtracking
967,numbers-with-same-consecutive-differences,https://leetcode.com/problems/numbers-with-same-consecutive-differences/,Numbers With Same Consecutive Differences,"Given two integers n and k, return  an array of all the integers of length  n  where the difference between every two consecutive digits is  k . You may return the answer in  any order . Note that the integers should not have leading zeros. Integers as  02  and  043  are not allowed.   Example 1: Input:  n = 3, k = 7 Output:  [181,292,707,818,929] Explanation:  Note that 070 is not a valid number, because it has leading zeroes. Example 2: Input:  n = 2, k = 1 Output:  [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]   Constraints: 2 <= n <= 9 0 <= k <= 9","['Backtracking', 'Breadth-First Search']",Média,Backtracking
352,data-stream-as-disjoint-intervals,https://leetcode.com/problems/data-stream-as-disjoint-intervals/,Data Stream as Disjoint Intervals,"Given a data stream input of non-negative integers  a 1 , a 2 , ..., a n , summarize the numbers seen so far as a list of disjoint intervals. Implement the  SummaryRanges  class: SummaryRanges()  Initializes the object with an empty stream. void addNum(int value)  Adds the integer  value  to the stream. int[][] getIntervals()  Returns a summary of the integers in the stream currently as a list of disjoint intervals  [start i , end i ] . The answer should be sorted by  start i .   Example 1: Input [""SummaryRanges"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals""] [[], [1], [], [3], [], [7], [], [2], [], [6], []] Output [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]] Explanation SummaryRanges summaryRanges = new SummaryRanges(); summaryRanges.addNum(1);      // arr = [1] summaryRanges.getIntervals(); // return [[1, 1]] summaryRanges.addNum(3);      // arr = [1, 3] summaryRanges.getIntervals(); // return [[1, 1], [3, 3]] summaryRanges.addNum(7);      // arr = [1, 3, 7] summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]] summaryRanges.addNum(2);      // arr = [1, 2, 3, 7] summaryRanges.getIntervals(); // return [[1, 3], [7, 7]] summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7] summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]   Constraints: 0 <= value <= 10 4 At most  3 * 10 4  calls will be made to  addNum  and  getIntervals . At most  10 2  calls will be made to  getIntervals .   Follow up:  What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?","['Binary Search', 'Design', 'Ordered Set']",Difícil,Binary Search
732,my-calendar-iii,https://leetcode.com/problems/my-calendar-iii/,My Calendar III,"A  k -booking happens when  k  events have some non-empty intersection (i.e., there is some time that is common to all  k  events.) You are given some events  [startTime, endTime) , after each given event, return an integer  k  representing the maximum  k -booking between all the previous events. Implement the  MyCalendarThree  class: MyCalendarThree()  Initializes the object. int book(int startTime, int endTime)  Returns an integer  k  representing the largest integer such that there exists a  k -booking in the calendar.   Example 1: Input [""MyCalendarThree"", ""book"", ""book"", ""book"", ""book"", ""book"", ""book""] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1 myCalendarThree.book(50, 60); // return 1 myCalendarThree.book(10, 40); // return 2 myCalendarThree.book(5, 15); // return 3 myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3   Constraints: 0 <= startTime < endTime <= 10 9 At most  400  calls will be made to  book .","['Binary Search', 'Design', 'Segment Tree', 'Prefix Sum', 'Ordered Set']",Difícil,Binary Search
1483,kth-ancestor-of-a-tree-node,https://leetcode.com/problems/kth-ancestor-of-a-tree-node/,Kth Ancestor of a Tree Node,"You are given a tree with  n  nodes numbered from  0  to  n - 1  in the form of a parent array  parent  where  parent[i]  is the parent of  i th  node. The root of the tree is node  0 . Find the  k th  ancestor of a given node. The  k th  ancestor of a tree node is the  k th  node in the path from that node to the root node. Implement the  TreeAncestor  class: TreeAncestor(int n, int[] parent)  Initializes the object with the number of nodes in the tree and the parent array. int getKthAncestor(int node, int k)  return the  k th  ancestor of the given node  node . If there is no such ancestor, return  -1 .   Example 1: Input [""TreeAncestor"", ""getKthAncestor"", ""getKthAncestor"", ""getKthAncestor""] [[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]] Output [null, 1, 0, -1] Explanation TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3 treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5 treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor   Constraints: 1 <= k <= n <= 5 * 10 4 parent.length == n parent[0] == -1 0 <= parent[i] < n  for all  0 < i < n 0 <= node < n There will be at most  5 * 10 4  queries.","['Binary Search', 'Dynamic Programming', 'Tree', 'Depth-First Search', 'Breadth-First Search', 'Design']",Difícil,Binary Search
2286,booking-concert-tickets-in-groups,https://leetcode.com/problems/booking-concert-tickets-in-groups/,Booking Concert Tickets in Groups,"A concert hall has  n  rows numbered from  0  to  n - 1 , each with  m  seats, numbered from  0  to  m - 1 . You need to design a ticketing system that can allocate seats in the following cases: If a group of  k  spectators can sit  together  in a row. If  every  member of a group of  k  spectators can get a seat. They may or  may not  sit together. Note that the spectators are very picky. Hence: They will book seats only if each member of their group can get a seat with row number  less than or equal  to  maxRow .  maxRow  can  vary  from group to group. In case there are multiple rows to choose from, the row with the  smallest  number is chosen. If there are multiple seats to choose in the same row, the seat with the  smallest  number is chosen. Implement the  BookMyShow  class: BookMyShow(int n, int m)  Initializes the object with  n  as number of rows and  m  as number of seats per row. int[] gather(int k, int maxRow)  Returns an array of length  2  denoting the row and seat number (respectively) of the  first seat  being allocated to the  k  members of the group, who must sit  together . In other words, it returns the smallest possible  r  and  c  such that all  [c, c + k - 1]  seats are valid and empty in row  r , and  r <= maxRow . Returns  []  in case it is  not possible  to allocate seats to the group. boolean scatter(int k, int maxRow)  Returns  true  if all  k  members of the group can be allocated seats in rows  0  to  maxRow , who may or  may not  sit together. If the seats can be allocated, it allocates  k  seats to the group with the  smallest  row numbers, and the smallest possible seat numbers in each row. Otherwise, returns  false .   Example 1: Input [""BookMyShow"", ""gather"", ""gather"", ""scatter"", ""scatter""] [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]] Output [null, [0, 0], [], true, false] Explanation BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each  bms.gather(4, 0); // return [0, 0]                   // The group books seats [0, 3] of row 0.  bms.gather(2, 0); // return []                   // There is only 1 seat left in row 0,                   // so it is not possible to book 2 consecutive seats.  bms.scatter(5, 1); // return True                    // The group books seat 4 of row 0 and seats [0, 3] of row 1.  bms.scatter(5, 1); // return False                    // There is only one seat left in the hall.   Constraints: 1 <= n <= 5 * 10 4 1 <= m, k <= 10 9 0 <= maxRow <= n - 1 At most  5 * 10 4  calls  in total  will be made to  gather  and  scatter .","['Binary Search', 'Design', 'Binary Indexed Tree', 'Segment Tree']",Difícil,Binary Search
222,count-complete-tree-nodes,https://leetcode.com/problems/count-complete-tree-nodes/,Count Complete Tree Nodes,"Given the  root  of a  complete  binary tree, return the number of the nodes in the tree. According to  Wikipedia , every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between  1  and  2 h  nodes inclusive at the last level  h . Design an algorithm that runs in less than  O(n)  time complexity.   Example 1: Input:  root = [1,2,3,4,5,6] Output:  6 Example 2: Input:  root = [] Output:  0 Example 3: Input:  root = [1] Output:  1   Constraints: The number of nodes in the tree is in the range  [0, 5 * 10 4 ] . 0 <= Node.val <= 5 * 10 4 The tree is guaranteed to be  complete .","['Binary Search', 'Bit Manipulation', 'Tree', 'Binary Tree']",Fácil,Binary Search
278,first-bad-version,https://leetcode.com/problems/first-bad-version/,First Bad Version,"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have  n  versions  [1, 2, ..., n]  and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API  bool isBadVersion(version)  which returns whether  version  is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.   Example 1: Input:  n = 5, bad = 4 Output:  4 Explanation: call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version. Example 2: Input:  n = 1, bad = 1 Output:  1   Constraints: 1 <= bad <= n <= 2 31  - 1","['Binary Search', 'Interactive']",Fácil,Binary Search
374,guess-number-higher-or-lower,https://leetcode.com/problems/guess-number-higher-or-lower/,Guess Number Higher or Lower,"We are playing the Guess Game. The game is as follows: I pick a number from  1  to  n . You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API  int guess(int num) , which returns three possible results: -1 : Your guess is higher than the number I picked (i.e.  num > pick ). 1 : Your guess is lower than the number I picked (i.e.  num < pick ). 0 : your guess is equal to the number I picked (i.e.  num == pick ). Return  the number that I picked .   Example 1: Input:  n = 10, pick = 6 Output:  6 Example 2: Input:  n = 1, pick = 1 Output:  1 Example 3: Input:  n = 2, pick = 1 Output:  1   Constraints: 1 <= n <= 2 31  - 1 1 <= pick <= n","['Binary Search', 'Interactive']",Fácil,Binary Search
1802,maximum-value-at-a-given-index-in-a-bounded-array,https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/,Maximum Value at a Given Index in a Bounded Array,"You are given three positive integers:  n ,  index , and  maxSum . You want to construct an array  nums  ( 0-indexed )   that satisfies the following conditions: nums.length == n nums[i]  is a  positive  integer where  0 <= i < n . abs(nums[i] - nums[i+1]) <= 1  where  0 <= i < n-1 . The sum of all the elements of  nums  does not exceed  maxSum . nums[index]  is  maximized . Return  nums[index]  of the constructed array . Note that  abs(x)  equals  x  if  x >= 0 , and  -x  otherwise.   Example 1: Input:  n = 4, index = 2,  maxSum = 6 Output:  2 Explanation:  nums = [1,2, 2 ,1] is one array that satisfies all the conditions. There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2]. Example 2: Input:  n = 6, index = 1,  maxSum = 10 Output:  3   Constraints: 1 <= n <= maxSum <= 10 9 0 <= index < n","['Binary Search', 'Greedy']",Média,Binary Search
2424,longest-uploaded-prefix,https://leetcode.com/problems/longest-uploaded-prefix/,Longest Uploaded Prefix,"You are given a stream of  n  videos, each represented by a  distinct  number from  1  to  n  that you need to ""upload"" to a server. You need to implement a data structure that calculates the length of the  longest uploaded prefix  at various points in the upload process. We consider  i  to be an uploaded prefix if all videos in the range  1  to  i  ( inclusive ) have been uploaded to the server. The longest uploaded prefix is the  maximum  value of  i  that satisfies this definition. Implement the  LUPrefix  class: LUPrefix(int n)  Initializes the object for a stream of  n  videos. void upload(int video)  Uploads  video  to the server. int longest()  Returns the length of the  longest uploaded prefix  defined above.   Example 1: Input [""LUPrefix"", ""upload"", ""longest"", ""upload"", ""longest"", ""upload"", ""longest""] [[4], [3], [], [1], [], [2], []] Output [null, null, 0, null, 1, null, 3] Explanation LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos. server.upload(3);                    // Upload video 3. server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.                                      // So, we return 0. server.upload(1);                    // Upload video 1. server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1. server.upload(2);                    // Upload video 2. server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.   Constraints: 1 <= n <= 10 5 1 <= video <= n All values of  video  are  distinct . At most  2 * 10 5  calls  in total  will be made to  upload  and  longest . At least one call will be made to  longest .","['Binary Search', 'Union Find', 'Design', 'Binary Indexed Tree', 'Segment Tree', 'Heap (Priority Queue)', 'Ordered Set']",Média,Binary Search
3007,maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k,https://leetcode.com/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/,Maximum Number That Sum of the Prices Is Less Than or Equal to K,"You are given an integer  k  and an integer  x . The price of a number  num  is calculated by the count of  set bits  at positions  x ,  2x ,  3x , etc., in its binary representation, starting from the least significant bit. The following table contains examples of how price is calculated. x num Binary Representation Price 1 13 0 0 0 0 0 1 1 0 1 3 2 13 0 0 0 0 0 1 1 0 1 1 2 233 0 1 1 1 0 1 0 0 1 3 3 13 0 00 0 01 1 01 1 3 362 1 01 1 01 0 10 2 The  accumulated price  of  num  is the  total  price of numbers from  1  to  num .  num  is considered  cheap  if its accumulated price is less than or equal to  k . Return the  greatest  cheap number.   Example 1: Input:   k = 9, x = 1 Output:   6 Explanation: As shown in the table below,  6  is the greatest cheap number. x num Binary Representation Price Accumulated Price 1 1 0 0 1 1 1 1 2 0 1 0 1 2 1 3 0 1 1 2 4 1 4 1 0 0 1 5 1 5 1 0 1 2 7 1 6 1 1 0 2 9 1 7 1 1 1 3 12 Example 2: Input:   k = 7, x = 2 Output:   9 Explanation: As shown in the table below,  9  is the greatest cheap number. x num Binary Representation Price Accumulated Price 2 1 0 0 0 1 0 0 2 2 0 0 1 0 1 1 2 3 0 0 1 1 1 2 2 4 0 1 0 0 0 2 2 5 0 1 0 1 0 2 2 6 0 1 1 0 1 3 2 7 0 1 1 1 1 4 2 8 1 0 0 0 1 5 2 9 1 0 0 1 1 6 2 10 1 0 1 0 2 8   Constraints: 1 <= k <= 10 15 1 <= x <= 8","['Binary Search', 'Dynamic Programming', 'Bit Manipulation']",Média,Binary Search
3419,minimize-the-maximum-edge-weight-of-graph,https://leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/,Minimize the Maximum Edge Weight of Graph,"You are given two integers,  n  and  threshold , as well as a  directed  weighted graph of  n  nodes numbered from 0 to  n - 1 . The graph is represented by a  2D  integer array  edges , where  edges[i] = [A i , B i , W i ]  indicates that there is an edge going from node  A i  to node  B i  with weight  W i . You have to remove some edges from this graph (possibly  none ), so that it satisfies the following conditions: Node 0 must be reachable from all other nodes. The  maximum  edge weight in the resulting graph is  minimized . Each node has  at most   threshold  outgoing edges. Return the  minimum  possible value of the  maximum  edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.   Example 1: Input:   n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2 Output:   1 Explanation: Remove the edge  2 -> 0 . The maximum weight among the remaining edges is 1. Example 2: Input:   n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1 Output:   -1 Explanation:   It is impossible to reach node 0 from node 2. Example 3: Input:   n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1 Output:   2 Explanation:   Remove the edges  1 -> 3  and  1 -> 4 . The maximum weight among the remaining edges is 2. Example 4: Input:   n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1 Output:   -1   Constraints: 2 <= n <= 10 5 1 <= threshold <= n - 1 1 <= edges.length <= min(10 5 , n * (n - 1) / 2). edges[i].length == 3 0 <= A i , B i  < n A i  != B i 1 <= W i  <= 10 6 There  may be  multiple edges between a pair of nodes, but they must have unique weights.","['Binary Search', 'Depth-First Search', 'Breadth-First Search', 'Graph', 'Shortest Path']",Média,Binary Search
2959,number-of-possible-sets-of-closing-branches,https://leetcode.com/problems/number-of-possible-sets-of-closing-branches/,Number of Possible Sets of Closing Branches,"There is a company with  n  branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads. The company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches ( possibly none ). However, they want to ensure that the remaining branches have a distance of at most  maxDistance  from each other. The  distance  between two branches is the  minimum  total traveled length needed to reach one branch from another. You are given integers  n ,  maxDistance , and a  0-indexed  2D array  roads , where  roads[i] = [u i , v i , w i ]  represents the  undirected  road between branches  u i  and  v i  with length  w i . Return  the number of possible sets of closing branches, so that any branch has a distance of at most  maxDistance  from any other . Note  that, after closing a branch, the company will no longer have access to any roads connected to it. Note  that, multiple roads are allowed.   Example 1: Input:  n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]] Output:  5 Explanation:  The possible sets of closing branches are: - The set [2], after closing, active branches are [0,1] and they are reachable to each other within distance 2. - The set [0,1], after closing, the active branch is [2]. - The set [1,2], after closing, the active branch is [0]. - The set [0,2], after closing, the active branch is [1]. - The set [0,1,2], after closing, there are no active branches. It can be proven, that there are only 5 possible sets of closing branches. Example 2: Input:  n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]] Output:  7 Explanation:  The possible sets of closing branches are: - The set [], after closing, active branches are [0,1,2] and they are reachable to each other within distance 4. - The set [0], after closing, active branches are [1,2] and they are reachable to each other within distance 2. - The set [1], after closing, active branches are [0,2] and they are reachable to each other within distance 2. - The set [0,1], after closing, the active branch is [2]. - The set [1,2], after closing, the active branch is [0]. - The set [0,2], after closing, the active branch is [1]. - The set [0,1,2], after closing, there are no active branches. It can be proven, that there are only 7 possible sets of closing branches. Example 3: Input:  n = 1, maxDistance = 10, roads = [] Output:  2 Explanation:  The possible sets of closing branches are: - The set [], after closing, the active branch is [0]. - The set [0], after closing, there are no active branches. It can be proven, that there are only 2 possible sets of closing branches.   Constraints: 1 <= n <= 10 1 <= maxDistance <= 10 5 0 <= roads.length <= 1000 roads[i].length == 3 0 <= u i , v i  <= n - 1 u i  != v i 1 <= w i  <= 1000 All branches are reachable from each other by traveling some roads.","['Bit Manipulation', 'Graph', 'Heap (Priority Queue)', 'Enumeration', 'Shortest Path']",Difícil,Bit Manipulation
461,hamming-distance,https://leetcode.com/problems/hamming-distance/,Hamming Distance,"The  Hamming distance  between two integers is the number of positions at which the corresponding bits are different. Given two integers  x  and  y , return  the  Hamming distance  between them .   Example 1: Input:  x = 1, y = 4 Output:  2 Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        ↑   ↑ The above arrows point to positions where the corresponding bits are different. Example 2: Input:  x = 3, y = 1 Output:  1   Constraints: 0 <= x, y <= 2 31  - 1   Note:  This question is the same as   2220: Minimum Bit Flips to Convert Number.",['Bit Manipulation'],Fácil,Bit Manipulation
476,number-complement,https://leetcode.com/problems/number-complement/,Number Complement,"The  complement  of an integer is the integer you get when you flip all the  0 's to  1 's and all the  1 's to  0 's in its binary representation. For example, The integer  5  is  ""101""  in binary and its  complement  is  ""010""  which is the integer  2 . Given an integer  num , return  its complement .   Example 1: Input:  num = 5 Output:  2 Explanation:  The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: Input:  num = 1 Output:  0 Explanation:  The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.   Constraints: 1 <= num < 2 31   Note:  This question is the same as 1009:  https://leetcode.com/problems/complement-of-base-10-integer/",['Bit Manipulation'],Fácil,Bit Manipulation
693,binary-number-with-alternating-bits,https://leetcode.com/problems/binary-number-with-alternating-bits/,Binary Number with Alternating Bits,"Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.   Example 1: Input:  n = 5 Output:  true Explanation:  The binary representation of 5 is: 101 Example 2: Input:  n = 7 Output:  false Explanation:  The binary representation of 7 is: 111. Example 3: Input:  n = 11 Output:  false Explanation:  The binary representation of 11 is: 1011.   Constraints: 1 <= n <= 2 31  - 1",['Bit Manipulation'],Fácil,Bit Manipulation
868,binary-gap,https://leetcode.com/problems/binary-gap/,Binary Gap,"Given a positive integer  n , find and return  the  longest distance  between any two  adjacent   1 's in the binary representation of  n . If there are no two adjacent  1 's, return  0 . Two  1 's are  adjacent  if there are only  0 's separating them (possibly no  0 's). The  distance  between two  1 's is the absolute difference between their bit positions. For example, the two  1 's in  ""1001""  have a distance of 3.   Example 1: Input:  n = 22 Output:  2 Explanation:  22 in binary is ""10110"". The first adjacent pair of 1's is "" 1 0 1 10"" with a distance of 2. The second adjacent pair of 1's is ""10 11 0"" with a distance of 1. The answer is the largest of these two distances, which is 2. Note that "" 1 01 1 0"" is not a valid pair since there is a 1 separating the two 1's underlined. Example 2: Input:  n = 8 Output:  0 Explanation:  8 in binary is ""1000"". There are not any adjacent pairs of 1's in the binary representation of 8, so we return 0. Example 3: Input:  n = 5 Output:  2 Explanation:  5 in binary is ""101"".   Constraints: 1 <= n <= 10 9",['Bit Manipulation'],Fácil,Bit Manipulation
1009,complement-of-base-10-integer,https://leetcode.com/problems/complement-of-base-10-integer/,Complement of Base 10 Integer,"The  complement  of an integer is the integer you get when you flip all the  0 's to  1 's and all the  1 's to  0 's in its binary representation. For example, The integer  5  is  ""101""  in binary and its  complement  is  ""010""  which is the integer  2 . Given an integer  n , return  its complement .   Example 1: Input:  n = 5 Output:  2 Explanation:  5 is ""101"" in binary, with complement ""010"" in binary, which is 2 in base-10. Example 2: Input:  n = 7 Output:  0 Explanation:  7 is ""111"" in binary, with complement ""000"" in binary, which is 0 in base-10. Example 3: Input:  n = 10 Output:  5 Explanation:  10 is ""1010"" in binary, with complement ""0101"" in binary, which is 5 in base-10.   Constraints: 0 <= n < 10 9   Note:  This question is the same as 476:  https://leetcode.com/problems/number-complement/",['Bit Manipulation'],Fácil,Bit Manipulation
2220,minimum-bit-flips-to-convert-number,https://leetcode.com/problems/minimum-bit-flips-to-convert-number/,Minimum Bit Flips to Convert Number,"A  bit flip  of a number  x  is choosing a bit in the binary representation of  x  and  flipping  it from either  0  to  1  or  1  to  0 . For example, for  x = 7 , the binary representation is  111  and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get  110 , flip the second bit from the right to get  101 , flip the fifth bit from the right (a leading zero) to get  10111 , etc. Given two integers  start  and  goal , return  the  minimum  number of  bit flips  to convert  start  to  goal .   Example 1: Input:  start = 10, goal = 7 Output:  3 Explanation:  The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps: - Flip the first bit from the right: 101 0  -> 101 1 . - Flip the third bit from the right: 1 0 11 -> 1 1 11. - Flip the fourth bit from the right:  1 111 ->  0 111. It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3. Example 2: Input:  start = 3, goal = 4 Output:  3 Explanation:  The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps: - Flip the first bit from the right: 01 1  -> 01 0 . - Flip the second bit from the right: 0 1 0 -> 0 0 0. - Flip the third bit from the right:  0 00 ->  1 00. It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.   Constraints: 0 <= start, goal <= 10 9   Note:  This question is the same as  461: Hamming Distance.",['Bit Manipulation'],Fácil,Bit Manipulation
2595,number-of-even-and-odd-bits,https://leetcode.com/problems/number-of-even-and-odd-bits/,Number of Even and Odd Bits,"You are given a  positive  integer  n . Let  even  denote the number of even indices in the binary representation of  n  with value 1. Let  odd  denote the number of odd indices in the binary representation of  n  with value 1. Note that bits are indexed from  right to left  in the binary representation of a number. Return the array  [even, odd] .   Example 1: Input:   n = 50 Output:   [1,2] Explanation: The binary representation of 50 is  110010 . It contains 1 on indices 1, 4, and 5. Example 2: Input:   n = 2 Output:   [0,1] Explanation: The binary representation of 2 is  10 . It contains 1 only on index 1.   Constraints: 1 <= n <= 1000",['Bit Manipulation'],Fácil,Bit Manipulation
3226,number-of-bit-changes-to-make-two-integers-equal,https://leetcode.com/problems/number-of-bit-changes-to-make-two-integers-equal/,Number of Bit Changes to Make Two Integers Equal,"You are given two positive integers  n  and  k . You can choose  any  bit in the  binary representation  of  n  that is equal to 1 and change it to 0. Return the  number of changes  needed to make  n  equal to  k . If it is impossible, return -1.   Example 1: Input:   n = 13, k = 4 Output:   2 Explanation: Initially, the binary representations of  n  and  k  are  n = (1101) 2  and  k = (0100) 2 . We can change the first and fourth bits of  n . The resulting integer is  n = ( 0 10 0 ) 2  = k . Example 2: Input:   n = 21, k = 21 Output:   0 Explanation: n  and  k  are already equal, so no changes are needed. Example 3: Input:   n = 14, k = 13 Output:   -1 Explanation: It is not possible to make  n  equal to  k .   Constraints: 1 <= n, k <= 10 6",['Bit Manipulation'],Fácil,Bit Manipulation
201,bitwise-and-of-numbers-range,https://leetcode.com/problems/bitwise-and-of-numbers-range/,Bitwise AND of Numbers Range,"Given two integers  left  and  right  that represent the range  [left, right] , return  the bitwise AND of all numbers in this range, inclusive .   Example 1: Input:  left = 5, right = 7 Output:  4 Example 2: Input:  left = 0, right = 0 Output:  0 Example 3: Input:  left = 1, right = 2147483647 Output:  0   Constraints: 0 <= left <= right <= 2 31  - 1",['Bit Manipulation'],Média,Bit Manipulation
756,pyramid-transition-matrix,https://leetcode.com/problems/pyramid-transition-matrix/,Pyramid Transition Matrix,"You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains  one less block  than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific  triangular patterns  that are allowed. A triangular pattern consists of a  single block  stacked on top of  two blocks . The patterns are given as a list of three-letter strings  allowed , where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block. For example,  ""ABC""  represents a triangular pattern with a  'C'  block stacked on top of an  'A'  (left) and  'B'  (right) block. Note that this is different from  ""BAC""  where  'B'  is on the left bottom and  'A'  is on the right bottom. You start with a bottom row of blocks  bottom , given as a single string, that you  must  use as the base of the pyramid. Given  bottom  and  allowed , return  true  if you can build the pyramid all the way to the top such that  every triangular pattern  in the pyramid is in  allowed , or  false  otherwise .   Example 1: Input:  bottom = ""BCD"", allowed = [""BCC"",""CDE"",""CEA"",""FFF""] Output:  true Explanation:  The allowed triangular patterns are shown on the right. Starting from the bottom (level 3), we can build ""CE"" on level 2 and then build ""A"" on level 1. There are three triangular patterns in the pyramid, which are ""BCC"", ""CDE"", and ""CEA"". All are allowed. Example 2: Input:  bottom = ""AAAA"", allowed = [""AAB"",""AAC"",""BCD"",""BBE"",""DEF""] Output:  false Explanation:  The allowed triangular patterns are shown on the right. Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.   Constraints: 2 <= bottom.length <= 6 0 <= allowed.length <= 216 allowed[i].length == 3 The letters in all input strings are from the set  {'A', 'B', 'C', 'D', 'E', 'F'} . All the values of  allowed  are  unique .","['Bit Manipulation', 'Depth-First Search', 'Breadth-First Search']",Média,Bit Manipulation
1318,minimum-flips-to-make-a-or-b-equal-to-c,https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/,Minimum Flips to Make a OR b Equal to c,"Given 3 positives numbers  a ,  b  and  c . Return the minimum flips required in some bits of  a  and  b  to make (  a  OR  b  ==  c  ). (bitwise OR operation). Flip operation consists of change  any  single bit 1 to 0 or change the bit 0 to 1 in their binary representation.   Example 1: Input:  a = 2, b = 6, c = 5 Output:  3 Explanation:  After flips a = 1 , b = 4 , c = 5 such that ( a  OR  b  ==  c ) Example 2: Input:  a = 4, b = 2, c = 7 Output:  1 Example 3: Input:  a = 1, b = 2, c = 3 Output:  0   Constraints: 1 <= a <= 10^9 1 <= b <= 10^9 1 <= c <= 10^9",['Bit Manipulation'],Média,Bit Manipulation
1457,pseudo-palindromic-paths-in-a-binary-tree,https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/,Pseudo-Palindromic Paths in a Binary Tree,"Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be  pseudo-palindromic  if at least one permutation of the node values in the path is a palindrome. Return the number of  pseudo-palindromic  paths going from the root node to leaf nodes.   Example 1: Input:  root = [2,3,1,3,1,null,1] Output:  2  Explanation:  The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 2: Input:  root = [2,1,1,1,3,null,null,null,null,null,1] Output:  1  Explanation:  The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 3: Input:  root = [9] Output:  1   Constraints: The number of nodes in the tree is in the range  [1, 10 5 ] . 1 <= Node.val <= 9","['Bit Manipulation', 'Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Média,Bit Manipulation
2749,minimum-operations-to-make-the-integer-zero,https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/,Minimum Operations to Make the Integer Zero,"You are given two integers  num1  and  num2 . In one operation, you can choose integer  i  in the range  [0, 60]  and subtract  2 i  + num2  from  num1 . Return  the integer denoting the  minimum  number of operations needed to make   num1   equal to   0 . If it is impossible to make  num1  equal to  0 , return  -1 .   Example 1: Input:  num1 = 3, num2 = -2 Output:  3 Explanation:  We can make 3 equal to 0 with the following operations: - We choose i = 2 and subtract 2 2  + (-2) from 3, 3 - (4 + (-2)) = 1. - We choose i = 2 and subtract 2 2  + (-2) from 1, 1 - (4 + (-2)) = -1. - We choose i = 0 and subtract 2 0  + (-2) from -1, (-1) - (1 + (-2)) = 0. It can be proven, that 3 is the minimum number of operations that we need to perform. Example 2: Input:  num1 = 5, num2 = 7 Output:  -1 Explanation:  It can be proven, that it is impossible to make 5 equal to 0 with the given operation.   Constraints: 1 <= num1 <= 10 9 -10 9  <= num2 <= 10 9","['Bit Manipulation', 'Brainteaser', 'Enumeration']",Média,Bit Manipulation
3133,minimum-array-end,https://leetcode.com/problems/minimum-array-end/,Minimum Array End,"You are given two integers  n  and  x . You have to construct an array of  positive  integers  nums  of size  n  where for every  0 <= i < n - 1 ,  nums[i + 1]  is  greater than   nums[i] , and the result of the bitwise  AND  operation between all elements of  nums  is  x . Return the  minimum  possible value of  nums[n - 1] .   Example 1: Input:   n = 3, x = 4 Output:   6 Explanation: nums  can be  [4,5,6]  and its last element is 6. Example 2: Input:   n = 2, x = 7 Output:   15 Explanation: nums  can be  [7,15]  and its last element is 15.   Constraints: 1 <= n, x <= 10 8",['Bit Manipulation'],Média,Bit Manipulation
2045,second-minimum-time-to-reach-destination,https://leetcode.com/problems/second-minimum-time-to-reach-destination/,Second Minimum Time to Reach Destination,"A city is represented as a  bi-directional connected  graph with  n  vertices where each vertex is labeled from  1  to  n  ( inclusive ). The edges in the graph are represented as a 2D integer array  edges , where each  edges[i] = [u i , v i ]  denotes a bi-directional edge between vertex  u i  and vertex  v i . Every vertex pair is connected by  at most one  edge, and no vertex has an edge to itself. The time taken to traverse any edge is  time  minutes. Each vertex has a traffic signal which changes its color from  green  to  red  and vice versa every  change  minutes. All signals change  at the same time . You can enter a vertex at  any time , but can leave a vertex  only when the signal is green . You  cannot wait  at a vertex if the signal is  green . The  second minimum value  is defined as the smallest value  strictly larger  than the minimum value. For example the second minimum value of  [2, 3, 4]  is  3 , and the second minimum value of  [2, 2, 4]  is  4 . Given  n ,  edges ,  time , and  change , return  the  second minimum time  it will take to go from vertex  1  to vertex  n . Notes: You can go through any vertex  any  number of times,  including   1  and  n . You can assume that when the journey  starts , all signals have just turned  green .   Example 1:          Input:  n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5 Output:  13 Explanation: The figure on the left shows the given graph. The blue path in the figure on the right is the minimum time path. The time taken is: - Start at 1, time elapsed=0 - 1 -> 4: 3 minutes, time elapsed=3 - 4 -> 5: 3 minutes, time elapsed=6 Hence the minimum time needed is 6 minutes. The red path shows the path to get the second minimum time. - Start at 1, time elapsed=0 - 1 -> 3: 3 minutes, time elapsed=3 - 3 -> 4: 3 minutes, time elapsed=6 - Wait at 4 for 4 minutes, time elapsed=10 - 4 -> 5: 3 minutes, time elapsed=13 Hence the second minimum time is 13 minutes.       Example 2: Input:  n = 2, edges = [[1,2]], time = 3, change = 2 Output:  11 Explanation: The minimum time path is 1 -> 2 with time = 3 minutes. The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.   Constraints: 2 <= n <= 10 4 n - 1 <= edges.length <= min(2 * 10 4 , n * (n - 1) / 2) edges[i].length == 2 1 <= u i , v i  <= n u i  != v i There are no duplicate edges. Each vertex can be reached directly or indirectly from every other vertex. 1 <= time, change <= 10 3","['Breadth-First Search', 'Graph', 'Shortest Path']",Difícil,Breadth-First Search
2608,shortest-cycle-in-a-graph,https://leetcode.com/problems/shortest-cycle-in-a-graph/,Shortest Cycle in a Graph,"There is a  bi-directional  graph with  n  vertices, where each vertex is labeled from  0  to  n - 1 . The edges in the graph are represented by a given 2D integer array  edges , where  edges[i] = [u i , v i ]  denotes an edge between vertex  u i  and vertex  v i . Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. Return  the length of the  shortest  cycle in the graph . If no cycle exists, return  -1 . A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.   Example 1: Input:  n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]] Output:  3 Explanation:  The cycle with the smallest length is : 0 -> 1 -> 2 -> 0  Example 2: Input:  n = 4, edges = [[0,1],[0,2]] Output:  -1 Explanation:  There are no cycles in this graph.   Constraints: 2 <= n <= 1000 1 <= edges.length <= 1000 edges[i].length == 2 0 <= u i , v i  < n u i  != v i There are no repeated edges.","['Breadth-First Search', 'Graph']",Difícil,Breadth-First Search
1129,shortest-path-with-alternating-colors,https://leetcode.com/problems/shortest-path-with-alternating-colors/,Shortest Path with Alternating Colors,"You are given an integer  n , the number of nodes in a directed graph where the nodes are labeled from  0  to  n - 1 . Each edge is red or blue in this graph, and there could be self-edges and parallel edges. You are given two arrays  redEdges  and  blueEdges  where: redEdges[i] = [a i , b i ]  indicates that there is a directed red edge from node  a i  to node  b i  in the graph, and blueEdges[j] = [u j , v j ]  indicates that there is a directed blue edge from node  u j  to node  v j  in the graph. Return an array  answer  of length  n , where each  answer[x]  is the length of the shortest path from node  0  to node  x  such that the edge colors alternate along the path, or  -1  if such a path does not exist.   Example 1: Input:  n = 3, redEdges = [[0,1],[1,2]], blueEdges = [] Output:  [0,1,-1] Example 2: Input:  n = 3, redEdges = [[0,1]], blueEdges = [[2,1]] Output:  [0,1,-1]   Constraints: 1 <= n <= 100 0 <= redEdges.length, blueEdges.length <= 400 redEdges[i].length == blueEdges[j].length == 2 0 <= a i , b i , u j , v j  < n","['Breadth-First Search', 'Graph']",Média,Breadth-First Search
3015,count-the-number-of-houses-at-a-certain-distance-i,https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-i/,Count the Number of Houses at a Certain Distance I,"You are given three  positive  integers  n ,  x , and  y . In a city, there exist houses numbered  1  to  n  connected by  n  streets. There is a street connecting the house numbered  i  with the house numbered  i + 1  for all  1 <= i <= n - 1  . An additional street connects the house numbered  x  with the house numbered  y . For each  k , such that  1 <= k <= n , you need to find the number of  pairs of houses   (house 1 , house 2 )  such that the  minimum  number of streets that need to be traveled to reach  house 2  from  house 1  is  k . Return  a  1-indexed  array  result  of length  n  where  result[k]  represents the  total  number of pairs of houses such that the  minimum  streets required to reach one house from the other is  k . Note  that  x  and  y  can be  equal .   Example 1: Input:  n = 3, x = 1, y = 3 Output:  [6,0,0] Explanation:  Let's look at each pair of houses: - For the pair (1, 2), we can go from house 1 to house 2 directly. - For the pair (2, 1), we can go from house 2 to house 1 directly. - For the pair (1, 3), we can go from house 1 to house 3 directly. - For the pair (3, 1), we can go from house 3 to house 1 directly. - For the pair (2, 3), we can go from house 2 to house 3 directly. - For the pair (3, 2), we can go from house 3 to house 2 directly. Example 2: Input:  n = 5, x = 2, y = 4 Output:  [10,8,2,0,0] Explanation:  For each distance k the pairs are: - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4). - For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3). - For k == 3, the pairs are (1, 5), and (5, 1). - For k == 4 and k == 5, there are no pairs. Example 3: Input:  n = 4, x = 1, y = 1 Output:  [6,4,2,0] Explanation:  For each distance k the pairs are: - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3). - For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2). - For k == 3, the pairs are (1, 4), and (4, 1). - For k == 4, there are no pairs.   Constraints: 2 <= n <= 100 1 <= x, y <= n","['Breadth-First Search', 'Graph', 'Prefix Sum']",Média,Breadth-First Search
1192,critical-connections-in-a-network,https://leetcode.com/problems/critical-connections-in-a-network/,Critical Connections in a Network,"There are  n  servers numbered from  0  to  n - 1  connected by undirected server-to-server  connections  forming a network where  connections[i] = [a i , b i ]  represents a connection between servers  a i  and  b i . Any server can reach other servers directly or indirectly through the network. A  critical connection  is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order.   Example 1: Input:  n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] Output:  [[1,3]] Explanation:  [[3,1]] is also accepted. Example 2: Input:  n = 2, connections = [[0,1]] Output:  [[0,1]]   Constraints: 2 <= n <= 10 5 n - 1 <= connections.length <= 10 5 0 <= a i , b i  <= n - 1 a i  != b i There are no repeated connections.","['Depth-First Search', 'Graph', 'Biconnected Component']",Difícil,Depth-First Search
1203,sort-items-by-groups-respecting-dependencies,https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/,Sort Items by Groups Respecting Dependencies,"There are  n  items each belonging to zero or one of  m  groups where  group[i]  is the group that the  i -th item belongs to and it's equal to  -1  if the  i -th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that: The items that belong to the same group are next to each other in the sorted list. There are some relations between these items where  beforeItems[i]  is a list containing all the items that should come before the  i -th item in the sorted array (to the left of the  i -th item). Return any solution if there is more than one solution and return an  empty list  if there is no solution.   Example 1: Input:  n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]] Output:  [6,3,4,1,5,2,0,7] Example 2: Input:  n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]] Output:  [] Explanation:  This is the same as example 1 except that 4 needs to be before 6 in the sorted list.   Constraints: 1 <= m <= n <= 3 * 10 4 group.length == beforeItems.length == n -1 <= group[i] <= m - 1 0 <= beforeItems[i].length <= n - 1 0 <= beforeItems[i][j] <= n - 1 i != beforeItems[i][j] beforeItems[i]  does not contain duplicates elements.","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Difícil,Depth-First Search
2092,find-all-people-with-secret,https://leetcode.com/problems/find-all-people-with-secret/,Find All People With Secret,"You are given an integer  n  indicating there are  n  people numbered from  0  to  n - 1 . You are also given a  0-indexed  2D integer array  meetings  where  meetings[i] = [x i , y i , time i ]  indicates that person  x i  and person  y i  have a meeting at  time i . A person may attend  multiple meetings  at the same time. Finally, you are given an integer  firstPerson . Person  0  has a  secret  and initially shares the secret with a person  firstPerson  at time  0 . This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person  x i  has the secret at  time i , then they will share the secret with person  y i , and vice versa. The secrets are shared  instantaneously . That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return  a list of all the people that have the secret after all the meetings have taken place.  You may return the answer in  any order .   Example 1: Input:  n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 Output:  [0,1,2,3,5] Explanation: At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.​​​​ Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings. Example 2: Input:  n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 Output:  [0,1,3] Explanation: At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings. Example 3: Input:  n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 Output:  [0,1,2,3,4] Explanation: At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.   Constraints: 2 <= n <= 10 5 1 <= meetings.length <= 10 5 meetings[i].length == 3 0 <= x i , y i  <= n - 1 x i  != y i 1 <= time i  <= 10 5 1 <= firstPerson <= n - 1","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph', 'Sorting']",Difícil,Depth-First Search
2097,valid-arrangement-of-pairs,https://leetcode.com/problems/valid-arrangement-of-pairs/,Valid Arrangement of Pairs,"You are given a  0-indexed  2D integer array  pairs  where  pairs[i] = [start i , end i ] . An arrangement of  pairs  is  valid  if for every index  i  where  1 <= i < pairs.length , we have  end i-1  == start i . Return  any  valid arrangement of  pairs . Note:  The inputs will be generated such that there exists a valid arrangement of  pairs .   Example 1: Input:  pairs = [[5,1],[4,5],[11,9],[9,4]] Output:  [[11,9],[9,4],[4,5],[5,1]] Explanation: This is a valid arrangement since end i-1  always equals start i . end 0  = 9 == 9 = start 1   end 1  = 4 == 4 = start 2 end 2  = 5 == 5 = start 3 Example 2: Input:  pairs = [[1,3],[3,2],[2,1]] Output:  [[1,3],[3,2],[2,1]] Explanation: This is a valid arrangement since end i-1  always equals start i . end 0  = 3 == 3 = start 1 end 1  = 2 == 2 = start 2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid. Example 3: Input:  pairs = [[1,2],[1,3],[2,1]] Output:  [[1,2],[2,1],[1,3]] Explanation: This is a valid arrangement since end i-1  always equals start i . end 0  = 2 == 2 = start 1 end 1  = 1 == 1 = start 2   Constraints: 1 <= pairs.length <= 10 5 pairs[i].length == 2 0 <= start i , end i  <= 10 9 start i  != end i No two pairs are exactly the same. There  exists  a valid arrangement of  pairs .","['Depth-First Search', 'Graph', 'Eulerian Circuit']",Difícil,Depth-First Search
2127,maximum-employees-to-be-invited-to-a-meeting,https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/,Maximum Employees to Be Invited to a Meeting,"A company is organizing a meeting and has a list of  n  employees, waiting to be invited. They have arranged for a large  circular  table, capable of seating  any number  of employees. The employees are numbered from  0  to  n - 1 . Each employee has a  favorite  person and they will attend the meeting  only if  they can sit next to their favorite person at the table. The favorite person of an employee is  not  themself. Given a  0-indexed  integer array  favorite , where  favorite[i]  denotes the favorite person of the  i th  employee, return  the  maximum number of employees  that can be invited to the meeting .   Example 1: Input:  favorite = [2,2,1,2] Output:  3 Explanation: The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table. All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously. Note that the company can also invite employees 1, 2, and 3, and give them their desired seats. The maximum number of employees that can be invited to the meeting is 3.  Example 2: Input:  favorite = [1,2,0] Output:  3 Explanation:   Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee. The seating arrangement will be the same as that in the figure given in example 1: - Employee 0 will sit between employees 2 and 1. - Employee 1 will sit between employees 0 and 2. - Employee 2 will sit between employees 1 and 0. The maximum number of employees that can be invited to the meeting is 3. Example 3: Input:  favorite = [3,0,1,4,1] Output:  4 Explanation: The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table. Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken. So the company leaves them out of the meeting. The maximum number of employees that can be invited to the meeting is 4.   Constraints: n == favorite.length 2 <= n <= 10 5 0 <= favorite[i] <= n - 1 favorite[i] != i","['Depth-First Search', 'Graph', 'Topological Sort']",Difícil,Depth-First Search
2360,longest-cycle-in-a-graph,https://leetcode.com/problems/longest-cycle-in-a-graph/,Longest Cycle in a Graph,"You are given a  directed  graph of  n  nodes numbered from  0  to  n - 1 , where each node has  at most one  outgoing edge. The graph is represented with a given  0-indexed  array  edges  of size  n , indicating that there is a directed edge from node  i  to node  edges[i] . If there is no outgoing edge from node  i , then  edges[i] == -1 . Return  the length of the  longest  cycle in the graph . If no cycle exists, return  -1 . A cycle is a path that starts and ends at the  same  node.   Example 1: Input:  edges = [3,3,4,2,3] Output:  3 Explanation:  The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2. The length of this cycle is 3, so 3 is returned. Example 2: Input:  edges = [2,-1,3,1] Output:  -1 Explanation:  There are no cycles in this graph.   Constraints: n == edges.length 2 <= n <= 10 5 -1 <= edges[i] < n edges[i] != i","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Difícil,Depth-First Search
2493,divide-nodes-into-the-maximum-number-of-groups,https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/,Divide Nodes Into the Maximum Number of Groups,"You are given a positive integer  n  representing the number of nodes in an  undirected  graph. The nodes are labeled from  1  to  n . You are also given a 2D integer array  edges , where  edges[i] = [a i,  b i ]  indicates that there is a  bidirectional  edge between nodes  a i  and  b i .  Notice  that the given graph may be disconnected. Divide the nodes of the graph into  m  groups ( 1-indexed ) such that: Each node in the graph belongs to exactly one group. For every pair of nodes in the graph that are connected by an edge  [a i,  b i ] , if  a i  belongs to the group with index  x , and  b i  belongs to the group with index  y , then  |y - x| = 1 . Return  the maximum number of groups (i.e., maximum  m ) into which you can divide the nodes . Return  -1   if it is impossible to group the nodes with the given conditions .   Example 1: Input:  n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]] Output:  4 Explanation:  As shown in the image we: - Add node 5 to the first group. - Add node 1 to the second group. - Add nodes 2 and 4 to the third group. - Add nodes 3 and 6 to the fourth group. We can see that every edge is satisfied. It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied. Example 2: Input:  n = 3, edges = [[1,2],[2,3],[3,1]] Output:  -1 Explanation:  If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied. It can be shown that no grouping is possible.   Constraints: 1 <= n <= 500 1 <= edges.length <= 10 4 edges[i].length == 2 1 <= a i , b i  <= n a i  != b i There is at most one edge between any pair of vertices.","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Difícil,Depth-First Search
1971,find-if-path-exists-in-graph,https://leetcode.com/problems/find-if-path-exists-in-graph/,Find if Path Exists in Graph,"There is a  bi-directional  graph with  n  vertices, where each vertex is labeled from  0  to  n - 1  ( inclusive ). The edges in the graph are represented as a 2D integer array  edges , where each  edges[i] = [u i , v i ]  denotes a bi-directional edge between vertex  u i  and vertex  v i . Every vertex pair is connected by  at most one  edge, and no vertex has an edge to itself. You want to determine if there is a  valid path  that exists from vertex  source  to vertex  destination . Given  edges  and the integers  n ,  source , and  destination , return  true  if there is a  valid path  from  source  to  destination , or  false  otherwise .   Example 1: Input:  n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output:  true Explanation:  There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2: Input:  n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output:  false Explanation:  There is no path from vertex 0 to vertex 5.   Constraints: 1 <= n <= 2 * 10 5 0 <= edges.length <= 2 * 10 5 edges[i].length == 2 0 <= u i , v i  <= n - 1 u i  != v i 0 <= source, destination <= n - 1 There are no duplicate edges. There are no self edges.","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Fácil,Depth-First Search
207,course-schedule,https://leetcode.com/problems/course-schedule/,Course Schedule,"There are a total of  numCourses  courses you have to take, labeled from  0  to  numCourses - 1 . You are given an array  prerequisites  where  prerequisites[i] = [a i , b i ]  indicates that you  must  take course  b i  first if you want to take course  a i . For example, the pair  [0, 1] , indicates that to take course  0  you have to first take course  1 . Return  true  if you can finish all courses. Otherwise, return  false .   Example 1: Input:  numCourses = 2, prerequisites = [[1,0]] Output:  true Explanation:  There are a total of 2 courses to take.  To take course 1 you should have finished course 0. So it is possible. Example 2: Input:  numCourses = 2, prerequisites = [[1,0],[0,1]] Output:  false Explanation:  There are a total of 2 courses to take.  To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.   Constraints: 1 <= numCourses <= 2000 0 <= prerequisites.length <= 5000 prerequisites[i].length == 2 0 <= a i , b i  < numCourses All the pairs prerequisites[i] are  unique .","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Média,Depth-First Search
310,minimum-height-trees,https://leetcode.com/problems/minimum-height-trees/,Minimum Height Trees,"A tree is an undirected graph in which any two vertices are connected by  exactly  one path. In other words, any connected graph without simple cycles is a tree. Given a tree of  n  nodes labelled from  0  to  n - 1 , and an array of  n - 1   edges  where  edges[i] = [a i , b i ]  indicates that there is an undirected edge between the two nodes  a i  and  b i  in the tree, you can choose any node of the tree as the root. When you select a node  x  as the root, the result tree has height  h . Among all possible rooted trees, those with minimum height (i.e.  min(h) )  are called  minimum height trees  (MHTs). Return  a list of all  MHTs'  root labels . You can return the answer in  any order . The  height  of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   Example 1: Input:  n = 4, edges = [[1,0],[1,2],[1,3]] Output:  [1] Explanation:  As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT. Example 2: Input:  n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output:  [3,4]   Constraints: 1 <= n <= 2 * 10 4 edges.length == n - 1 0 <= a i , b i  < n a i  != b i All the pairs  (a i , b i )  are distinct. The given input is  guaranteed  to be a tree and there will be  no repeated  edges.","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Média,Depth-First Search
386,lexicographical-numbers,https://leetcode.com/problems/lexicographical-numbers/,Lexicographical Numbers,"Given an integer  n , return all the numbers in the range  [1, n]  sorted in lexicographical order. You must write an algorithm that runs in  O(n)  time and uses  O(1)  extra space.    Example 1: Input:  n = 13 Output:  [1,10,11,12,13,2,3,4,5,6,7,8,9] Example 2: Input:  n = 2 Output:  [1,2]   Constraints: 1 <= n <= 5 * 10 4","['Depth-First Search', 'Trie']",Média,Depth-First Search
547,number-of-provinces,https://leetcode.com/problems/number-of-provinces/,Number of Provinces,"There are  n  cities. Some of them are connected, while some are not. If city  a  is connected directly with city  b , and city  b  is connected directly with city  c , then city  a  is connected indirectly with city  c . A  province  is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an  n x n  matrix  isConnected  where  isConnected[i][j] = 1  if the  i th  city and the  j th  city are directly connected, and  isConnected[i][j] = 0  otherwise. Return  the total number of  provinces .   Example 1: Input:  isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output:  2 Example 2: Input:  isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output:  3   Constraints: 1 <= n <= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j]  is  1  or  0 . isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i]","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
684,redundant-connection,https://leetcode.com/problems/redundant-connection/,Redundant Connection,"In this problem, a tree is an  undirected graph  that is connected and has no cycles. You are given a graph that started as a tree with  n  nodes labeled from  1  to  n , with one additional edge added. The added edge has two  different  vertices chosen from  1  to  n , and was not an edge that already existed. The graph is represented as an array  edges  of length  n  where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the graph. Return  an edge that can be removed so that the resulting graph is a tree of  n  nodes . If there are multiple answers, return the answer that occurs last in the input.   Example 1: Input:  edges = [[1,2],[1,3],[2,3]] Output:  [2,3] Example 2: Input:  edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] Output:  [1,4]   Constraints: n == edges.length 3 <= n <= 1000 edges[i].length == 2 1 <= a i  < b i  <= edges.length a i  != b i There are no repeated edges. The given graph is connected.","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
785,is-graph-bipartite,https://leetcode.com/problems/is-graph-bipartite/,Is Graph Bipartite?,"There is an  undirected  graph with  n  nodes, where each node is numbered between  0  and  n - 1 . You are given a 2D array  graph , where  graph[u]  is an array of nodes that node  u  is adjacent to. More formally, for each  v  in  graph[u] , there is an undirected edge between node  u  and node  v . The graph has the following properties: There are no self-edges ( graph[u]  does not contain  u ). There are no parallel edges ( graph[u]  does not contain duplicate values). If  v  is in  graph[u] , then  u  is in  graph[v]  (the graph is undirected). The graph may not be connected, meaning there may be two nodes  u  and  v  such that there is no path between them. A graph is  bipartite  if the nodes can be partitioned into two independent sets  A  and  B  such that  every  edge in the graph connects a node in set  A  and a node in set  B . Return  true  if and only if it is  bipartite .   Example 1: Input:  graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output:  false Explanation:  There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. Example 2: Input:  graph = [[1,3],[0,2],[1,3],[0,2]] Output:  true Explanation:  We can partition the nodes into two sets: {0, 2} and {1, 3}.   Constraints: graph.length == n 1 <= n <= 100 0 <= graph[u].length < n 0 <= graph[u][i] <= n - 1 graph[u]  does not contain  u . All the values of  graph[u]  are  unique . If  graph[u]  contains  v , then  graph[v]  contains  u .","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
802,find-eventual-safe-states,https://leetcode.com/problems/find-eventual-safe-states/,Find Eventual Safe States,"There is a directed graph of  n  nodes with each node labeled from  0  to  n - 1 . The graph is represented by a  0-indexed  2D integer array  graph  where  graph[i]  is an integer array of nodes adjacent to node  i , meaning there is an edge from node  i  to each node in  graph[i] . A node is a  terminal node  if there are no outgoing edges. A node is a  safe node  if every possible path starting from that node leads to a  terminal node  (or another safe node). Return  an array containing all the  safe nodes  of the graph . The answer should be sorted in  ascending  order.   Example 1: Input:  graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output:  [2,4,5,6] Explanation:  The given graph is shown above. Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them. Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6. Example 2: Input:  graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] Output:  [4] Explanation: Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.   Constraints: n == graph.length 1 <= n <= 10 4 0 <= graph[i].length <= n 0 <= graph[i][j] <= n - 1 graph[i]  is sorted in a strictly increasing order. The graph may contain self-loops. The number of edges in the graph will be in the range  [1, 4 * 10 4 ] .","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Média,Depth-First Search
841,keys-and-rooms,https://leetcode.com/problems/keys-and-rooms/,Keys and Rooms,"There are  n  rooms labeled from  0  to  n - 1  and all the rooms are locked except for room  0 . Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of  distinct keys  in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array  rooms  where  rooms[i]  is the set of keys that you can obtain if you visited room  i , return  true   if you can visit  all  the rooms, or   false   otherwise .   Example 1: Input:  rooms = [[1],[2],[3],[]] Output:  true Explanation:   We visit room 0 and pick up key 1. We then visit room 1 and pick up key 2. We then visit room 2 and pick up key 3. We then visit room 3. Since we were able to visit every room, we return true. Example 2: Input:  rooms = [[1,3],[3,0,1],[2],[0]] Output:  false Explanation:  We can not enter room number 2 since the only key that unlocks it is in that room.   Constraints: n == rooms.length 2 <= n <= 1000 0 <= rooms[i].length <= 1000 1 <= sum(rooms[i].length) <= 3000 0 <= rooms[i][j] < n All the values of  rooms[i]  are  unique .","['Depth-First Search', 'Breadth-First Search', 'Graph']",Média,Depth-First Search
886,possible-bipartition,https://leetcode.com/problems/possible-bipartition/,Possible Bipartition,"We want to split a group of  n  people (labeled from  1  to  n ) into two groups of  any size . Each person may dislike some other people, and they should not go into the same group. Given the integer  n  and the array  dislikes  where  dislikes[i] = [a i , b i ]  indicates that the person labeled  a i  does not like the person labeled  b i , return  true   if it is possible to split everyone into two groups in this way .   Example 1: Input:  n = 4, dislikes = [[1,2],[1,3],[2,4]] Output:  true Explanation:  The first group has [1,4], and the second group has [2,3]. Example 2: Input:  n = 3, dislikes = [[1,2],[1,3],[2,3]] Output:  false Explanation:  We need at least 3 groups to divide them. We cannot put them in two groups.   Constraints: 1 <= n <= 2000 0 <= dislikes.length <= 10 4 dislikes[i].length == 2 1 <= a i  < b i  <= n All the pairs of  dislikes  are  unique .","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
1319,number-of-operations-to-make-network-connected,https://leetcode.com/problems/number-of-operations-to-make-network-connected/,Number of Operations to Make Network Connected,"There are  n  computers numbered from  0  to  n - 1  connected by ethernet cables  connections  forming a network where  connections[i] = [a i , b i ]  represents a connection between computers  a i  and  b i . Any computer can reach any other computer directly or indirectly through the network. You are given an initial computer network  connections . You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return  the minimum number of times you need to do this in order to make all the computers connected . If it is not possible, return  -1 .   Example 1: Input:  n = 4, connections = [[0,1],[0,2],[1,2]] Output:  1 Explanation:  Remove cable between computer 1 and 2 and place between computers 1 and 3. Example 2: Input:  n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] Output:  2 Example 3: Input:  n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] Output:  -1 Explanation:  There are not enough cables.   Constraints: 1 <= n <= 10 5 1 <= connections.length <= min(n * (n - 1) / 2, 10 5 ) connections[i].length == 2 0 <= a i , b i  < n a i  != b i There are no repeated connections. No two computers are connected by more than one cable.","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
2192,all-ancestors-of-a-node-in-a-directed-acyclic-graph,https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/,All Ancestors of a Node in a Directed Acyclic Graph,"You are given a positive integer  n  representing the number of nodes of a  Directed Acyclic Graph  (DAG). The nodes are numbered from  0  to  n - 1  ( inclusive ). You are also given a 2D integer array  edges , where  edges[i] = [from i , to i ]  denotes that there is a  unidirectional  edge from  from i  to  to i  in the graph. Return  a list   answer , where  answer[i]  is the  list of ancestors  of the   i th   node, sorted in  ascending order . A node  u  is an  ancestor  of another node  v  if  u  can reach  v  via a set of edges.   Example 1: Input:  n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]] Output:  [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]] Explanation: The above diagram represents the input graph. - Nodes 0, 1, and 2 do not have any ancestors. - Node 3 has two ancestors 0 and 1. - Node 4 has two ancestors 0 and 2. - Node 5 has three ancestors 0, 1, and 3. - Node 6 has five ancestors 0, 1, 2, 3, and 4. - Node 7 has four ancestors 0, 1, 2, and 3. Example 2: Input:  n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Output:  [[],[0],[0,1],[0,1,2],[0,1,2,3]] Explanation: The above diagram represents the input graph. - Node 0 does not have any ancestor. - Node 1 has one ancestor 0. - Node 2 has two ancestors 0 and 1. - Node 3 has three ancestors 0, 1, and 2. - Node 4 has four ancestors 0, 1, 2, and 3.   Constraints: 1 <= n <= 1000 0 <= edges.length <= min(2000, n * (n - 1) / 2) edges[i].length == 2 0 <= from i , to i  <= n - 1 from i  != to i There are no duplicate edges. The graph is  directed  and  acyclic .","['Depth-First Search', 'Breadth-First Search', 'Graph', 'Topological Sort']",Média,Depth-First Search
2316,count-unreachable-pairs-of-nodes-in-an-undirected-graph,https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/,Count Unreachable Pairs of Nodes in an Undirected Graph,"You are given an integer  n . There is an  undirected  graph with  n  nodes, numbered from  0  to  n - 1 . You are given a 2D integer array  edges  where  edges[i] = [a i , b i ]  denotes that there exists an  undirected  edge connecting nodes  a i  and  b i . Return  the  number of pairs  of different nodes that are  unreachable  from each other .   Example 1: Input:  n = 3, edges = [[0,1],[0,2],[1,2]] Output:  0 Explanation:  There are no pairs of nodes that are unreachable from each other. Therefore, we return 0. Example 2: Input:  n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]] Output:  14 Explanation:  There are 14 pairs of nodes that are unreachable from each other: [[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]. Therefore, we return 14.   Constraints: 1 <= n <= 10 5 0 <= edges.length <= 2 * 10 5 edges[i].length == 2 0 <= a i , b i  < n a i  != b i There are no repeated edges.","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
2492,minimum-score-of-a-path-between-two-cities,https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/,Minimum Score of a Path Between Two Cities,"You are given a positive integer  n  representing  n  cities numbered from  1  to  n . You are also given a  2D  array  roads  where  roads[i] = [a i , b i , distance i ]  indicates that there is a  bidirectional  road between cities  a i  and  b i  with a distance equal to  distance i . The cities graph is not necessarily connected. The  score  of a path between two cities is defined as the  minimum  distance of a road in this path. Return  the  minimum  possible score of a path between cities  1  and  n . Note : A path is a sequence of roads between two cities. It is allowed for a path to contain the same road  multiple  times, and you can visit cities  1  and  n  multiple times along the path. The test cases are generated such that there is  at least  one path between  1  and  n .   Example 1: Input:  n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]] Output:  5 Explanation:  The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5. It can be shown that no other path has less score. Example 2: Input:  n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]] Output:  2 Explanation:  The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.   Constraints: 2 <= n <= 10 5 1 <= roads.length <= 10 5 roads[i].length == 3 1 <= a i , b i  <= n a i  != b i 1 <= distance i  <= 10 4 There are no repeated edges. There is at least one path between  1  and  n .","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
2685,count-the-number-of-complete-components,https://leetcode.com/problems/count-the-number-of-complete-components/,Count the Number of Complete Components,"You are given an integer  n . There is an  undirected  graph with  n  vertices, numbered from  0  to  n - 1 . You are given a 2D integer array  edges  where  edges[i] = [a i , b i ]  denotes that there exists an  undirected  edge connecting vertices  a i  and  b i . Return  the number of  complete connected components  of the graph . A  connected component  is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph. A connected component is said to be  complete  if there exists an edge between every pair of its vertices.   Example 1: Input:  n = 6, edges = [[0,1],[0,2],[1,2],[3,4]] Output:  3 Explanation:  From the picture above, one can see that all of the components of this graph are complete. Example 2: Input:  n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]] Output:  1 Explanation:  The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.   Constraints: 1 <= n <= 50 0 <= edges.length <= n * (n - 1) / 2 edges[i].length == 2 0 <= a i , b i  <= n - 1 a i  != b i There are no repeated edges.","['Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Média,Depth-First Search
3310,remove-methods-from-project,https://leetcode.com/problems/remove-methods-from-project/,Remove Methods From Project,"You are maintaining a project that has  n  methods numbered from  0  to  n - 1 . You are given two integers  n  and  k , and a 2D integer array  invocations , where  invocations[i] = [a i , b i ]  indicates that method  a i  invokes method  b i . There is a known bug in method  k . Method  k , along with any method invoked by it, either  directly  or  indirectly , are considered  suspicious  and we aim to remove them. A group of methods can only be removed if no method  outside  the group invokes any methods  within  it. Return an array containing all the remaining methods after removing all the  suspicious  methods. You may return the answer in  any order . If it is not possible to remove  all  the suspicious methods,  none  should be removed.   Example 1: Input:   n = 4, k = 1, invocations = [[1,2],[0,1],[3,2]] Output:   [0,1,2,3] Explanation: Method 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything. Example 2: Input:   n = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]] Output:   [3,4] Explanation: Methods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them. Example 3: Input:   n = 3, k = 2, invocations = [[1,2],[0,1],[2,0]] Output:   [] Explanation: All methods are suspicious. We can remove them.   Constraints: 1 <= n <= 10 5 0 <= k <= n - 1 0 <= invocations.length <= 2 * 10 5 invocations[i] == [a i , b i ] 0 <= a i , b i  <= n - 1 a i  != b i invocations[i] != invocations[j]","['Depth-First Search', 'Breadth-First Search', 'Graph']",Média,Depth-First Search
715,range-module,https://leetcode.com/problems/range-module/,Range Module,"A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as  half-open intervals  and query about them. A  half-open interval   [left, right)  denotes all the real numbers  x  where  left <= x < right . Implement the  RangeModule  class: RangeModule()  Initializes the object of the data structure. void addRange(int left, int right)  Adds the  half-open interval   [left, right) , tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval  [left, right)  that are not already tracked. boolean queryRange(int left, int right)  Returns  true  if every real number in the interval  [left, right)  is currently being tracked, and  false  otherwise. void removeRange(int left, int right)  Stops tracking every real number currently being tracked in the  half-open interval   [left, right) .   Example 1: Input [""RangeModule"", ""addRange"", ""removeRange"", ""queryRange"", ""queryRange"", ""queryRange""] [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]] Output [null, null, null, true, false, true] Explanation RangeModule rangeModule = new RangeModule(); rangeModule.addRange(10, 20); rangeModule.removeRange(14, 16); rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked) rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)   Constraints: 1 <= left < right <= 10 9 At most  10 4  calls will be made to  addRange ,  queryRange , and  removeRange .","['Design', 'Segment Tree', 'Ordered Set']",Difícil,Design
1825,finding-mk-average,https://leetcode.com/problems/finding-mk-average/,Finding MK Average,"You are given two integers,  m  and  k , and a stream of integers. You are tasked to implement a data structure that calculates the  MKAverage  for the stream. The  MKAverage  can be calculated using these steps: If the number of the elements in the stream is less than  m  you should consider the  MKAverage  to be  -1 . Otherwise, copy the last  m  elements of the stream to a separate container. Remove the smallest  k  elements and the largest  k  elements from the container. Calculate the average value for the rest of the elements  rounded down to the nearest integer . Implement the  MKAverage  class: MKAverage(int m, int k)  Initializes the  MKAverage  object with an empty stream and the two integers  m  and  k . void addElement(int num)  Inserts a new element  num  into the stream. int calculateMKAverage()  Calculates and returns the  MKAverage  for the current stream  rounded down to the nearest integer .   Example 1: Input [""MKAverage"", ""addElement"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""addElement"", ""addElement"", ""calculateMKAverage""] [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []] Output [null, null, null, -1, null, 3, null, null, null, 5] Explanation MKAverage obj = new MKAverage(3, 1);  obj.addElement(3);        // current elements are [3] obj.addElement(1);        // current elements are [3,1] obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist. obj.addElement(10);       // current elements are [3,1,10] obj.calculateMKAverage(); // The last 3 elements are [3,1,10].                           // After removing smallest and largest 1 element the container will be [3].                           // The average of [3] equals 3/1 = 3, return 3 obj.addElement(5);        // current elements are [3,1,10,5] obj.addElement(5);        // current elements are [3,1,10,5,5] obj.addElement(5);        // current elements are [3,1,10,5,5,5] obj.calculateMKAverage(); // The last 3 elements are [5,5,5].                           // After removing smallest and largest 1 element the container will be [5].                           // The average of [5] equals 5/1 = 5, return 5   Constraints: 3 <= m <= 10 5 1 < k*2 < m 1 <= num <= 10 5 At most  10 5  calls will be made to  addElement  and  calculateMKAverage .","['Design', 'Queue', 'Heap (Priority Queue)', 'Data Stream', 'Ordered Set']",Difícil,Design
2102,sequentially-ordinal-rank-tracker,https://leetcode.com/problems/sequentially-ordinal-rank-tracker/,Sequentially Ordinal Rank Tracker,"A scenic location is represented by its  name  and attractiveness  score , where  name  is a  unique  string among all locations and  score  is an integer. Locations can be ranked from the best to the worst. The  higher  the score, the better the location. If the scores of two locations are equal, then the location with the  lexicographically smaller  name is better. You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports: Adding  scenic locations,  one at a time . Querying  the  i th   best  location of  all locations already added , where  i  is the number of times the system has been queried (including the current query). 	 For example, when the system is queried for the  4 th  time, it returns the  4 th  best location of all locations already added. Note that the test data are generated so that  at any time , the number of queries  does not exceed  the number of locations added to the system. Implement the  SORTracker  class: SORTracker()  Initializes the tracker system. void add(string name, int score)  Adds a scenic location with  name  and  score  to the system. string get()  Queries and returns the  i th  best location, where  i  is the number of times this method has been invoked (including this invocation).   Example 1: Input [""SORTracker"", ""add"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""get""] [[], [""bradford"", 2], [""branford"", 3], [], [""alps"", 2], [], [""orland"", 2], [], [""orlando"", 3], [], [""alpine"", 2], [], []] Output [null, null, null, ""branford"", null, ""alps"", null, ""bradford"", null, ""bradford"", null, ""bradford"", ""orland""] Explanation SORTracker tracker = new SORTracker(); // Initialize the tracker system. tracker.add(""bradford"", 2); // Add location with name=""bradford"" and score=2 to the system. tracker.add(""branford"", 3); // Add location with name=""branford"" and score=3 to the system. tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.                             // Note that branford precedes bradford due to its  higher score  (3 > 2).                             // This is the 1 st  time get() is called, so return the best location: ""branford"". tracker.add(""alps"", 2);     // Add location with name=""alps"" and score=2 to the system. tracker.get();              // Sorted locations: branford, alps, bradford.                             // Note that alps precedes bradford even though they have the same score (2).                             // This is because ""alps"" is  lexicographically smaller  than ""bradford"".                             // Return the 2 nd  best location ""alps"", as it is the 2 nd  time get() is called. tracker.add(""orland"", 2);   // Add location with name=""orland"" and score=2 to the system. tracker.get();              // Sorted locations: branford, alps, bradford, orland.                             // Return ""bradford"", as it is the 3 rd  time get() is called. tracker.add(""orlando"", 3);  // Add location with name=""orlando"" and score=3 to the system. tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.                             // Return ""bradford"". tracker.add(""alpine"", 2);   // Add location with name=""alpine"" and score=2 to the system. tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.                             // Return ""bradford"". tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.                             // Return ""orland"".   Constraints: name  consists of lowercase English letters, and is unique among all locations. 1 <= name.length <= 10 1 <= score <= 10 5 At any time, the number of calls to  get  does not exceed the number of calls to  add . At most  4 * 10 4  calls  in total  will be made to  add  and  get .","['Design', 'Heap (Priority Queue)', 'Data Stream', 'Ordered Set']",Difícil,Design
2276,count-integers-in-intervals,https://leetcode.com/problems/count-integers-in-intervals/,Count Integers in Intervals,"Given an  empty  set of intervals, implement a data structure that can: Add  an interval to the set of intervals. Count  the number of integers that are present in  at least one  interval. Implement the  CountIntervals  class: CountIntervals()  Initializes the object with an empty set of intervals. void add(int left, int right)  Adds the interval  [left, right]  to the set of intervals. int count()  Returns the number of integers that are present in  at least one  interval. Note  that an interval  [left, right]  denotes all the integers  x  where  left <= x <= right .   Example 1: Input [""CountIntervals"", ""add"", ""add"", ""count"", ""add"", ""count""] [[], [2, 3], [7, 10], [], [5, 8], []] Output [null, null, null, 6, null, 8] Explanation CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals.  countIntervals.add(2, 3);  // add [2, 3] to the set of intervals. countIntervals.add(7, 10); // add [7, 10] to the set of intervals. countIntervals.count();    // return 6                            // the integers 2 and 3 are present in the interval [2, 3].                            // the integers 7, 8, 9, and 10 are present in the interval [7, 10]. countIntervals.add(5, 8);  // add [5, 8] to the set of intervals. countIntervals.count();    // return 8                            // the integers 2 and 3 are present in the interval [2, 3].                            // the integers 5 and 6 are present in the interval [5, 8].                            // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].                            // the integers 9 and 10 are present in the interval [7, 10].   Constraints: 1 <= left <= right <= 10 9 At most  10 5  calls  in total  will be made to  add  and  count . At least  one  call will be made to  count .","['Design', 'Segment Tree', 'Ordered Set']",Difícil,Design
933,number-of-recent-calls,https://leetcode.com/problems/number-of-recent-calls/,Number of Recent Calls,"You have a  RecentCounter  class which counts the number of recent requests within a certain time frame. Implement the  RecentCounter  class: RecentCounter()  Initializes the counter with zero recent requests. int ping(int t)  Adds a new request at time  t , where  t  represents some time in milliseconds, and returns the number of requests that has happened in the past  3000  milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range  [t - 3000, t] . It is  guaranteed  that every call to  ping  uses a strictly larger value of  t  than the previous call.   Example 1: Input [""RecentCounter"", ""ping"", ""ping"", ""ping"", ""ping""] [[], [1], [100], [3001], [3002]] Output [null, 1, 2, 3, 3] Explanation RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1);     // requests = [ 1 ], range is [-2999,1], return 1 recentCounter.ping(100);   // requests = [ 1 ,  100 ], range is [-2900,100], return 2 recentCounter.ping(3001);  // requests = [ 1 ,  100 ,  3001 ], range is [1,3001], return 3 recentCounter.ping(3002);  // requests = [1,  100 ,  3001 ,  3002 ], range is [2,3002], return 3   Constraints: 1 <= t <= 10 9 Each test case will call  ping  with  strictly increasing  values of  t . At most  10 4  calls will be made to  ping .","['Design', 'Queue', 'Data Stream']",Fácil,Design
1603,design-parking-system,https://leetcode.com/problems/design-parking-system/,Design Parking System,"Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the  ParkingSystem  class: ParkingSystem(int big, int medium, int small)  Initializes object of the  ParkingSystem  class. The number of slots for each parking space are given as part of the constructor. bool addCar(int carType)  Checks whether there is a parking space of  carType  for the car that wants to get into the parking lot.  carType  can be of three kinds: big, medium, or small, which are represented by  1 ,  2 , and  3  respectively.  A car can only park in a parking space of its  carType . If there is no space available, return  false , else park the car in that size space and return  true .   Example 1: Input [""ParkingSystem"", ""addCar"", ""addCar"", ""addCar"", ""addCar""] [[1, 1, 0], [1], [2], [3], [1]] Output [null, true, true, false, false] Explanation ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // return true because there is 1 available slot for a big car parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car parkingSystem.addCar(3); // return false because there is no available slot for a small car parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.   Constraints: 0 <= big, medium, small <= 1000 carType  is  1 ,  2 , or  3 At most  1000  calls will be made to  addCar","['Design', 'Simulation', 'Counting']",Fácil,Design
855,exam-room,https://leetcode.com/problems/exam-room/,Exam Room,"There is an exam room with  n  seats in a single row labeled from  0  to  n - 1 . When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number  0 . Design a class that simulates the mentioned exam room. Implement the  ExamRoom  class: ExamRoom(int n)  Initializes the object of the exam room with the number of the seats  n . int seat()  Returns the label of the seat at which the next student will set. void leave(int p)  Indicates that the student sitting at seat  p  will leave the room. It is guaranteed that there will be a student sitting at seat  p .   Example 1: Input [""ExamRoom"", ""seat"", ""seat"", ""seat"", ""seat"", ""leave"", ""seat""] [[10], [], [], [], [], [4], []] Output [null, 0, 9, 4, 2, null, 5] Explanation ExamRoom examRoom = new ExamRoom(10); examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0. examRoom.seat(); // return 9, the student sits at the last seat number 9. examRoom.seat(); // return 4, the student sits at the last seat number 4. examRoom.seat(); // return 2, the student sits at the last seat number 2. examRoom.leave(4); examRoom.seat(); // return 5, the student sits at the last seat number 5.   Constraints: 1 <= n <= 10 9 It is guaranteed that there is a student sitting at seat  p . At most  10 4  calls will be made to  seat  and  leave .","['Design', 'Heap (Priority Queue)', 'Ordered Set']",Média,Design
1845,seat-reservation-manager,https://leetcode.com/problems/seat-reservation-manager/,Seat Reservation Manager,"Design a system that manages the reservation state of  n  seats that are numbered from  1  to  n . Implement the  SeatManager  class: SeatManager(int n)  Initializes a  SeatManager  object that will manage  n  seats numbered from  1  to  n . All seats are initially available. int reserve()  Fetches the  smallest-numbered  unreserved seat, reserves it, and returns its number. void unreserve(int seatNumber)  Unreserves the seat with the given  seatNumber .   Example 1: Input [""SeatManager"", ""reserve"", ""reserve"", ""unreserve"", ""reserve"", ""reserve"", ""reserve"", ""reserve"", ""unreserve""] [[5], [], [], [2], [], [], [], [], [5]] Output [null, 1, 2, null, 2, 3, 4, 5, null] Explanation SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats. seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1. seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5]. seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3. seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4. seatManager.reserve();    // The only available seat is seat 5, so return 5. seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].   Constraints: 1 <= n <= 10 5 1 <= seatNumber <= n For each call to  reserve , it is guaranteed that there will be at least one unreserved seat. For each call to  unreserve , it is guaranteed that  seatNumber  will be reserved. At most  10 5  calls  in total  will be made to  reserve  and  unreserve .","['Design', 'Heap (Priority Queue)']",Média,Design
2069,walking-robot-simulation-ii,https://leetcode.com/problems/walking-robot-simulation-ii/,Walking Robot Simulation II,"A  width x height  grid is on an XY-plane with the  bottom-left  cell at  (0, 0)  and the  top-right  cell at  (width - 1, height - 1) . The grid is aligned with the four cardinal directions ( ""North"" ,  ""East"" ,  ""South"" , and  ""West"" ). A robot is  initially  at cell  (0, 0)  facing direction  ""East"" . The robot can be instructed to move for a specific number of  steps . For each step, it does the following. Attempts to move  forward one  cell in the direction it is facing. If the cell the robot is  moving to  is  out of bounds , the robot instead  turns  90 degrees  counterclockwise  and retries the step. After the robot finishes moving the number of steps required, it stops and awaits the next instruction. Implement the  Robot  class: Robot(int width, int height)  Initializes the  width x height  grid with the robot at  (0, 0)  facing  ""East"" . void step(int num)  Instructs the robot to move forward  num  steps. int[] getPos()  Returns the current cell the robot is at, as an array of length 2,  [x, y] . String getDir()  Returns the current direction of the robot,  ""North"" ,  ""East"" ,  ""South"" , or  ""West"" .   Example 1: Input [""Robot"", ""step"", ""step"", ""getPos"", ""getDir"", ""step"", ""step"", ""step"", ""getPos"", ""getDir""] [[6, 3], [2], [2], [], [], [2], [1], [4], [], []] Output [null, null, null, [4, 0], ""East"", null, null, null, [1, 2], ""West""] Explanation Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East. robot.step(2);  // It moves two steps East to (2, 0), and faces East. robot.step(2);  // It moves two steps East to (4, 0), and faces East. robot.getPos(); // return [4, 0] robot.getDir(); // return ""East"" robot.step(2);  // It moves one step East to (5, 0), and faces East.                 // Moving the next step East would be out of bounds, so it turns and faces North.                 // Then, it moves one step North to (5, 1), and faces North. robot.step(1);  // It moves one step North to (5, 2), and faces  North  (not West). robot.step(4);  // Moving the next step North would be out of bounds, so it turns and faces West.                 // Then, it moves four steps West to (1, 2), and faces West. robot.getPos(); // return [1, 2] robot.getDir(); // return ""West""   Constraints: 2 <= width, height <= 100 1 <= num <= 10 5 At most  10 4  calls  in total  will be made to  step ,  getPos , and  getDir .","['Design', 'Simulation']",Média,Design
190,reverse-bits,https://leetcode.com/problems/reverse-bits/,Reverse Bits,"Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using  2's complement notation . Therefore, in  Example 2  above, the input represents the signed integer  -3  and the output represents the signed integer  -1073741825 .   Example 1: Input:  n = 00000010100101000001111010011100 Output:     964176192 (00111001011110000010100101000000) Explanation:  The input binary string  00000010100101000001111010011100  represents the unsigned integer 43261596, so return 964176192 which its binary representation is  00111001011110000010100101000000 . Example 2: Input:  n = 11111111111111111111111111111101 Output:    3221225471 (10111111111111111111111111111111) Explanation:  The input binary string  11111111111111111111111111111101  represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is  10111111111111111111111111111111 .   Constraints: The input must be a  binary string  of length  32   Follow up:  If this function is called many times, how would you optimize it?","['Divide and Conquer', 'Bit Manipulation']",Fácil,Divide and Conquer
191,number-of-1-bits,https://leetcode.com/problems/number-of-1-bits/,Number of 1 Bits,"Given a positive integer  n , write a function that returns the number of  set bits  in its binary representation (also known as the  Hamming weight ).   Example 1: Input:   n = 11 Output:   3 Explanation: The input binary string  1011  has a total of three set bits. Example 2: Input:   n = 128 Output:   1 Explanation: The input binary string  10000000  has a total of one set bit. Example 3: Input:   n = 2147483645 Output:   30 Explanation: The input binary string  1111111111111111111111111111101  has a total of thirty set bits.   Constraints: 1 <= n <= 2 31  - 1   Follow up:  If this function is called many times, how would you optimize it?","['Divide and Conquer', 'Bit Manipulation']",Fácil,Divide and Conquer
558,logical-or-of-two-binary-grids-represented-as-quad-trees,https://leetcode.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/,Logical OR of Two Binary Grids Represented as Quad-Trees,"A Binary Matrix is a matrix in which all the elements are either  0  or  1 . Given  quadTree1  and  quadTree2 .  quadTree1  represents a  n * n  binary matrix and  quadTree2  represents another  n * n  binary matrix. Return  a Quad-Tree  representing the  n * n  binary matrix which is the result of  logical bitwise OR  of the two binary matrixes represented by  quadTree1  and  quadTree2 . Notice that you can assign the value of a node to  True  or  False  when  isLeaf  is  False , and both are  accepted  in the answer. A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes: val : True if the node represents a grid of 1's or False if the node represents a grid of 0's. isLeaf : True if the node is leaf node on the tree or False if the node has the four children. class Node {     public boolean val;     public boolean isLeaf;     public Node topLeft;     public Node topRight;     public Node bottomLeft;     public Node bottomRight; } We can construct a Quad-Tree from a two-dimensional area using the following steps: If the current grid has the same value (i.e all  1's  or all  0's ) set  isLeaf  True and set  val  to the value of the grid and set the four children to Null and stop. If the current grid has different values, set  isLeaf  to False and set  val  to any value and divide the current grid into four sub-grids as shown in the photo. Recurse for each of the children with the proper sub-grid. If you want to know more about the Quad-Tree, you can refer to the  wiki . Quad-Tree format: The input/output represents the serialized format of a Quad-Tree using level order traversal, where  null  signifies a path terminator where no node exists below. It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list  [isLeaf, val] . If the value of  isLeaf  or  val  is True we represent it as  1  in the list  [isLeaf, val]  and if the value of  isLeaf  or  val  is False we represent it as  0 .   Example 1:   Input:  quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]] , quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]] Output:  [[0,0],[1,1],[1,1],[1,1],[1,0]] Explanation:  quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree. If we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree. Notice that the binary matrices shown are only for illustration, you don't have to construct the binary matrix to get the result tree. Example 2: Input:  quadTree1 = [[1,0]], quadTree2 = [[1,0]] Output:  [[1,0]] Explanation:  Each tree represents a binary matrix of size 1*1. Each matrix contains only zero. The resulting matrix is of size 1*1 with also zero.   Constraints: quadTree1  and  quadTree2  are both  valid  Quad-Trees each representing a  n * n  grid. n == 2 x  where  0 <= x <= 9 .","['Divide and Conquer', 'Tree']",Média,Divide and Conquer
1382,balance-a-binary-search-tree,https://leetcode.com/problems/balance-a-binary-search-tree/,Balance a Binary Search Tree,"Given the  root  of a binary search tree, return  a  balanced  binary search tree with the same node values . If there is more than one answer, return  any of them . A binary search tree is  balanced  if the depth of the two subtrees of every node never differs by more than  1 .   Example 1: Input:  root = [1,null,2,null,3,null,4,null,null] Output:  [2,1,3,null,null,null,4] Explanation:  This is not the only correct answer, [3,1,4,null,2] is also correct. Example 2: Input:  root = [2,1,3] Output:  [2,1,3]   Constraints: The number of nodes in the tree is in the range  [1, 10 4 ] . 1 <= Node.val <= 10 5","['Divide and Conquer', 'Greedy', 'Tree', 'Depth-First Search', 'Binary Search Tree', 'Binary Tree']",Média,Divide and Conquer
1411,number-of-ways-to-paint-n-3-grid,https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/,Number of Ways to Paint N × 3 Grid,"You have a  grid  of size  n x 3  and you want to paint each cell of the grid with exactly one of the three colors:  Red ,  Yellow,  or  Green  while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color). Given  n  the number of rows of the grid, return  the number of ways  you can paint this  grid . As the answer may grow large, the answer  must be  computed modulo  10 9  + 7 .   Example 1: Input:  n = 1 Output:  12 Explanation:  There are 12 possible way to paint the grid as shown. Example 2: Input:  n = 5000 Output:  30228214   Constraints: n == grid.length 1 <= n <= 5000",['Dynamic Programming'],Difícil,Dynamic Programming
2791,count-paths-that-can-form-a-palindrome-in-a-tree,https://leetcode.com/problems/count-paths-that-can-form-a-palindrome-in-a-tree/,Count Paths That Can Form a Palindrome in a Tree,"You are given a  tree  (i.e. a connected, undirected graph that has no cycles)  rooted  at node  0  consisting of  n  nodes numbered from  0  to  n - 1 . The tree is represented by a  0-indexed  array  parent  of size  n , where  parent[i]  is the parent of node  i . Since node  0  is the root,  parent[0] == -1 . You are also given a string  s  of length  n , where  s[i]  is the character assigned to the edge between  i  and  parent[i] .  s[0]  can be ignored. Return  the number of pairs of nodes  (u, v)  such that  u < v  and the characters assigned to edges on the path from  u  to  v  can be  rearranged  to form a  palindrome . A string is a  palindrome  when it reads the same backwards as forwards.   Example 1: Input:  parent = [-1,0,0,1,1,2], s = ""acaabc"" Output:  8 Explanation:  The valid pairs are: - All the pairs (0,1), (0,2), (1,3), (1,4) and (2,5) result in one character which is always a palindrome. - The pair (2,3) result in the string ""aca"" which is a palindrome. - The pair (1,5) result in the string ""cac"" which is a palindrome. - The pair (3,5) result in the string ""acac"" which can be rearranged into the palindrome ""acca"". Example 2: Input:  parent = [-1,0,0,0,0], s = ""aaaaa"" Output:  10 Explanation:  Any pair of nodes (u,v) where u < v is valid.   Constraints: n == parent.length == s.length 1 <= n <= 10 5 0 <= parent[i] <= n - 1  for all  i >= 1 parent[0] == -1 parent  represents a valid tree. s  consists of only lowercase English letters.","['Dynamic Programming', 'Bit Manipulation', 'Tree', 'Depth-First Search', 'Bitmask']",Difícil,Dynamic Programming
2858,minimum-edge-reversals-so-every-node-is-reachable,https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/,Minimum Edge Reversals So Every Node Is Reachable,"There is a  simple directed graph  with  n  nodes labeled from  0  to  n - 1 . The graph would form a  tree  if its edges were bi-directional. You are given an integer  n  and a  2D  integer array  edges , where  edges[i] = [u i , v i ]  represents a  directed edge  going from node  u i  to node  v i . An  edge reversal  changes the direction of an edge, i.e., a directed edge going from node  u i  to node  v i  becomes a directed edge going from node  v i  to node  u i . For every node  i  in the range  [0, n - 1] , your task is to  independently  calculate the  minimum  number of  edge reversals  required so it is possible to reach any other node starting from node  i  through a  sequence  of  directed edges . Return  an integer array  answer , where  answer[i]  is the     minimum  number of  edge reversals  required so it is possible to reach any other node starting from node  i  through a  sequence  of  directed edges .   Example 1: Input:  n = 4, edges = [[2,0],[2,1],[1,3]] Output:  [1,1,0,2] Explanation:  The image above shows the graph formed by the edges. For node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0. So, answer[0] = 1. For node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1. So, answer[1] = 1. For node 2: it is already possible to reach any other node starting from node 2. So, answer[2] = 0. For node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3. So, answer[3] = 2. Example 2: Input:  n = 3, edges = [[1,2],[2,0]] Output:  [2,0,1] Explanation:  The image above shows the graph formed by the edges. For node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0. So, answer[0] = 2. For node 1: it is already possible to reach any other node starting from node 1. So, answer[1] = 0. For node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2. So, answer[2] = 1.   Constraints: 2 <= n <= 10 5 edges.length == n - 1 edges[i].length == 2 0 <= u i  == edges[i][0] < n 0 <= v i  == edges[i][1] < n u i  != v i The input is generated such that if the edges were bi-directional, the graph would be a tree.","['Dynamic Programming', 'Depth-First Search', 'Breadth-First Search', 'Graph']",Difícil,Dynamic Programming
2876,count-visited-nodes-in-a-directed-graph,https://leetcode.com/problems/count-visited-nodes-in-a-directed-graph/,Count Visited Nodes in a Directed Graph,"There is a  directed  graph consisting of  n  nodes numbered from  0  to  n - 1  and  n  directed edges. You are given a  0-indexed  array  edges  where  edges[i]  indicates that there is an edge from node  i  to node  edges[i] . Consider the following process on the graph: You start from a node  x  and keep visiting other nodes through edges until you reach a node that you have already visited before on this  same  process. Return  an array  answer  where  answer[i]  is the number of  different  nodes that you will visit if you perform the process starting from node  i .   Example 1: Input:  edges = [1,2,0,0] Output:  [3,3,3,4] Explanation:  We perform the process starting from each node in the following way: - Starting from node 0, we visit the nodes 0 -> 1 -> 2 -> 0. The number of different nodes we visit is 3. - Starting from node 1, we visit the nodes 1 -> 2 -> 0 -> 1. The number of different nodes we visit is 3. - Starting from node 2, we visit the nodes 2 -> 0 -> 1 -> 2. The number of different nodes we visit is 3. - Starting from node 3, we visit the nodes 3 -> 0 -> 1 -> 2 -> 0. The number of different nodes we visit is 4. Example 2: Input:  edges = [1,2,3,4,0] Output:  [5,5,5,5,5] Explanation:  Starting from any node we can visit every node in the graph in the process.   Constraints: n == edges.length 2 <= n <= 10 5 0 <= edges[i] <= n - 1 edges[i] != i","['Dynamic Programming', 'Graph', 'Memoization']",Difícil,Dynamic Programming
2973,find-number-of-coins-to-place-in-tree-nodes,https://leetcode.com/problems/find-number-of-coins-to-place-in-tree-nodes/,Find Number of Coins to Place in Tree Nodes,"You are given an  undirected  tree with  n  nodes labeled from  0  to  n - 1 , and rooted at node  0 . You are given a 2D integer array  edges  of length  n - 1 , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. You are also given a  0-indexed  integer array  cost  of length  n , where  cost[i]  is the  cost  assigned to the  i th  node. You need to place some coins on every node of the tree. The number of coins to be placed at node  i  can be calculated as: If size of the subtree of node  i  is less than  3 , place  1  coin. Otherwise, place an amount of coins equal to the  maximum  product of cost values assigned to  3  distinct nodes in the subtree of node  i . If this product is  negative , place  0  coins. Return  an array  coin  of size  n  such that  coin[i]  is the number of coins placed at node  i .   Example 1: Input:  edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6] Output:  [120,1,1,1,1,1] Explanation:  For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them. Example 2: Input:  edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2] Output:  [280,140,32,1,1,1,1,1,1] Explanation:  The coins placed on each node are: - Place 8 * 7 * 5 = 280 coins on node 0. - Place 7 * 5 * 4 = 140 coins on node 1. - Place 8 * 2 * 2 = 32 coins on node 2. - All other nodes are leaves with subtree of size 1, place 1 coin on each of them. Example 3: Input:  edges = [[0,1],[0,2]], cost = [1,2,-2] Output:  [0,1,1] Explanation:  Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.   Constraints: 2 <= n <= 2 * 10 4 edges.length == n - 1 edges[i].length == 2 0 <= a i , b i  < n cost.length == n 1 <= |cost[i]| <= 10 4 The input is generated such that  edges  represents a valid tree.","['Dynamic Programming', 'Tree', 'Depth-First Search', 'Sorting', 'Heap (Priority Queue)']",Difícil,Dynamic Programming
3130,find-all-possible-stable-binary-arrays-ii,https://leetcode.com/problems/find-all-possible-stable-binary-arrays-ii/,Find All Possible Stable Binary Arrays II,"You are given 3 positive integers  zero ,  one , and  limit . A  binary array   arr  is called  stable  if: The number of occurrences of 0 in  arr  is  exactly  zero . The number of occurrences of 1 in  arr  is  exactly   one . Each  subarray  of  arr  with a size greater than  limit  must contain  both  0 and 1. Return the  total  number of  stable  binary arrays. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:   zero = 1, one = 1, limit = 2 Output:   2 Explanation: The two possible stable binary arrays are  [1,0]  and  [0,1] . Example 2: Input:   zero = 1, one = 2, limit = 1 Output:   1 Explanation: The only possible stable binary array is  [1,0,1] . Example 3: Input:   zero = 3, one = 3, limit = 2 Output:   14 Explanation: All the possible stable binary arrays are  [0,0,1,0,1,1] ,  [0,0,1,1,0,1] ,  [0,1,0,0,1,1] ,  [0,1,0,1,0,1] ,  [0,1,0,1,1,0] ,  [0,1,1,0,0,1] ,  [0,1,1,0,1,0] ,  [1,0,0,1,0,1] ,  [1,0,0,1,1,0] ,  [1,0,1,0,0,1] ,  [1,0,1,0,1,0] ,  [1,0,1,1,0,0] ,  [1,1,0,0,1,0] , and  [1,1,0,1,0,0] .   Constraints: 1 <= zero, one, limit <= 1000","['Dynamic Programming', 'Prefix Sum']",Difícil,Dynamic Programming
3241,time-taken-to-mark-all-nodes,https://leetcode.com/problems/time-taken-to-mark-all-nodes/,Time Taken to Mark All Nodes,"There exists an  undirected  tree with  n  nodes numbered  0  to  n - 1 . You are given a 2D integer array  edges  of length  n - 1 , where  edges[i] = [u i , v i ]  indicates that there is an edge between nodes  u i  and  v i  in the tree. Initially,  all  nodes are  unmarked . For each node  i : If  i  is odd, the node will get marked at time  x  if there is  at least  one node  adjacent  to it which was marked at time  x - 1 . If  i  is even, the node will get marked at time  x  if there is  at least  one node  adjacent  to it which was marked at time  x - 2 . Return an array  times  where  times[i]  is the time when all nodes get marked in the tree, if you mark node  i  at time  t = 0 . Note  that the answer for each  times[i]  is  independent , i.e. when you mark node  i  all other nodes are  unmarked .   Example 1: Input:   edges = [[0,1],[0,2]] Output:  [2,4,3] Explanation: For  i = 0 : 	 Node 1 is marked at  t = 1 , and Node 2 at  t = 2 . For  i = 1 : 	 Node 0 is marked at  t = 2 , and Node 2 at  t = 4 . For  i = 2 : 	 Node 0 is marked at  t = 2 , and Node 1 at  t = 3 . Example 2: Input:   edges = [[0,1]] Output:  [1,2] Explanation: For  i = 0 : 	 Node 1 is marked at  t = 1 . For  i = 1 : 	 Node 0 is marked at  t = 2 . Example 3: Input:   edges =  [[2,4],[0,1],[2,3],[0,2]] Output:  [4,6,3,5,5] Explanation:   Constraints: 2 <= n <= 10 5 edges.length == n - 1 edges[i].length == 2 0 <= edges[i][0], edges[i][1] <= n - 1 The input is generated such that  edges  represents a valid tree.","['Dynamic Programming', 'Tree', 'Depth-First Search', 'Graph']",Difícil,Dynamic Programming
338,counting-bits,https://leetcode.com/problems/counting-bits/,Counting Bits,"Given an integer  n , return  an array  ans  of length  n + 1  such that for each  i   ( 0 <= i <= n ) ,  ans[i]  is the  number of  1 's  in the binary representation of  i .   Example 1: Input:  n = 2 Output:  [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10 Example 2: Input:  n = 5 Output:  [0,1,1,2,1,2] Explanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101   Constraints: 0 <= n <= 10 5   Follow up: It is very easy to come up with a solution with a runtime of  O(n log n) . Can you do it in linear time  O(n)  and possibly in a single pass? Can you do it without using any built-in function (i.e., like  __builtin_popcount  in C++)?","['Dynamic Programming', 'Bit Manipulation']",Fácil,Dynamic Programming
95,unique-binary-search-trees-ii,https://leetcode.com/problems/unique-binary-search-trees-ii/,Unique Binary Search Trees II,"Given an integer  n , return  all the structurally unique  BST' s (binary search trees), which has exactly  n  nodes of unique values from   1   to   n . Return the answer in  any order .   Example 1: Input:  n = 3 Output:  [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] Example 2: Input:  n = 1 Output:  [[1]]   Constraints: 1 <= n <= 8","['Dynamic Programming', 'Backtracking', 'Tree', 'Binary Search Tree', 'Binary Tree']",Média,Dynamic Programming
337,house-robber-iii,https://leetcode.com/problems/house-robber-iii/,House Robber III,"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called  root . Besides the  root , each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if  two directly-linked houses were broken into on the same night . Given the  root  of the binary tree, return  the maximum amount of money the thief can rob  without alerting the police .   Example 1: Input:  root = [3,2,3,null,3,null,1] Output:  7 Explanation:  Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input:  root = [3,4,5,1,3,null,1] Output:  9 Explanation:  Maximum amount of money the thief can rob = 4 + 5 = 9.   Constraints: The number of nodes in the tree is in the range  [1, 10 4 ] . 0 <= Node.val <= 10 4","['Dynamic Programming', 'Tree', 'Depth-First Search', 'Binary Tree']",Média,Dynamic Programming
576,out-of-boundary-paths,https://leetcode.com/problems/out-of-boundary-paths/,Out of Boundary Paths,"There is an  m x n  grid with a ball. The ball is initially at the position  [startRow, startColumn] . You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply  at most   maxMove  moves to the ball. Given the five integers  m ,  n ,  maxMove ,  startRow ,  startColumn , return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0 Output:  6 Example 2: Input:  m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1 Output:  12   Constraints: 1 <= m, n <= 50 0 <= maxMove <= 50 0 <= startRow < m 0 <= startColumn < n",['Dynamic Programming'],Média,Dynamic Programming
688,knight-probability-in-chessboard,https://leetcode.com/problems/knight-probability-in-chessboard/,Knight Probability in Chessboard,"On an  n x n  chessboard, a knight starts at the cell  (row, column)  and attempts to make exactly  k  moves. The rows and columns are  0-indexed , so the top-left cell is  (0, 0) , and the bottom-right cell is  (n - 1, n - 1) . A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction. Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly  k  moves or has moved off the chessboard. Return  the probability that the knight remains on the board after it has stopped moving .   Example 1: Input:  n = 3, k = 2, row = 0, column = 0 Output:  0.06250 Explanation:  There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625. Example 2: Input:  n = 1, k = 0, row = 0, column = 0 Output:  1.00000   Constraints: 1 <= n <= 25 0 <= k <= 100 0 <= row, column <= n - 1",['Dynamic Programming'],Média,Dynamic Programming
787,cheapest-flights-within-k-stops,https://leetcode.com/problems/cheapest-flights-within-k-stops/,Cheapest Flights Within K Stops,"There are  n  cities connected by some number of flights. You are given an array  flights  where  flights[i] = [from i , to i , price i ]  indicates that there is a flight from city  from i  to city  to i  with cost  price i . You are also given three integers  src ,  dst , and  k , return  the cheapest price  from  src  to  dst  with at most  k  stops.  If there is no such route, return   -1 .   Example 1: Input:  n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1 Output:  700 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700. Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops. Example 2: Input:  n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 Output:  200 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200. Example 3: Input:  n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 Output:  500 Explanation: The graph is shown above. The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.   Constraints: 1 <= n <= 100 0 <= flights.length <= (n * (n - 1) / 2) flights[i].length == 3 0 <= from i , to i  < n from i  != to i 1 <= price i  <= 10 4 There will not be any multiple flights between two cities. 0 <= src, dst, k < n src != dst","['Dynamic Programming', 'Depth-First Search', 'Breadth-First Search', 'Graph', 'Heap (Priority Queue)', 'Shortest Path']",Média,Dynamic Programming
790,domino-and-tromino-tiling,https://leetcode.com/problems/domino-and-tromino-tiling/,Domino and Tromino Tiling,"You have two types of tiles: a  2 x 1  domino shape and a tromino shape. You may rotate these shapes. Given an integer n, return  the number of ways to tile an   2 x n   board . Since the answer may be very large, return it  modulo   10 9  + 7 . In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.   Example 1: Input:  n = 3 Output:  5 Explanation:  The five different ways are shown above. Example 2: Input:  n = 1 Output:  1   Constraints: 1 <= n <= 1000",['Dynamic Programming'],Média,Dynamic Programming
894,all-possible-full-binary-trees,https://leetcode.com/problems/all-possible-full-binary-trees/,All Possible Full Binary Trees,"Given an integer  n , return  a list of all possible  full binary trees  with   n   nodes . Each node of each tree in the answer must have  Node.val == 0 . Each element of the answer is the root node of one possible tree. You may return the final list of trees in  any order . A  full binary tree  is a binary tree where each node has exactly  0  or  2  children.   Example 1: Input:  n = 7 Output:  [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Example 2: Input:  n = 3 Output:  [[0,0,0]]   Constraints: 1 <= n <= 20","['Dynamic Programming', 'Tree', 'Recursion', 'Memoization', 'Binary Tree']",Média,Dynamic Programming
935,knight-dialer,https://leetcode.com/problems/knight-dialer/,Knight Dialer,"The chess knight has a  unique movement , it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an  L ). The possible movements of chess knight are shown in this diagram: A chess knight can move as indicated in the chess diagram below: We have a chess knight and a phone pad as shown below, the knight  can only stand on a numeric cell  (i.e. blue cell). Given an integer  n , return how many distinct phone numbers of length  n  we can dial. You are allowed to place the knight  on any numeric cell  initially and then you should perform  n - 1  jumps to dial a number of length  n . All jumps should be  valid  knight jumps. As the answer may be very large,  return the answer modulo   10 9  + 7 .   Example 1: Input:  n = 1 Output:  10 Explanation:  We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient. Example 2: Input:  n = 2 Output:  20 Explanation:  All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94] Example 3: Input:  n = 3131 Output:  136006598 Explanation:  Please take care of the mod.   Constraints: 1 <= n <= 5000",['Dynamic Programming'],Média,Dynamic Programming
1155,number-of-dice-rolls-with-target-sum,https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/,Number of Dice Rolls With Target Sum,"You have  n  dice, and each dice has  k  faces numbered from  1  to  k . Given three integers  n ,  k , and  target , return  the number of possible ways (out of the  k n  total ways)  to roll the dice, so the sum of the face-up numbers equals  target . Since the answer may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 1, k = 6, target = 3 Output:  1 Explanation:  You throw one die with 6 faces. There is only one way to get a sum of 3. Example 2: Input:  n = 2, k = 6, target = 7 Output:  6 Explanation:  You throw two dice, each with 6 faces. There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1. Example 3: Input:  n = 30, k = 30, target = 500 Output:  222616187 Explanation:  The answer must be returned modulo 10 9  + 7.   Constraints: 1 <= n, k <= 30 1 <= target <= 1000",['Dynamic Programming'],Média,Dynamic Programming
1334,find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance,https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/,Find the City With the Smallest Number of Neighbors at a Threshold Distance,"There are  n  cities numbered from  0  to  n-1 . Given the array  edges  where  edges[i] = [from i , to i , weight i ]  represents a bidirectional and weighted edge between cities  from i  and  to i , and given the integer  distanceThreshold . Return the city with the smallest number of cities that are reachable through some path and whose distance is  at most   distanceThreshold , If there are multiple such cities, return the city with the greatest number. Notice that the distance of a path connecting cities  i  and  j  is equal to the sum of the edges' weights along that path.   Example 1: Input:  n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 Output:  3 Explanation:  The figure above describes the graph.  The neighboring cities at a distanceThreshold = 4 for each city are: City 0 -> [City 1, City 2]  City 1 -> [City 0, City 2, City 3]  City 2 -> [City 0, City 1, City 3]  City 3 -> [City 1, City 2]  Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. Example 2: Input:  n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 Output:  0 Explanation:  The figure above describes the graph.  The neighboring cities at a distanceThreshold = 2 for each city are: City 0 -> [City 1]  City 1 -> [City 0, City 4]  City 2 -> [City 3, City 4]  City 3 -> [City 2, City 4] City 4 -> [City 1, City 2, City 3]  The city 0 has 1 neighboring city at a distanceThreshold = 2.   Constraints: 2 <= n <= 100 1 <= edges.length <= n * (n - 1) / 2 edges[i].length == 3 0 <= from i  < to i  < n 1 <= weight i , distanceThreshold <= 10^4 All pairs  (from i , to i )  are distinct.","['Dynamic Programming', 'Graph', 'Shortest Path']",Média,Dynamic Programming
1387,sort-integers-by-the-power-value,https://leetcode.com/problems/sort-integers-by-the-power-value/,Sort Integers by The Power Value,"The power of an integer  x  is defined as the number of steps needed to transform  x  into  1  using the following steps: if  x  is even then  x = x / 2 if  x  is odd then  x = 3 * x + 1 For example, the power of  x = 3  is  7  because  3  needs  7  steps to become  1  ( 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1 ). Given three integers  lo ,  hi  and  k . The task is to sort all integers in the interval  [lo, hi]  by the power value in  ascending order , if two or more integers have  the same  power value sort them by  ascending order . Return the  k th  integer in the range  [lo, hi]  sorted by the power value. Notice that for any integer  x   (lo <= x <= hi)  it is  guaranteed  that  x  will transform into  1  using these steps and that the power of  x  is will  fit  in a 32-bit signed integer.   Example 1: Input:  lo = 12, hi = 15, k = 2 Output:  13 Explanation:  The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1) The power of 13 is 9 The power of 14 is 17 The power of 15 is 17 The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13. Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15. Example 2: Input:  lo = 7, hi = 11, k = 4 Output:  7 Explanation:  The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14]. The interval sorted by power is [8, 10, 11, 7, 9]. The fourth number in the sorted array is 7.   Constraints: 1 <= lo <= hi <= 1000 1 <= k <= hi - lo + 1","['Dynamic Programming', 'Memoization', 'Sorting']",Média,Dynamic Programming
1786,number-of-restricted-paths-from-first-to-last-node,https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/,Number of Restricted Paths From First to Last Node,"There is an undirected weighted connected graph. You are given a positive integer  n  which denotes that the graph has  n  nodes labeled from  1  to  n , and an array  edges  where each  edges[i] = [u i , v i , weight i ]  denotes that there is an edge between nodes  u i  and  v i  with weight equal to  weight i . A path from node  start  to node  end  is a sequence of nodes  [z 0 , z 1 ,   z 2 , ..., z k ]  such that  z 0  = start  and  z k  = end  and there is an edge between  z i  and  z i+1  where  0 <= i <= k-1 . The distance of a path is the sum of the weights on the edges of the path. Let  distanceToLastNode(x)  denote the shortest distance of a path between node  n  and node  x . A  restricted path  is a path that also satisfies that  distanceToLastNode(z i ) > distanceToLastNode(z i+1 )  where  0 <= i <= k-1 . Return  the number of restricted paths from node   1   to node   n . Since that number may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] Output:  3 Explanation:  Each circle contains the node number in black and its  distanceToLastNode value in blue.  The three restricted paths are: 1) 1 --> 2 --> 5 2) 1 --> 2 --> 3 --> 5 3) 1 --> 3 --> 5 Example 2: Input:  n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] Output:  1 Explanation:  Each circle contains the node number in black and its  distanceToLastNode value in blue.  The only restricted path is 1 --> 3 --> 7.   Constraints: 1 <= n <= 2 * 10 4 n - 1 <= edges.length <= 4 * 10 4 edges[i].length == 3 1 <= u i , v i  <= n u i  != v i 1 <= weight i  <= 10 5 There is at most one edge between any two nodes. There is at least one path between any two nodes.","['Dynamic Programming', 'Graph', 'Topological Sort', 'Heap (Priority Queue)', 'Shortest Path']",Média,Dynamic Programming
2327,number-of-people-aware-of-a-secret,https://leetcode.com/problems/number-of-people-aware-of-a-secret/,Number of People Aware of a Secret,"On day  1 , one person discovers a secret. You are given an integer  delay , which means that each person will  share  the secret with a new person  every day , starting from  delay  days after discovering the secret. You are also given an integer  forget , which means that each person will  forget  the secret  forget  days after discovering it. A person  cannot  share the secret on the same day they forgot it, or on any day afterwards. Given an integer  n , return  the number of people who know the secret at the end of day  n . Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 6, delay = 2, forget = 4 Output:  5 Explanation: Day 1: Suppose the first person is named A. (1 person) Day 2: A is the only person who knows the secret. (1 person) Day 3: A shares the secret with a new person, B. (2 people) Day 4: A shares the secret with a new person, C. (3 people) Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people) Day 6: B shares the secret with E, and C shares the secret with F. (5 people) Example 2: Input:  n = 4, delay = 1, forget = 3 Output:  6 Explanation: Day 1: The first person is named A. (1 person) Day 2: A shares the secret with B. (2 people) Day 3: A and B share the secret with 2 new people, C and D. (4 people) Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)   Constraints: 2 <= n <= 1000 1 <= delay < forget <= n","['Dynamic Programming', 'Queue', 'Simulation']",Média,Dynamic Programming
2787,ways-to-express-an-integer-as-sum-of-powers,https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/,Ways to Express an Integer as Sum of Powers,"Given two  positive  integers  n  and  x . Return  the number of ways  n  can be expressed as the sum of the  x th  power of  unique  positive integers, in other words, the number of sets of unique integers  [n 1 , n 2 , ..., n k ]  where  n = n 1 x  + n 2 x  + ... + n k x . Since the result can be very large, return it modulo  10 9  + 7 . For example, if  n = 160  and  x = 3 , one way to express  n  is  n = 2 3  + 3 3  + 5 3 .   Example 1: Input:  n = 10, x = 2 Output:  1 Explanation:  We can express n as the following: n = 3 2  + 1 2  = 10. It can be shown that it is the only way to express 10 as the sum of the 2 nd  power of unique integers. Example 2: Input:  n = 4, x = 1 Output:  2 Explanation:  We can express n in the following ways: - n = 4 1  = 4. - n = 3 1  + 1 1  = 4.   Constraints: 1 <= n <= 300 1 <= x <= 5",['Dynamic Programming'],Média,Dynamic Programming
2925,maximum-score-after-applying-operations-on-a-tree,https://leetcode.com/problems/maximum-score-after-applying-operations-on-a-tree/,Maximum Score After Applying Operations on a Tree,"There is an undirected tree with  n  nodes labeled from  0  to  n - 1 , and rooted at node  0 . You are given a 2D integer array  edges  of length  n - 1 , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. You are also given a  0-indexed  integer array  values  of length  n , where  values[i]  is the  value  associated with the  i th  node. You start with a score of  0 . In one operation, you can: Pick any node  i . Add  values[i]  to your score. Set  values[i]  to  0 . A tree is  healthy  if the sum of values on the path from the root to any leaf node is different than zero. Return  the  maximum score  you can obtain after performing these operations on the tree any number of times so that it remains  healthy .   Example 1: Input:  edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1] Output:  11 Explanation:  We can choose nodes 1, 2, 3, 4, and 5. The value of the root is non-zero. Hence, the sum of values on the path from the root to any leaf is different than zero. Therefore, the tree is healthy and the score is values[1] + values[2] + values[3] + values[4] + values[5] = 11. It can be shown that 11 is the maximum score obtainable after any number of operations on the tree. Example 2: Input:  edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5] Output:  40 Explanation:  We can choose nodes 0, 2, 3, and 4. - The sum of values on the path from 0 to 4 is equal to 10. - The sum of values on the path from 0 to 3 is equal to 10. - The sum of values on the path from 0 to 5 is equal to 3. - The sum of values on the path from 0 to 6 is equal to 5. Therefore, the tree is healthy and the score is values[0] + values[2] + values[3] + values[4] = 40. It can be shown that 40 is the maximum score obtainable after any number of operations on the tree.   Constraints: 2 <= n <= 2 * 10 4 edges.length == n - 1 edges[i].length == 2 0 <= a i , b i  < n values.length == n 1 <= values[i] <= 10 9 The input is generated such that  edges  represents a valid tree.","['Dynamic Programming', 'Tree', 'Depth-First Search']",Média,Dynamic Programming
1291,sequential-digits,https://leetcode.com/problems/sequential-digits/,Sequential Digits,"An integer has  sequential digits  if and only if each digit in the number is one more than the previous digit. Return a  sorted  list of all the integers in the range  [low, high]  inclusive that have sequential digits.   Example 1: Input:  low = 100, high = 300 Output:  [123,234] Example 2: Input:  low = 1000, high = 13000 Output:  [1234,2345,3456,4567,5678,6789,12345]   Constraints: 10 <= low <= high <= 10^9",['Enumeration'],Média,Enumeration
882,reachable-nodes-in-subdivided-graph,https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/,Reachable Nodes In Subdivided Graph,"You are given an undirected graph (the  ""original graph"" ) with  n  nodes labeled from  0  to  n - 1 . You decide to  subdivide  each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge. The graph is given as a 2D array of  edges  where  edges[i] = [u i , v i , cnt i ]  indicates that there is an edge between nodes  u i  and  v i  in the original graph, and  cnt i  is the total number of new nodes that you will  subdivide  the edge into. Note that  cnt i  == 0  means you will not subdivide the edge. To  subdivide  the edge  [u i , v i ] , replace it with  (cnt i  + 1)  new edges and  cnt i  new nodes. The new nodes are  x 1 ,  x 2 , ...,  x cnt i , and the new edges are  [u i , x 1 ] ,  [x 1 , x 2 ] ,  [x 2 , x 3 ] , ...,  [x cnt i -1 , x cnt i ] ,  [x cnt i , v i ] . In this  new graph , you want to know how many nodes are  reachable  from the node  0 , where a node is  reachable  if the distance is  maxMoves  or less. Given the original graph and  maxMoves , return  the number of nodes that are  reachable  from node  0  in the new graph .   Example 1: Input:  edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3 Output:  13 Explanation:  The edge subdivisions are shown in the image above. The nodes that are reachable are highlighted in yellow. Example 2: Input:  edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4 Output:  23 Example 3: Input:  edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5 Output:  1 Explanation:  Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.   Constraints: 0 <= edges.length <= min(n * (n - 1) / 2, 10 4 ) edges[i].length == 3 0 <= u i  < v i  < n There are  no multiple edges  in the graph. 0 <= cnt i  <= 10 4 0 <= maxMoves <= 10 9 1 <= n <= 3000","['Graph', 'Heap (Priority Queue)', 'Shortest Path']",Difícil,Graph
1761,minimum-degree-of-a-connected-trio-in-a-graph,https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/,Minimum Degree of a Connected Trio in a Graph,"You are given an undirected graph. You are given an integer  n  which is the number of nodes in the graph and an array  edges , where each  edges[i] = [u i , v i ]  indicates that there is an undirected edge between  u i  and  v i . A  connected trio  is a set of  three  nodes where there is an edge between  every  pair of them. The  degree of a connected trio  is the number of edges where one endpoint is in the trio, and the other is not. Return  the  minimum  degree of a connected trio in the graph, or   -1   if the graph has no connected trios.   Example 1: Input:  n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] Output:  3 Explanation:  There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above. Example 2: Input:  n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] Output:  0 Explanation:  There are exactly three trios: 1) [1,4,3] with degree 0. 2) [2,5,6] with degree 2. 3) [5,6,7] with degree 2.   Constraints: 2 <= n <= 400 edges[i].length == 2 1 <= edges.length <= n * (n-1) / 2 1 <= u i , v i  <= n u i  != v i There are no repeated edges.",['Graph'],Difícil,Graph
2203,minimum-weighted-subgraph-with-the-required-paths,https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/,Minimum Weighted Subgraph With the Required Paths,"You are given an integer  n  denoting the number of nodes of a  weighted directed  graph. The nodes are numbered from  0  to  n - 1 . You are also given a 2D integer array  edges  where  edges[i] = [from i , to i , weight i ]  denotes that there exists a  directed  edge from  from i  to  to i  with weight  weight i . Lastly, you are given three  distinct  integers  src1 ,  src2 , and  dest  denoting three distinct nodes of the graph. Return  the  minimum weight  of a subgraph of the graph such that it is  possible  to reach   dest   from both   src1   and   src2   via a set of edges of this subgraph . In case such a subgraph does not exist, return  -1 . A  subgraph  is a graph whose vertices and edges are subsets of the original graph. The  weight  of a subgraph is the sum of weights of its constituent edges.   Example 1: Input:  n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5 Output:  9 Explanation: The above figure represents the input graph. The blue edges represent one of the subgraphs that yield the optimal answer. Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints. Example 2: Input:  n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2 Output:  -1 Explanation: The above figure represents the input graph. It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.   Constraints: 3 <= n <= 10 5 0 <= edges.length <= 10 5 edges[i].length == 3 0 <= from i , to i , src1, src2, dest <= n - 1 from i  != to i src1 ,  src2 , and  dest  are pairwise distinct. 1 <= weight[i] <= 10 5","['Graph', 'Shortest Path']",Difícil,Graph
2642,design-graph-with-shortest-path-calculator,https://leetcode.com/problems/design-graph-with-shortest-path-calculator/,Design Graph With Shortest Path Calculator,"There is a  directed weighted  graph that consists of  n  nodes numbered from  0  to  n - 1 . The edges of the graph are initially represented by the given array  edges  where  edges[i] = [from i , to i , edgeCost i ]  meaning that there is an edge from  from i  to  to i  with the cost  edgeCost i . Implement the  Graph  class: Graph(int n, int[][] edges)  initializes the object with  n  nodes and the given edges. addEdge(int[] edge)  adds an edge to the list of edges where  edge = [from, to, edgeCost] . It is guaranteed that there is no edge between the two nodes before adding this one. int shortestPath(int node1, int node2)  returns the  minimum  cost of a path from  node1  to  node2 . If no path exists, return  -1 . The cost of a path is the sum of the costs of the edges in the path.   Example 1: Input [""Graph"", ""shortestPath"", ""shortestPath"", ""addEdge"", ""shortestPath""] [[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]] Output [null, 6, -1, null, 6] Explanation Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]); g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6. g.shortestPath(0, 3); // return -1. There is no path from 0 to 3. g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above. g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.   Constraints: 1 <= n <= 100 0 <= edges.length <= n * (n - 1) edges[i].length == edge.length == 3 0 <= from i , to i , from, to, node1, node2 <= n - 1 1 <= edgeCost i , edgeCost <= 10 6 There are no repeated edges and no self-loops in the graph at any point. At most  100  calls will be made for  addEdge . At most  100  calls will be made for  shortestPath .","['Graph', 'Design', 'Heap (Priority Queue)', 'Shortest Path']",Difícil,Graph
2699,modify-graph-edge-weights,https://leetcode.com/problems/modify-graph-edge-weights/,Modify Graph Edge Weights,"You are given an  undirected weighted   connected  graph containing  n  nodes labeled from  0  to  n - 1 , and an integer array  edges  where  edges[i] = [a i , b i , w i ]  indicates that there is an edge between nodes  a i  and  b i  with weight  w i . Some edges have a weight of  -1  ( w i  = -1 ), while others have a  positive  weight ( w i  > 0 ). Your task is to modify  all edges  with a weight of  -1  by assigning them  positive integer values  in the range  [1, 2 * 10 9 ]  so that the  shortest distance  between the nodes  source  and  destination  becomes equal to an integer  target . If there are  multiple   modifications  that make the shortest distance between  source  and  destination  equal to  target , any of them will be considered correct. Return  an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from  source  to  destination  equal to  target , or an  empty array  if it's impossible. Note:  You are not allowed to modify the weights of edges with initial positive weights.   Example 1: Input:  n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5 Output:  [[4,1,1],[2,0,1],[0,3,3],[4,3,1]] Explanation:  The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5. Example 2: Input:  n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6 Output:  [] Explanation:  The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned. Example 3: Input:  n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6 Output:  [[1,0,4],[1,2,3],[2,3,5],[0,3,1]] Explanation:  The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.   Constraints: 1 <= n <= 100 1 <= edges.length <= n * (n - 1) / 2 edges[i].length == 3 0 <= a i , b i  < n w i  = -1  or  1 <= w i  <= 10 7 a i  != b i 0 <= source, destination < n source != destination 1 <= target <= 10 9 The graph is connected, and there are no self-loops or repeated edges","['Graph', 'Heap (Priority Queue)', 'Shortest Path']",Difícil,Graph
3017,count-the-number-of-houses-at-a-certain-distance-ii,https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-ii/,Count the Number of Houses at a Certain Distance II,"You are given three  positive  integers  n ,  x , and  y . In a city, there exist houses numbered  1  to  n  connected by  n  streets. There is a street connecting the house numbered  i  with the house numbered  i + 1  for all  1 <= i <= n - 1  . An additional street connects the house numbered  x  with the house numbered  y . For each  k , such that  1 <= k <= n , you need to find the number of  pairs of houses   (house 1 , house 2 )  such that the  minimum  number of streets that need to be traveled to reach  house 2  from  house 1  is  k . Return  a  1-indexed  array  result  of length  n  where  result[k]  represents the  total  number of pairs of houses such that the  minimum  streets required to reach one house from the other is  k . Note  that  x  and  y  can be  equal .   Example 1: Input:  n = 3, x = 1, y = 3 Output:  [6,0,0] Explanation:  Let's look at each pair of houses: - For the pair (1, 2), we can go from house 1 to house 2 directly. - For the pair (2, 1), we can go from house 2 to house 1 directly. - For the pair (1, 3), we can go from house 1 to house 3 directly. - For the pair (3, 1), we can go from house 3 to house 1 directly. - For the pair (2, 3), we can go from house 2 to house 3 directly. - For the pair (3, 2), we can go from house 3 to house 2 directly. Example 2: Input:  n = 5, x = 2, y = 4 Output:  [10,8,2,0,0] Explanation:  For each distance k the pairs are: - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4). - For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3). - For k == 3, the pairs are (1, 5), and (5, 1). - For k == 4 and k == 5, there are no pairs. Example 3: Input:  n = 4, x = 1, y = 1 Output:  [6,4,2,0] Explanation:  For each distance k the pairs are: - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3). - For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2). - For k == 3, the pairs are (1, 4), and (4, 1). - For k == 4, there are no pairs.   Constraints: 2 <= n <= 10 5 1 <= x, y <= n","['Graph', 'Prefix Sum']",Difícil,Graph
1791,find-center-of-star-graph,https://leetcode.com/problems/find-center-of-star-graph/,Find Center of Star Graph,"There is an undirected  star  graph consisting of  n  nodes labeled from  1  to  n . A star graph is a graph where there is one  center  node and  exactly   n - 1  edges that connect the center node with every other node. You are given a 2D integer array  edges  where each  edges[i] = [u i , v i ]  indicates that there is an edge between the nodes  u i  and  v i . Return the center of the given star graph.   Example 1: Input:  edges = [[1,2],[2,3],[4,2]] Output:  2 Explanation:  As shown in the figure above, node 2 is connected to every other node, so 2 is the center. Example 2: Input:  edges = [[1,2],[5,1],[1,3],[1,4]] Output:  1   Constraints: 3 <= n <= 10 5 edges.length == n - 1 edges[i].length == 2 1 <= u i,  v i  <= n u i  != v i The given  edges  represent a valid star graph.",['Graph'],Fácil,Graph
1557,minimum-number-of-vertices-to-reach-all-nodes,https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/,Minimum Number of Vertices to Reach All Nodes,"Given a  directed acyclic graph , with  n  vertices numbered from  0  to  n-1 , and an array  edges  where  edges[i] = [from i , to i ]  represents a directed edge from node  from i  to node  to i . Find  the smallest set of vertices from which all nodes in the graph are reachable . It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order.   Example 1: Input:  n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] Output:  [0,3] Explanation:  It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]. Example 2: Input:  n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] Output:  [0,2,3] Explanation:  Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.   Constraints: 2 <= n <= 10^5 1 <= edges.length <= min(10^5, n * (n - 1) / 2) edges[i].length == 2 0 <= from i,  to i  < n All pairs  (from i , to i )  are distinct.",['Graph'],Média,Graph
1615,maximal-network-rank,https://leetcode.com/problems/maximal-network-rank/,Maximal Network Rank,"There is an infrastructure of  n  cities with some number of  roads  connecting these cities. Each  roads[i] = [a i , b i ]  indicates that there is a bidirectional road between cities  a i  and  b i . The  network rank   of  two different cities  is defined as the total number of  directly  connected roads to  either  city. If a road is directly connected to both cities, it is only counted  once . The  maximal network rank  of the infrastructure is the  maximum network rank  of all pairs of different cities. Given the integer  n  and the array  roads , return  the  maximal network rank  of the entire infrastructure .   Example 1: Input:  n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] Output:  4 Explanation:  The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once. Example 2: Input:  n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] Output:  5 Explanation:  There are 5 roads that are connected to cities 1 or 2. Example 3: Input:  n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] Output:  5 Explanation:  The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.   Constraints: 2 <= n <= 100 0 <= roads.length <= n * (n - 1) / 2 roads[i].length == 2 0 <= a i , b i  <= n-1 a i  != b i Each pair of cities has  at most one  road connecting them.",['Graph'],Média,Graph
2924,find-champion-ii,https://leetcode.com/problems/find-champion-ii/,Find Champion II,"There are  n  teams numbered from  0  to  n - 1  in a tournament; each team is also a node in a  DAG . You are given the integer  n  and a  0-indexed  2D integer array  edges  of length  m  representing the  DAG , where  edges[i] = [u i , v i ]  indicates that there is a directed edge from team  u i  to team  v i  in the graph. A directed edge from  a  to  b  in the graph means that team  a  is  stronger  than team  b  and team  b  is  weaker  than team  a . Team  a  will be the  champion  of the tournament if there is no team  b  that is  stronger  than team  a . Return  the team that will be the  champion  of the tournament if there is a  unique  champion, otherwise, return  -1 . Notes A  cycle  is a series of nodes  a 1 , a 2 , ..., a n , a n+1  such that node  a 1  is the same node as node  a n+1 , the nodes  a 1 , a 2 , ..., a n  are distinct, and there is a directed edge from the node  a i  to node  a i+1  for every  i  in the range  [1, n] . A  DAG  is a directed graph that does not have any  cycle .   Example 1: Input:  n = 3, edges = [[0,1],[1,2]] Output:  0 Explanation:  Team 1 is weaker than team 0. Team 2 is weaker than team 1. So the champion is team 0. Example 2: Input:  n = 4, edges = [[0,2],[1,3],[1,2]] Output:  -1 Explanation:  Team 2 is weaker than team 0 and team 1. Team 3 is weaker than team 1. But team 1 and team 0 are not weaker than any other teams. So the answer is -1.   Constraints: 1 <= n <= 100 m == edges.length 0 <= m <= n * (n - 1) / 2 edges[i].length == 2 0 <= edge[i][j] <= n - 1 edges[i][0] != edges[i][1] The input is generated such that if team  a  is stronger than team  b , team  b  is not stronger than team  a . The input is generated such that if team  a  is stronger than team  b  and team  b  is stronger than team  c , then team  a  is stronger than team  c .",['Graph'],Média,Graph
765,couples-holding-hands,https://leetcode.com/problems/couples-holding-hands/,Couples Holding Hands,"There are  n  couples sitting in  2n  seats arranged in a row and want to hold hands. The people and seats are represented by an integer array  row  where  row[i]  is the ID of the person sitting in the  i th  seat. The couples are numbered in order, the first couple being  (0, 1) , the second couple being  (2, 3) , and so on with the last couple being  (2n - 2, 2n - 1) . Return  the minimum number of swaps so that every couple is sitting side by side . A swap consists of choosing any two people, then they stand up and switch seats.   Example 1: Input:  row = [0,2,1,3] Output:  1 Explanation:  We only need to swap the second (row[1]) and third (row[2]) person. Example 2: Input:  row = [3,2,0,1] Output:  0 Explanation:  All couples are already seated side by side.   Constraints: 2n == row.length 2 <= n <= 30 n  is even. 0 <= row[i] < 2n All the elements of  row  are  unique .","['Greedy', 'Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph']",Difícil,Greedy
3547,maximum-sum-of-edge-values-in-a-graph,https://leetcode.com/problems/maximum-sum-of-edge-values-in-a-graph/,Maximum Sum of Edge Values in a Graph,"You are given an  undirected connected  graph of  n  nodes, numbered from  0  to  n - 1 . Each node is connected to  at most  2 other nodes. The graph consists of  m  edges, represented by a 2D array  edges , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i . You have to assign a  unique  value from  1  to  n  to each node. The value of an edge will be the  product  of the values assigned to the two nodes it connects. Your score is the sum of the values of all edges in the graph. Return the  maximum  score you can achieve.   Example 1: Input:   n = 4, edges =  [[0,1],[1,2],[2,3]] Output:  23 Explanation: The diagram above illustrates an optimal assignment of values to nodes. The sum of the values of the edges is:  (1 * 3) + (3 * 4) + (4 * 2) = 23 . Example 2: Input:   n = 6, edges = [[0,3],[4,5],[2,0],[1,3],[2,4],[1,5]] Output:   82 Explanation: The diagram above illustrates an optimal assignment of values to nodes. The sum of the values of the edges is:  (1 * 2) + (2 * 4) + (4 * 6) + (6 * 5) + (5 * 3) + (3 * 1) = 82 .   Constraints: 1 <= n <= 5 * 10 4 m == edges.length 1 <= m <= n edges[i].length == 2 0 <= a i , b i  < n a i  != b i There are no repeated edges. The graph is connected. Each node is connected to at most 2 other nodes.","['Greedy', 'Depth-First Search', 'Graph', 'Sorting']",Difícil,Greedy
2285,maximum-total-importance-of-roads,https://leetcode.com/problems/maximum-total-importance-of-roads/,Maximum Total Importance of Roads,"You are given an integer  n  denoting the number of cities in a country. The cities are numbered from  0  to  n - 1 . You are also given a 2D integer array  roads  where  roads[i] = [a i , b i ]  denotes that there exists a  bidirectional  road connecting cities  a i  and  b i . You need to assign each city with an integer value from  1  to  n , where each value can only be used  once . The  importance  of a road is then defined as the  sum  of the values of the two cities it connects. Return  the  maximum total importance  of all roads possible after assigning the values optimally.   Example 1: Input:  n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] Output:  43 Explanation:  The figure above shows the country and the assigned values of [2,4,5,3,1]. - The road (0,1) has an importance of 2 + 4 = 6. - The road (1,2) has an importance of 4 + 5 = 9. - The road (2,3) has an importance of 5 + 3 = 8. - The road (0,2) has an importance of 2 + 5 = 7. - The road (1,3) has an importance of 4 + 3 = 7. - The road (2,4) has an importance of 5 + 1 = 6. The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43. It can be shown that we cannot obtain a greater total importance than 43. Example 2: Input:  n = 5, roads = [[0,3],[2,4],[1,3]] Output:  20 Explanation:  The figure above shows the country and the assigned values of [4,3,2,5,1]. - The road (0,3) has an importance of 4 + 5 = 9. - The road (2,4) has an importance of 2 + 1 = 3. - The road (1,3) has an importance of 3 + 5 = 8. The total importance of all roads is 9 + 3 + 8 = 20. It can be shown that we cannot obtain a greater total importance than 20.   Constraints: 2 <= n <= 5 * 10 4 1 <= roads.length <= 5 * 10 4 roads[i].length == 2 0 <= a i , b i  <= n - 1 a i  != b i There are no duplicate roads.","['Greedy', 'Graph', 'Sorting', 'Heap (Priority Queue)']",Média,Greedy
2429,minimize-xor,https://leetcode.com/problems/minimize-xor/,Minimize XOR,"Given two positive integers  num1  and  num2 , find the positive integer  x  such that: x  has the same number of set bits as  num2 , and The value  x XOR num1  is  minimal . Note that  XOR  is the bitwise XOR operation. Return  the integer  x . The test cases are generated such that  x  is  uniquely determined . The number of  set bits  of an integer is the number of  1 's in its binary representation.   Example 1: Input:  num1 = 3, num2 = 5 Output:  3 Explanation: The binary representations of num1 and num2 are 0011 and 0101, respectively. The integer  3  has the same number of set bits as num2, and the value  3 XOR 3 = 0  is minimal. Example 2: Input:  num1 = 1, num2 = 12 Output:  3 Explanation: The binary representations of num1 and num2 are 0001 and 1100, respectively. The integer  3  has the same number of set bits as num2, and the value  3 XOR 1 = 2  is minimal.   Constraints: 1 <= num1, num2 <= 10 9","['Greedy', 'Bit Manipulation']",Média,Greedy
30,substring-with-concatenation-of-all-words,https://leetcode.com/problems/substring-with-concatenation-of-all-words/,Substring with Concatenation of All Words,"You are given a string  s  and an array of strings  words . All the strings of  words  are of  the same length . A  concatenated string  is a string that exactly contains all the strings of any permutation of  words  concatenated. For example, if  words = [""ab"",""cd"",""ef""] , then  ""abcdef"" ,  ""abefcd"" ,  ""cdabef"" ,  ""cdefab"" ,  ""efabcd"" , and  ""efcdab""  are all concatenated strings.  ""acdbef""  is not a concatenated string because it is not the concatenation of any permutation of  words . Return an array of  the starting indices  of all the concatenated substrings in  s . You can return the answer in  any order .   Example 1: Input:   s = ""barfoothefoobarman"", words = [""foo"",""bar""] Output:   [0,9] Explanation: The substring starting at 0 is  ""barfoo"" . It is the concatenation of  [""bar"",""foo""]  which is a permutation of  words . The substring starting at 9 is  ""foobar"" . It is the concatenation of  [""foo"",""bar""]  which is a permutation of  words . Example 2: Input:   s = ""wordgoodgoodgoodbestword"", words = [""word"",""good"",""best"",""word""] Output:   [] Explanation: There is no concatenated substring. Example 3: Input:   s = ""barfoofoobarthefoobarman"", words = [""bar"",""foo"",""the""] Output:   [6,9,12] Explanation: The substring starting at 6 is  ""foobarthe"" . It is the concatenation of  [""foo"",""bar"",""the""] . The substring starting at 9 is  ""barthefoo"" . It is the concatenation of  [""bar"",""the"",""foo""] . The substring starting at 12 is  ""thefoobar"" . It is the concatenation of  [""the"",""foo"",""bar""] .   Constraints: 1 <= s.length <= 10 4 1 <= words.length <= 5000 1 <= words[i].length <= 30 s  and  words[i]  consist of lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Difícil,Hash Table
2949,count-beautiful-substrings-ii,https://leetcode.com/problems/count-beautiful-substrings-ii/,Count Beautiful Substrings II,"You are given a string  s  and a positive integer  k . Let  vowels  and  consonants  be the number of vowels and consonants in a string. A string is  beautiful  if: vowels == consonants . (vowels * consonants) % k == 0 , in other terms the multiplication of  vowels  and  consonants  is divisible by  k . Return  the number of  non-empty beautiful substrings  in the given string   s . A  substring  is a contiguous sequence of characters in a string. Vowel letters  in English are  'a' ,  'e' ,  'i' ,  'o' , and  'u' . Consonant letters  in English are every letter except vowels.   Example 1: Input:  s = ""baeyh"", k = 2 Output:  2 Explanation:  There are 2 beautiful substrings in the given string. - Substring ""b aeyh "", vowels = 2 ([""a"",e""]), consonants = 2 ([""y"",""h""]). You can see that string ""aeyh"" is beautiful as vowels == consonants and vowels * consonants % k == 0. - Substring "" baey h"", vowels = 2 ([""a"",e""]), consonants = 2 ([""b"",""y""]). You can see that string ""baey"" is beautiful as vowels == consonants and vowels * consonants % k == 0. It can be shown that there are only 2 beautiful substrings in the given string. Example 2: Input:  s = ""abba"", k = 1 Output:  3 Explanation:  There are 3 beautiful substrings in the given string. - Substring "" ab ba"", vowels = 1 ([""a""]), consonants = 1 ([""b""]). - Substring ""ab ba "", vowels = 1 ([""a""]), consonants = 1 ([""b""]). - Substring "" abba "", vowels = 2 ([""a"",""a""]), consonants = 2 ([""b"",""b""]). It can be shown that there are only 3 beautiful substrings in the given string. Example 3: Input:  s = ""bcdf"", k = 1 Output:  0 Explanation:  There are no beautiful substrings in the given string.   Constraints: 1 <= s.length <= 5 * 10 4 1 <= k <= 1000 s  consists of only English lowercase letters.","['Hash Table', 'Math', 'String', 'Number Theory', 'Prefix Sum']",Difícil,Hash Table
2953,count-complete-substrings,https://leetcode.com/problems/count-complete-substrings/,Count Complete Substrings,"You are given a string  word  and an integer  k . A substring  s  of  word  is  complete  if: Each character in  s  occurs  exactly   k  times. The difference between two adjacent characters is  at most   2 . That is, for any two adjacent characters  c1  and  c2  in  s , the absolute difference in their positions in the alphabet is  at most   2 . Return  the number of  complete  substrings of   word . A  substring  is a  non-empty  contiguous sequence of characters in a string.   Example 1: Input:  word = ""igigee"", k = 2 Output:  3 Explanation:  The complete substrings where each character appears exactly twice and the difference between adjacent characters is at most 2 are:  igig ee, igig ee ,  igigee . Example 2: Input:  word = ""aaabbbccc"", k = 3 Output:  6 Explanation:  The complete substrings where each character appears exactly three times and the difference between adjacent characters is at most 2 are:  aaa bbbccc, aaa bbb ccc, aaabbb ccc ,  aaabbb ccc, aaa bbbccc ,  aaabbbccc .   Constraints: 1 <= word.length <= 10 5 word  consists only of lowercase English letters. 1 <= k <= word.length","['Hash Table', 'String', 'Sliding Window']",Difícil,Hash Table
3272,find-the-count-of-good-integers,https://leetcode.com/problems/find-the-count-of-good-integers/,Find the Count of Good Integers,"You are given two  positive  integers  n  and  k . An integer  x  is called  k-palindromic  if: x  is a  palindrome . x  is divisible by  k . An integer is called  good  if its digits can be  rearranged  to form a  k-palindromic  integer. For example, for  k = 2 , 2020 can be rearranged to form the  k-palindromic  integer 2002, whereas 1010 cannot be rearranged to form a  k-palindromic  integer. Return the count of  good  integers containing  n  digits. Note  that  any  integer must  not  have leading zeros,  neither  before  nor  after rearrangement. For example, 1010  cannot  be rearranged to form 101.   Example 1: Input:   n = 3, k = 5 Output:   27 Explanation: Some  of the good integers are: 551 because it can be rearranged to form 515. 525 because it is already k-palindromic. Example 2: Input:   n = 1, k = 4 Output:   2 Explanation: The two good integers are 4 and 8. Example 3: Input:   n = 5, k = 6 Output:   2468   Constraints: 1 <= n <= 10 1 <= k <= 9","['Hash Table', 'Math', 'Combinatorics', 'Enumeration']",Difícil,Hash Table
3298,count-substrings-that-can-be-rearranged-to-contain-a-string-ii,https://leetcode.com/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/,Count Substrings That Can Be Rearranged to Contain a String II,"You are given two strings  word1  and  word2 . A string  x  is called  valid  if  x  can be rearranged to have  word2  as a  prefix . Return the total number of  valid   substrings  of  word1 . Note  that the memory limits in this problem are  smaller  than usual, so you  must  implement a solution with a  linear  runtime complexity.   Example 1: Input:   word1 = ""bcca"", word2 = ""abc"" Output:   1 Explanation: The only valid substring is  ""bcca""  which can be rearranged to  ""abcc""  having  ""abc""  as a prefix. Example 2: Input:   word1 = ""abcabc"", word2 = ""abc"" Output:   10 Explanation: All the substrings except substrings of size 1 and size 2 are valid. Example 3: Input:   word1 = ""abcabc"", word2 = ""aaabc"" Output:   0   Constraints: 1 <= word1.length <= 10 6 1 <= word2.length <= 10 4 word1  and  word2  consist only of lowercase English letters.","['Hash Table', 'String', 'Sliding Window']",Difícil,Hash Table
3337,total-characters-in-string-after-transformations-ii,https://leetcode.com/problems/total-characters-in-string-after-transformations-ii/,Total Characters in String After Transformations II,"You are given a string  s  consisting of lowercase English letters, an integer  t  representing the number of  transformations  to perform, and an array  nums  of size 26. In one  transformation , every character in  s  is replaced according to the following rules: Replace  s[i]  with the  next   nums[s[i] - 'a']  consecutive characters in the alphabet. For example, if  s[i] = 'a'  and  nums[0] = 3 , the character  'a'  transforms into the next 3 consecutive characters ahead of it, which results in  ""bcd"" . The transformation  wraps  around the alphabet if it exceeds  'z' . For example, if  s[i] = 'y'  and  nums[24] = 3 , the character  'y'  transforms into the next 3 consecutive characters ahead of it, which results in  ""zab"" . Return the length of the resulting string after  exactly   t  transformations. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:   s = ""abcyy"", t = 2, nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2] Output:   7 Explanation: First Transformation (t = 1): 'a'  becomes  'b'  as  nums[0] == 1 'b'  becomes  'c'  as  nums[1] == 1 'c'  becomes  'd'  as  nums[2] == 1 'y'  becomes  'z'  as  nums[24] == 1 'y'  becomes  'z'  as  nums[24] == 1 String after the first transformation:  ""bcdzz"" Second Transformation (t = 2): 'b'  becomes  'c'  as  nums[1] == 1 'c'  becomes  'd'  as  nums[2] == 1 'd'  becomes  'e'  as  nums[3] == 1 'z'  becomes  'ab'  as  nums[25] == 2 'z'  becomes  'ab'  as  nums[25] == 2 String after the second transformation:  ""cdeabab"" Final Length of the string:  The string is  ""cdeabab"" , which has 7 characters. Example 2: Input:   s = ""azbk"", t = 1, nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2] Output:   8 Explanation: First Transformation (t = 1): 'a'  becomes  'bc'  as  nums[0] == 2 'z'  becomes  'ab'  as  nums[25] == 2 'b'  becomes  'cd'  as  nums[1] == 2 'k'  becomes  'lm'  as  nums[10] == 2 String after the first transformation:  ""bcabcdlm"" Final Length of the string:  The string is  ""bcabcdlm"" , which has 8 characters.   Constraints: 1 <= s.length <= 10 5 s  consists only of lowercase English letters. 1 <= t <= 10 9 nums.length == 26 1 <= nums[i] <= 25","['Hash Table', 'Math', 'String', 'Dynamic Programming', 'Counting']",Difícil,Hash Table
160,intersection-of-two-linked-lists,https://leetcode.com/problems/intersection-of-two-linked-lists/,Intersection of Two Linked Lists,"Given the heads of two singly linked-lists  headA  and  headB , return  the node at which the two lists intersect . If the two linked lists have no intersection at all, return  null . For example, the following two linked lists begin to intersect at node  c1 : The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note  that the linked lists must  retain their original structure  after the function returns. Custom Judge: The inputs to the  judge  are given as follows (your program is  not  given these inputs): intersectVal  - The value of the node where the intersection occurs. This is  0  if there is no intersected node. listA  - The first linked list. listB  - The second linked list. skipA  - The number of nodes to skip ahead in  listA  (starting from the head) to get to the intersected node. skipB  - The number of nodes to skip ahead in  listB  (starting from the head) to get to the intersected node. The judge will then create the linked structure based on these inputs and pass the two heads,  headA  and  headB  to your program. If you correctly return the intersected node, then your solution will be  accepted .   Example 1: Input:  intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output:  Intersected at '8' Explanation:  The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. - Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2 nd  node in A and 3 rd  node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3 rd  node in A and 4 th  node in B) point to the same location in memory. Example 2: Input:  intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output:  Intersected at '2' Explanation:  The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: Input:  intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output:  No intersection Explanation:  From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null.   Constraints: The number of nodes of  listA  is in the  m . The number of nodes of  listB  is in the  n . 1 <= m, n <= 3 * 10 4 1 <= Node.val <= 10 5 0 <= skipA <= m 0 <= skipB <= n intersectVal  is  0  if  listA  and  listB  do not intersect. intersectVal == listA[skipA] == listB[skipB]  if  listA  and  listB  intersect.   Follow up:  Could you write a solution that runs in  O(m + n)  time and use only  O(1)  memory?","['Hash Table', 'Linked List', 'Two Pointers']",Fácil,Hash Table
859,buddy-strings,https://leetcode.com/problems/buddy-strings/,Buddy Strings,"Given two strings  s  and  goal , return  true  if you can swap two letters in  s  so the result is equal to  goal , otherwise, return  false . Swapping letters is defined as taking two indices  i  and  j  (0-indexed) such that  i != j  and swapping the characters at  s[i]  and  s[j] . For example, swapping at indices  0  and  2  in  ""abcd""  results in  ""cbad"" .   Example 1: Input:  s = ""ab"", goal = ""ba"" Output:  true Explanation:  You can swap s[0] = 'a' and s[1] = 'b' to get ""ba"", which is equal to goal. Example 2: Input:  s = ""ab"", goal = ""ab"" Output:  false Explanation:  The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in ""ba"" != goal. Example 3: Input:  s = ""aa"", goal = ""aa"" Output:  true Explanation:  You can swap s[0] = 'a' and s[1] = 'a' to get ""aa"", which is equal to goal.   Constraints: 1 <= s.length, goal.length <= 2 * 10 4 s  and  goal  consist of lowercase letters.","['Hash Table', 'String']",Fácil,Hash Table
1370,increasing-decreasing-string,https://leetcode.com/problems/increasing-decreasing-string/,Increasing Decreasing String,"You are given a string  s . Reorder the string using the following algorithm: Remove the  smallest  character from  s  and  append  it to the result. Remove the  smallest  character from  s  that is greater than the last appended character, and  append  it to the result. Repeat step 2 until no more characters can be removed. Remove the  largest  character from  s  and  append  it to the result. Remove the  largest  character from  s  that is smaller than the last appended character, and  append  it to the result. Repeat step 5 until no more characters can be removed. Repeat steps 1 through 6 until all characters from  s  have been removed. If the smallest or largest character appears more than once, you may choose any occurrence to append to the result. Return the resulting string after reordering  s  using this algorithm.   Example 1: Input:  s = ""aaaabbbbcccc"" Output:  ""abccbaabccba"" Explanation:  After steps 1, 2 and 3 of the first iteration, result = ""abc"" After steps 4, 5 and 6 of the first iteration, result = ""abccba"" First iteration is done. Now s = ""aabbcc"" and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = ""abccbaabc"" After steps 4, 5 and 6 of the second iteration, result = ""abccbaabccba"" Example 2: Input:  s = ""rat"" Output:  ""art"" Explanation:  The word ""rat"" becomes ""art"" after re-ordering it with the mentioned algorithm.   Constraints: 1 <= s.length <= 500 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table
2309,greatest-english-letter-in-upper-and-lower-case,https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/,Greatest English Letter in Upper and Lower Case,"Given a string of English letters  s , return  the  greatest  English letter which occurs as  both  a lowercase and uppercase letter in   s . The returned letter should be in  uppercase . If no such letter exists, return  an empty string . An English letter  b  is  greater  than another letter  a  if  b  appears  after   a  in the English alphabet.   Example 1: Input:  s = ""l Ee TcOd E "" Output:  ""E"" Explanation: The letter 'E' is the only letter to appear in both lower and upper case. Example 2: Input:  s = ""a rR AzFif"" Output:  ""R"" Explanation: The letter 'R' is the greatest letter to appear in both lower and upper case. Note that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'. Example 3: Input:  s = ""AbCdEfGhIjK"" Output:  """" Explanation: There is no letter that appears in both lower and upper case.   Constraints: 1 <= s.length <= 1000 s  consists of lowercase and uppercase English letters.","['Hash Table', 'String', 'Enumeration']",Fácil,Hash Table
2423,remove-letter-to-equalize-frequency,https://leetcode.com/problems/remove-letter-to-equalize-frequency/,Remove Letter To Equalize Frequency,"You are given a  0-indexed  string  word , consisting of lowercase English letters. You need to select  one  index and  remove  the letter at that index from  word  so that the  frequency  of every letter present in  word  is equal. Return   true  if it is possible to remove one letter so that the frequency of all letters in  word  are equal, and  false  otherwise . Note: The  frequency  of a letter  x  is the number of times it occurs in the string. You  must  remove exactly one letter and cannot choose to do nothing.   Example 1: Input:  word = ""abcc"" Output:  true Explanation:  Select index 3 and delete it: word becomes ""abc"" and each character has a frequency of 1. Example 2: Input:  word = ""aazz"" Output:  false Explanation:  We must delete a character, so either the frequency of ""a"" is 1 and the frequency of ""z"" is 2, or vice versa. It is impossible to make all present letters have equal frequency.   Constraints: 2 <= word.length <= 100 word  consists of lowercase English letters only.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table
2729,check-if-the-number-is-fascinating,https://leetcode.com/problems/check-if-the-number-is-fascinating/,Check if The Number is Fascinating,"You are given an integer  n  that consists of exactly  3  digits. We call the number  n   fascinating  if, after the following modification, the resulting number contains all the digits from  1  to  9   exactly  once and does not contain any  0 's: Concatenate   n  with the numbers  2 * n  and  3 * n . Return  true  if  n  is fascinating, or  false  otherwise . Concatenating  two numbers means joining them together. For example, the concatenation of  121  and  371  is  121371 .   Example 1: Input:  n = 192 Output:  true Explanation:  We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once. Example 2: Input:  n = 100 Output:  false Explanation:  We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.   Constraints: 100 <= n <= 999","['Hash Table', 'Math']",Fácil,Hash Table
3438,find-valid-pair-of-adjacent-digits-in-string,https://leetcode.com/problems/find-valid-pair-of-adjacent-digits-in-string/,Find Valid Pair of Adjacent Digits in String,"You are given a string  s  consisting only of digits. A  valid pair  is defined as two  adjacent  digits in  s  such that: The first digit is  not equal  to the second. Each digit in the pair appears in  s   exactly  as many times as its numeric value. Return the first  valid pair  found in the string  s  when traversing from left to right. If no valid pair exists, return an empty string.   Example 1: Input:   s = ""2523533"" Output:   ""23"" Explanation: Digit  '2'  appears 2 times and digit  '3'  appears 3 times. Each digit in the pair  ""23""  appears in  s  exactly as many times as its numeric value. Hence, the output is  ""23"" . Example 2: Input:   s = ""221"" Output:   ""21"" Explanation: Digit  '2'  appears 2 times and digit  '1'  appears 1 time. Hence, the output is  ""21"" . Example 3: Input:   s = ""22"" Output:   """" Explanation: There are no valid adjacent pairs.   Constraints: 2 <= s.length <= 100 s  only consists of digits from  '1'  to  '9' .","['Hash Table', 'String', 'Counting']",Fácil,Hash Table
3442,maximum-difference-between-even-and-odd-frequency-i,https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i/,Maximum Difference Between Even and Odd Frequency I,"You are given a string  s  consisting of lowercase English letters.  Your task is to find the  maximum  difference  diff = a 1  - a 2  between the frequency of characters  a 1  and  a 2  in the string such that: a 1  has an  odd frequency  in the string. a 2  has an  even frequency  in the string. Return this  maximum  difference.   Example 1: Input:   s = ""aaaaabbc"" Output:  3 Explanation: The character  'a'  has an  odd frequency  of  5 ,  and  'b'  has an  even frequency  of  2 . The maximum difference is  5 - 2 = 3 . Example 2: Input:   s = ""abcabcab"" Output:  1 Explanation: The character  'a'  has an  odd frequency  of  3 ,  and  'c'  has an  even frequency  of  2 . The maximum difference is  3 - 2 = 1 .   Constraints: 3 <= s.length <= 100 s  consists only of lowercase English letters. s  contains at least one character with an odd frequency and one with an even frequency.","['Hash Table', 'String', 'Counting']",Fácil,Hash Table
519,random-flip-matrix,https://leetcode.com/problems/random-flip-matrix/,Random Flip Matrix,"There is an  m x n  binary grid  matrix  with all the values set  0  initially. Design an algorithm to randomly pick an index  (i, j)  where  matrix[i][j] == 0  and flips it to  1 . All the indices  (i, j)  where  matrix[i][j] == 0  should be equally likely to be returned. Optimize your algorithm to minimize the number of calls made to the  built-in  random function of your language and optimize the time and space complexity. Implement the  Solution  class: Solution(int m, int n)  Initializes the object with the size of the binary matrix  m  and  n . int[] flip()  Returns a random index  [i, j]  of the matrix where  matrix[i][j] == 0  and flips it to  1 . void reset()  Resets all the values of the matrix to be  0 .   Example 1: Input [""Solution"", ""flip"", ""flip"", ""flip"", ""reset"", ""flip""] [[3, 1], [], [], [], [], []] Output [null, [1, 0], [2, 0], [0, 0], null, [2, 0]] Explanation Solution solution = new Solution(3, 1); solution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned. solution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0] solution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned. solution.reset(); // All the values are reset to 0 and can be returned. solution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.   Constraints: 1 <= m, n <= 10 4 There will be at least one free cell for each call to  flip . At most  1000  calls will be made to  flip  and  reset .","['Hash Table', 'Math', 'Reservoir Sampling', 'Randomized']",Média,Hash Table
676,implement-magic-dictionary,https://leetcode.com/problems/implement-magic-dictionary/,Implement Magic Dictionary,"Design a data structure that is initialized with a list of  different  words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure. Implement the  MagicDictionary  class: MagicDictionary()  Initializes the object. void buildDict(String[] dictionary)  Sets the data structure with an array of distinct strings  dictionary . bool search(String searchWord)  Returns  true  if you can change  exactly one character  in  searchWord  to match any string in the data structure, otherwise returns  false .   Example 1: Input [""MagicDictionary"", ""buildDict"", ""search"", ""search"", ""search"", ""search""] [[], [[""hello"", ""leetcode""]], [""hello""], [""hhllo""], [""hell""], [""leetcoded""]] Output [null, null, false, true, false, false] Explanation MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([""hello"", ""leetcode""]); magicDictionary.search(""hello""); // return False magicDictionary.search(""hhllo""); // We can change the second 'h' to 'e' to match ""hello"" so we return True magicDictionary.search(""hell""); // return False magicDictionary.search(""leetcoded""); // return False   Constraints: 1 <= dictionary.length <= 100 1 <= dictionary[i].length <= 100 dictionary[i]  consists of only lower-case English letters. All the strings in  dictionary  are  distinct . 1 <= searchWord.length <= 100 searchWord  consists of only lower-case English letters. buildDict  will be called only once before  search . At most  100  calls will be made to  search .","['Hash Table', 'String', 'Depth-First Search', 'Design', 'Trie']",Média,Hash Table
869,reordered-power-of-2,https://leetcode.com/problems/reordered-power-of-2/,Reordered Power of 2,You are given an integer  n . We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return  true   if and only if we can do this so that the resulting number is a power of two .   Example 1: Input:  n = 1 Output:  true Example 2: Input:  n = 10 Output:  false   Constraints: 1 <= n <= 10 9,"['Hash Table', 'Math', 'Sorting', 'Counting', 'Enumeration']",Média,Hash Table
947,most-stones-removed-with-same-row-or-column,https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/,Most Stones Removed with Same Row or Column,"On a 2D plane, we place  n  stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either  the same row or the same column  as another stone that has not been removed. Given an array  stones  of length  n  where  stones[i] = [x i , y i ]  represents the location of the  i th  stone, return  the largest possible number of stones that can be removed .   Example 1: Input:  stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output:  5 Explanation:  One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example 2: Input:  stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output:  3 Explanation:  One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example 3: Input:  stones = [[0,0]] Output:  0 Explanation:  [0,0] is the only stone on the plane, so you cannot remove it.   Constraints: 1 <= stones.length <= 1000 0 <= x i , y i  <= 10 4 No two stones are at the same coordinate point.","['Hash Table', 'Depth-First Search', 'Union Find', 'Graph']",Média,Hash Table
1410,html-entity-parser,https://leetcode.com/problems/html-entity-parser/,HTML Entity Parser,"HTML entity parser  is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: Quotation Mark:  the entity is  &quot;  and symbol character is  "" . Single Quote Mark:  the entity is  &apos;  and symbol character is  ' . Ampersand:  the entity is  &amp;  and symbol character is  & . Greater Than Sign:  the entity is  &gt;  and symbol character is  > . Less Than Sign:  the entity is  &lt;  and symbol character is  < . Slash:  the entity is  &frasl;  and symbol character is  / . Given the input  text  string to the HTML parser, you have to implement the entity parser. Return  the text after replacing the entities by the special characters .   Example 1: Input:  text = ""&amp; is an HTML entity but &ambassador; is not."" Output:  ""& is an HTML entity but &ambassador; is not."" Explanation:  The parser will replace the &amp; entity by & Example 2: Input:  text = ""and I quote: &quot;...&quot;"" Output:  ""and I quote: \""...\""""   Constraints: 1 <= text.length <= 10 5 The string may contain any possible characters out of all the 256 ASCII characters.","['Hash Table', 'String']",Média,Hash Table
1443,minimum-time-to-collect-all-apples-in-a-tree,https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/,Minimum Time to Collect All Apples in a Tree,"Given an undirected tree consisting of  n  vertices numbered from  0  to  n-1 , which has some apples in their vertices. You spend 1 second to walk over one edge of the tree.  Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at  vertex 0  and coming back to this vertex. The edges of the undirected tree are given in the array  edges , where  edges[i] = [a i , b i ]  means that exists an edge connecting the vertices  a i  and  b i . Additionally, there is a boolean array  hasApple , where  hasApple[i] = true  means that vertex  i  has an apple; otherwise, it does not have any apple.   Example 1: Input:  n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] Output:  8  Explanation:  The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.   Example 2: Input:  n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] Output:  6 Explanation:  The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.   Example 3: Input:  n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] Output:  0   Constraints: 1 <= n <= 10 5 edges.length == n - 1 edges[i].length == 2 0 <= a i  < b i  <= n - 1 hasApple.length == n","['Hash Table', 'Tree', 'Depth-First Search', 'Breadth-First Search']",Média,Hash Table
1461,check-if-a-string-contains-all-binary-codes-of-size-k,https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/,Check If a String Contains All Binary Codes of Size K,"Given a binary string  s  and an integer  k , return  true   if every binary code of length   k   is a substring of   s . Otherwise, return  false .   Example 1: Input:  s = ""00110110"", k = 2 Output:  true Explanation:  The binary codes of length 2 are ""00"", ""01"", ""10"" and ""11"". They can be all found as substrings at indices 0, 1, 3 and 2 respectively. Example 2: Input:  s = ""0110"", k = 1 Output:  true Explanation:  The binary codes of length 1 are ""0"" and ""1"", it is clear that both exist as a substring.  Example 3: Input:  s = ""0110"", k = 2 Output:  false Explanation:  The binary code ""00"" is of length 2 and does not exist in the array.   Constraints: 1 <= s.length <= 5 * 10 5 s[i]  is either  '0'  or  '1' . 1 <= k <= 20","['Hash Table', 'String', 'Bit Manipulation', 'Rolling Hash', 'Hash Function']",Média,Hash Table
1525,number-of-good-ways-to-split-a-string,https://leetcode.com/problems/number-of-good-ways-to-split-a-string/,Number of Good Ways to Split a String,"You are given a string  s . A split is called  good  if you can split  s  into two non-empty strings  s left  and  s right  where their concatenation is equal to  s  (i.e.,  s left  + s right  = s ) and the number of distinct letters in  s left  and  s right  is the same. Return  the number of  good splits  you can make in  s .   Example 1: Input:  s = ""aacaba"" Output:  2 Explanation:  There are 5 ways to split  ""aacaba""  and 2 of them are good.  (""a"", ""acaba"") Left string and right string contains 1 and 3 different letters respectively. (""aa"", ""caba"") Left string and right string contains 1 and 3 different letters respectively. (""aac"", ""aba"") Left string and right string contains 2 and 2 different letters respectively (good split). (""aaca"", ""ba"") Left string and right string contains 2 and 2 different letters respectively (good split). (""aacab"", ""a"") Left string and right string contains 3 and 1 different letters respectively. Example 2: Input:  s = ""abcd"" Output:  1 Explanation:  Split the string as follows (""ab"", ""cd"").   Constraints: 1 <= s.length <= 10 5 s  consists of only lowercase English letters.","['Hash Table', 'String', 'Dynamic Programming', 'Bit Manipulation']",Média,Hash Table
1647,minimum-deletions-to-make-character-frequencies-unique,https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/,Minimum Deletions to Make Character Frequencies Unique,"A string  s  is called  good  if there are no two different characters in  s  that have the same  frequency . Given a string  s , return  the  minimum  number of characters you need to delete to make  s   good . The  frequency  of a character in a string is the number of times it appears in the string. For example, in the string  ""aab"" , the  frequency  of  'a'  is  2 , while the  frequency  of  'b'  is  1 .   Example 1: Input:  s = ""aab"" Output:  0 Explanation:   s  is already good. Example 2: Input:  s = ""aaabbbcc"" Output:  2 Explanation:  You can delete two 'b's resulting in the good string ""aaabcc"". Another way it to delete one 'b' and one 'c' resulting in the good string ""aaabbc"". Example 3: Input:  s = ""ceabaacb"" Output:  2 Explanation:  You can delete both 'c's resulting in the good string ""eabaab"". Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).   Constraints: 1 <= s.length <= 10 5 s  contains only lowercase English letters.","['Hash Table', 'String', 'Greedy', 'Sorting']",Média,Hash Table
2349,design-a-number-container-system,https://leetcode.com/problems/design-a-number-container-system/,Design a Number Container System,"Design a number container system that can do the following: Insert  or  Replace  a number at the given index in the system. Return  the smallest index for the given number in the system. Implement the  NumberContainers  class: NumberContainers()  Initializes the number container system. void change(int index, int number)  Fills the container at  index  with the  number . If there is already a number at that  index , replace it. int find(int number)  Returns the smallest index for the given  number , or  -1  if there is no index that is filled by  number  in the system.   Example 1: Input [""NumberContainers"", ""find"", ""change"", ""change"", ""change"", ""change"", ""find"", ""change"", ""find""] [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]] Output [null, -1, null, null, null, null, 1, null, 2] Explanation NumberContainers nc = new NumberContainers(); nc.find(10); // There is no index that is filled with number 10. Therefore, we return -1. nc.change(2, 10); // Your container at index 2 will be filled with number 10. nc.change(1, 10); // Your container at index 1 will be filled with number 10. nc.change(3, 10); // Your container at index 3 will be filled with number 10. nc.change(5, 10); // Your container at index 5 will be filled with number 10. nc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1. nc.change(1, 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20.  nc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2.   Constraints: 1 <= index, number <= 10 9 At most  10 5  calls will be made  in total  to  change  and  find .","['Hash Table', 'Design', 'Heap (Priority Queue)', 'Ordered Set']",Média,Hash Table
2370,longest-ideal-subsequence,https://leetcode.com/problems/longest-ideal-subsequence/,Longest Ideal Subsequence,"You are given a string  s  consisting of lowercase letters and an integer  k . We call a string  t   ideal  if the following conditions are satisfied: t  is a  subsequence  of the string  s . The absolute difference in the alphabet order of every two  adjacent  letters in  t  is less than or equal to  k . Return  the length of the  longest  ideal string . A  subsequence  is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. Note  that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of  'a'  and  'z'  is  25 , not  1 .   Example 1: Input:  s = ""acfgbd"", k = 2 Output:  4 Explanation:  The longest ideal string is ""acbd"". The length of this string is 4, so 4 is returned. Note that ""acfgbd"" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order. Example 2: Input:  s = ""abcd"", k = 3 Output:  4 Explanation:  The longest ideal string is ""abcd"". The length of this string is 4, so 4 is returned.   Constraints: 1 <= s.length <= 10 5 0 <= k <= 25 s  consists of lowercase English letters.","['Hash Table', 'String', 'Dynamic Programming']",Média,Hash Table
2374,node-with-highest-edge-score,https://leetcode.com/problems/node-with-highest-edge-score/,Node With Highest Edge Score,"You are given a directed graph with  n  nodes labeled from  0  to  n - 1 , where each node has  exactly one  outgoing edge. The graph is represented by a given  0-indexed  integer array  edges  of length  n , where  edges[i]  indicates that there is a  directed  edge from node  i  to node  edges[i] . The  edge score  of a node  i  is defined as the sum of the  labels  of all the nodes that have an edge pointing to  i . Return  the node with the highest  edge score . If multiple nodes have the same  edge score , return the node with the  smallest  index.   Example 1: Input:  edges = [1,0,0,0,0,7,7,5] Output:  7 Explanation: - The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10. - The node 0 has an edge pointing to node 1. The edge score of node 1 is 0. - The node 7 has an edge pointing to node 5. The edge score of node 5 is 7. - The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11. Node 7 has the highest edge score so return 7. Example 2: Input:  edges = [2,0,0,2] Output:  0 Explanation: - The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3. - The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3. Nodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.   Constraints: n == edges.length 2 <= n <= 10 5 0 <= edges[i] < n edges[i] != i","['Hash Table', 'Graph']",Média,Hash Table
2385,amount-of-time-for-binary-tree-to-be-infected,https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/,Amount of Time for Binary Tree to Be Infected,"You are given the  root  of a binary tree with  unique  values, and an integer  start . At minute  0 , an  infection  starts from the node with value  start . Each minute, a node becomes infected if: The node is currently uninfected. The node is adjacent to an infected node. Return  the number of minutes needed for the entire tree to be infected.   Example 1: Input:  root = [1,5,3,null,4,10,6,9,2], start = 3 Output:  4 Explanation:  The following nodes are infected during: - Minute 0: Node 3 - Minute 1: Nodes 1, 10 and 6 - Minute 2: Node 5 - Minute 3: Node 4 - Minute 4: Nodes 9 and 2 It takes 4 minutes for the whole tree to be infected so we return 4. Example 2: Input:  root = [1], start = 1 Output:  0 Explanation:  At minute 0, the only node in the tree is infected so we return 0.   Constraints: The number of nodes in the tree is in the range  [1, 10 5 ] . 1 <= Node.val <= 10 5 Each node has a  unique  value. A node with a value of  start  exists in the tree.","['Hash Table', 'Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Média,Hash Table
2516,take-k-of-each-character-from-left-and-right,https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/,Take K of Each Character From Left and Right,"You are given a string  s  consisting of the characters  'a' ,  'b' , and  'c'  and a non-negative integer  k . Each minute, you may take either the  leftmost  character of  s , or the  rightmost  character of  s . Return  the  minimum  number of minutes needed for you to take  at least   k  of each character, or return  -1  if it is not possible to take  k  of each character.   Example 1: Input:  s = ""aabaaaacaabc"", k = 2 Output:  8 Explanation:   Take three characters from the left of s. You now have two 'a' characters, and one 'b' character. Take five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters. A total of 3 + 5 = 8 minutes is needed. It can be proven that 8 is the minimum number of minutes needed. Example 2: Input:  s = ""a"", k = 1 Output:  -1 Explanation:  It is not possible to take one 'b' or 'c' so return -1.   Constraints: 1 <= s.length <= 10 5 s  consists of only the letters  'a' ,  'b' , and  'c' . 0 <= k <= s.length","['Hash Table', 'String', 'Sliding Window']",Média,Hash Table
2526,find-consecutive-integers-from-a-data-stream,https://leetcode.com/problems/find-consecutive-integers-from-a-data-stream/,Find Consecutive Integers from a Data Stream,"For a stream of integers, implement a data structure that checks if the last  k  integers parsed in the stream are  equal  to  value . Implement the  DataStream  class: DataStream(int value, int k)  Initializes the object with an empty integer stream and the two integers  value  and  k . boolean consec(int num)  Adds  num  to the stream of integers. Returns  true  if the last  k  integers are equal to  value , and  false  otherwise. If there are less than  k  integers, the condition does not hold true, so returns  false .   Example 1: Input [""DataStream"", ""consec"", ""consec"", ""consec"", ""consec""] [[4, 3], [4], [4], [4], [3]] Output [null, false, false, true, false] Explanation DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3  dataStream.consec(4); // Only 1 integer is parsed, so returns False.  dataStream.consec(4); // Only 2 integers are parsed.                       // Since 2 is less than k, returns False.  dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True.  dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].                       // Since 3 is not equal to value, it returns False.   Constraints: 1 <= value, num <= 10 9 1 <= k <= 10 5 At most  10 5  calls will be made to  consec .","['Hash Table', 'Design', 'Queue', 'Counting', 'Data Stream']",Média,Hash Table
2531,make-number-of-distinct-characters-equal,https://leetcode.com/problems/make-number-of-distinct-characters-equal/,Make Number of Distinct Characters Equal,"You are given two  0-indexed  strings  word1  and  word2 . A  move  consists of choosing two indices  i  and  j  such that  0 <= i < word1.length  and  0 <= j < word2.length  and swapping  word1[i]  with  word2[j] . Return  true   if it is possible to get the number of distinct characters in   word1   and   word2   to be equal with  exactly one  move.  Return  false   otherwise .   Example 1: Input:  word1 = ""ac"", word2 = ""b"" Output:  false Explanation:  Any pair of swaps would yield two distinct characters in the first string, and one in the second string. Example 2: Input:  word1 = ""abcc"", word2 = ""aab"" Output:  true Explanation:  We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = ""abac"" and word2 = ""cab"", which both have 3 distinct characters. Example 3: Input:  word1 = ""abcde"", word2 = ""fghij"" Output:  true Explanation:  Both resulting strings will have 5 distinct characters, regardless of which indices we swap.   Constraints: 1 <= word1.length, word2.length <= 10 5 word1  and  word2  consist of only lowercase English letters.","['Hash Table', 'String', 'Counting']",Média,Hash Table
23,merge-k-sorted-lists,https://leetcode.com/problems/merge-k-sorted-lists/,Merge k Sorted Lists,"You are given an array of  k  linked-lists  lists , each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.   Example 1: Input:  lists = [[1,4,5],[1,3,4],[2,6]] Output:  [1,1,2,3,4,4,5,6] Explanation:  The linked-lists are: [   1->4->5,   1->3->4,   2->6 ] merging them into one sorted list: 1->1->2->3->4->4->5->6 Example 2: Input:  lists = [] Output:  [] Example 3: Input:  lists = [[]] Output:  []   Constraints: k == lists.length 0 <= k <= 10 4 0 <= lists[i].length <= 500 -10 4  <= lists[i][j] <= 10 4 lists[i]  is sorted in  ascending order . The sum of  lists[i].length  will not exceed  10 4 .","['Linked List', 'Divide and Conquer', 'Heap (Priority Queue)', 'Merge Sort']",Difícil,Linked List
25,reverse-nodes-in-k-group,https://leetcode.com/problems/reverse-nodes-in-k-group/,Reverse Nodes in k-Group,"Given the  head  of a linked list, reverse the nodes of the list  k  at a time, and return  the modified list . k  is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of  k  then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.   Example 1: Input:  head = [1,2,3,4,5], k = 2 Output:  [2,1,4,3,5] Example 2: Input:  head = [1,2,3,4,5], k = 3 Output:  [3,2,1,4,5]   Constraints: The number of nodes in the list is  n . 1 <= k <= n <= 5000 0 <= Node.val <= 1000   Follow-up:  Can you solve the problem in  O(1)  extra memory space?","['Linked List', 'Recursion']",Difícil,Linked List
1206,design-skiplist,https://leetcode.com/problems/design-skiplist/,Design Skiplist,"Design a  Skiplist  without using any built-in libraries. A  skiplist  is a data structure that takes  O(log(n))  time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists. For example, we have a Skiplist containing  [30,40,50,60,70,90]  and we want to add  80  and  45  into it. The Skiplist works this way: Artyom Kalinin [CC BY-SA 3.0], via  Wikimedia Commons You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than  O(n) . It can be proven that the average time complexity for each operation is  O(log(n))  and space complexity is  O(n) . See more about Skiplist:  https://en.wikipedia.org/wiki/Skip_list Implement the  Skiplist  class: Skiplist()  Initializes the object of the skiplist. bool search(int target)  Returns  true  if the integer  target  exists in the Skiplist or  false  otherwise. void add(int num)  Inserts the value  num  into the SkipList. bool erase(int num)  Removes the value  num  from the Skiplist and returns  true . If  num  does not exist in the Skiplist, do nothing and return  false . If there exist multiple  num  values, removing any one of them is fine. Note that duplicates may exist in the Skiplist, your code needs to handle this situation.   Example 1: Input [""Skiplist"", ""add"", ""add"", ""add"", ""search"", ""add"", ""search"", ""erase"", ""erase"", ""search""] [[], [1], [2], [3], [0], [4], [1], [0], [1], [1]] Output [null, null, null, null, false, null, true, false, true, false] Explanation Skiplist skiplist = new Skiplist(); skiplist.add(1); skiplist.add(2); skiplist.add(3); skiplist.search(0); // return False skiplist.add(4); skiplist.search(1); // return True skiplist.erase(0);  // return False, 0 is not in skiplist. skiplist.erase(1);  // return True skiplist.search(1); // return False, 1 has already been erased.   Constraints: 0 <= num, target <= 2 * 10 4 At most  5 * 10 4  calls will be made to  search ,  add , and  erase .","['Linked List', 'Design']",Difícil,Linked List
2296,design-a-text-editor,https://leetcode.com/problems/design-a-text-editor/,Design a Text Editor,"Design a text editor with a cursor that can do the following: Add  text to where the cursor is. Delete  text from where the cursor is (simulating the backspace key). Move  the cursor either left or right. When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that  0 <= cursor.position <= currentText.length  always holds. Implement the  TextEditor  class: TextEditor()  Initializes the object with empty text. void addText(string text)  Appends  text  to where the cursor is. The cursor ends to the right of  text . int deleteText(int k)  Deletes  k  characters to the left of the cursor. Returns the number of characters actually deleted. string cursorLeft(int k)  Moves the cursor to the left  k  times. Returns the last  min(10, len)  characters to the left of the cursor, where  len  is the number of characters to the left of the cursor. string cursorRight(int k)  Moves the cursor to the right  k  times. Returns the last  min(10, len)  characters to the left of the cursor, where  len  is the number of characters to the left of the cursor.   Example 1: Input [""TextEditor"", ""addText"", ""deleteText"", ""addText"", ""cursorRight"", ""cursorLeft"", ""deleteText"", ""cursorLeft"", ""cursorRight""] [[], [""leetcode""], [4], [""practice""], [3], [8], [10], [2], [6]] Output [null, null, 4, null, ""etpractice"", ""leet"", 4, """", ""practi""] Explanation TextEditor textEditor = new TextEditor(); // The current text is ""|"". (The '|' character represents the cursor) textEditor.addText(""leetcode""); // The current text is ""leetcode|"". textEditor.deleteText(4); // return 4                           // The current text is ""leet|"".                            // 4 characters were deleted. textEditor.addText(""practice""); // The current text is ""leetpractice|"".  textEditor.cursorRight(3); // return ""etpractice""                            // The current text is ""leetpractice|"".                             // The cursor cannot be moved beyond the actual text and thus did not move.                            // ""etpractice"" is the last 10 characters to the left of the cursor. textEditor.cursorLeft(8); // return ""leet""                           // The current text is ""leet|practice"".                           // ""leet"" is the last min(10, 4) = 4 characters to the left of the cursor. textEditor.deleteText(10); // return 4                            // The current text is ""|practice"".                            // Only 4 characters were deleted. textEditor.cursorLeft(2); // return """"                           // The current text is ""|practice"".                           // The cursor cannot be moved beyond the actual text and thus did not move.                            // """" is the last min(10, 0) = 0 characters to the left of the cursor. textEditor.cursorRight(6); // return ""practi""                            // The current text is ""practi|ce"".                            // ""practi"" is the last min(10, 6) = 6 characters to the left of the cursor.   Constraints: 1 <= text.length, k <= 40 text  consists of lowercase English letters. At most  2 * 10 4  calls  in total  will be made to  addText ,  deleteText ,  cursorLeft  and  cursorRight .   Follow-up:  Could you find a solution with time complexity of  O(k)  per call?","['Linked List', 'String', 'Stack', 'Design', 'Simulation', 'Doubly-Linked List']",Difícil,Linked List
21,merge-two-sorted-lists,https://leetcode.com/problems/merge-two-sorted-lists/,Merge Two Sorted Lists,"You are given the heads of two sorted linked lists  list1  and  list2 . Merge the two lists into one  sorted  list. The list should be made by splicing together the nodes of the first two lists. Return  the head of the merged linked list .   Example 1: Input:  list1 = [1,2,4], list2 = [1,3,4] Output:  [1,1,2,3,4,4] Example 2: Input:  list1 = [], list2 = [] Output:  [] Example 3: Input:  list1 = [], list2 = [0] Output:  [0]   Constraints: The number of nodes in both lists is in the range  [0, 50] . -100 <= Node.val <= 100 Both  list1  and  list2  are sorted in  non-decreasing  order.","['Linked List', 'Recursion']",Fácil,Linked List
83,remove-duplicates-from-sorted-list,https://leetcode.com/problems/remove-duplicates-from-sorted-list/,Remove Duplicates from Sorted List,"Given the  head  of a sorted linked list,  delete all duplicates such that each element appears only once . Return  the linked list  sorted  as well .   Example 1: Input:  head = [1,1,2] Output:  [1,2] Example 2: Input:  head = [1,1,2,3,3] Output:  [1,2,3]   Constraints: The number of nodes in the list is in the range  [0, 300] . -100 <= Node.val <= 100 The list is guaranteed to be  sorted  in ascending order.",['Linked List'],Fácil,Linked List
203,remove-linked-list-elements,https://leetcode.com/problems/remove-linked-list-elements/,Remove Linked List Elements,"Given the  head  of a linked list and an integer  val , remove all the nodes of the linked list that has  Node.val == val , and return  the new head .   Example 1: Input:  head = [1,2,6,3,4,5,6], val = 6 Output:  [1,2,3,4,5] Example 2: Input:  head = [], val = 1 Output:  [] Example 3: Input:  head = [7,7,7,7], val = 7 Output:  []   Constraints: The number of nodes in the list is in the range  [0, 10 4 ] . 1 <= Node.val <= 50 0 <= val <= 50","['Linked List', 'Recursion']",Fácil,Linked List
206,reverse-linked-list,https://leetcode.com/problems/reverse-linked-list/,Reverse Linked List,"Given the  head  of a singly linked list, reverse the list, and return  the reversed list .   Example 1: Input:  head = [1,2,3,4,5] Output:  [5,4,3,2,1] Example 2: Input:  head = [1,2] Output:  [2,1] Example 3: Input:  head = [] Output:  []   Constraints: The number of nodes in the list is the range  [0, 5000] . -5000 <= Node.val <= 5000   Follow up:  A linked list can be reversed either iteratively or recursively. Could you implement both?","['Linked List', 'Recursion']",Fácil,Linked List
234,palindrome-linked-list,https://leetcode.com/problems/palindrome-linked-list/,Palindrome Linked List,"Given the  head  of a singly linked list, return  true  if it is a  palindrome  or  false  otherwise .   Example 1: Input:  head = [1,2,2,1] Output:  true Example 2: Input:  head = [1,2] Output:  false   Constraints: The number of nodes in the list is in the range  [1, 10 5 ] . 0 <= Node.val <= 9   Follow up:  Could you do it in  O(n)  time and  O(1)  space?","['Linked List', 'Two Pointers', 'Stack', 'Recursion']",Fácil,Linked List
876,middle-of-the-linked-list,https://leetcode.com/problems/middle-of-the-linked-list/,Middle of the Linked List,"Given the  head  of a singly linked list, return  the middle node of the linked list . If there are two middle nodes, return  the second middle  node.   Example 1: Input:  head = [1,2,3,4,5] Output:  [3,4,5] Explanation:  The middle node of the list is node 3. Example 2: Input:  head = [1,2,3,4,5,6] Output:  [4,5,6] Explanation:  Since the list has two middle nodes with values 3 and 4, we return the second one.   Constraints: The number of nodes in the list is in the range  [1, 100] . 1 <= Node.val <= 100","['Linked List', 'Two Pointers']",Fácil,Linked List
1290,convert-binary-number-in-a-linked-list-to-integer,https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/,Convert Binary Number in a Linked List to Integer,"Given  head  which is a reference node to a singly-linked list. The value of each node in the linked list is either  0  or  1 . The linked list holds the binary representation of a number. Return the  decimal value  of the number in the linked list. The  most significant bit  is at the head of the linked list.   Example 1: Input:  head = [1,0,1] Output:  5 Explanation:  (101) in base 2 = (5) in base 10 Example 2: Input:  head = [0] Output:  0   Constraints: The Linked List is not empty. Number of nodes will not exceed  30 . Each node's value is either  0  or  1 .","['Linked List', 'Math']",Fácil,Linked List
2,add-two-numbers,https://leetcode.com/problems/add-two-numbers/,Add Two Numbers,"You are given two  non-empty  linked lists representing two non-negative integers. The digits are stored in  reverse order , and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.   Example 1: Input:  l1 = [2,4,3], l2 = [5,6,4] Output:  [7,0,8] Explanation:  342 + 465 = 807. Example 2: Input:  l1 = [0], l2 = [0] Output:  [0] Example 3: Input:  l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output:  [8,9,9,9,0,0,0,1]   Constraints: The number of nodes in each linked list is in the range  [1, 100] . 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros.","['Linked List', 'Math', 'Recursion']",Média,Linked List
19,remove-nth-node-from-end-of-list,https://leetcode.com/problems/remove-nth-node-from-end-of-list/,Remove Nth Node From End of List,"Given the  head  of a linked list, remove the  n th  node from the end of the list and return its head.   Example 1: Input:  head = [1,2,3,4,5], n = 2 Output:  [1,2,3,5] Example 2: Input:  head = [1], n = 1 Output:  [] Example 3: Input:  head = [1,2], n = 1 Output:  [1]   Constraints: The number of nodes in the list is  sz . 1 <= sz <= 30 0 <= Node.val <= 100 1 <= n <= sz   Follow up:  Could you do this in one pass?","['Linked List', 'Two Pointers']",Média,Linked List
82,remove-duplicates-from-sorted-list-ii,https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/,Remove Duplicates from Sorted List II,"Given the  head  of a sorted linked list,  delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list . Return  the linked list  sorted  as well .   Example 1: Input:  head = [1,2,3,3,4,4,5] Output:  [1,2,5] Example 2: Input:  head = [1,1,1,2,3] Output:  [2,3]   Constraints: The number of nodes in the list is in the range  [0, 300] . -100 <= Node.val <= 100 The list is guaranteed to be  sorted  in ascending order.","['Linked List', 'Two Pointers']",Média,Linked List
86,partition-list,https://leetcode.com/problems/partition-list/,Partition List,"Given the  head  of a linked list and a value  x , partition it such that all nodes  less than   x  come before nodes  greater than or equal  to  x . You should  preserve  the original relative order of the nodes in each of the two partitions.   Example 1: Input:  head = [1,4,3,2,5,2], x = 3 Output:  [1,2,2,4,3,5] Example 2: Input:  head = [2,1], x = 2 Output:  [1,2]   Constraints: The number of nodes in the list is in the range  [0, 200] . -100 <= Node.val <= 100 -200 <= x <= 200","['Linked List', 'Two Pointers']",Média,Linked List
92,reverse-linked-list-ii,https://leetcode.com/problems/reverse-linked-list-ii/,Reverse Linked List II,"Given the  head  of a singly linked list and two integers  left  and  right  where  left <= right , reverse the nodes of the list from position  left  to position  right , and return  the reversed list .   Example 1: Input:  head = [1,2,3,4,5], left = 2, right = 4 Output:  [1,4,3,2,5] Example 2: Input:  head = [5], left = 1, right = 1 Output:  [5]   Constraints: The number of nodes in the list is  n . 1 <= n <= 500 -500 <= Node.val <= 500 1 <= left <= right <= n   Follow up:  Could you do it in one pass?",['Linked List'],Média,Linked List
143,reorder-list,https://leetcode.com/problems/reorder-list/,Reorder List,"You are given the head of a singly linked-list. The list can be represented as: L 0  → L 1  → … → L n - 1  → L n Reorder the list to be on the following form: L 0  → L n  → L 1  → L n - 1  → L 2  → L n - 2  → … You may not modify the values in the list's nodes. Only nodes themselves may be changed.   Example 1: Input:  head = [1,2,3,4] Output:  [1,4,2,3] Example 2: Input:  head = [1,2,3,4,5] Output:  [1,5,2,4,3]   Constraints: The number of nodes in the list is in the range  [1, 5 * 10 4 ] . 1 <= Node.val <= 1000","['Linked List', 'Two Pointers', 'Stack', 'Recursion']",Média,Linked List
147,insertion-sort-list,https://leetcode.com/problems/insertion-sort-list/,Insertion Sort List,"Given the  head  of a singly linked list, sort the list using  insertion sort , and return  the sorted list's head . The steps of the  insertion sort  algorithm: Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.   Example 1: Input:  head = [4,2,1,3] Output:  [1,2,3,4] Example 2: Input:  head = [-1,5,3,4,0] Output:  [-1,0,3,4,5]   Constraints: The number of nodes in the list is in the range  [1, 5000] . -5000 <= Node.val <= 5000","['Linked List', 'Sorting']",Média,Linked List
148,sort-list,https://leetcode.com/problems/sort-list/,Sort List,"Given the  head  of a linked list, return  the list after sorting it in  ascending order .   Example 1: Input:  head = [4,2,1,3] Output:  [1,2,3,4] Example 2: Input:  head = [-1,5,3,4,0] Output:  [-1,0,3,4,5] Example 3: Input:  head = [] Output:  []   Constraints: The number of nodes in the list is in the range  [0, 5 * 10 4 ] . -10 5  <= Node.val <= 10 5   Follow up:  Can you sort the linked list in  O(n logn)  time and  O(1)  memory (i.e. constant space)?","['Linked List', 'Two Pointers', 'Divide and Conquer', 'Sorting', 'Merge Sort']",Média,Linked List
237,delete-node-in-a-linked-list,https://leetcode.com/problems/delete-node-in-a-linked-list/,Delete Node in a Linked List,"There is a singly-linked list  head  and we want to delete a node  node  in it. You are given the node to be deleted  node . You will  not be given access  to the first node of  head . All the values of the linked list are  unique , and it is guaranteed that the given node  node  is not the last node in the linked list. Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean: The value of the given node should not exist in the linked list. The number of nodes in the linked list should decrease by one. All the values before  node  should be in the same order. All the values after  node  should be in the same order. Custom testing: For the input, you should provide the entire linked list  head  and the node to be given  node .  node  should not be the last node of the list and should be an actual node in the list. We will build the linked list and pass the node to your function. The output will be the entire list after calling your function.   Example 1: Input:  head = [4,5,1,9], node = 5 Output:  [4,1,9] Explanation:  You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Example 2: Input:  head = [4,5,1,9], node = 1 Output:  [4,5,9] Explanation:  You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.   Constraints: The number of the nodes in the given list is in the range  [2, 1000] . -1000 <= Node.val <= 1000 The value of each node in the list is  unique . The  node  to be deleted is  in the list  and is  not a tail  node.",['Linked List'],Média,Linked List
2058,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/,Find the Minimum and Maximum Number of Nodes Between Critical Points,"A  critical point  in a linked list is defined as  either  a  local maxima  or a  local minima . A node is a  local maxima  if the current node has a value  strictly greater  than the previous node and the next node. A node is a  local minima  if the current node has a value  strictly smaller  than the previous node and the next node. Note that a node can only be a local maxima/minima if there exists  both  a previous node and a next node. Given a linked list  head , return  an array of length 2 containing  [minDistance, maxDistance]  where  minDistance  is the  minimum distance  between  any two distinct  critical points and  maxDistance  is the  maximum distance  between  any two distinct  critical points. If there are  fewer  than two critical points, return  [-1, -1] .   Example 1: Input:  head = [3,1] Output:  [-1,-1] Explanation:  There are no critical points in [3,1]. Example 2: Input:  head = [5,3,1,2,5,1,2] Output:  [1,3] Explanation:  There are three critical points: - [5,3, 1 ,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2. - [5,3,1,2, 5 ,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1. - [5,3,1,2,5, 1 ,2]: The sixth node is a local minima because 1 is less than 5 and 2. The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1. The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3. Example 3: Input:  head = [1,3,2,2,3,2,2,2,7] Output:  [3,3] Explanation:  There are two critical points: - [1, 3 ,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2. - [1,3,2,2, 3 ,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2. Both the minimum and maximum distances are between the second and the fifth node. Thus, minDistance and maxDistance is 5 - 2 = 3. Note that the last node is not considered a local maxima because it does not have a next node.   Constraints: The number of nodes in the list is in the range  [2, 10 5 ] . 1 <= Node.val <= 10 5",['Linked List'],Média,Linked List
2074,reverse-nodes-in-even-length-groups,https://leetcode.com/problems/reverse-nodes-in-even-length-groups/,Reverse Nodes in Even Length Groups,"You are given the  head  of a linked list. The nodes in the linked list are  sequentially  assigned to  non-empty  groups whose lengths form the sequence of the natural numbers ( 1, 2, 3, 4, ... ). The  length  of a group is the number of nodes assigned to it. In other words, The  1 st  node is assigned to the first group. The  2 nd  and the  3 rd  nodes are assigned to the second group. The  4 th ,  5 th , and  6 th  nodes are assigned to the third group, and so on. Note that the length of the last group may be less than or equal to  1 + the length of the second to last group . Reverse  the nodes in each group with an  even  length, and return  the   head   of the modified linked list .   Example 1: Input:  head = [5,2,6,3,9,1,7,3,8,4] Output:  [5,6,2,3,9,1,4,8,3,7] Explanation: - The length of the first group is 1, which is odd, hence no reversal occurs. - The length of the second group is 2, which is even, hence the nodes are reversed. - The length of the third group is 3, which is odd, hence no reversal occurs. - The length of the last group is 4, which is even, hence the nodes are reversed. Example 2: Input:  head = [1,1,0,6] Output:  [1,0,1,6] Explanation: - The length of the first group is 1. No reversal occurs. - The length of the second group is 2. The nodes are reversed. - The length of the last group is 1. No reversal occurs. Example 3: Input:  head = [1,1,0,6,5] Output:  [1,0,1,5,6] Explanation: - The length of the first group is 1. No reversal occurs. - The length of the second group is 2. The nodes are reversed. - The length of the last group is 2. The nodes are reversed.   Constraints: The number of nodes in the list is in the range  [1, 10 5 ] . 0 <= Node.val <= 10 5",['Linked List'],Média,Linked List
2095,delete-the-middle-node-of-a-linked-list,https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/,Delete the Middle Node of a Linked List,"You are given the  head  of a linked list.  Delete  the  middle node , and return  the   head   of the modified linked list . The  middle node  of a linked list of size  n  is the  ⌊n / 2⌋ th  node from the  start  using  0-based indexing , where  ⌊x⌋  denotes the largest integer less than or equal to  x . For  n  =  1 ,  2 ,  3 ,  4 , and  5 , the middle nodes are  0 ,  1 ,  1 ,  2 , and  2 , respectively.   Example 1: Input:  head = [1,3,4,7,1,2,6] Output:  [1,3,4,1,2,6] Explanation: The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node.  Example 2: Input:  head = [1,2,3,4] Output:  [1,2,4] Explanation: The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. Example 3: Input:  head = [2,1] Output:  [2] Explanation: The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1.   Constraints: The number of nodes in the list is in the range  [1, 10 5 ] . 1 <= Node.val <= 10 5","['Linked List', 'Two Pointers']",Média,Linked List
2130,maximum-twin-sum-of-a-linked-list,https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/,Maximum Twin Sum of a Linked List,"In a linked list of size  n , where  n  is  even , the  i th  node ( 0-indexed ) of the linked list is known as the  twin  of the  (n-1-i) th  node, if  0 <= i <= (n / 2) - 1 . For example, if  n = 4 , then node  0  is the twin of node  3 , and node  1  is the twin of node  2 . These are the only nodes with twins for  n = 4 . The  twin sum  is defined as the sum of a node and its twin. Given the  head  of a linked list with even length, return  the  maximum twin sum  of the linked list .   Example 1: Input:  head = [5,4,2,1] Output:  6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6.  Example 2: Input:  head = [4,2,2,3] Output:  7 Explanation: The nodes with twins present in this linked list are: - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7.  Example 3: Input:  head = [1,100000] Output:  100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.   Constraints: The number of nodes in the list is an  even  integer in the range  [2, 10 5 ] . 1 <= Node.val <= 10 5","['Linked List', 'Two Pointers', 'Stack']",Média,Linked List
2181,merge-nodes-in-between-zeros,https://leetcode.com/problems/merge-nodes-in-between-zeros/,Merge Nodes in Between Zeros,"You are given the  head  of a linked list, which contains a series of integers  separated  by  0 's. The  beginning  and  end  of the linked list will have  Node.val == 0 . For  every  two consecutive  0 's,  merge  all the nodes lying in between them into a single node whose value is the  sum  of all the merged nodes. The modified list should not contain any  0 's. Return  the   head   of the modified linked list .   Example 1: Input:  head = [0,3,1,0,4,5,2,0] Output:  [4,11] Explanation:   The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 3 + 1 = 4. - The sum of the nodes marked in red: 4 + 5 + 2 = 11. Example 2: Input:  head = [0,1,0,3,0,2,2,0] Output:  [1,3,4] Explanation:   The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 1 = 1. - The sum of the nodes marked in red: 3 = 3. - The sum of the nodes marked in yellow: 2 + 2 = 4.   Constraints: The number of nodes in the list is in the range  [3, 2 * 10 5 ] . 0 <= Node.val <= 1000 There are  no  two consecutive nodes with  Node.val == 0 . The  beginning  and  end  of the linked list have  Node.val == 0 .","['Linked List', 'Simulation']",Média,Linked List
2487,remove-nodes-from-linked-list,https://leetcode.com/problems/remove-nodes-from-linked-list/,Remove Nodes From Linked List,"You are given the  head  of a linked list. Remove every node which has a node with a greater value anywhere to the right side of it. Return  the  head  of the modified linked list.   Example 1: Input:  head = [5,2,13,3,8] Output:  [13,8] Explanation:  The nodes that should be removed are 5, 2 and 3. - Node 13 is to the right of node 5. - Node 13 is to the right of node 2. - Node 8 is to the right of node 3. Example 2: Input:  head = [1,1,1,1] Output:  [1,1,1,1] Explanation:  Every node has value 1, so no nodes are removed.   Constraints: The number of the nodes in the given list is in the range  [1, 10 5 ] . 1 <= Node.val <= 10 5","['Linked List', 'Stack', 'Recursion', 'Monotonic Stack']",Média,Linked List
920,number-of-music-playlists,https://leetcode.com/problems/number-of-music-playlists/,Number of Music Playlists,"Your music player contains  n  different songs. You want to listen to  goal  songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that: Every song is played  at least once . A song can only be played again only if  k  other songs have been played. Given  n ,  goal , and  k , return  the number of possible playlists that you can create . Since the answer can be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  n = 3, goal = 3, k = 1 Output:  6 Explanation:  There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. Example 2: Input:  n = 2, goal = 3, k = 0 Output:  6 Explanation:  There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2]. Example 3: Input:  n = 2, goal = 3, k = 1 Output:  2 Explanation:  There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].   Constraints: 0 <= k < n <= goal <= 100","['Math', 'Dynamic Programming', 'Combinatorics']",Difícil,Math
2999,count-the-number-of-powerful-integers,https://leetcode.com/problems/count-the-number-of-powerful-integers/,Count the Number of Powerful Integers,"You are given three integers  start ,  finish , and  limit . You are also given a  0-indexed  string  s  representing a  positive  integer. A  positive  integer  x  is called  powerful  if it ends with  s  (in other words,  s  is a  suffix  of  x ) and each digit in  x  is at most  limit . Return  the  total  number of powerful integers in the range   [start..finish] . A string  x  is a suffix of a string  y  if and only if  x  is a substring of  y  that starts from some index ( including  0 ) in  y  and extends to the index  y.length - 1 . For example,  25  is a suffix of  5125  whereas  512  is not.   Example 1: Input:  start = 1, finish = 6000, limit = 4, s = ""124"" Output:  5 Explanation:  The powerful integers in the range [1..6000] are 124, 1124, 2124, 3124, and, 4124. All these integers have each digit <= 4, and ""124"" as a suffix. Note that 5124 is not a powerful integer because the first digit is 5 which is greater than 4. It can be shown that there are only 5 powerful integers in this range. Example 2: Input:  start = 15, finish = 215, limit = 6, s = ""10"" Output:  2 Explanation:  The powerful integers in the range [15..215] are 110 and 210. All these integers have each digit <= 6, and ""10"" as a suffix. It can be shown that there are only 2 powerful integers in this range. Example 3: Input:  start = 1000, finish = 2000, limit = 4, s = ""3000"" Output:  0 Explanation:  All integers in the range [1000..2000] are smaller than 3000, hence ""3000"" cannot be a suffix of any integer in this range.   Constraints: 1 <= start <= finish <= 10 15 1 <= limit <= 9 1 <= s.length <= floor(log 10 (finish)) + 1 s  only consists of numeric digits which are at most  limit . s  does not have leading zeros.","['Math', 'String', 'Dynamic Programming']",Difícil,Math
3154,find-number-of-ways-to-reach-the-k-th-stair,https://leetcode.com/problems/find-number-of-ways-to-reach-the-k-th-stair/,Find Number of Ways to Reach the K-th Stair,"You are given a  non-negative  integer  k . There exists a staircase with an infinite number of stairs, with the  lowest  stair numbered 0. Alice has an integer  jump , with an initial value of 0. She starts on stair 1 and wants to reach stair  k  using  any  number of  operations . If she is on stair  i , in one  operation  she can: Go down to stair  i - 1 . This operation  cannot  be used consecutively or on stair 0. Go up to stair  i + 2 jump . And then,  jump  becomes  jump + 1 . Return the  total  number of ways Alice can reach stair  k . Note  that it is possible that Alice reaches the stair  k , and performs some operations to reach the stair  k  again.   Example 1: Input:   k = 0 Output:   2 Explanation: The 2 possible ways of reaching stair 0 are: Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 0  stairs to reach stair 1. Using an operation of the first type, she goes down 1 stair to reach stair 0. Example 2: Input:   k = 1 Output:   4 Explanation: The 4 possible ways of reaching stair 1 are: Alice starts at stair 1. Alice is at stair 1. Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 0  stairs to reach stair 1. Alice starts at stair 1. 	 Using an operation of the second type, she goes up 2 0  stairs to reach stair 2. Using an operation of the first type, she goes down 1 stair to reach stair 1. Alice starts at stair 1. 	 Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 0  stairs to reach stair 1. Using an operation of the first type, she goes down 1 stair to reach stair 0. Using an operation of the second type, she goes up 2 1  stairs to reach stair 2. Using an operation of the first type, she goes down 1 stair to reach stair 1.   Constraints: 0 <= k <= 10 9","['Math', 'Dynamic Programming', 'Bit Manipulation', 'Memoization', 'Combinatorics']",Difícil,Math
3260,find-the-largest-palindrome-divisible-by-k,https://leetcode.com/problems/find-the-largest-palindrome-divisible-by-k/,Find the Largest Palindrome Divisible by K,"You are given two  positive  integers  n  and  k . An integer  x  is called  k-palindromic  if: x  is a  palindrome . x  is divisible by  k . Return the  largest  integer having  n  digits (as a string) that is  k-palindromic . Note  that the integer must  not  have leading zeros.   Example 1: Input:   n = 3, k = 5 Output:   ""595"" Explanation: 595 is the largest k-palindromic integer with 3 digits. Example 2: Input:   n = 1, k = 4 Output:   ""8"" Explanation: 4 and 8 are the only k-palindromic integers with 1 digit. Example 3: Input:   n = 5, k = 6 Output:   ""89898""   Constraints: 1 <= n <= 10 5 1 <= k <= 9","['Math', 'String', 'Dynamic Programming', 'Greedy', 'Number Theory']",Difícil,Math
3352,count-k-reducible-numbers-less-than-n,https://leetcode.com/problems/count-k-reducible-numbers-less-than-n/,Count K-Reducible Numbers Less Than N,"You are given a  binary  string  s  representing a number  n  in its binary form. You are also given an integer  k . An integer  x  is called  k-reducible  if performing the following operation  at most   k  times reduces it to 1: Replace  x  with the  count  of  set bits  in its binary representation. For example, the binary representation of 6 is  ""110"" . Applying the operation once reduces it to 2 (since  ""110""  has two set bits). Applying the operation again to 2 (binary  ""10"" ) reduces it to 1 (since  ""10""  has one set bit). Return an integer denoting the number of positive integers  less  than  n  that are  k-reducible . Since the answer may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:   s = ""111"", k = 1 Output:   3 Explanation:  n = 7 . The 1-reducible integers less than 7 are 1, 2, and 4. Example 2: Input:   s = ""1000"", k = 2 Output:   6 Explanation: n = 8 . The 2-reducible integers less than 8 are 1, 2, 3, 4, 5, and 6. Example 3: Input:   s = ""1"", k = 3 Output:   0 Explanation: There are no positive integers less than  n = 1 , so the answer is 0.   Constraints: 1 <= s.length <= 800 s  has no leading zeros. s  consists only of the characters  '0'  and  '1' . 1 <= k <= 5","['Math', 'String', 'Dynamic Programming', 'Combinatorics']",Difícil,Math
3405,count-the-number-of-arrays-with-k-matching-adjacent-elements,https://leetcode.com/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/,Count the Number of Arrays with K Matching Adjacent Elements,"You are given three integers  n ,  m ,  k . A  good array   arr  of size  n  is defined as follows: Each element in  arr  is in the  inclusive  range  [1, m] . Exactly   k  indices  i  (where  1 <= i < n ) satisfy the condition  arr[i - 1] == arr[i] . Return the number of  good arrays  that can be formed. Since the answer may be very large, return it  modulo  10 9  + 7 .   Example 1: Input:   n = 3, m = 2, k = 1 Output:   4 Explanation: There are 4 good arrays. They are  [1, 1, 2] ,  [1, 2, 2] ,  [2, 1, 1]  and  [2, 2, 1] . Hence, the answer is 4. Example 2: Input:   n = 4, m = 2, k = 2 Output:   6 Explanation: The good arrays are  [1, 1, 1, 2] ,  [1, 1, 2, 2] ,  [1, 2, 2, 2] ,  [2, 1, 1, 1] ,  [2, 2, 1, 1]  and  [2, 2, 2, 1] . Hence, the answer is 6. Example 3: Input:   n = 5, m = 2, k = 0 Output:   2 Explanation: The good arrays are  [1, 2, 1, 2, 1]  and  [2, 1, 2, 1, 2] . Hence, the answer is 2.   Constraints: 1 <= n <= 10 5 1 <= m <= 10 5 0 <= k <= n - 1","['Math', 'Combinatorics']",Difícil,Math
3426,manhattan-distances-of-all-arrangements-of-pieces,https://leetcode.com/problems/manhattan-distances-of-all-arrangements-of-pieces/,Manhattan Distances of All Arrangements of Pieces,"You are given three integers  m ,  n , and  k . There is a rectangular grid of size  m × n  containing  k  identical pieces. Return the sum of Manhattan distances between every pair of pieces over all  valid arrangements  of pieces. A  valid arrangement  is a placement of all  k  pieces on the grid with  at most  one piece per cell. Since the answer may be very large, return it  modulo   10 9  + 7 . The Manhattan Distance between two cells  (x i , y i )  and  (x j , y j )  is  |x i  - x j | + |y i  - y j | .   Example 1: Input:   m = 2, n = 2, k = 2 Output:   8 Explanation: The valid arrangements of pieces on the board are: In the first 4 arrangements, the Manhattan distance between the two pieces is 1. In the last 2 arrangements, the Manhattan distance between the two pieces is 2. Thus, the total Manhattan distance across all valid arrangements is  1 + 1 + 1 + 1 + 2 + 2 = 8 . Example 2: Input:   m = 1, n = 4, k = 3 Output:   20 Explanation: The valid arrangements of pieces on the board are: The first and last arrangements have a total Manhattan distance of  1 + 1 + 2 = 4 . The middle two arrangements have a total Manhattan distance of  1 + 2 + 3 = 6 . The total Manhattan distance between all pairs of pieces across all arrangements is  4 + 6 + 6 + 4 = 20 .   Constraints: 1 <= m, n <= 10 5 2 <= m * n <= 10 5 2 <= k <= m * n","['Math', 'Combinatorics']",Difícil,Math
415,add-strings,https://leetcode.com/problems/add-strings/,Add Strings,"Given two non-negative integers,  num1  and  num2  represented as string, return  the sum of   num1   and   num2   as a string . You must solve the problem without using any built-in library for handling large integers (such as  BigInteger ). You must also not convert the inputs to integers directly.   Example 1: Input:  num1 = ""11"", num2 = ""123"" Output:  ""134"" Example 2: Input:  num1 = ""456"", num2 = ""77"" Output:  ""533"" Example 3: Input:  num1 = ""0"", num2 = ""0"" Output:  ""0""   Constraints: 1 <= num1.length, num2.length <= 10 4 num1  and  num2  consist of only digits. num1  and  num2  don't have any leading zeros except for the zero itself.","['Math', 'String', 'Simulation']",Fácil,Math
509,fibonacci-number,https://leetcode.com/problems/fibonacci-number/,Fibonacci Number,"The  Fibonacci numbers , commonly denoted  F(n)  form a sequence, called the  Fibonacci sequence , such that each number is the sum of the two preceding ones, starting from  0  and  1 . That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1. Given  n , calculate  F(n) .   Example 1: Input:  n = 2 Output:  1 Explanation:  F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input:  n = 3 Output:  2 Explanation:  F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input:  n = 4 Output:  3 Explanation:  F(4) = F(3) + F(2) = 2 + 1 = 3.   Constraints: 0 <= n <= 30","['Math', 'Dynamic Programming', 'Recursion', 'Memoization']",Fácil,Math
1137,n-th-tribonacci-number,https://leetcode.com/problems/n-th-tribonacci-number/,N-th Tribonacci Number,"The Tribonacci sequence T n  is defined as follows:  T 0  = 0, T 1  = 1, T 2  = 1, and T n+3  = T n  + T n+1  + T n+2  for n >= 0. Given  n , return the value of T n .   Example 1: Input:  n = 4 Output:  4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2: Input:  n = 25 Output:  1389537   Constraints: 0 <= n <= 37 The answer is guaranteed to fit within a 32-bit integer, ie.  answer <= 2^31 - 1 .","['Math', 'Dynamic Programming', 'Memoization']",Fácil,Math
1185,day-of-the-week,https://leetcode.com/problems/day-of-the-week/,Day of the Week,"Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the  day ,  month  and  year  respectively. Return the answer as one of the following values  {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""} .   Example 1: Input:  day = 31, month = 8, year = 2019 Output:  ""Saturday"" Example 2: Input:  day = 18, month = 7, year = 1999 Output:  ""Sunday"" Example 3: Input:  day = 15, month = 8, year = 1993 Output:  ""Sunday""   Constraints: The given dates are valid dates between the years  1971  and  2100 .",['Math'],Fácil,Math
1281,subtract-the-product-and-sum-of-digits-of-an-integer,https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/,Subtract the Product and Sum of Digits of an Integer,"Given an integer number  n , return the difference between the product of its digits and the sum of its digits.   Example 1: Input:  n = 234 Output:  15  Explanation:   Product of digits = 2 * 3 * 4 = 24  Sum of digits = 2 + 3 + 4 = 9  Result = 24 - 9 = 15 Example 2: Input:  n = 4421 Output:  21 Explanation:  Product of digits = 4 * 4 * 2 * 1 = 32  Sum of digits = 4 + 4 + 2 + 1 = 11  Result = 32 - 11 = 21   Constraints: 1 <= n <= 10^5",['Math'],Fácil,Math
1317,convert-integer-to-the-sum-of-two-no-zero-integers,https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/,Convert Integer to the Sum of Two No-Zero Integers,"No-Zero integer  is a positive integer that  does not contain any  0  in its decimal representation. Given an integer  n , return  a list of two integers   [a, b]   where : a  and  b  are  No-Zero integers . a + b = n The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.   Example 1: Input:  n = 2 Output:  [1,1] Explanation:  Let a = 1 and b = 1. Both a and b are no-zero integers, and a + b = 2 = n. Example 2: Input:  n = 11 Output:  [2,9] Explanation:  Let a = 2 and b = 9. Both a and b are no-zero integers, and a + b = 11 = n. Note that there are other valid answers as [8, 3] that can be accepted.   Constraints: 2 <= n <= 10 4",['Math'],Fácil,Math
1342,number-of-steps-to-reduce-a-number-to-zero,https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/,Number of Steps to Reduce a Number to Zero,"Given an integer  num , return  the number of steps to reduce it to zero . In one step, if the current number is even, you have to divide it by  2 , otherwise, you have to subtract  1  from it.   Example 1: Input:  num = 14 Output:  6 Explanation:   Step 1) 14 is even; divide by 2 and obtain 7.  Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3.  Step 4) 3 is odd; subtract 1 and obtain 2.  Step 5) 2 is even; divide by 2 and obtain 1.  Step 6) 1 is odd; subtract 1 and obtain 0. Example 2: Input:  num = 8 Output:  4 Explanation:   Step 1) 8 is even; divide by 2 and obtain 4.  Step 2) 4 is even; divide by 2 and obtain 2.  Step 3) 2 is even; divide by 2 and obtain 1.  Step 4) 1 is odd; subtract 1 and obtain 0. Example 3: Input:  num = 123 Output:  12   Constraints: 0 <= num <= 10 6","['Math', 'Bit Manipulation']",Fácil,Math
2269,find-the-k-beauty-of-a-number,https://leetcode.com/problems/find-the-k-beauty-of-a-number/,Find the K-Beauty of a Number,"The  k-beauty  of an integer  num  is defined as the number of  substrings  of  num  when it is read as a string that meet the following conditions: It has a length of  k . It is a divisor of  num . Given integers  num  and  k , return  the k-beauty of  num . Note: Leading zeros  are allowed. 0  is not a divisor of any value. A  substring  is a contiguous sequence of characters in a string.   Example 1: Input:  num = 240, k = 2 Output:  2 Explanation:  The following are the substrings of num of length k: - ""24"" from "" 24 0"": 24 is a divisor of 240. - ""40"" from ""2 40 "": 40 is a divisor of 240. Therefore, the k-beauty is 2. Example 2: Input:  num = 430043, k = 2 Output:  2 Explanation:  The following are the substrings of num of length k: - ""43"" from "" 43 0043"": 43 is a divisor of 430043. - ""30"" from ""4 30 043"": 30 is not a divisor of 430043. - ""00"" from ""43 00 43"": 0 is not a divisor of 430043. - ""04"" from ""430 04 3"": 4 is not a divisor of 430043. - ""43"" from ""4300 43 "": 43 is a divisor of 430043. Therefore, the k-beauty is 2.   Constraints: 1 <= num <= 10 9 1 <= k <= num.length  (taking  num  as a string)","['Math', 'String', 'Sliding Window']",Fácil,Math
592,fraction-addition-and-subtraction,https://leetcode.com/problems/fraction-addition-and-subtraction/,Fraction Addition and Subtraction,"Given a string  expression  representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an  irreducible fraction . If your final result is an integer, change it to the format of a fraction that has a denominator  1 . So in this case,  2  should be converted to  2/1 .   Example 1: Input:  expression = ""-1/2+1/2"" Output:  ""0/1"" Example 2: Input:  expression = ""-1/2+1/2+1/3"" Output:  ""1/3"" Example 3: Input:  expression = ""1/3-1/2"" Output:  ""-1/6""   Constraints: The input string only contains  '0'  to  '9' ,  '/' ,  '+'  and  '-' . So does the output. Each fraction (input and output) has the format  ±numerator/denominator . If the first input fraction or the output is positive, then  '+'  will be omitted. The input only contains valid  irreducible fractions , where the  numerator  and  denominator  of each fraction will always be in the range  [1, 10] . If the denominator is  1 , it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range  [1, 10] . The numerator and denominator of the  final result  are guaranteed to be valid and in the range of  32-bit  int.","['Math', 'String', 'Simulation']",Média,Math
738,monotone-increasing-digits,https://leetcode.com/problems/monotone-increasing-digits/,Monotone Increasing Digits,"An integer has  monotone increasing digits  if and only if each pair of adjacent digits  x  and  y  satisfy  x <= y . Given an integer  n , return  the largest number that is less than or equal to  n  with  monotone increasing digits .   Example 1: Input:  n = 10 Output:  9 Example 2: Input:  n = 1234 Output:  1234 Example 3: Input:  n = 332 Output:  299   Constraints: 0 <= n <= 10 9","['Math', 'Greedy']",Média,Math
754,reach-a-number,https://leetcode.com/problems/reach-a-number/,Reach a Number,"You are standing at position  0  on an infinite number line. There is a destination at position  target . You can make some number of moves  numMoves  so that: On each move, you can either go left or right. During the  i th  move (starting from  i == 1  to  i == numMoves ), you take  i  steps in the chosen direction. Given the integer  target , return  the  minimum  number of moves required (i.e., the minimum  numMoves ) to reach the destination .   Example 1: Input:  target = 2 Output:  3 Explanation: On the 1 st  move, we step from 0 to 1 (1 step). On the 2 nd  move, we step from 1 to -1 (2 steps). On the 3 rd  move, we step from -1 to 2 (3 steps). Example 2: Input:  target = 3 Output:  2 Explanation: On the 1 st  move, we step from 0 to 1 (1 step). On the 2 nd  move, we step from 1 to 3 (2 steps).   Constraints: -10 9  <= target <= 10 9 target != 0","['Math', 'Binary Search']",Média,Math
779,k-th-symbol-in-grammar,https://leetcode.com/problems/k-th-symbol-in-grammar/,K-th Symbol in Grammar,"We build a table of  n  rows ( 1-indexed ). We start by writing  0  in the  1 st  row. Now in every subsequent row, we look at the previous row and replace each occurrence of  0  with  01 , and each occurrence of  1  with  10 . For example, for  n = 3 , the  1 st  row is  0 , the  2 nd  row is  01 , and the  3 rd  row is  0110 . Given two integer  n  and  k , return the  k th  ( 1-indexed ) symbol in the  n th  row of a table of  n  rows.   Example 1: Input:  n = 1, k = 1 Output:  0 Explanation:  row 1:  0 Example 2: Input:  n = 2, k = 1 Output:  0 Explanation:   row 1: 0 row 2:  0 1 Example 3: Input:  n = 2, k = 2 Output:  1 Explanation:   row 1: 0 row 2: 0 1   Constraints: 1 <= n <= 30 1 <= k <= 2 n - 1","['Math', 'Bit Manipulation', 'Recursion']",Média,Math
1237,find-positive-integer-solution-for-a-given-equation,https://leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/,Find Positive Integer Solution for a Given Equation,"Given a callable function  f(x, y)   with a hidden formula  and a value  z , reverse engineer the formula and return  all positive integer pairs  x  and  y  where  f(x,y) == z . You may return the pairs in any order. While the exact formula is hidden, the function is monotonically increasing, i.e.: f(x, y) < f(x + 1, y) f(x, y) < f(x, y + 1) The function interface is defined like this: interface CustomFunction { public:   // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.   int f(int x, int y); }; We will judge your solution as follows: The judge has a list of  9  hidden implementations of  CustomFunction , along with a way to generate an  answer key  of all valid pairs for a specific  z . The judge will receive two inputs: a  function_id  (to determine which implementation to test your code with), and the target  z . The judge will call your  findSolution  and compare your results with the  answer key . If your results match the  answer key , your solution will be  Accepted .   Example 1: Input:  function_id = 1, z = 5 Output:  [[1,4],[2,3],[3,2],[4,1]] Explanation:  The hidden formula for function_id = 1 is f(x, y) = x + y. The following positive integer values of x and y make f(x, y) equal to 5: x=1, y=4 -> f(1, 4) = 1 + 4 = 5. x=2, y=3 -> f(2, 3) = 2 + 3 = 5. x=3, y=2 -> f(3, 2) = 3 + 2 = 5. x=4, y=1 -> f(4, 1) = 4 + 1 = 5. Example 2: Input:  function_id = 2, z = 5 Output:  [[1,5],[5,1]] Explanation:  The hidden formula for function_id = 2 is f(x, y) = x * y. The following positive integer values of x and y make f(x, y) equal to 5: x=1, y=5 -> f(1, 5) = 1 * 5 = 5. x=5, y=1 -> f(5, 1) = 5 * 1 = 5.   Constraints: 1 <= function_id <= 9 1 <= z <= 100 It is guaranteed that the solutions of  f(x, y) == z  will be in the range  1 <= x, y <= 1000 . It is also guaranteed that  f(x, y)  will fit in 32 bit signed integer if  1 <= x, y <= 1000 .","['Math', 'Two Pointers', 'Binary Search', 'Interactive']",Média,Math
1238,circular-permutation-in-binary-representation,https://leetcode.com/problems/circular-permutation-in-binary-representation/,Circular Permutation in Binary Representation,"Given 2 integers  n  and  start . Your task is return  any  permutation  p  of  (0,1,2.....,2^n -1)  such that : p[0] = start p[i]  and  p[i+1]  differ by only one bit in their binary representation. p[0]  and  p[2^n -1]  must also differ by only one bit in their binary representation.   Example 1: Input:  n = 2, start = 3 Output:  [3,2,0,1] Explanation:  The binary representation of the permutation is (11,10,00,01).  All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2] Example 2: Input:  n = 3, start = 2 Output:  [2,6,7,5,4,0,1,3] Explanation:  The binary representation of the permutation is (010,110,111,101,100,000,001,011).   Constraints: 1 <= n <= 16 0 <= start < 2 ^ n","['Math', 'Backtracking', 'Bit Manipulation']",Média,Math
1414,find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k,https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/,Find the Minimum Number of Fibonacci Numbers Whose Sum Is K,"Given an integer  k ,  return the minimum number of Fibonacci numbers whose sum is equal to  k . The same Fibonacci number can be used multiple times. The Fibonacci numbers are defined as: F 1  = 1 F 2  = 1 F n  = F n-1  + F n-2  for  n > 2. It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to  k .   Example 1: Input:  k = 7 Output:  2  Explanation:  The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...  For k = 7 we can use 2 + 5 = 7. Example 2: Input:  k = 10 Output:  2  Explanation:  For k = 10 we can use 2 + 8 = 10. Example 3: Input:  k = 19 Output:  3  Explanation:  For k = 19 we can use 1 + 5 + 13 = 19.   Constraints: 1 <= k <= 10 9","['Math', 'Greedy']",Média,Math
1860,incremental-memory-leak,https://leetcode.com/problems/incremental-memory-leak/,Incremental Memory Leak,"You are given two integers  memory1  and  memory2  representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second. At the  i th  second (starting from 1),  i  bits of memory are allocated to the stick with  more available memory  (or from the first memory stick if both have the same available memory). If neither stick has at least  i  bits of available memory, the program  crashes . Return  an array containing  [crashTime, memory1 crash , memory2 crash ] , where  crashTime  is the time (in seconds) when the program crashed and  memory1 crash  and  memory2 crash  are the available bits of memory in the first and second sticks respectively .   Example 1: Input:  memory1 = 2, memory2 = 2 Output:  [3,1,0] Explanation:  The memory is allocated as follows: - At the 1 st  second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory. - At the 2 nd  second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory. - At the 3 rd  second, the program crashes. The sticks have 1 and 0 bits available respectively. Example 2: Input:  memory1 = 8, memory2 = 11 Output:  [6,0,4] Explanation:  The memory is allocated as follows: - At the 1 st  second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory. - At the 2 nd  second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory. - At the 3 rd  second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory. - At the 4 th  second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory. - At the 5 th  second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory. - At the 6 th  second, the program crashes. The sticks have 0 and 4 bits available respectively.   Constraints: 0 <= memory1, memory2 <= 2 31  - 1","['Math', 'Simulation']",Média,Math
1884,egg-drop-with-2-eggs-and-n-floors,https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/,Egg Drop With 2 Eggs and N Floors,"You are given  two identical  eggs and you have access to a building with  n  floors labeled from  1  to  n . You know that there exists a floor  f  where  0 <= f <= n  such that any egg dropped at a floor  higher  than  f  will  break , and any egg dropped  at or below  floor  f  will  not break . In each move, you may take an  unbroken  egg and drop it from any floor  x  (where  1 <= x <= n ). If the egg breaks, you can no longer use it. However, if the egg does not break, you may  reuse  it in future moves. Return  the  minimum number of moves  that you need to determine  with certainty  what the value of  f  is.   Example 1: Input:  n = 2 Output:  2 Explanation:  We can drop the first egg from floor 1 and the second egg from floor 2. If the first egg breaks, we know that f = 0. If the second egg breaks but the first egg didn't, we know that f = 1. Otherwise, if both eggs survive, we know that f = 2. Example 2: Input:  n = 100 Output:  14 Explanation:  One optimal strategy is: - Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9. - If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14. - If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100. Regardless of the outcome, it takes at most 14 drops to determine f.   Constraints: 1 <= n <= 1000","['Math', 'Dynamic Programming']",Média,Math
1904,the-number-of-full-rounds-you-have-played,https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/,The Number of Full Rounds You Have Played,"You are participating in an online chess tournament. There is a chess round that starts every  15  minutes. The first round of the day starts at  00:00 , and after every  15  minutes, a new round starts. For example, the second round starts at  00:15 , the fourth round starts at  00:45 , and the seventh round starts at  01:30 . You are given two strings  loginTime  and  logoutTime  where: loginTime  is the time you will login to the game, and logoutTime  is the time you will logout from the game. If  logoutTime  is  earlier  than  loginTime , this means you have played from  loginTime  to midnight and from midnight to  logoutTime . Return  the number of full chess rounds you have played in the tournament . Note:  All the given times follow the 24-hour clock. That means the first round of the day starts at  00:00  and the last round of the day starts at  23:45 .   Example 1: Input:  loginTime = ""09:31"", logoutTime = ""10:14"" Output:  1 Explanation:  You played one full round from 09:45 to 10:00. You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began. You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended. Example 2: Input:  loginTime = ""21:30"", logoutTime = ""03:00"" Output:  22 Explanation:  You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00. 10 + 12 = 22.   Constraints: loginTime  and  logoutTime  are in the format  hh:mm . 00 <= hh <= 23 00 <= mm <= 59 loginTime  and  logoutTime  are not equal.","['Math', 'String']",Média,Math
1927,sum-game,https://leetcode.com/problems/sum-game/,Sum Game,"Alice and Bob take turns playing a game, with  Alice  starting first . You are given a string  num  of  even length  consisting of digits and  '?'  characters. On each turn, a player will do the following if there is still at least one  '?'  in  num : Choose an index  i  where  num[i] == '?' . Replace  num[i]  with any digit between  '0'  and  '9' . The game ends when there are no more  '?'  characters in  num . For Bob to win, the sum of the digits in the first half of  num  must be  equal  to the sum of the digits in the second half. For Alice to win, the sums must  not be equal . For example, if the game ended with  num = ""243801"" , then Bob wins because  2+4+3 = 8+0+1 . If the game ended with  num = ""243803"" , then Alice wins because  2+4+3 != 8+0+3 . Assuming Alice and Bob play  optimally , return  true   if Alice will win and  false   if Bob will win .   Example 1: Input:  num = ""5023"" Output:  false Explanation:  There are no moves to be made. The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3. Example 2: Input:  num = ""25??"" Output:  true Explanation:  Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal. Example 3: Input:  num = ""?3295???"" Output:  false Explanation:  It can be proven that Bob will always win. One possible outcome is: - Alice replaces the first '?' with '9'. num = ""93295???"". - Bob replaces one of the '?' in the right half with '9'. num = ""932959??"". - Alice replaces one of the '?' in the right half with '2'. num = ""9329592?"". - Bob replaces the last '?' in the right half with '7'. num = ""93295927"". Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.   Constraints: 2 <= num.length <= 10 5 num.length  is  even . num  consists of only digits and  '?' .","['Math', 'String', 'Greedy', 'Game Theory']",Média,Math
2063,vowels-of-all-substrings,https://leetcode.com/problems/vowels-of-all-substrings/,Vowels of All Substrings,"Given a string  word , return  the  sum of the number of vowels  ( 'a' ,  'e' ,   'i' ,   'o' , and   'u' )   in every substring of  word . A  substring  is a contiguous (non-empty) sequence of characters within a string. Note:  Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.   Example 1: Input:  word = ""aba"" Output:  6 Explanation:   All possible substrings are: ""a"", ""ab"", ""aba"", ""b"", ""ba"", and ""a"". - ""b"" has 0 vowels in it - ""a"", ""ab"", ""ba"", and ""a"" have 1 vowel each - ""aba"" has 2 vowels in it Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6.  Example 2: Input:  word = ""abc"" Output:  3 Explanation:   All possible substrings are: ""a"", ""ab"", ""abc"", ""b"", ""bc"", and ""c"". - ""a"", ""ab"", and ""abc"" have 1 vowel each - ""b"", ""bc"", and ""c"" have 0 vowels each Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3. Example 3: Input:  word = ""ltcd"" Output:  0 Explanation:  There are no vowels in any substring of ""ltcd"".   Constraints: 1 <= word.length <= 10 5 word  consists of lowercase English letters.","['Math', 'String', 'Dynamic Programming', 'Combinatorics']",Média,Math
2162,minimum-cost-to-set-cooking-time,https://leetcode.com/problems/minimum-cost-to-set-cooking-time/,Minimum Cost to Set Cooking Time,"A generic microwave supports cooking times for: at least  1  second. at most  99  minutes and  99  seconds. To set the cooking time, you push  at most four digits . The microwave normalizes what you push as four digits by  prepending zeroes . It interprets the  first  two digits as the minutes and the  last  two digits as the seconds. It then  adds  them up as the cooking time. For example, You push  9   5   4  (three digits). It is normalized as  0954  and interpreted as  9  minutes and  54  seconds. You push  0   0   0   8  (four digits). It is interpreted as  0  minutes and  8  seconds. You push  8   0   9   0 . It is interpreted as  80  minutes and  90  seconds. You push  8   1   3   0 . It is interpreted as  81  minutes and  30  seconds. You are given integers  startAt ,  moveCost ,  pushCost , and  targetSeconds .  Initially , your finger is on the digit  startAt . Moving the finger above  any specific digit  costs  moveCost  units of fatigue. Pushing the digit below the finger  once  costs  pushCost  units of fatigue. There can be multiple ways to set the microwave to cook for  targetSeconds  seconds but you are interested in the way with the minimum cost. Return  the  minimum cost  to set   targetSeconds   seconds of cooking time . Remember that one minute consists of  60  seconds.   Example 1: Input:  startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600 Output:  6 Explanation:  The following are the possible ways to set the cooking time. - 1 0 0 0, interpreted as 10 minutes and 0 seconds.   The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).   The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost. - 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.   The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).   The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12. - 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.   The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).   The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9. Example 2: Input:  startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76 Output:  6 Explanation:  The optimal way is to push two digits: 7 6, interpreted as 76 seconds. The finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6 Note other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.   Constraints: 0 <= startAt <= 9 1 <= moveCost, pushCost <= 10 5 1 <= targetSeconds <= 6039","['Math', 'Enumeration']",Média,Math
2177,find-three-consecutive-integers-that-sum-to-a-given-number,https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/,Find Three Consecutive Integers That Sum to a Given Number,"Given an integer  num , return  three consecutive integers (as a sorted array)  that  sum  to  num . If  num  cannot be expressed as the sum of three consecutive integers, return  an  empty  array.   Example 1: Input:  num = 33 Output:  [10,11,12] Explanation:  33 can be expressed as 10 + 11 + 12 = 33. 10, 11, 12 are 3 consecutive integers, so we return [10, 11, 12]. Example 2: Input:  num = 4 Output:  [] Explanation:  There is no way to express 4 as the sum of 3 consecutive integers.   Constraints: 0 <= num <= 10 15","['Math', 'Simulation']",Média,Math
2310,sum-of-numbers-with-units-digit-k,https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/,Sum of Numbers With Units Digit K,"Given two integers  num  and  k , consider a set of positive integers with the following properties: The units digit of each integer is  k . The sum of the integers is  num . Return  the  minimum  possible size of such a set, or  -1  if no such set exists. Note: The set can contain multiple instances of the same integer, and the sum of an empty set is considered  0 . The  units digit  of a number is the rightmost digit of the number.   Example 1: Input:  num = 58, k = 9 Output:  2 Explanation: One valid set is [9,49], as the sum is 58 and each integer has a units digit of 9. Another valid set is [19,39]. It can be shown that 2 is the minimum possible size of a valid set. Example 2: Input:  num = 37, k = 2 Output:  -1 Explanation:  It is not possible to obtain a sum of 37 using only integers that have a units digit of 2. Example 3: Input:  num = 0, k = 7 Output:  0 Explanation:  The sum of an empty set is considered 0.   Constraints: 0 <= num <= 3000 0 <= k <= 9","['Math', 'Dynamic Programming', 'Greedy', 'Enumeration']",Média,Math
2523,closest-prime-numbers-in-range,https://leetcode.com/problems/closest-prime-numbers-in-range/,Closest Prime Numbers in Range,"Given two positive integers  left  and  right , find the two integers  num1  and  num2  such that: left <= num1 < num2 <= right  . Both  num1  and  num2  are  prime numbers . num2 - num1  is the  minimum  amongst all other pairs satisfying the above conditions. Return the positive integer array  ans = [num1, num2] . If there are multiple pairs satisfying these conditions, return the one with the  smallest   num1  value. If no such numbers exist, return  [-1, -1] .   Example 1: Input:  left = 10, right = 19 Output:  [11,13] Explanation:  The prime numbers between 10 and 19 are 11, 13, 17, and 19. The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19]. Since 11 is smaller than 17, we return the first pair. Example 2: Input:  left = 4, right = 6 Output:  [-1,-1] Explanation:  There exists only one prime number in the given range, so the conditions cannot be satisfied.   Constraints: 1 <= left <= right <= 10 6","['Math', 'Number Theory']",Média,Math
2231,largest-number-after-digit-swaps-by-parity,https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/,Largest Number After Digit Swaps by Parity,"You are given a positive integer  num . You may swap any two digits of  num  that have the same  parity  (i.e. both odd digits or both even digits). Return  the  largest  possible value of  num  after  any  number of swaps.   Example 1: Input:  num = 1234 Output:  3412 Explanation:  Swap the digit 3 with the digit 1, this results in the number 3214. Swap the digit 2 with the digit 4, this results in the number 3412. Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number. Also note that we may not swap the digit 4 with the digit 1 since they are of different parities. Example 2: Input:  num = 65875 Output:  87655 Explanation:  Swap the digit 8 with the digit 6, this results in the number 85675. Swap the first digit 5 with the digit 7, this results in the number 87655. Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.   Constraints: 1 <= num <= 10 9","['Sorting', 'Heap (Priority Queue)']",Fácil,Sorting
94,binary-tree-inorder-traversal,https://leetcode.com/problems/binary-tree-inorder-traversal/,Binary Tree Inorder Traversal,"Given the  root  of a binary tree, return  the inorder traversal of its nodes' values .   Example 1: Input:   root = [1,null,2,3] Output:   [1,3,2] Explanation: Example 2: Input:   root = [1,2,3,4,5,null,8,null,null,6,7,9] Output:   [4,2,6,5,7,1,3,9,8] Explanation: Example 3: Input:   root = [] Output:   [] Example 4: Input:   root = [1] Output:   [1]   Constraints: The number of nodes in the tree is in the range  [0, 100] . -100 <= Node.val <= 100   Follow up:  Recursive solution is trivial, could you do it iteratively?","['Stack', 'Tree', 'Depth-First Search', 'Binary Tree']",Fácil,Stack
144,binary-tree-preorder-traversal,https://leetcode.com/problems/binary-tree-preorder-traversal/,Binary Tree Preorder Traversal,"Given the  root  of a binary tree, return  the preorder traversal of its nodes' values .   Example 1: Input:   root = [1,null,2,3] Output:   [1,2,3] Explanation: Example 2: Input:   root = [1,2,3,4,5,null,8,null,null,6,7,9] Output:   [1,2,4,5,6,7,3,8,9] Explanation: Example 3: Input:   root = [] Output:   [] Example 4: Input:   root = [1] Output:   [1]   Constraints: The number of nodes in the tree is in the range  [0, 100] . -100 <= Node.val <= 100   Follow up:  Recursive solution is trivial, could you do it iteratively?","['Stack', 'Tree', 'Depth-First Search', 'Binary Tree']",Fácil,Stack
145,binary-tree-postorder-traversal,https://leetcode.com/problems/binary-tree-postorder-traversal/,Binary Tree Postorder Traversal,"Given the  root  of a binary tree, return  the postorder traversal of its nodes' values .   Example 1: Input:   root = [1,null,2,3] Output:   [3,2,1] Explanation: Example 2: Input:   root = [1,2,3,4,5,null,8,null,null,6,7,9] Output:   [4,6,7,5,2,9,8,3,1] Explanation: Example 3: Input:   root = [] Output:   [] Example 4: Input:   root = [1] Output:   [1]   Constraints: The number of the nodes in the tree is in the range  [0, 100] . -100 <= Node.val <= 100   Follow up:  Recursive solution is trivial, could you do it iteratively?","['Stack', 'Tree', 'Depth-First Search', 'Binary Tree']",Fácil,Stack
225,implement-stack-using-queues,https://leetcode.com/problems/implement-stack-using-queues/,Implement Stack using Queues,"Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack ( push ,  top ,  pop , and  empty ). Implement the  MyStack  class: void push(int x)  Pushes element x to the top of the stack. int pop()  Removes the element on the top of the stack and returns it. int top()  Returns the element on the top of the stack. boolean empty()  Returns  true  if the stack is empty,  false  otherwise. Notes: You must use  only  standard operations of a queue, which means that only  push to back ,  peek/pop from front ,  size  and  is empty  operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.   Example 1: Input [""MyStack"", ""push"", ""push"", ""top"", ""pop"", ""empty""] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False   Constraints: 1 <= x <= 9 At most  100  calls will be made to  push ,  pop ,  top , and  empty . All the calls to  pop  and  top  are valid.   Follow-up:  Can you implement the stack using only one queue?","['Stack', 'Design', 'Queue']",Fácil,Stack
232,implement-queue-using-stacks,https://leetcode.com/problems/implement-queue-using-stacks/,Implement Queue using Stacks,"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue ( push ,  peek ,  pop , and  empty ). Implement the  MyQueue  class: void push(int x)  Pushes element x to the back of the queue. int pop()  Removes the element from the front of the queue and returns it. int peek()  Returns the element at the front of the queue. boolean empty()  Returns  true  if the queue is empty,  false  otherwise. Notes: You must use  only  standard operations of a stack, which means only  push to top ,  peek/pop from top ,  size , and  is empty  operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.   Example 1: Input [""MyQueue"", ""push"", ""push"", ""peek"", ""pop"", ""empty""] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false   Constraints: 1 <= x <= 9 At most  100  calls will be made to  push ,  pop ,  peek , and  empty . All the calls to  pop  and  peek  are valid.   Follow-up:  Can you implement the queue such that each operation is  amortized   O(1)  time complexity? In other words, performing  n  operations will take overall  O(n)  time even if one of those operations may take longer.","['Stack', 'Design', 'Queue']",Fácil,Stack
589,n-ary-tree-preorder-traversal,https://leetcode.com/problems/n-ary-tree-preorder-traversal/,N-ary Tree Preorder Traversal,"Given the  root  of an n-ary tree, return  the preorder traversal of its nodes' values . Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)   Example 1: Input:  root = [1,null,3,2,4,null,5,6] Output:  [1,3,5,6,2,4] Example 2: Input:  root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output:  [1,2,3,6,7,11,14,4,8,12,5,9,13,10]   Constraints: The number of nodes in the tree is in the range  [0, 10 4 ] . 0 <= Node.val <= 10 4 The height of the n-ary tree is less than or equal to  1000 .   Follow up:  Recursive solution is trivial, could you do it iteratively?","['Stack', 'Tree', 'Depth-First Search']",Fácil,Stack
590,n-ary-tree-postorder-traversal,https://leetcode.com/problems/n-ary-tree-postorder-traversal/,N-ary Tree Postorder Traversal,"Given the  root  of an n-ary tree, return  the postorder traversal of its nodes' values . Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)   Example 1: Input:  root = [1,null,3,2,4,null,5,6] Output:  [5,6,3,2,4,1] Example 2: Input:  root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output:  [2,6,14,11,7,3,12,8,4,13,9,10,5,1]   Constraints: The number of nodes in the tree is in the range  [0, 10 4 ] . 0 <= Node.val <= 10 4 The height of the n-ary tree is less than or equal to  1000 .   Follow up:  Recursive solution is trivial, could you do it iteratively?","['Stack', 'Tree', 'Depth-First Search']",Fácil,Stack
897,increasing-order-search-tree,https://leetcode.com/problems/increasing-order-search-tree/,Increasing Order Search Tree,"Given the  root  of a binary search tree, rearrange the tree in  in-order  so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.   Example 1: Input:  root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output:  [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] Example 2: Input:  root = [5,1,7] Output:  [1,null,5,null,7]   Constraints: The number of nodes in the given tree will be in the range  [1, 100] . 0 <= Node.val <= 1000","['Stack', 'Tree', 'Depth-First Search', 'Binary Search Tree', 'Binary Tree']",Fácil,Stack
155,min-stack,https://leetcode.com/problems/min-stack/,Min Stack,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the  MinStack  class: MinStack()  initializes the stack object. void push(int val)  pushes the element  val  onto the stack. void pop()  removes the element on the top of the stack. int top()  gets the top element of the stack. int getMin()  retrieves the minimum element in the stack. You must implement a solution with  O(1)  time complexity for each function.   Example 1: Input [""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top();    // return 0 minStack.getMin(); // return -2   Constraints: -2 31  <= val <= 2 31  - 1 Methods  pop ,  top  and  getMin  operations will always be called on  non-empty  stacks. At most  3 * 10 4  calls will be made to  push ,  pop ,  top , and  getMin .","['Stack', 'Design']",Média,Stack
173,binary-search-tree-iterator,https://leetcode.com/problems/binary-search-tree-iterator/,Binary Search Tree Iterator,"Implement the  BSTIterator  class that represents an iterator over the  in-order traversal  of a binary search tree (BST): BSTIterator(TreeNode root)  Initializes an object of the  BSTIterator  class. The  root  of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext()  Returns  true  if there exists a number in the traversal to the right of the pointer, otherwise returns  false . int next()  Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to  next()  will return the smallest element in the BST. You may assume that  next()  calls will always be valid. That is, there will be at least a next number in the in-order traversal when  next()  is called.   Example 1: Input [""BSTIterator"", ""next"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext""] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next();    // return 3 bSTIterator.next();    // return 7 bSTIterator.hasNext(); // return True bSTIterator.next();    // return 9 bSTIterator.hasNext(); // return True bSTIterator.next();    // return 15 bSTIterator.hasNext(); // return True bSTIterator.next();    // return 20 bSTIterator.hasNext(); // return False   Constraints: The number of nodes in the tree is in the range  [1, 10 5 ] . 0 <= Node.val <= 10 6 At most  10 5  calls will be made to  hasNext , and  next .   Follow up: Could you implement  next()  and  hasNext()  to run in average  O(1)  time and use  O(h)  memory, where  h  is the height of the tree?","['Stack', 'Tree', 'Design', 'Binary Search Tree', 'Binary Tree', 'Iterator']",Média,Stack
341,flatten-nested-list-iterator,https://leetcode.com/problems/flatten-nested-list-iterator/,Flatten Nested List Iterator,"You are given a nested list of integers  nestedList . Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the  NestedIterator  class: NestedIterator(List<NestedInteger> nestedList)  Initializes the iterator with the nested list  nestedList . int next()  Returns the next integer in the nested list. boolean hasNext()  Returns  true  if there are still some integers in the nested list and  false  otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedList res = [] while iterator.hasNext()     append iterator.next() to the end of res return res If  res  matches the expected flattened list, then your code will be judged as correct.   Example 1: Input:  nestedList = [[1,1],2,[1,1]] Output:  [1,1,2,1,1] Explanation:  By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Input:  nestedList = [1,[4,[6]]] Output:  [1,4,6] Explanation:  By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].   Constraints: 1 <= nestedList.length <= 500 The values of the integers in the nested list is in the range  [-10 6 , 10 6 ] .","['Stack', 'Tree', 'Depth-First Search', 'Design', 'Queue', 'Iterator']",Média,Stack
901,online-stock-span,https://leetcode.com/problems/online-stock-span/,Online Stock Span,"Design an algorithm that collects daily price quotes for some stock and returns  the span  of that stock's price for the current day. The  span  of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day. For example, if the prices of the stock in the last four days is  [7,2,1,2]  and the price of the stock today is  2 , then the span of today is  4  because starting from today, the price of the stock was less than or equal  2  for  4  consecutive days. Also, if the prices of the stock in the last four days is  [7,34,1,2]  and the price of the stock today is  8 , then the span of today is  3  because starting from today, the price of the stock was less than or equal  8  for  3  consecutive days. Implement the  StockSpanner  class: StockSpanner()  Initializes the object of the class. int next(int price)  Returns the  span  of the stock's price given that today's price is  price .   Example 1: Input [""StockSpanner"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next""] [[], [100], [80], [60], [70], [60], [75], [85]] Output [null, 1, 1, 1, 2, 1, 4, 6] Explanation StockSpanner stockSpanner = new StockSpanner(); stockSpanner.next(100); // return 1 stockSpanner.next(80);  // return 1 stockSpanner.next(60);  // return 1 stockSpanner.next(70);  // return 2 stockSpanner.next(60);  // return 1 stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. stockSpanner.next(85);  // return 6   Constraints: 1 <= price <= 10 5 At most  10 4  calls will be made to  next .","['Stack', 'Design', 'Monotonic Stack', 'Data Stream']",Média,Stack
10,regular-expression-matching,https://leetcode.com/problems/regular-expression-matching/,Regular Expression Matching,"Given an input string  s  and a pattern  p , implement regular expression matching with support for  '.'  and  '*'  where: '.'  Matches any single character.​​​​ '*'  Matches zero or more of the preceding element. The matching should cover the  entire  input string (not partial).   Example 1: Input:  s = ""aa"", p = ""a"" Output:  false Explanation:  ""a"" does not match the entire string ""aa"". Example 2: Input:  s = ""aa"", p = ""a*"" Output:  true Explanation:  '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes ""aa"". Example 3: Input:  s = ""ab"", p = "".*"" Output:  true Explanation:  "".*"" means ""zero or more (*) of any character (.)"".   Constraints: 1 <= s.length <= 20 1 <= p.length <= 20 s  contains only lowercase English letters. p  contains only lowercase English letters,  '.' , and  '*' . It is guaranteed for each appearance of the character  '*' , there will be a previous valid character to match.","['String', 'Dynamic Programming', 'Recursion']",Difícil,String
65,valid-number,https://leetcode.com/problems/valid-number/,Valid Number,"Given a string  s , return whether  s  is a  valid number . For example, all the following are valid numbers:  ""2"", ""0089"", ""-0.1"", ""+3.14"", ""4."", ""-.9"", ""2e10"", ""-90E3"", ""3e+7"", ""+6e-1"", ""53.5e93"", ""-123.456e789"" , while the following are not valid numbers:  ""abc"", ""1a"", ""1e"", ""e3"", ""99e2.5"", ""--6"", ""-+3"", ""95a54e53"" . Formally, a  valid number  is defined using one of the following definitions: An  integer number  followed by an  optional exponent . A  decimal number  followed by an  optional exponent . An  integer number  is defined with an  optional sign   '-'  or  '+'  followed by  digits . A  decimal number  is defined with an  optional sign   '-'  or  '+'  followed by one of the following definitions: Digits  followed by a  dot   '.' . Digits  followed by a  dot   '.'  followed by  digits . A  dot   '.'  followed by  digits . An  exponent  is defined with an  exponent notation   'e'  or  'E'  followed by an  integer number . The  digits  are defined as one or more digits.   Example 1: Input:   s = ""0"" Output:   true Example 2: Input:   s = ""e"" Output:   false Example 3: Input:   s = ""."" Output:   false   Constraints: 1 <= s.length <= 20 s  consists of only English letters (both uppercase and lowercase), digits ( 0-9 ), plus  '+' , minus  '-' , or dot  '.' .",['String'],Difícil,String
87,scramble-string,https://leetcode.com/problems/scramble-string/,Scramble String,"We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: 	 Split the string into two non-empty substrings at a random index, i.e., if the string is  s , divide it to  x  and  y  where  s = x + y . Randomly  decide to swap the two substrings or to keep them in the same order. i.e., after this step,  s  may become  s = x + y  or  s = y + x . Apply step 1 recursively on each of the two substrings  x  and  y . Given two strings  s1  and  s2  of  the same length , return  true  if  s2  is a scrambled string of  s1 , otherwise, return  false .   Example 1: Input:  s1 = ""great"", s2 = ""rgeat"" Output:  true Explanation:  One possible scenario applied on s1 is: ""great"" --> ""gr/eat"" // divide at random index. ""gr/eat"" --> ""gr/eat"" // random decision is not to swap the two substrings and keep them in order. ""gr/eat"" --> ""g/r / e/at"" // apply the same algorithm recursively on both substrings. divide at random index each of them. ""g/r / e/at"" --> ""r/g / e/at"" // random decision was to swap the first substring and to keep the second substring in the same order. ""r/g / e/at"" --> ""r/g / e/ a/t"" // again apply the algorithm recursively, divide ""at"" to ""a/t"". ""r/g / e/ a/t"" --> ""r/g / e/ a/t"" // random decision is to keep both substrings in the same order. The algorithm stops now, and the result string is ""rgeat"" which is s2. As one possible scenario led s1 to be scrambled to s2, we return true. Example 2: Input:  s1 = ""abcde"", s2 = ""caebd"" Output:  false Example 3: Input:  s1 = ""a"", s2 = ""a"" Output:  true   Constraints: s1.length == s2.length 1 <= s1.length <= 30 s1  and  s2  consist of lowercase English letters.","['String', 'Dynamic Programming']",Difícil,String
115,distinct-subsequences,https://leetcode.com/problems/distinct-subsequences/,Distinct Subsequences,"Given two strings s and t, return  the number of distinct   subsequences  of  s  which equals  t. The test cases are generated so that the answer fits on a 32-bit signed integer.   Example 1: Input:  s = ""rabbbit"", t = ""rabbit"" Output:  3 Explanation: As shown below, there are 3 ways you can generate ""rabbit"" from s. rabb b it ra b bbit rab b bit Example 2: Input:  s = ""babgbag"", t = ""bag"" Output:  5 Explanation: As shown below, there are 5 ways you can generate ""bag"" from s. ba b g bag ba bgba g b abgb ag ba b gb ag babg bag   Constraints: 1 <= s.length, t.length <= 1000 s  and  t  consist of English letters.","['String', 'Dynamic Programming']",Difícil,String
1096,brace-expansion-ii,https://leetcode.com/problems/brace-expansion-ii/,Brace Expansion II,"Under the grammar given below, strings can represent a set of lowercase words. Let  R(expr)  denote the set of words the expression represents. The grammar can best be understood through simple examples: Single letters represent a singleton set containing that word. 	 R(""a"") = {""a""} R(""w"") = {""w""} When we take a comma-delimited list of two or more expressions, we take the union of possibilities. 	 R(""{a,b,c}"") = {""a"",""b"",""c""} R(""{{a,b},{b,c}}"") = {""a"",""b"",""c""}  (notice the final set only contains each word at most once) When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. 	 R(""{a,b}{c,d}"") = {""ac"",""ad"",""bc"",""bd""} R(""a{b,c}{d,e}f{g,h}"") = {""abdfg"", ""abdfh"", ""abefg"", ""abefh"", ""acdfg"", ""acdfh"", ""acefg"", ""acefh""} Formally, the three rules for our grammar: For every lowercase letter  x , we have  R(x) = {x} . For expressions  e 1 , e 2 , ... , e k  with  k >= 2 , we have  R({e 1 , e 2 , ...}) = R(e 1 ) ∪ R(e 2 ) ∪ ... For expressions  e 1  and  e 2 , we have  R(e 1  + e 2 ) = {a + b for (a, b) in R(e 1 ) × R(e 2 )} , where  +  denotes concatenation, and  ×  denotes the cartesian product. Given an expression representing a set of words under the given grammar, return  the sorted list of words that the expression represents .   Example 1: Input:  expression = ""{a,b}{c,{d,e}}"" Output:  [""ac"",""ad"",""ae"",""bc"",""bd"",""be""] Example 2: Input:  expression = ""{{a,z},a{b,c},{ab,z}}"" Output:  [""a"",""ab"",""ac"",""z""] Explanation:  Each distinct word is written only once in the final answer.   Constraints: 1 <= expression.length <= 60 expression[i]  consists of  '{' ,  '}' ,  ',' or lowercase English letters. The given  expression  represents a set of words based on the grammar given in the description.","['String', 'Backtracking', 'Stack', 'Breadth-First Search']",Difícil,String
1106,parsing-a-boolean-expression,https://leetcode.com/problems/parsing-a-boolean-expression/,Parsing A Boolean Expression,"A  boolean expression  is an expression that evaluates to either  true  or  false . It can be in one of the following shapes: 't'  that evaluates to  true . 'f'  that evaluates to  false . '!(subExpr)'  that evaluates to  the logical NOT  of the inner expression  subExpr . '&(subExpr 1 , subExpr 2 , ..., subExpr n )'  that evaluates to  the logical AND  of the inner expressions  subExpr 1 , subExpr 2 , ..., subExpr n  where  n >= 1 . '|(subExpr 1 , subExpr 2 , ..., subExpr n )'  that evaluates to  the logical OR  of the inner expressions  subExpr 1 , subExpr 2 , ..., subExpr n  where  n >= 1 . Given a string  expression  that represents a  boolean expression , return  the evaluation of that expression . It is  guaranteed  that the given expression is valid and follows the given rules.   Example 1: Input:  expression = ""&(|(f))"" Output:  false Explanation:   First, evaluate |(f) --> f. The expression is now ""&(f)"". Then, evaluate &(f) --> f. The expression is now ""f"". Finally, return false. Example 2: Input:  expression = ""|(f,f,f,t)"" Output:  true Explanation:  The evaluation of (false OR false OR false OR true) is true. Example 3: Input:  expression = ""!(&(f,t))"" Output:  true Explanation:   First, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now ""!(f)"". Then, evaluate !(f) --> NOT false --> true. We return true.   Constraints: 1 <= expression.length <= 2 * 10 4 expression[i] is one following characters:  '(' ,  ')' ,  '&' ,  '|' ,  '!' ,  't' ,  'f' , and  ',' .","['String', 'Stack', 'Recursion']",Difícil,String
1221,split-a-string-in-balanced-strings,https://leetcode.com/problems/split-a-string-in-balanced-strings/,Split a String in Balanced Strings,"Balanced  strings are those that have an equal quantity of  'L'  and  'R'  characters. Given a  balanced  string  s , split it into some number of substrings such that: Each substring is balanced. Return  the  maximum  number of balanced strings you can obtain.   Example 1: Input:  s = ""RLRRLLRLRL"" Output:  4 Explanation:  s can be split into ""RL"", ""RRLL"", ""RL"", ""RL"", each substring contains same number of 'L' and 'R'. Example 2: Input:  s = ""RLRRRLLRLL"" Output:  2 Explanation:  s can be split into ""RL"", ""RRRLLRLL"", each substring contains same number of 'L' and 'R'. Note that s cannot be split into ""RL"", ""RR"", ""RL"", ""LR"", ""LL"", because the 2 nd  and 5 th  substrings are not balanced. Example 3: Input:  s = ""LLLLRRRR"" Output:  1 Explanation:  s can be split into ""LLLLRRRR"".   Constraints: 2 <= s.length <= 1000 s[i]  is either  'L'  or  'R' . s  is a  balanced  string.","['String', 'Greedy', 'Counting']",Fácil,String
1880,check-if-word-equals-summation-of-two-words,https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/,Check if Word Equals Summation of Two Words,"The  letter value  of a letter is its position in the alphabet  starting from 0  (i.e.  'a' -> 0 ,  'b' -> 1 ,  'c' -> 2 , etc.). The  numerical value  of some string of lowercase English letters  s  is the  concatenation  of the  letter values  of each letter in  s , which is then  converted  into an integer. For example, if  s = ""acb"" , we concatenate each letter's letter value, resulting in  ""021"" . After converting it, we get  21 . You are given three strings  firstWord ,  secondWord , and  targetWord , each consisting of lowercase English letters  'a'  through  'j'   inclusive . Return  true   if the  summation  of the  numerical values  of  firstWord  and  secondWord  equals the  numerical value  of  targetWord , or  false  otherwise.   Example 1: Input:  firstWord = ""acb"", secondWord = ""cba"", targetWord = ""cdb"" Output:  true Explanation: The numerical value of firstWord is ""acb"" -> ""021"" -> 21. The numerical value of secondWord is ""cba"" -> ""210"" -> 210. The numerical value of targetWord is ""cdb"" -> ""231"" -> 231. We return true because 21 + 210 == 231. Example 2: Input:  firstWord = ""aaa"", secondWord = ""a"", targetWord = ""aab"" Output:  false Explanation:   The numerical value of firstWord is ""aaa"" -> ""000"" -> 0. The numerical value of secondWord is ""a"" -> ""0"" -> 0. The numerical value of targetWord is ""aab"" -> ""001"" -> 1. We return false because 0 + 0 != 1. Example 3: Input:  firstWord = ""aaa"", secondWord = ""a"", targetWord = ""aaaa"" Output:  true Explanation:   The numerical value of firstWord is ""aaa"" -> ""000"" -> 0. The numerical value of secondWord is ""a"" -> ""0"" -> 0. The numerical value of targetWord is ""aaaa"" -> ""0000"" -> 0. We return true because 0 + 0 == 0.   Constraints: 1 <= firstWord.length,  secondWord.length,  targetWord.length <= 8 firstWord ,  secondWord , and  targetWord  consist of lowercase English letters from  'a'  to  'j'   inclusive .",['String'],Fácil,String
1945,sum-of-digits-of-string-after-convert,https://leetcode.com/problems/sum-of-digits-of-string-after-convert/,Sum of Digits of String After Convert,"You are given a string  s  consisting of lowercase English letters, and an integer  k . Your task is to  convert  the string into an integer by a special process, and then  transform  it by summing its digits repeatedly  k  times. More specifically, perform the following steps: Convert   s  into an integer by replacing each letter with its position in the alphabet (i.e. replace  'a'  with  1 ,  'b'  with  2 , ...,  'z'  with  26 ). T ransform  the integer by replacing it with the  sum of its digits . Repeat the  transform  operation (step 2)  k  times  in total. For example, if  s = ""zbax""  and  k = 2 , then the resulting integer would be  8  by the following operations: Convert :  ""zbax"" ➝ ""(26)(2)(1)(24)"" ➝ ""262124"" ➝ 262124 Transform #1 :  262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17 Transform #2 :  17 ➝ 1 + 7 ➝ 8 Return the  resulting   integer  after performing the  operations  described above.   Example 1: Input:   s = ""iiii"", k = 1 Output:   36 Explanation: The operations are as follows: - Convert: ""iiii"" ➝ ""(9)(9)(9)(9)"" ➝ ""9999"" ➝ 9999 - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36 Thus the resulting integer is 36. Example 2: Input:   s = ""leetcode"", k = 2 Output:   6 Explanation: The operations are as follows: - Convert: ""leetcode"" ➝ ""(12)(5)(5)(20)(3)(15)(4)(5)"" ➝ ""12552031545"" ➝ 12552031545 - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33 - Transform #2: 33 ➝ 3 + 3 ➝ 6 Thus the resulting integer is 6. Example 3: Input:   s = ""zbax"", k = 2 Output:   8   Constraints: 1 <= s.length <= 100 1 <= k <= 10 s  consists of lowercase English letters.","['String', 'Simulation']",Fácil,String
2194,cells-in-a-range-on-an-excel-sheet,https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/,Cells in a Range on an Excel Sheet,"A cell  (r, c)  of an excel sheet is represented as a string  ""<col><row>""  where: <col>  denotes the column number  c  of the cell. It is represented by  alphabetical letters . 	 For example, the  1 st  column is denoted by  'A' , the  2 nd  by  'B' , the  3 rd  by  'C' , and so on. <row>  is the row number  r  of the cell. The  r th  row is represented by the  integer   r . You are given a string  s  in the format  ""<col1><row1>:<col2><row2>"" , where  <col1>  represents the column  c1 ,  <row1>  represents the row  r1 ,  <col2>  represents the column  c2 , and  <row2>  represents the row  r2 , such that  r1 <= r2  and  c1 <= c2 . Return  the  list of cells   (x, y)   such that   r1 <= x <= r2   and   c1 <= y <= c2 . The cells should be represented as  strings  in the format mentioned above and be sorted in  non-decreasing  order first by columns and then by rows.   Example 1: Input:  s = ""K1:L2"" Output:  [""K1"",""K2"",""L1"",""L2""] Explanation: The above diagram shows the cells which should be present in the list. The red arrows denote the order in which the cells should be presented. Example 2: Input:  s = ""A1:F1"" Output:  [""A1"",""B1"",""C1"",""D1"",""E1"",""F1""] Explanation: The above diagram shows the cells which should be present in the list. The red arrow denotes the order in which the cells should be presented.   Constraints: s.length == 5 'A' <= s[0] <= s[3] <= 'Z' '1' <= s[1] <= s[4] <= '9' s  consists of uppercase English letters, digits and  ':' .",['String'],Fácil,String
2259,remove-digit-from-number-to-maximize-result,https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/,Remove Digit From Number to Maximize Result,"You are given a string  number  representing a  positive integer  and a character  digit . Return  the resulting string after removing  exactly one occurrence  of  digit  from  number  such that the value of the resulting string in  decimal  form is  maximized . The test cases are generated such that  digit  occurs at least once in  number .   Example 1: Input:  number = ""123"", digit = ""3"" Output:  ""12"" Explanation:  There is only one '3' in ""123"". After removing '3', the result is ""12"". Example 2: Input:  number = ""1231"", digit = ""1"" Output:  ""231"" Explanation:  We can remove the first '1' to get ""231"" or remove the second '1' to get ""123"". Since 231 > 123, we return ""231"". Example 3: Input:  number = ""551"", digit = ""5"" Output:  ""51"" Explanation:  We can remove either the first or second '5' from ""551"". Both result in the string ""51"".   Constraints: 2 <= number.length <= 100 number  consists of digits from  '1'  to  '9' . digit  is a digit from  '1'  to  '9' . digit  occurs at least once in  number .","['String', 'Greedy', 'Enumeration']",Fácil,String
2490,circular-sentence,https://leetcode.com/problems/circular-sentence/,Circular Sentence,"A  sentence  is a list of words that are separated by a  single  space with no leading or trailing spaces. For example,  ""Hello World"" ,  ""HELLO"" ,  ""hello world hello world""  are all sentences. Words consist of  only  uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different. A sentence is  circular  if: The last character of each word in the sentence is equal to the first character of its next word. The last character of the last word is equal to the first character of the first word. For example,  ""leetcode exercises sound delightful"" ,  ""eetcode"" ,  ""leetcode eats soul""  are all circular sentences. However,  ""Leetcode is cool"" ,  ""happy Leetcode"" ,  ""Leetcode""  and  ""I like Leetcode""  are  not  circular sentences. Given a string  sentence , return  true  if it is circular . Otherwise, return  false .   Example 1: Input:  sentence = ""leetcode exercises sound delightful"" Output:  true Explanation:  The words in sentence are [""leetcode"", ""exercises"", ""sound"", ""delightful""]. - leetcod e 's last character is equal to  e xercises's first character. - exercise s 's last character is equal to  s ound's first character. - soun d 's last character is equal to  d elightful's first character. - delightfu l 's last character is equal to  l eetcode's first character. The sentence is circular. Example 2: Input:  sentence = ""eetcode"" Output:  true Explanation:  The words in sentence are [""eetcode""]. - eetcod e 's last character is equal to  e etcode's first character. The sentence is circular. Example 3: Input:  sentence = ""Leetcode is cool"" Output:  false Explanation:  The words in sentence are [""Leetcode"", ""is"", ""cool""]. - Leetcod e 's last character is  not  equal to  i s's first character. The sentence is  not  circular.   Constraints: 1 <= sentence.length <= 500 sentence  consist of only lowercase and uppercase English letters and spaces. The words in  sentence  are separated by a single space. There are no leading or trailing spaces.",['String'],Fácil,String
2609,find-the-longest-balanced-substring-of-a-binary-string,https://leetcode.com/problems/find-the-longest-balanced-substring-of-a-binary-string/,Find the Longest Balanced Substring of a Binary String,"You are given a binary string  s  consisting only of zeroes and ones. A substring of  s  is considered balanced if  all zeroes are before ones  and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring. Return  the length of the longest balanced substring of  s . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""01000111"" Output:  6 Explanation:  The longest balanced substring is ""000111"", which has length 6. Example 2: Input:  s = ""00111"" Output:  4 Explanation:  The longest balanced substring is ""0011"", which has length 4.  Example 3: Input:  s = ""111"" Output:  0 Explanation:  There is no balanced substring except the empty substring, so the answer is 0.   Constraints: 1 <= s.length <= 50 '0' <= s[i] <= '1'",['String'],Fácil,String
3456,find-special-substring-of-length-k,https://leetcode.com/problems/find-special-substring-of-length-k/,Find Special Substring of Length K,"You are given a string  s  and an integer  k . Determine if there exists a  substring  of length  exactly   k  in  s  that satisfies the following conditions: The substring consists of  only one distinct character  (e.g.,  ""aaa""  or  ""bbb"" ). If there is a character  immediately before  the substring, it must be different from the character in the substring. If there is a character  immediately after  the substring, it must also be different from the character in the substring. Return  true  if such a substring exists. Otherwise, return  false .   Example 1: Input:   s = ""aaabaaa"", k = 3 Output:   true Explanation: The substring  s[4..6] == ""aaa""  satisfies the conditions. It has a length of 3. All characters are the same. The character before  ""aaa""  is  'b' , which is different from  'a' . There is no character after  ""aaa"" . Example 2: Input:   s = ""abc"", k = 2 Output:   false Explanation: There is no substring of length 2 that consists of one distinct character and satisfies the conditions.   Constraints: 1 <= k <= s.length <= 100 s  consists of lowercase English letters only.",['String'],Fácil,String
649,dota2-senate,https://leetcode.com/problems/dota2-senate/,Dota2 Senate,"In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise  one  of the two rights: Ban one senator's right:  A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory:  If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string  senate  representing each senator's party belonging. The character  'R'  and  'D'  represent the Radiant party and the Dire party. Then if there are  n  senators, the size of the given string will be  n . The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be  ""Radiant""  or  ""Dire"" .   Example 1: Input:  senate = ""RD"" Output:  ""Radiant"" Explanation:   The first senator comes from Radiant and he can just ban the next senator's right in round 1.  And the second senator can't exercise any rights anymore since his right has been banned.  And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. Example 2: Input:  senate = ""RDD"" Output:  ""Dire"" Explanation:   The first senator comes from Radiant and he can just ban the next senator's right in round 1.  And the second senator can't exercise any rights anymore since his right has been banned.  And the third senator comes from Dire and he can ban the first senator's right in round 1.  And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.   Constraints: n == senate.length 1 <= n <= 10 4 senate[i]  is either  'R'  or  'D' .","['String', 'Greedy', 'Queue']",Média,String
1404,number-of-steps-to-reduce-a-number-in-binary-representation-to-one,https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/,Number of Steps to Reduce a Number in Binary Representation to One,"Given the binary representation of an integer as a string  s , return  the number of steps to reduce it to  1  under the following rules : If the current number is even, you have to divide it by  2 . If the current number is odd, you have to add  1  to it. It is guaranteed that you can always reach one for all test cases.   Example 1: Input:  s = ""1101"" Output:  6 Explanation:  ""1101"" corressponds to number 13 in their decimal representation. Step 1) 13 is odd, add 1 and obtain 14.  Step 2) 14 is even, divide by 2 and obtain 7. Step 3) 7 is odd, add 1 and obtain 8. Step 4) 8 is even, divide by 2 and obtain 4.   Step 5) 4 is even, divide by 2 and obtain 2.  Step 6) 2 is even, divide by 2 and obtain 1.   Example 2: Input:  s = ""10"" Output:  1 Explanation:  ""10"" corresponds to number 2 in their decimal representation. Step 1) 2 is even, divide by 2 and obtain 1.   Example 3: Input:  s = ""1"" Output:  0   Constraints: 1 <= s.length <= 500 s  consists of characters '0' or '1' s[0] == '1'","['String', 'Bit Manipulation', 'Simulation']",Média,String
1415,the-k-th-lexicographical-string-of-all-happy-strings-of-length-n,https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/,The k-th Lexicographical String of All Happy Strings of Length n,"A  happy string  is a string that: consists only of letters of the set  ['a', 'b', 'c'] . s[i] != s[i + 1]  for all values of  i  from  1  to  s.length - 1  (string is 1-indexed). For example, strings  ""abc"", ""ac"", ""b""  and  ""abcbabcbcb""  are all happy strings and strings  ""aa"", ""baa""  and  ""ababbc""  are not happy strings. Given two integers  n  and  k , consider a list of all happy strings of length  n  sorted in lexicographical order. Return  the kth string  of this list or return an  empty string  if there are less than  k  happy strings of length  n .   Example 1: Input:  n = 1, k = 3 Output:  ""c"" Explanation:  The list [""a"", ""b"", ""c""] contains all happy strings of length 1. The third string is ""c"". Example 2: Input:  n = 1, k = 4 Output:  """" Explanation:  There are only 3 happy strings of length 1. Example 3: Input:  n = 3, k = 9 Output:  ""cab"" Explanation:  There are 12 different happy string of length 3 [""aba"", ""abc"", ""aca"", ""acb"", ""bab"", ""bac"", ""bca"", ""bcb"", ""cab"", ""cac"", ""cba"", ""cbc""]. You will find the 9 th  string = ""cab""   Constraints: 1 <= n <= 10 1 <= k <= 100","['String', 'Backtracking']",Média,String
1433,check-if-a-string-can-break-another-string,https://leetcode.com/problems/check-if-a-string-can-break-another-string/,Check If a String Can Break Another String,"Given two strings:  s1  and  s2  with the same size, check if some permutation of string  s1  can break some permutation of string  s2  or vice-versa. In other words  s2  can break  s1  or vice-versa. A string  x  can break string  y  (both of size  n ) if  x[i] >= y[i]  (in alphabetical order) for all  i  between  0  and  n-1 .   Example 1: Input:  s1 = ""abc"", s2 = ""xya"" Output:  true Explanation:  ""ayx"" is a permutation of s2=""xya"" which can break to string ""abc"" which is a permutation of s1=""abc"". Example 2: Input:  s1 = ""abe"", s2 = ""acd"" Output:  false  Explanation:  All permutations for s1=""abe"" are: ""abe"", ""aeb"", ""bae"", ""bea"", ""eab"" and ""eba"" and all permutation for s2=""acd"" are: ""acd"", ""adc"", ""cad"", ""cda"", ""dac"" and ""dca"". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa. Example 3: Input:  s1 = ""leetcodee"", s2 = ""interview"" Output:  true   Constraints: s1.length == n s2.length == n 1 <= n <= 10^5 All strings consist of lowercase English letters.","['String', 'Greedy', 'Sorting']",Média,String
1545,find-kth-bit-in-nth-binary-string,https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/,Find Kth Bit in Nth Binary String,"Given two positive integers  n  and  k , the binary string  S n  is formed as follows: S 1  = ""0"" S i  = S i - 1  + ""1"" + reverse(invert(S i - 1 ))  for  i > 1 Where  +  denotes the concatenation operation,  reverse(x)  returns the reversed string  x , and  invert(x)  inverts all the bits in  x  ( 0  changes to  1  and  1  changes to  0 ). For example, the first four strings in the above sequence are: S 1  = ""0"" S 2  = ""0 1 1"" S 3  = ""011 1 001"" S 4  = ""0111001 1 0110001"" Return  the   k th   bit   in   S n . It is guaranteed that  k  is valid for the given  n .   Example 1: Input:  n = 3, k = 1 Output:  ""0"" Explanation:  S 3  is "" 0 111001"". The 1 st  bit is ""0"". Example 2: Input:  n = 4, k = 11 Output:  ""1"" Explanation:  S 4  is ""0111001101 1 0001"". The 11 th  bit is ""1"".   Constraints: 1 <= n <= 20 1 <= k <= 2 n  - 1","['String', 'Recursion', 'Simulation']",Média,String
1625,lexicographically-smallest-string-after-applying-operations,https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/,Lexicographically Smallest String After Applying Operations,"You are given a string  s  of  even length  consisting of digits from  0  to  9 , and two integers  a  and  b . You can apply either of the following two operations any number of times and in any order on  s : Add  a  to all odd indices of  s   (0-indexed) . Digits post  9  are cycled back to  0 . For example, if  s = ""3456""  and  a = 5 ,  s  becomes  ""3951"" . Rotate  s  to the right by  b  positions. For example, if  s = ""3456""  and  b = 1 ,  s  becomes  ""6345"" . Return  the  lexicographically smallest  string you can obtain by applying the above operations any number of times on   s . A string  a  is lexicographically smaller than a string  b  (of the same length) if in the first position where  a  and  b  differ, string  a  has a letter that appears earlier in the alphabet than the corresponding letter in  b . For example,  ""0158""  is lexicographically smaller than  ""0190""  because the first position they differ is at the third letter, and  '5'  comes before  '9' .   Example 1: Input:  s = ""5525"", a = 9, b = 2 Output:  ""2050"" Explanation:  We can apply the following operations: Start:  ""5525"" Rotate: ""2555"" Add:    ""2454"" Add:    ""2353"" Rotate: ""5323"" Add:    ""5222"" Add:    ""5121"" Rotate: ""2151"" Add:    ""2050""​​​​​ There is no way to obtain a string that is lexicographically smaller than ""2050"". Example 2: Input:  s = ""74"", a = 5, b = 1 Output:  ""24"" Explanation:  We can apply the following operations: Start:  ""74"" Rotate: ""47"" ​​​​​​​Add:    ""42"" ​​​​​​​Rotate: ""24""​​​​​​​​​​​​ There is no way to obtain a string that is lexicographically smaller than ""24"". Example 3: Input:  s = ""0011"", a = 4, b = 2 Output:  ""0011"" Explanation:  There are no sequence of operations that will give us a lexicographically smaller string than ""0011"".   Constraints: 2 <= s.length <= 100 s.length  is even. s  consists of digits from  0  to  9  only. 1 <= a <= 9 1 <= b <= s.length - 1","['String', 'Depth-First Search', 'Breadth-First Search', 'Enumeration']",Média,String
1653,minimum-deletions-to-make-string-balanced,https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/,Minimum Deletions to Make String Balanced,"You are given a string  s  consisting only of characters  'a'  and  'b' ​​​​. You can delete any number of characters in  s  to make  s   balanced .  s  is  balanced  if there is no pair of indices  (i,j)  such that  i < j  and  s[i] = 'b'  and  s[j]= 'a' . Return  the  minimum  number of deletions needed to make  s   balanced .   Example 1: Input:  s = ""aababbab"" Output:  2 Explanation:  You can either: Delete the characters at 0-indexed positions 2 and 6 (""aa b abb a b"" -> ""aaabbb""), or Delete the characters at 0-indexed positions 3 and 6 (""aab a bb a b"" -> ""aabbbb""). Example 2: Input:  s = ""bbaaaaabb"" Output:  2 Explanation:  The only solution is to delete the first two characters.   Constraints: 1 <= s.length <= 10 5 s[i]  is  'a'  or  'b' ​​.","['String', 'Dynamic Programming', 'Stack']",Média,String
1910,remove-all-occurrences-of-a-substring,https://leetcode.com/problems/remove-all-occurrences-of-a-substring/,Remove All Occurrences of a Substring,"Given two strings  s  and  part , perform the following operation on  s  until  all  occurrences of the substring  part  are removed: Find the  leftmost  occurrence of the substring  part  and  remove  it from  s . Return  s  after removing all occurrences of  part . A  substring  is a contiguous sequence of characters in a string.   Example 1: Input:  s = ""daabcbaabcbc"", part = ""abc"" Output:  ""dab"" Explanation : The following operations are done: - s = ""da abc baabcbc"", remove ""abc"" starting at index 2, so s = ""dabaabcbc"". - s = ""daba abc bc"", remove ""abc"" starting at index 4, so s = ""dababc"". - s = ""dab abc "", remove ""abc"" starting at index 3, so s = ""dab"". Now s has no occurrences of ""abc"". Example 2: Input:  s = ""axxxxyyyyb"", part = ""xy"" Output:  ""ab"" Explanation : The following operations are done: - s = ""axxx xy yyyb"", remove ""xy"" starting at index 4 so s = ""axxxyyyb"". - s = ""axx xy yyb"", remove ""xy"" starting at index 3 so s = ""axxyyb"". - s = ""ax xy yb"", remove ""xy"" starting at index 2 so s = ""axyb"". - s = ""a xy b"", remove ""xy"" starting at index 1 so s = ""ab"". Now s has no occurrences of ""xy"".   Constraints: 1 <= s.length <= 1000 1 <= part.length <= 1000 s ​​​​​​ and  part  consists of lowercase English letters.","['String', 'Stack', 'Simulation']",Média,String
2075,decode-the-slanted-ciphertext,https://leetcode.com/problems/decode-the-slanted-ciphertext/,Decode the Slanted Ciphertext,"A string  originalText  is encoded using a  slanted transposition cipher  to a string  encodedText  with the help of a matrix having a  fixed number of rows   rows . originalText  is placed first in a top-left to bottom-right manner. The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of  originalText . The arrow indicates the order in which the cells are filled. All empty cells are filled with  ' ' . The number of columns is chosen such that the rightmost column will  not be empty  after filling in  originalText . encodedText  is then formed by appending all characters of the matrix in a row-wise fashion. The characters in the blue cells are appended first to  encodedText , then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed. For example, if  originalText = ""cipher""  and  rows = 3 , then we encode it in the following manner: The blue arrows depict how  originalText  is placed in the matrix, and the red arrows denote the order in which  encodedText  is formed. In the above example,  encodedText = ""ch ie pr"" . Given the encoded string  encodedText  and number of rows  rows , return  the original string   originalText . Note:   originalText   does not  have any trailing spaces  ' ' . The test cases are generated such that there is only one possible  originalText .   Example 1: Input:  encodedText = ""ch   ie   pr"", rows = 3 Output:  ""cipher"" Explanation:  This is the same example described in the problem description. Example 2: Input:  encodedText = ""iveo    eed   l te   olc"", rows = 4 Output:  ""i love leetcode"" Explanation:  The figure above denotes the matrix that was used to encode originalText.  The blue arrows show how we can find originalText from encodedText. Example 3: Input:  encodedText = ""coding"", rows = 1 Output:  ""coding"" Explanation:  Since there is only 1 row, both originalText and encodedText are the same.   Constraints: 0 <= encodedText.length <= 10 6 encodedText  consists of lowercase English letters and  ' '  only. encodedText  is a valid encoding of some  originalText  that  does not  have trailing spaces. 1 <= rows <= 1000 The testcases are generated such that there is  only one  possible  originalText .","['String', 'Simulation']",Média,String
2086,minimum-number-of-food-buckets-to-feed-the-hamsters,https://leetcode.com/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/,Minimum Number of Food Buckets to Feed the Hamsters,"You are given a  0-indexed  string  hamsters  where  hamsters[i]  is either: 'H'  indicating that there is a hamster at index  i , or '.'  indicating that index  i  is empty. You will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index  i  can be fed if you place a food bucket at index  i - 1   and/or  at index  i + 1 . Return  the minimum number of food buckets you should  place at empty indices  to feed all the hamsters or  -1  if it is impossible to feed all of them .   Example 1: Input:  hamsters = ""H..H"" Output:  2 Explanation:  We place two food buckets at indices 1 and 2. It can be shown that if we place only one food bucket, one of the hamsters will not be fed. Example 2: Input:  hamsters = "".H.H."" Output:  1 Explanation:  We place one food bucket at index 2. Example 3: Input:  hamsters = "".HHH."" Output:  -1 Explanation:  If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat.   Constraints: 1 <= hamsters.length <= 10 5 hamsters[i]  is either 'H'  or  '.' .","['String', 'Dynamic Programming', 'Greedy']",Média,String
2096,step-by-step-directions-from-a-binary-tree-node-to-another,https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/,Step-By-Step Directions From a Binary Tree Node to Another,"You are given the  root  of a  binary tree  with  n  nodes. Each node is uniquely assigned a value from  1  to  n . You are also given an integer  startValue  representing the value of the start node  s , and a different integer  destValue  representing the value of the destination node  t . Find the  shortest path  starting from node  s  and ending at node  t . Generate step-by-step directions of such path as a string consisting of only the  uppercase  letters  'L' ,  'R' , and  'U' . Each letter indicates a specific direction: 'L'  means to go from a node to its  left child  node. 'R'  means to go from a node to its  right child  node. 'U'  means to go from a node to its  parent  node. Return  the step-by-step directions of the  shortest path  from node  s  to node   t .   Example 1: Input:  root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 Output:  ""UURL"" Explanation:  The shortest path is: 3 → 1 → 5 → 2 → 6. Example 2: Input:  root = [2,1], startValue = 2, destValue = 1 Output:  ""L"" Explanation:  The shortest path is: 2 → 1.   Constraints: The number of nodes in the tree is  n . 2 <= n <= 10 5 1 <= Node.val <= n All the values in the tree are  unique . 1 <= startValue, destValue <= n startValue != destValue","['String', 'Tree', 'Depth-First Search', 'Binary Tree']",Média,String
2116,check-if-a-parentheses-string-can-be-valid,https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/,Check if a Parentheses String Can Be Valid,"A parentheses string is a  non-empty  string consisting only of  '('  and  ')' . It is valid if  any  of the following conditions is  true : It is  () . It can be written as  AB  ( A  concatenated with  B ), where  A  and  B  are valid parentheses strings. It can be written as  (A) , where  A  is a valid parentheses string. You are given a parentheses string  s  and a string  locked , both of length  n .  locked  is a binary string consisting only of  '0' s and  '1' s. For  each  index  i  of  locked , If  locked[i]  is  '1' , you  cannot  change  s[i] . But if  locked[i]  is  '0' , you  can  change  s[i]  to either  '('  or  ')' . Return  true   if you can make  s  a valid parentheses string . Otherwise, return  false .   Example 1: Input:  s = ""))()))"", locked = ""010100"" Output:  true Explanation:  locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3]. We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid. Example 2: Input:  s = ""()()"", locked = ""0000"" Output:  true Explanation:  We do not need to make any changes because s is already valid. Example 3: Input:  s = "")"", locked = ""0"" Output:  false Explanation:  locked permits us to change s[0].  Changing s[0] to either '(' or ')' will not make s valid. Example 4: Input:  s = ""(((())(((())"", locked = ""111111010111"" Output:  true Explanation:  locked permits us to change s[6] and s[8].  We change s[6] and s[8] to ')' to make s valid.   Constraints: n == s.length == locked.length 1 <= n <= 10 5 s[i]  is either  '('  or  ')' . locked[i]  is either  '0'  or  '1' .","['String', 'Stack', 'Greedy']",Média,String
2222,number-of-ways-to-select-buildings,https://leetcode.com/problems/number-of-ways-to-select-buildings/,Number of Ways to Select Buildings,"You are given a  0-indexed  binary string  s  which represents the types of buildings along a street where: s[i] = '0'  denotes that the  i th  building is an office and s[i] = '1'  denotes that the  i th  building is a restaurant. As a city official, you would like to  select  3 buildings for random inspection. However, to ensure variety,  no two consecutive  buildings out of the  selected  buildings can be of the same type. For example, given  s = ""0 0 1 1 0 1 "" , we cannot select the  1 st ,  3 rd , and  5 th  buildings as that would form  ""0 11 ""  which is  not  allowed due to having two consecutive buildings of the same type. Return  the  number of valid ways  to select 3 buildings.   Example 1: Input:  s = ""001101"" Output:  6 Explanation:   The following sets of indices selected are valid: - [0,2,4] from "" 0 0 1 1 0 1"" forms ""010"" - [0,3,4] from "" 0 01 10 1"" forms ""010"" - [1,2,4] from ""0 01 1 0 1"" forms ""010"" - [1,3,4] from ""0 0 1 10 1"" forms ""010"" - [2,4,5] from ""00 1 1 01 "" forms ""101"" - [3,4,5] from ""001 101 "" forms ""101"" No other selection is valid. Thus, there are 6 total ways. Example 2: Input:  s = ""11100"" Output:  0 Explanation:  It can be shown that there are no valid selections.   Constraints: 3 <= s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['String', 'Dynamic Programming', 'Prefix Sum']",Média,String
2232,minimize-result-by-adding-parentheses-to-expression,https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/,Minimize Result by Adding Parentheses to Expression,"You are given a  0-indexed  string  expression  of the form  ""<num1>+<num2>""  where  <num1>  and  <num2>  represent positive integers. Add a pair of parentheses to  expression  such that after the addition of parentheses,  expression  is a  valid  mathematical expression and evaluates to the  smallest  possible value. The left parenthesis  must  be added to the left of  '+'  and the right parenthesis  must  be added to the right of  '+' . Return  expression  after adding a pair of parentheses such that  expression  evaluates to the  smallest  possible value.  If there are multiple answers that yield the same result, return any of them. The input has been generated such that the original value of  expression , and the value of  expression  after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.   Example 1: Input:  expression = ""247+38"" Output:  ""2(47+38)"" Explanation:  The  expression  evaluates to 2 * (47 + 38) = 2 * 85 = 170. Note that ""2(4)7+38"" is invalid because the right parenthesis must be to the right of the  '+' . It can be shown that 170 is the smallest possible value. Example 2: Input:  expression = ""12+34"" Output:  ""1(2+3)4"" Explanation:  The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20. Example 3: Input:  expression = ""999+999"" Output:  ""(999+999)"" Explanation:  The  expression  evaluates to 999 + 999 = 1998.   Constraints: 3 <= expression.length <= 10 expression  consists of digits from  '1'  to  '9'  and  '+' . expression  starts and ends with digits. expression  contains exactly one  '+' . The original value of  expression , and the value of  expression  after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.","['String', 'Enumeration']",Média,String
2288,apply-discount-to-prices,https://leetcode.com/problems/apply-discount-to-prices/,Apply Discount to Prices,"A  sentence  is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign  '$' . A word represents a  price  if it is a sequence of digits preceded by a dollar sign. For example,  ""$100"" ,  ""$23"" , and  ""$6""  represent prices while  ""100"" ,  ""$"" , and  ""$1e5""  do not. You are given a string  sentence  representing a sentence and an integer  discount . For each word representing a price, apply a discount of  discount%  on the price and  update  the word in the sentence. All updated prices should be represented with  exactly two  decimal places. Return  a string representing the modified sentence . Note that all prices will contain  at most   10  digits.   Example 1: Input:  sentence = ""there are $1 $2 and 5$ candies in the shop"", discount = 50 Output:  ""there are $0.50 $1.00 and 5$ candies in the shop"" Explanation:   The words which represent prices are ""$1"" and ""$2"".  - A 50% discount on ""$1"" yields ""$0.50"", so ""$1"" is replaced by ""$0.50"". - A 50% discount on ""$2"" yields ""$1"". Since we need to have exactly 2 decimal places after a price, we replace ""$2"" with ""$1.00"". Example 2: Input:  sentence = ""1 2 $3 4 $5 $6 7 8$ $9 $10$"", discount = 100 Output:  ""1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$"" Explanation:   Applying a 100% discount on any price will result in 0. The words representing prices are ""$3"", ""$5"", ""$6"", and ""$9"". Each of them is replaced by ""$0.00"".   Constraints: 1 <= sentence.length <= 10 5 sentence  consists of lowercase English letters, digits,  ' ' , and  '$' . sentence  does not have leading or trailing spaces. All words in  sentence  are separated by a single space. All prices will be  positive  numbers without leading zeros. All prices will have  at most   10  digits. 0 <= discount <= 100",['String'],Média,String
3499,maximize-active-section-with-trade-i,https://leetcode.com/problems/maximize-active-section-with-trade-i/,Maximize Active Section with Trade I,"You are given a binary string  s  of length  n , where: '1'  represents an  active  section. '0'  represents an  inactive  section. You can perform  at most one trade  to maximize the number of active sections in  s . In a trade, you: Convert a contiguous block of  '1' s that is surrounded by  '0' s to all  '0' s. Afterward, convert a contiguous block of  '0' s that is surrounded by  '1' s to all  '1' s. Return the  maximum  number of active sections in  s  after making the optimal trade. Note:  Treat  s  as if it is  augmented  with a  '1'  at both ends, forming  t = '1' + s + '1' . The augmented  '1' s  do not  contribute to the final count.   Example 1: Input:   s = ""01"" Output:   1 Explanation: Because there is no block of  '1' s surrounded by  '0' s, no valid trade is possible. The maximum number of active sections is 1. Example 2: Input:   s = ""0100"" Output:   4 Explanation: String  ""0100""  → Augmented to  ""101001"" . Choose  ""0100"" , convert  ""10 1 001""  →  ""1 0000 1""  →  ""1 1111 1"" . The final string without augmentation is  ""1111"" . The maximum number of active sections is 4. Example 3: Input:   s = ""1000100"" Output:   7 Explanation: String  ""1000100""  → Augmented to  ""110001001"" . Choose  ""000100"" , convert  ""11000 1 001""  →  ""11 000000 1""  →  ""11 111111 1"" . The final string without augmentation is  ""1111111"" . The maximum number of active sections is 7. Example 4: Input:   s = ""01010"" Output:   4 Explanation: String  ""01010""  → Augmented to  ""1010101"" . Choose  ""010"" , convert  ""10 1 0101""  →  ""1 000 101""  →  ""1 111 101"" . The final string without augmentation is  ""11110"" . The maximum number of active sections is 4.   Constraints: 1 <= n == s.length <= 10 5 s[i]  is either  '0'  or  '1'","['String', 'Enumeration']",Média,String
1377,frog-position-after-t-seconds,https://leetcode.com/problems/frog-position-after-t-seconds/,Frog Position After T Seconds,"Given an undirected tree consisting of  n  vertices numbered from  1  to  n . A frog starts jumping from  vertex 1 . In one second, the frog jumps from its current vertex to another  unvisited  vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex. The edges of the undirected tree are given in the array  edges , where  edges[i] = [a i , b i ]  means that exists an edge connecting the vertices  a i  and  b i . Return the probability that after  t  seconds the frog is on the vertex  target .  Answers within  10 -5  of the actual answer will be accepted.   Example 1: Input:  n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 Output:  0.16666666666666666  Explanation:  The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after  second 1  and then jumping with 1/2 probability to vertex 4 after  second 2 . Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.  Example 2: Input:  n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output:  0.3333333333333333 Explanation:  The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after  second 1 .    Constraints: 1 <= n <= 100 edges.length == n - 1 edges[i].length == 2 1 <= a i , b i  <= n 1 <= t <= 50 1 <= target <= n","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Graph']",Difícil,Tree
1719,number-of-ways-to-reconstruct-a-tree,https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/,Number Of Ways To Reconstruct A Tree,"You are given an array  pairs , where  pairs[i] = [x i , y i ] , and: There are no duplicates. x i  < y i Let  ways  be the number of rooted trees that satisfy the following conditions: The tree consists of nodes whose values appeared in  pairs . A pair  [x i , y i ]  exists in  pairs   if and only if   x i  is an ancestor of  y i  or  y i  is an ancestor of  x i . Note:  the tree does not have to be a binary tree. Two ways are considered to be different if there is at least one node that has different parents in both ways. Return: 0  if  ways == 0 1  if  ways == 1 2  if  ways > 1 A  rooted tree  is a tree that has a single root node, and all edges are oriented to be outgoing from the root. An  ancestor  of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.   Example 1: Input:  pairs = [[1,2],[2,3]] Output:  1 Explanation:  There is exactly one valid rooted tree, which is shown in the above figure. Example 2: Input:  pairs = [[1,2],[2,3],[1,3]] Output:  2 Explanation:  There are multiple valid rooted trees. Three of them are shown in the above figures. Example 3: Input:  pairs = [[1,2],[2,3],[2,4],[1,5]] Output:  0 Explanation:  There are no valid rooted trees.   Constraints: 1 <= pairs.length <= 10 5 1 <= x i  < y i  <= 500 The elements in  pairs  are unique.","['Tree', 'Graph']",Difícil,Tree
2872,maximum-number-of-k-divisible-components,https://leetcode.com/problems/maximum-number-of-k-divisible-components/,Maximum Number of K-Divisible Components,"There is an undirected tree with  n  nodes labeled from  0  to  n - 1 . You are given the integer  n  and a 2D integer array  edges  of length  n - 1 , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. You are also given a  0-indexed  integer array  values  of length  n , where  values[i]  is the  value  associated with the  i th  node, and an integer  k . A  valid split  of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by  k , where the  value of a connected component  is the sum of the values of its nodes. Return  the  maximum number of components  in any valid split .   Example 1: Input:  n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6 Output:  2 Explanation:  We remove the edge connecting node 1 with 2. The resulting split is valid because: - The value of the component containing nodes 1 and 3 is values[1] + values[3] = 12. - The value of the component containing nodes 0, 2, and 4 is values[0] + values[2] + values[4] = 6. It can be shown that no other valid split has more than 2 connected components. Example 2: Input:  n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3 Output:  3 Explanation:  We remove the edge connecting node 0 with 2, and the edge connecting node 0 with 1. The resulting split is valid because: - The value of the component containing node 0 is values[0] = 3. - The value of the component containing nodes 2, 5, and 6 is values[2] + values[5] + values[6] = 9. - The value of the component containing nodes 1, 3, and 4 is values[1] + values[3] + values[4] = 6. It can be shown that no other valid split has more than 3 connected components.   Constraints: 1 <= n <= 3 * 10 4 edges.length == n - 1 edges[i].length == 2 0 <= a i , b i  < n values.length == n 0 <= values[i] <= 10 9 1 <= k <= 10 9 Sum of  values  is divisible by  k . The input is generated such that  edges  represents a valid tree.","['Tree', 'Depth-First Search']",Difícil,Tree
3203,find-minimum-diameter-after-merging-two-trees,https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/,Find Minimum Diameter After Merging Two Trees,"There exist two  undirected  trees with  n  and  m  nodes, numbered from  0  to  n - 1  and from  0  to  m - 1 , respectively. You are given two 2D integer arrays  edges1  and  edges2  of lengths  n - 1  and  m - 1 , respectively, where  edges1[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the first tree and  edges2[i] = [u i , v i ]  indicates that there is an edge between nodes  u i  and  v i  in the second tree. You must connect one node from the first tree with another node from the second tree with an edge. Return the  minimum  possible  diameter  of the resulting tree. The  diameter  of a tree is the length of the  longest  path between any two nodes in the tree.   Example 1: Input:   edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]] Output:   3 Explanation: We can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree. Example 2: Input:   edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]] Output:   5 Explanation: We can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.   Constraints: 1 <= n, m <= 10 5 edges1.length == n - 1 edges2.length == m - 1 edges1[i].length == edges2[i].length == 2 edges1[i] = [a i , b i ] 0 <= a i , b i  < n edges2[i] = [u i , v i ] 0 <= u i , v i  < m The input is generated such that  edges1  and  edges2  represent valid trees.","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Graph']",Difícil,Tree
3373,maximize-the-number-of-target-nodes-after-connecting-trees-ii,https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii/,Maximize the Number of Target Nodes After Connecting Trees II,"There exist two  undirected  trees with  n  and  m  nodes, labeled from  [0, n - 1]  and  [0, m - 1] , respectively. You are given two 2D integer arrays  edges1  and  edges2  of lengths  n - 1  and  m - 1 , respectively, where  edges1[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the first tree and  edges2[i] = [u i , v i ]  indicates that there is an edge between nodes  u i  and  v i  in the second tree. Node  u  is  target  to node  v  if the number of edges on the path from  u  to  v  is even.  Note  that a node is  always   target  to itself. Return an array of  n  integers  answer , where  answer[i]  is the  maximum  possible number of nodes that are  target  to node  i  of the first tree if you had to connect one node from the first tree to another node in the second tree. Note  that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.   Example 1: Input:   edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]] Output:   [8,7,7,8,8] Explanation: For  i = 0 , connect node 0 from the first tree to node 0 from the second tree. For  i = 1 , connect node 1 from the first tree to node 4 from the second tree. For  i = 2 , connect node 2 from the first tree to node 7 from the second tree. For  i = 3 , connect node 3 from the first tree to node 0 from the second tree. For  i = 4 , connect node 4 from the first tree to node 4 from the second tree. Example 2: Input:   edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]] Output:   [3,6,6,6,6] Explanation: For every  i , connect node  i  of the first tree with any node of the second tree.   Constraints: 2 <= n, m <= 10 5 edges1.length == n - 1 edges2.length == m - 1 edges1[i].length == edges2[i].length == 2 edges1[i] = [a i , b i ] 0 <= a i , b i  < n edges2[i] = [u i , v i ] 0 <= u i , v i  < m The input is generated such that  edges1  and  edges2  represent valid trees.","['Tree', 'Depth-First Search', 'Breadth-First Search']",Difícil,Tree
100,same-tree,https://leetcode.com/problems/same-tree/,Same Tree,"Given the roots of two binary trees  p  and  q , write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.   Example 1: Input:  p = [1,2,3], q = [1,2,3] Output:  true Example 2: Input:  p = [1,2], q = [1,null,2] Output:  false Example 3: Input:  p = [1,2,1], q = [1,1,2] Output:  false   Constraints: The number of nodes in both trees is in the range  [0, 100] . -10 4  <= Node.val <= 10 4","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Fácil,Tree
101,symmetric-tree,https://leetcode.com/problems/symmetric-tree/,Symmetric Tree,"Given the  root  of a binary tree,  check whether it is a mirror of itself  (i.e., symmetric around its center).   Example 1: Input:  root = [1,2,2,3,4,4,3] Output:  true Example 2: Input:  root = [1,2,2,null,3,null,3] Output:  false   Constraints: The number of nodes in the tree is in the range  [1, 1000] . -100 <= Node.val <= 100   Follow up:  Could you solve it both recursively and iteratively?","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Fácil,Tree
872,leaf-similar-trees,https://leetcode.com/problems/leaf-similar-trees/,Leaf-Similar Trees,"Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a  leaf value sequence . For example, in the given tree above, the leaf value sequence is  (6, 7, 4, 9, 8) . Two binary trees are considered  leaf-similar  if their leaf value sequence is the same. Return  true  if and only if the two given trees with head nodes  root1  and  root2  are leaf-similar.   Example 1: Input:  root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] Output:  true Example 2: Input:  root1 = [1,2,3], root2 = [1,3,2] Output:  false   Constraints: The number of nodes in each tree will be in the range  [1, 200] . Both of the given trees will have values in the range  [0, 200] .","['Tree', 'Depth-First Search', 'Binary Tree']",Fácil,Tree
938,range-sum-of-bst,https://leetcode.com/problems/range-sum-of-bst/,Range Sum of BST,"Given the  root  node of a binary search tree and two integers  low  and  high , return  the sum of values of all nodes with a value in the  inclusive  range  [low, high] .   Example 1: Input:  root = [10,5,15,3,7,null,18], low = 7, high = 15 Output:  32 Explanation:  Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: Input:  root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output:  23 Explanation:  Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.   Constraints: The number of nodes in the tree is in the range  [1, 2 * 10 4 ] . 1 <= Node.val <= 10 5 1 <= low <= high <= 10 5 All  Node.val  are  unique .","['Tree', 'Depth-First Search', 'Binary Search Tree', 'Binary Tree']",Fácil,Tree
965,univalued-binary-tree,https://leetcode.com/problems/univalued-binary-tree/,Univalued Binary Tree,"A binary tree is  uni-valued  if every node in the tree has the same value. Given the  root  of a binary tree, return  true  if the given tree is  uni-valued , or  false  otherwise.   Example 1: Input:  root = [1,1,1,1,1,null,1] Output:  true Example 2: Input:  root = [2,2,2,5,2] Output:  false   Constraints: The number of nodes in the tree is in the range  [1, 100] . 0 <= Node.val < 100","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Fácil,Tree
993,cousins-in-binary-tree,https://leetcode.com/problems/cousins-in-binary-tree/,Cousins in Binary Tree,"Given the  root  of a binary tree with unique values and the values of two different nodes of the tree  x  and  y , return  true   if the nodes corresponding to the values  x  and  y  in the tree are  cousins , or  false  otherwise. Two nodes of a binary tree are  cousins  if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth  0 , and children of each depth  k  node are at the depth  k + 1 .   Example 1: Input:  root = [1,2,3,4], x = 4, y = 3 Output:  false Example 2: Input:  root = [1,2,3,null,4,null,5], x = 5, y = 4 Output:  true Example 3: Input:  root = [1,2,3,null,4], x = 2, y = 3 Output:  false   Constraints: The number of nodes in the tree is in the range  [2, 100] . 1 <= Node.val <= 100 Each node has a  unique  value. x != y x  and  y  are exist in the tree.","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Fácil,Tree
1022,sum-of-root-to-leaf-binary-numbers,https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/,Sum of Root To Leaf Binary Numbers,"You are given the  root  of a binary tree where each node has a value  0  or  1 . Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is  0 -> 1 -> 1 -> 0 -> 1 , then this could represent  01101  in binary, which is  13 . For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return  the sum of these numbers . The test cases are generated so that the answer fits in a  32-bits  integer.   Example 1: Input:  root = [1,0,1,0,1,0,1] Output:  22 Explanation:  (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 Example 2: Input:  root = [0] Output:  0   Constraints: The number of nodes in the tree is in the range  [1, 1000] . Node.val  is  0  or  1 .","['Tree', 'Depth-First Search', 'Binary Tree']",Fácil,Tree
1379,find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree,https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/,Find a Corresponding Node of a Binary Tree in a Clone of That Tree,"Given two binary trees  original  and  cloned  and given a reference to a node  target  in the original tree. The  cloned  tree is a  copy of  the  original  tree. Return  a reference to the same node  in the  cloned  tree. Note  that you are  not allowed  to change any of the two trees or the  target  node and the answer  must be  a reference to a node in the  cloned  tree.   Example 1: Input:  tree = [7,4,3,null,null,6,19], target = 3 Output:  3 Explanation:  In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree. Example 2: Input:  tree = [7], target =  7 Output:  7 Example 3: Input:  tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4 Output:  4   Constraints: The number of nodes in the  tree  is in the range  [1, 10 4 ] . The values of the nodes of the  tree  are unique. target  node is a node from the  original  tree and is not  null .   Follow up:  Could you solve the problem if repeated values on the tree are allowed?","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Fácil,Tree
102,binary-tree-level-order-traversal,https://leetcode.com/problems/binary-tree-level-order-traversal/,Binary Tree Level Order Traversal,"Given the  root  of a binary tree, return  the level order traversal of its nodes' values . (i.e., from left to right, level by level).   Example 1: Input:  root = [3,9,20,null,null,15,7] Output:  [[3],[9,20],[15,7]] Example 2: Input:  root = [1] Output:  [[1]] Example 3: Input:  root = [] Output:  []   Constraints: The number of nodes in the tree is in the range  [0, 2000] . -1000 <= Node.val <= 1000","['Tree', 'Breadth-First Search', 'Binary Tree']",Média,Tree
235,lowest-common-ancestor-of-a-binary-search-tree,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/,Lowest Common Ancestor of a Binary Search Tree,"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the  definition of LCA on Wikipedia : “The lowest common ancestor is defined between two nodes  p  and  q  as the lowest node in  T  that has both  p  and  q  as descendants (where we allow  a node to be a descendant of itself ).”   Example 1: Input:  root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output:  6 Explanation:  The LCA of nodes 2 and 8 is 6. Example 2: Input:  root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output:  2 Explanation:  The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3: Input:  root = [2,1], p = 2, q = 1 Output:  2   Constraints: The number of nodes in the tree is in the range  [2, 10 5 ] . -10 9  <= Node.val <= 10 9 All  Node.val  are  unique . p != q p  and  q  will exist in the BST.","['Tree', 'Depth-First Search', 'Binary Search Tree', 'Binary Tree']",Média,Tree
538,convert-bst-to-greater-tree,https://leetcode.com/problems/convert-bst-to-greater-tree/,Convert BST to Greater Tree,"Given the  root  of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a  binary search tree  is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys  less than  the node's key. The right subtree of a node contains only nodes with keys  greater than  the node's key. Both the left and right subtrees must also be binary search trees.   Example 1: Input:  root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output:  [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input:  root = [0,null,1] Output:  [1,null,1]   Constraints: The number of nodes in the tree is in the range  [0, 10 4 ] . -10 4  <= Node.val <= 10 4 All the values in the tree are  unique . root  is guaranteed to be a valid binary search tree.   Note:  This question is the same as 1038:  https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/","['Tree', 'Depth-First Search', 'Binary Search Tree', 'Binary Tree']",Média,Tree
662,maximum-width-of-binary-tree,https://leetcode.com/problems/maximum-width-of-binary-tree/,Maximum Width of Binary Tree,"Given the  root  of a binary tree, return  the  maximum width  of the given tree . The  maximum width  of a tree is the maximum  width  among all levels. The  width  of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is  guaranteed  that the answer will in the range of a  32-bit  signed integer.   Example 1: Input:  root = [1,3,2,5,3,null,9] Output:  4 Explanation:  The maximum width exists in the third level with length 4 (5,3,null,9). Example 2: Input:  root = [1,3,2,5,null,null,9,6,null,7] Output:  7 Explanation:  The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). Example 3: Input:  root = [1,3,2,5] Output:  2 Explanation:  The maximum width exists in the second level with length 2 (3,2).   Constraints: The number of nodes in the tree is in the range  [1, 3000] . -100 <= Node.val <= 100","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Média,Tree
669,trim-a-binary-search-tree,https://leetcode.com/problems/trim-a-binary-search-tree/,Trim a Binary Search Tree,"Given the  root  of a binary search tree and the lowest and highest boundaries as  low  and  high , trim the tree so that all its elements lies in  [low, high] . Trimming the tree should  not  change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a  unique answer . Return  the root of the trimmed binary search tree . Note that the root may change depending on the given bounds.   Example 1: Input:  root = [1,0,2], low = 1, high = 2 Output:  [1,null,2] Example 2: Input:  root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output:  [3,2,null,1]   Constraints: The number of nodes in the tree is in the range  [1, 10 4 ] . 0 <= Node.val <= 10 4 The value of each node in the tree is  unique . root  is guaranteed to be a valid binary search tree. 0 <= low <= high <= 10 4","['Tree', 'Depth-First Search', 'Binary Search Tree', 'Binary Tree']",Média,Tree
687,longest-univalue-path,https://leetcode.com/problems/longest-univalue-path/,Longest Univalue Path,"Given the  root  of a binary tree, return  the length of the longest path, where each node in the path has the same value . This path may or may not pass through the root. The length of the path  between two nodes is represented by the number of edges between them.   Example 1: Input:  root = [5,4,5,1,1,null,5] Output:  2 Explanation:  The shown image shows that the longest path of the same value (i.e. 5). Example 2: Input:  root = [1,4,5,4,4,null,5] Output:  2 Explanation:  The shown image shows that the longest path of the same value (i.e. 4).   Constraints: The number of nodes in the tree is in the range  [0, 10 4 ] . -1000 <= Node.val <= 1000 The depth of the tree will not exceed  1000 .","['Tree', 'Depth-First Search', 'Binary Tree']",Média,Tree
1305,all-elements-in-two-binary-search-trees,https://leetcode.com/problems/all-elements-in-two-binary-search-trees/,All Elements in Two Binary Search Trees,"Given two binary search trees  root1  and  root2 , return  a list containing all the integers from both trees sorted in  ascending  order .   Example 1: Input:  root1 = [2,1,4], root2 = [1,0,3] Output:  [0,1,1,2,3,4] Example 2: Input:  root1 = [1,null,8], root2 = [8,1] Output:  [1,1,8,8]   Constraints: The number of nodes in each tree is in the range  [0, 5000] . -10 5  <= Node.val <= 10 5","['Tree', 'Depth-First Search', 'Binary Search Tree', 'Sorting', 'Binary Tree']",Média,Tree
1325,delete-leaves-with-a-given-value,https://leetcode.com/problems/delete-leaves-with-a-given-value/,Delete Leaves With a Given Value,"Given a binary tree  root  and an integer  target , delete all the  leaf nodes  with value  target . Note that once you delete a leaf node with value  target ,  if its parent node becomes a leaf node and has the value  target , it should also be deleted (you need to continue doing that until you cannot).   Example 1: Input:  root = [1,2,3,2,null,2,4], target = 2 Output:  [1,null,3,null,4] Explanation:  Leaf nodes in green with value (target = 2) are removed (Picture in left).  After removing, new nodes become leaf nodes with value (target = 2) (Picture in center). Example 2: Input:  root = [1,3,3,3,2], target = 3 Output:  [1,3,null,null,2] Example 3: Input:  root = [1,2,null,2,null,2], target = 2 Output:  [1] Explanation:  Leaf nodes in green with value (target = 2) are removed at each step.   Constraints: The number of nodes in the tree is in the range  [1, 3000] . 1 <= Node.val, target <= 1000","['Tree', 'Depth-First Search', 'Binary Tree']",Média,Tree
1339,maximum-product-of-splitted-binary-tree,https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/,Maximum Product of Splitted Binary Tree,"Given the  root  of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return  the maximum product of the sums of the two subtrees . Since the answer may be too large, return it  modulo   10 9  + 7 . Note  that you need to maximize the answer before taking the mod and not after taking it.   Example 1: Input:  root = [1,2,3,4,5,6] Output:  110 Explanation:  Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Example 2: Input:  root = [1,null,2,3,4,null,null,5,6] Output:  90 Explanation:  Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)   Constraints: The number of nodes in the tree is in the range  [2, 5 * 10 4 ] . 1 <= Node.val <= 10 4","['Tree', 'Depth-First Search', 'Binary Tree']",Média,Tree
1361,validate-binary-tree-nodes,https://leetcode.com/problems/validate-binary-tree-nodes/,Validate Binary Tree Nodes,"You have  n  binary tree nodes numbered from  0  to  n - 1  where node  i  has two children  leftChild[i]  and  rightChild[i] , return  true  if and only if  all  the given nodes form  exactly one  valid binary tree. If node  i  has no left child then  leftChild[i]  will equal  -1 , similarly for the right child. Note that the nodes have no values and that we only use the node numbers in this problem.   Example 1: Input:  n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1] Output:  true Example 2: Input:  n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1] Output:  false Example 3: Input:  n = 2, leftChild = [1,0], rightChild = [-1,-1] Output:  false   Constraints: n == leftChild.length == rightChild.length 1 <= n <= 10 4 -1 <= leftChild[i], rightChild[i] <= n - 1","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Union Find', 'Graph', 'Binary Tree']",Média,Tree
1376,time-needed-to-inform-all-employees,https://leetcode.com/problems/time-needed-to-inform-all-employees/,Time Needed to Inform All Employees,"A company has  n  employees with a unique ID for each employee from  0  to  n - 1 . The head of the company is the one with  headID . Each employee has one direct manager given in the  manager  array where  manager[i]  is the direct manager of the  i-th  employee,  manager[headID] = -1 . Also, it is guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news. The  i-th  employee needs  informTime[i]  minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news). Return  the number of minutes  needed to inform all the employees about the urgent news.   Example 1: Input:  n = 1, headID = 0, manager = [-1], informTime = [0] Output:  0 Explanation:  The head of the company is the only employee in the company. Example 2: Input:  n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0] Output:  1 Explanation:  The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all. The tree structure of the employees in the company is shown.   Constraints: 1 <= n <= 10 5 0 <= headID < n manager.length == n 0 <= manager[i] < n manager[headID] == -1 informTime.length == n 0 <= informTime[i] <= 1000 informTime[i] == 0  if employee  i  has no subordinates. It is  guaranteed  that all the employees can be informed.","['Tree', 'Depth-First Search', 'Breadth-First Search']",Média,Tree
1448,count-good-nodes-in-binary-tree,https://leetcode.com/problems/count-good-nodes-in-binary-tree/,Count Good Nodes in Binary Tree,"Given a binary tree  root , a node  X  in the tree is named  good  if in the path from root to  X  there are no nodes with a value  greater than  X. Return the number of  good  nodes in the binary tree.   Example 1: Input:  root = [3,1,4,3,null,1,5] Output:  4 Explanation:  Nodes in blue are  good . Root Node (3) is always a good node. Node 4 -> (3,4) is the maximum value in the path starting from the root. Node 5 -> (3,4,5) is the maximum value in the path Node 3 -> (3,1,3) is the maximum value in the path. Example 2: Input:  root = [3,3,null,4,2] Output:  3 Explanation:  Node 2 -> (3, 3, 2) is not good, because ""3"" is higher than it. Example 3: Input:  root = [1] Output:  1 Explanation:  Root is considered as  good .   Constraints: The number of nodes in the binary tree is in the range  [1, 10^5] . Each node's value is between  [-10^4, 10^4] .","['Tree', 'Depth-First Search', 'Breadth-First Search', 'Binary Tree']",Média,Tree
1530,number-of-good-leaf-nodes-pairs,https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/,Number of Good Leaf Nodes Pairs,"You are given the  root  of a binary tree and an integer  distance . A pair of two different  leaf  nodes of a binary tree is said to be good if the length of  the shortest path  between them is less than or equal to  distance . Return  the number of good leaf node pairs  in the tree.   Example 1: Input:  root = [1,2,3,null,4], distance = 3 Output:  1 Explanation:  The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair. Example 2: Input:  root = [1,2,3,4,5,6,7], distance = 3 Output:  2 Explanation:  The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4. Example 3: Input:  root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 Output:  1 Explanation:  The only good pair is [2,5].   Constraints: The number of nodes in the  tree  is in the range  [1, 2 10 ]. 1 <= Node.val <= 100 1 <= distance <= 10","['Tree', 'Depth-First Search', 'Binary Tree']",Média,Tree
1609,even-odd-tree,https://leetcode.com/problems/even-odd-tree/,Even Odd Tree,"A binary tree is named  Even-Odd  if it meets the following conditions: The root of the binary tree is at level index  0 , its children are at level index  1 , their children are at level index  2 , etc. For every  even-indexed  level, all nodes at the level have  odd  integer values in  strictly increasing  order (from left to right). For every  odd-indexed  level, all nodes at the level have  even  integer values in  strictly decreasing  order (from left to right). Given the  root  of a binary tree,  return  true  if the binary tree is  Even-Odd , otherwise return  false .   Example 1: Input:  root = [1,10,4,3,null,7,9,12,8,6,null,null,2] Output:  true Explanation:  The node values on each level are: Level 0: [1] Level 1: [10,4] Level 2: [3,7,9] Level 3: [12,8,6,2] Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd. Example 2: Input:  root = [5,4,2,3,3,7] Output:  false Explanation:  The node values on each level are: Level 0: [5] Level 1: [4,2] Level 2: [3,3,7] Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd. Example 3: Input:  root = [5,9,1,3,5,7] Output:  false Explanation:  Node values in the level 1 should be even integers.   Constraints: The number of nodes in the tree is in the range  [1, 10 5 ] . 1 <= Node.val <= 10 6","['Tree', 'Breadth-First Search', 'Binary Tree']",Média,Tree
2583,kth-largest-sum-in-a-binary-tree,https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/,Kth Largest Sum in a Binary Tree,"You are given the  root  of a binary tree and a positive integer  k . The  level sum  in the tree is the sum of the values of the nodes that are on the  same  level. Return  the  k th   largest  level sum in the tree (not necessarily distinct) . If there are fewer than  k  levels in the tree, return  -1 . Note  that two nodes are on the same level if they have the same distance from the root.   Example 1: Input:  root = [5,8,9,2,1,3,7,4,6], k = 2 Output:  13 Explanation:  The level sums are the following: - Level 1: 5. - Level 2: 8 + 9 = 17. - Level 3: 2 + 1 + 3 + 7 = 13. - Level 4: 4 + 6 = 10. The 2 nd  largest level sum is 13. Example 2: Input:  root = [1,2,null,3], k = 1 Output:  3 Explanation:  The largest level sum is 3.   Constraints: The number of nodes in the tree is  n . 2 <= n <= 10 5 1 <= Node.val <= 10 6 1 <= k <= n","['Tree', 'Breadth-First Search', 'Sorting', 'Binary Tree']",Média,Tree
3249,count-the-number-of-good-nodes,https://leetcode.com/problems/count-the-number-of-good-nodes/,Count the Number of Good Nodes,"There is an  undirected  tree with  n  nodes labeled from  0  to  n - 1 , and rooted at node  0 . You are given a 2D integer array  edges  of length  n - 1 , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. A node is  good  if all the  subtrees  rooted at its children have the same size. Return the number of  good  nodes in the given tree. A  subtree  of  treeName  is a tree consisting of a node in  treeName  and all of its descendants.   Example 1: Input:   edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]] Output:   7 Explanation: All of the nodes of the given tree are good. Example 2: Input:   edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]] Output:   6 Explanation: There are 6 good nodes in the given tree. They are colored in the image above. Example 3: Input:   edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]] Output:   12 Explanation: All nodes except node 9 are good.   Constraints: 2 <= n <= 10 5 edges.length == n - 1 edges[i].length == 2 0 <= a i , b i  < n The input is generated such that  edges  represents a valid tree.","['Tree', 'Depth-First Search']",Média,Tree
440,k-th-smallest-in-lexicographical-order,https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/,K-th Smallest in Lexicographical Order,"Given two integers  n  and  k , return  the   k th   lexicographically smallest integer in the range   [1, n] .   Example 1: Input:  n = 13, k = 2 Output:  10 Explanation:  The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10. Example 2: Input:  n = 1, k = 1 Output:  1   Constraints: 1 <= k <= n <= 10 9",['Trie'],Difícil,Trie
1147,longest-chunked-palindrome-decomposition,https://leetcode.com/problems/longest-chunked-palindrome-decomposition/,Longest Chunked Palindrome Decomposition,"You are given a string  text . You should split it to k substrings  (subtext 1 , subtext 2 , ..., subtext k )  such that: subtext i  is a  non-empty  string. The concatenation of all the substrings is equal to  text  (i.e.,  subtext 1  + subtext 2  + ... + subtext k  == text ). subtext i  == subtext k - i + 1  for all valid values of  i  (i.e.,  1 <= i <= k ). Return the largest possible value of  k .   Example 1: Input:  text = ""ghiabcdefhelloadamhelloabcdefghi"" Output:  7 Explanation:  We can split the string on ""(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"". Example 2: Input:  text = ""merchant"" Output:  1 Explanation:  We can split the string on ""(merchant)"". Example 3: Input:  text = ""antaprezatepzapreanta"" Output:  11 Explanation:  We can split the string on ""(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)"".   Constraints: 1 <= text.length <= 1000 text  consists only of lowercase English characters.","['Two Pointers', 'String', 'Dynamic Programming', 'Greedy', 'Rolling Hash', 'Hash Function']",Difícil,Two Pointers
2193,minimum-number-of-moves-to-make-palindrome,https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/,Minimum Number of Moves to Make Palindrome,"You are given a string  s  consisting only of lowercase English letters. In one  move , you can select any two  adjacent  characters of  s  and swap them. Return  the  minimum number of moves  needed to make   s   a palindrome . Note  that the input will be generated such that  s  can always be converted to a palindrome.   Example 1: Input:  s = ""aabb"" Output:  2 Explanation: We can obtain two palindromes from s, ""abba"" and ""baab"".  - We can obtain ""abba"" from s in 2 moves: ""a ab b"" -> ""ab ab "" -> ""abba"". - We can obtain ""baab"" from s in 2 moves: ""a ab b"" -> "" ab ab"" -> ""baab"". Thus, the minimum number of moves needed to make s a palindrome is 2. Example 2: Input:  s = ""letelt"" Output:  2 Explanation: One of the palindromes we can obtain from s in 2 moves is ""lettel"". One of the ways we can obtain it is ""lete lt "" -> ""let et l"" -> ""lettel"". Other palindromes such as ""tleelt"" can also be obtained in 2 moves. It can be shown that it is not possible to obtain a palindrome in less than 2 moves.   Constraints: 1 <= s.length <= 2000 s  consists only of lowercase English letters. s  can be converted to a palindrome using a finite number of moves.","['Two Pointers', 'String', 'Greedy', 'Binary Indexed Tree']",Difícil,Two Pointers
2472,maximum-number-of-non-overlapping-palindrome-substrings,https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/,Maximum Number of Non-overlapping Palindrome Substrings,"You are given a string  s  and a  positive  integer  k . Select a set of  non-overlapping  substrings from the string  s  that satisfy the following conditions: The  length  of each substring is  at least   k . Each substring is a  palindrome . Return  the  maximum  number of substrings in an optimal selection . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""abaccdbbd"", k = 3 Output:  2 Explanation:  We can select the substrings underlined in s = "" aba cc dbbd "". Both ""aba"" and ""dbbd"" are palindromes and have a length of at least k = 3. It can be shown that we cannot find a selection with more than two valid substrings. Example 2: Input:  s = ""adbcda"", k = 2 Output:  0 Explanation:  There is no palindrome substring of length at least 2 in the string.   Constraints: 1 <= k <= s.length <= 2000 s  consists of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming', 'Greedy']",Difícil,Two Pointers
2565,subsequence-with-the-minimum-score,https://leetcode.com/problems/subsequence-with-the-minimum-score/,Subsequence With the Minimum Score,"You are given two strings  s  and  t . You are allowed to remove any number of characters from the string  t . The score of the string is  0  if no characters are removed from the string  t , otherwise: Let  left  be the minimum index among all removed characters. Let  right  be the maximum index among all removed characters. Then the score of the string is  right - left + 1 . Return  the minimum possible score to make  t  a subsequence of  s . A  subsequence  of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,  ""ace""  is a subsequence of  "" a b c d e ""  while  ""aec""  is not).   Example 1: Input:  s = ""abacaba"", t = ""bzaa"" Output:  1 Explanation:  In this example, we remove the character ""z"" at index 1 (0-indexed). The string t becomes ""baa"" which is a subsequence of the string ""abacaba"" and the score is 1 - 1 + 1 = 1. It can be proven that 1 is the minimum score that we can achieve. Example 2: Input:  s = ""cde"", t = ""xyz"" Output:  3 Explanation:  In this example, we remove characters ""x"", ""y"" and ""z"" at indices 0, 1, and 2 (0-indexed). The string t becomes """" which is a subsequence of the string ""cde"" and the score is 2 - 0 + 1 = 3. It can be proven that 3 is the minimum score that we can achieve.   Constraints: 1 <= s.length, t.length <= 10 5 s  and  t  consist of only lowercase English letters.","['Two Pointers', 'String', 'Binary Search']",Difícil,Two Pointers
2911,minimum-changes-to-make-k-semi-palindromes,https://leetcode.com/problems/minimum-changes-to-make-k-semi-palindromes/,Minimum Changes to Make K Semi-palindromes,"Given a string  s  and an integer  k , partition  s  into  k   substrings  such that the letter changes needed to make each substring a  semi-palindrome  are minimized. Return the  minimum  number of letter changes  required . A  semi-palindrome  is a special type of string that can be divided into  palindromes  based on a repeating pattern. To check if a string is a semi-palindrome:​ Choose a positive divisor  d  of the string's length.  d  can range from  1  up to, but not including, the string's length. For a string of length  1 , it does not have a valid divisor as per this definition, since the only divisor is its length, which is not allowed. For a given divisor  d , divide the string into groups where each group contains characters from the string that follow a repeating pattern of length  d . Specifically, the first group consists of characters at positions  1 ,  1 + d ,  1 + 2d , and so on; the second group includes characters at positions  2 ,  2 + d ,  2 + 2d , etc. The string is considered a semi-palindrome if each of these groups forms a palindrome. Consider the string  ""abcabc"" : The length of  ""abcabc""  is  6 . Valid divisors are  1 ,  2 , and  3 . For  d = 1 : The entire string  ""abcabc""  forms one group. Not a palindrome. For  d = 2 : 	 Group 1 (positions  1, 3, 5 ):  ""acb"" Group 2 (positions  2, 4, 6 ):  ""bac"" Neither group forms a palindrome. For  d = 3 : 	 Group 1 (positions  1, 4 ):  ""aa"" Group 2 (positions  2, 5 ):  ""bb"" Group 3 (positions  3, 6 ):  ""cc"" All groups form palindromes. Therefore,  ""abcabc""  is a semi-palindrome.   Example 1:  Input:     s = ""abcac"", k = 2  Output:     1  Explanation:   Divide  s  into  ""ab""  and  ""cac"" .  ""cac""  is already semi-palindrome. Change  ""ab""  to  ""aa"" , it becomes semi-palindrome with  d = 1 . Example 2:  Input:     s = ""abcdef"", k = 2  Output:     2  Explanation:   Divide  s  into substrings  ""abc""  and  ""def"" . Each needs one change to become semi-palindrome. Example 3:  Input:     s = ""aabbaa"", k = 3  Output:     0  Explanation:   Divide  s  into substrings  ""aa"" ,  ""bb""  and  ""aa"" . All are already semi-palindromes.   Constraints: 2 <= s.length <= 200 1 <= k <= s.length / 2 s  contains only lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming']",Difícil,Two Pointers
3008,find-beautiful-indices-in-the-given-array-ii,https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/,Find Beautiful Indices in the Given Array II,"You are given a  0-indexed  string  s , a string  a , a string  b , and an integer  k . An index  i  is  beautiful  if: 0 <= i <= s.length - a.length s[i..(i + a.length - 1)] == a There exists an index  j  such that: 	 0 <= j <= s.length - b.length s[j..(j + b.length - 1)] == b |j - i| <= k Return  the array that contains beautiful indices in  sorted order from smallest to largest .   Example 1: Input:  s = ""isawsquirrelnearmysquirrelhouseohmy"", a = ""my"", b = ""squirrel"", k = 15 Output:  [16,33] Explanation:  There are 2 beautiful indices: [16,33]. - The index 16 is beautiful as s[16..17] == ""my"" and there exists an index 4 with s[4..11] == ""squirrel"" and |16 - 4| <= 15. - The index 33 is beautiful as s[33..34] == ""my"" and there exists an index 18 with s[18..25] == ""squirrel"" and |33 - 18| <= 15. Thus we return [16,33] as the result. Example 2: Input:  s = ""abcd"", a = ""a"", b = ""a"", k = 4 Output:  [0] Explanation:  There is 1 beautiful index: [0]. - The index 0 is beautiful as s[0..0] == ""a"" and there exists an index 0 with s[0..0] == ""a"" and |0 - 0| <= 4. Thus we return [0] as the result.   Constraints: 1 <= k <= s.length <= 5 * 10 5 1 <= a.length, b.length <= 5 * 10 5 s ,  a , and  b  contain only lowercase English letters.","['Two Pointers', 'String', 'Binary Search', 'Rolling Hash', 'String Matching', 'Hash Function']",Difícil,Two Pointers
3455,shortest-matching-substring,https://leetcode.com/problems/shortest-matching-substring/,Shortest Matching Substring,"You are given a string  s  and a pattern string  p , where  p  contains  exactly two   '*'  characters. The  '*'  in  p  matches any sequence of zero or more characters. Return the length of the  shortest   substring  in  s  that matches  p . If there is no such substring, return -1. Note:  The empty substring is considered valid.   Example 1: Input:   s = ""abaacbaecebce"", p = ""ba*c*ce"" Output:   8 Explanation: The shortest matching substring of  p  in  s  is  "" ba e c eb ce "" . Example 2: Input:   s = ""baccbaadbc"", p = ""cc*baa*adb"" Output:   -1 Explanation: There is no matching substring in  s . Example 3: Input:   s = ""a"", p = ""**"" Output:   0 Explanation: The empty substring is the shortest matching substring. Example 4: Input:   s = ""madlogic"", p = ""*adlogi*"" Output:   6 Explanation: The shortest matching substring of  p  in  s  is  "" adlogi "" .   Constraints: 1 <= s.length <= 10 5 2 <= p.length <= 10 5 s  contains only lowercase English letters. p  contains only lowercase English letters and exactly two  '*' .","['Two Pointers', 'String', 'Binary Search', 'String Matching']",Difícil,Two Pointers
125,valid-palindrome,https://leetcode.com/problems/valid-palindrome/,Valid Palindrome,"A phrase is a  palindrome  if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string  s , return  true  if it is a  palindrome , or  false  otherwise .   Example 1: Input:  s = ""A man, a plan, a canal: Panama"" Output:  true Explanation:  ""amanaplanacanalpanama"" is a palindrome. Example 2: Input:  s = ""race a car"" Output:  false Explanation:  ""raceacar"" is not a palindrome. Example 3: Input:  s = "" "" Output:  true Explanation:  s is an empty string """" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome.   Constraints: 1 <= s.length <= 2 * 10 5 s  consists only of printable ASCII characters.","['Two Pointers', 'String']",Fácil,Two Pointers
345,reverse-vowels-of-a-string,https://leetcode.com/problems/reverse-vowels-of-a-string/,Reverse Vowels of a String,"Given a string  s , reverse only all the vowels in the string and return it. The vowels are  'a' ,  'e' ,  'i' ,  'o' , and  'u' , and they can appear in both lower and upper cases, more than once.   Example 1: Input:   s = ""IceCreAm"" Output:   ""AceCreIm"" Explanation: The vowels in  s  are  ['I', 'e', 'e', 'A'] . On reversing the vowels, s becomes  ""AceCreIm"" . Example 2: Input:   s = ""leetcode"" Output:   ""leotcede""   Constraints: 1 <= s.length <= 3 * 10 5 s  consist of  printable ASCII  characters.","['Two Pointers', 'String']",Fácil,Two Pointers
392,is-subsequence,https://leetcode.com/problems/is-subsequence/,Is Subsequence,"Given two strings  s  and  t , return  true  if  s  is a  subsequence  of  t , or  false  otherwise . A  subsequence  of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,  ""ace""  is a subsequence of  "" a b c d e ""  while  ""aec""  is not).   Example 1: Input:  s = ""abc"", t = ""ahbgdc"" Output:  true Example 2: Input:  s = ""axc"", t = ""ahbgdc"" Output:  false   Constraints: 0 <= s.length <= 100 0 <= t.length <= 10 4 s  and  t  consist only of lowercase English letters.   Follow up:  Suppose there are lots of incoming  s , say  s 1 , s 2 , ..., s k  where  k >= 10 9 , and you want to check one by one to see if  t  has its subsequence. In this scenario, how would you change your code?","['Two Pointers', 'String', 'Dynamic Programming']",Fácil,Two Pointers
541,reverse-string-ii,https://leetcode.com/problems/reverse-string-ii/,Reverse String II,"Given a string  s  and an integer  k , reverse the first  k  characters for every  2k  characters counting from the start of the string. If there are fewer than  k  characters left, reverse all of them. If there are less than  2k  but greater than or equal to  k  characters, then reverse the first  k  characters and leave the other as original.   Example 1: Input:  s = ""abcdefg"", k = 2 Output:  ""bacdfeg"" Example 2: Input:  s = ""abcd"", k = 2 Output:  ""bacd""   Constraints: 1 <= s.length <= 10 4 s  consists of only lowercase English letters. 1 <= k <= 10 4","['Two Pointers', 'String']",Fácil,Two Pointers
557,reverse-words-in-a-string-iii,https://leetcode.com/problems/reverse-words-in-a-string-iii/,Reverse Words in a String III,"Given a string  s , reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.   Example 1: Input:  s = ""Let's take LeetCode contest"" Output:  ""s'teL ekat edoCteeL tsetnoc"" Example 2: Input:  s = ""Mr Ding"" Output:  ""rM gniD""   Constraints: 1 <= s.length <= 5 * 10 4 s  contains printable  ASCII  characters. s  does not contain any leading or trailing spaces. There is  at least one  word in  s . All the words in  s  are separated by a single space.","['Two Pointers', 'String']",Fácil,Two Pointers
696,count-binary-substrings,https://leetcode.com/problems/count-binary-substrings/,Count Binary Substrings,"Given a binary string  s , return the number of non-empty substrings that have the same number of  0 's and  1 's, and all the  0 's and all the  1 's in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.   Example 1: Input:  s = ""00110011"" Output:  6 Explanation:  There are 6 substrings that have equal number of consecutive 1's and 0's: ""0011"", ""01"", ""1100"", ""10"", ""0011"", and ""01"". Notice that some of these substrings repeat and are counted the number of times they occur. Also, ""00110011"" is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: Input:  s = ""10101"" Output:  4 Explanation:  There are 4 substrings: ""10"", ""01"", ""10"", ""01"" that have equal number of consecutive 1's and 0's.   Constraints: 1 <= s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['Two Pointers', 'String']",Fácil,Two Pointers
844,backspace-string-compare,https://leetcode.com/problems/backspace-string-compare/,Backspace String Compare,"Given two strings  s  and  t , return  true   if they are equal when both are typed into empty text editors .  '#'  means a backspace character. Note that after backspacing an empty text, the text will continue empty.   Example 1: Input:  s = ""ab#c"", t = ""ad#c"" Output:  true Explanation:  Both s and t become ""ac"". Example 2: Input:  s = ""ab##"", t = ""c#d#"" Output:  true Explanation:  Both s and t become """". Example 3: Input:  s = ""a#c"", t = ""b"" Output:  false Explanation:  s becomes ""c"" while t becomes ""b"".   Constraints: 1 <= s.length, t.length <= 200 s  and  t  only contain lowercase letters and  '#'  characters.   Follow up:  Can you solve it in  O(n)  time and  O(1)  space?","['Two Pointers', 'String', 'Stack', 'Simulation']",Fácil,Two Pointers
1332,remove-palindromic-subsequences,https://leetcode.com/problems/remove-palindromic-subsequences/,Remove Palindromic Subsequences,"You are given a string  s  consisting  only  of letters  'a'  and  'b' . In a single step you can remove one  palindromic subsequence  from  s . Return  the  minimum  number of steps to make the given string empty . A string is a  subsequence  of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does  not  necessarily need to be contiguous. A string is called  palindrome  if is one that reads the same backward as well as forward.   Example 1: Input:  s = ""ababa"" Output:  1 Explanation:  s is already a palindrome, so its entirety can be removed in a single step. Example 2: Input:  s = ""abb"" Output:  2 Explanation:  "" a bb"" -> "" bb "" -> """".  Remove palindromic subsequence ""a"" then ""bb"". Example 3: Input:  s = ""baabb"" Output:  2 Explanation:  "" baa b b "" -> "" b "" -> """".  Remove palindromic subsequence ""baab"" then ""b"".   Constraints: 1 <= s.length <= 1000 s[i]  is either  'a'  or  'b' .","['Two Pointers', 'String']",Fácil,Two Pointers
151,reverse-words-in-a-string,https://leetcode.com/problems/reverse-words-in-a-string/,Reverse Words in a String,"Given an input string  s , reverse the order of the  words . A  word  is defined as a sequence of non-space characters. The  words  in  s  will be separated by at least one space. Return  a string of the words in reverse order concatenated by a single space. Note  that  s  may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.   Example 1: Input:  s = ""the sky is blue"" Output:  ""blue is sky the"" Example 2: Input:  s = ""  hello world  "" Output:  ""world hello"" Explanation:  Your reversed string should not contain leading or trailing spaces. Example 3: Input:  s = ""a good   example"" Output:  ""example good a"" Explanation:  You need to reduce multiple spaces between two words to a single space in the reversed string.   Constraints: 1 <= s.length <= 10 4 s  contains English letters (upper-case and lower-case), digits, and spaces  ' ' . There is  at least one  word in  s .   Follow-up:  If the string data type is mutable in your language, can you solve it  in-place  with  O(1)  extra space?","['Two Pointers', 'String']",Média,Two Pointers
165,compare-version-numbers,https://leetcode.com/problems/compare-version-numbers/,Compare Version Numbers,"Given two  version strings ,  version1  and  version2 , compare them. A version string consists of  revisions  separated by dots  '.' . The  value of the revision  is its  integer conversion  ignoring leading zeros. To compare version strings, compare their revision values in  left-to-right order . If one of the version strings has fewer revisions, treat the missing revision values as  0 . Return the following: If  version1 < version2 , return -1. If  version1 > version2 , return 1. Otherwise, return 0.   Example 1: Input:   version1 = ""1.2"", version2 = ""1.10"" Output:   -1 Explanation: version1's second revision is ""2"" and version2's second revision is ""10"": 2 < 10, so version1 < version2. Example 2: Input:   version1 = ""1.01"", version2 = ""1.001"" Output:   0 Explanation: Ignoring leading zeroes, both ""01"" and ""001"" represent the same integer ""1"". Example 3: Input:   version1 = ""1.0"", version2 = ""1.0.0.0"" Output:   0 Explanation: version1 has less revisions, which means every missing revision are treated as ""0"".   Constraints: 1 <= version1.length, version2.length <= 500 version1  and  version2  only contain digits and  '.' . version1  and  version2   are valid version numbers . All the given revisions in  version1  and  version2  can be stored in a  32-bit integer .","['Two Pointers', 'String']",Média,Two Pointers
443,string-compression,https://leetcode.com/problems/string-compression/,String Compression,"Given an array of characters  chars , compress it using the following algorithm: Begin with an empty string  s . For each group of  consecutive repeating characters  in  chars : If the group's length is  1 , append the character to  s . Otherwise, append the character followed by the group's length. The compressed string  s   should not be returned separately , but instead, be stored  in the input character array  chars . Note that group lengths that are  10  or longer will be split into multiple characters in  chars . After you are done  modifying the input array,  return  the new length of the array . You must write an algorithm that uses only constant extra space.   Example 1: Input:  chars = [""a"",""a"",""b"",""b"",""c"",""c"",""c""] Output:  Return 6, and the first 6 characters of the input array should be: [""a"",""2"",""b"",""2"",""c"",""3""] Explanation:  The groups are ""aa"", ""bb"", and ""ccc"". This compresses to ""a2b2c3"". Example 2: Input:  chars = [""a""] Output:  Return 1, and the first character of the input array should be: [""a""] Explanation:  The only group is ""a"", which remains uncompressed since it's a single character. Example 3: Input:  chars = [""a"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b""] Output:  Return 4, and the first 4 characters of the input array should be: [""a"",""b"",""1"",""2""]. Explanation:  The groups are ""a"" and ""bbbbbbbbbbbb"". This compresses to ""ab12"".   Constraints: 1 <= chars.length <= 2000 chars[i]  is a lowercase English letter, uppercase English letter, digit, or symbol.","['Two Pointers', 'String']",Média,Two Pointers
481,magical-string,https://leetcode.com/problems/magical-string/,Magical String,"A magical string  s  consists of only  '1'  and  '2'  and obeys the following rules: The string s is magical because concatenating the number of contiguous occurrences of characters  '1'  and  '2'  generates the string  s  itself. The first few elements of  s  is  s = ""1221121221221121122……"" . If we group the consecutive  1 's and  2 's in  s , it will be  ""1 22 11 2 1 22 1 22 11 2 11 22 ......""  and the occurrences of  1 's or  2 's in each group are  ""1 2 2 1 1 2 1 2 2 1 2 2 ......"" . You can see that the occurrence sequence is  s  itself. Given an integer  n , return the number of  1 's in the first  n  number in the magical string  s .   Example 1: Input:  n = 6 Output:  3 Explanation:  The first 6 elements of magical string s is ""122112"" and it contains three 1's, so return 3. Example 2: Input:  n = 1 Output:  1   Constraints: 1 <= n <= 10 5","['Two Pointers', 'String']",Média,Two Pointers
777,swap-adjacent-in-lr-string,https://leetcode.com/problems/swap-adjacent-in-lr-string/,Swap Adjacent in LR String,"In a string composed of  'L' ,  'R' , and  'X'  characters, like  ""RXXLRXRXL"" , a move consists of either replacing one occurrence of  ""XL""  with  ""LX"" , or replacing one occurrence of  ""RX""  with  ""XR"" . Given the starting string  start  and the ending string  result , return  True  if and only if there exists a sequence of moves to transform  start  to  result .   Example 1: Input:  start = ""RXXLRXRXL"", result = ""XRLXXRRLX"" Output:  true Explanation:  We can transform start to result following these steps: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX Example 2: Input:  start = ""X"", result = ""L"" Output:  false   Constraints: 1 <= start.length <= 10 4 start.length == result.length Both  start  and  result  will only consist of characters in  'L' ,  'R' , and  'X' .","['Two Pointers', 'String']",Média,Two Pointers
838,push-dominoes,https://leetcode.com/problems/push-dominoes/,Push Dominoes,"There are  n  dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. You are given a string  dominoes  representing the initial state where: dominoes[i] = 'L' , if the  i th  domino has been pushed to the left, dominoes[i] = 'R' , if the  i th  domino has been pushed to the right, and dominoes[i] = '.' , if the  i th  domino has not been pushed. Return  a string representing the final state .   Example 1: Input:  dominoes = ""RR.L"" Output:  ""RR.L"" Explanation:  The first domino expends no additional force on the second domino. Example 2: Input:  dominoes = "".L.R...LR..L.."" Output:  ""LL.RR.LLRRLL..""   Constraints: n == dominoes.length 1 <= n <= 10 5 dominoes[i]  is either  'L' ,  'R' , or  '.' .","['Two Pointers', 'String', 'Dynamic Programming']",Média,Two Pointers
1616,split-two-strings-to-make-palindrome,https://leetcode.com/problems/split-two-strings-to-make-palindrome/,Split Two Strings to Make Palindrome,"You are given two strings  a  and  b  of the same length. Choose an index and split both strings  at the same index , splitting  a  into two strings:  a prefix  and  a suffix  where  a = a prefix  + a suffix , and splitting  b  into two strings:  b prefix  and  b suffix  where  b = b prefix  + b suffix . Check if  a prefix  + b suffix  or  b prefix  + a suffix  forms a palindrome. When you split a string  s  into  s prefix  and  s suffix , either  s suffix  or  s prefix  is allowed to be empty. For example, if  s = ""abc"" , then  """" + ""abc"" ,  ""a"" + ""bc"" ,  ""ab"" + ""c""  , and  ""abc"" + """"  are valid splits. Return  true  if it is possible to form  a palindrome string, otherwise return  false . Notice  that  x + y  denotes the concatenation of strings  x  and  y .   Example 1: Input:  a = ""x"", b = ""y"" Output:  true Explaination:  If either a or b are palindromes the answer is true since you can split in the following way: a prefix  = """", a suffix  = ""x"" b prefix  = """", b suffix  = ""y"" Then, a prefix  + b suffix  = """" + ""y"" = ""y"", which is a palindrome. Example 2: Input:  a = ""xbdef"", b = ""xecab"" Output:  false Example 3: Input:  a = ""ulacfd"", b = ""jizalu"" Output:  true Explaination:  Split them at index 3: a prefix  = ""ula"", a suffix  = ""cfd"" b prefix  = ""jiz"", b suffix  = ""alu"" Then, a prefix  + b suffix  = ""ula"" + ""alu"" = ""ulaalu"", which is a palindrome.   Constraints: 1 <= a.length, b.length <= 10 5 a.length == b.length a  and  b  consist of lowercase English letters","['Two Pointers', 'String']",Média,Two Pointers
1750,minimum-length-of-string-after-deleting-similar-ends,https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/,Minimum Length of String After Deleting Similar Ends,"Given a string  s  consisting only of characters  'a' ,  'b' , and  'c' . You are asked to apply the following algorithm on the string any number of times: Pick a  non-empty  prefix from the string  s  where all the characters in the prefix are equal. Pick a  non-empty  suffix from the string  s  where all the characters in this suffix are equal. The prefix and the suffix should not intersect at any index. The characters from the prefix and suffix must be the same. Delete both the prefix and the suffix. Return  the  minimum length  of  s   after performing the above operation any number of times (possibly zero times) .   Example 1: Input:  s = ""ca"" Output:  2 Explanation:  You can't remove any characters, so the string stays as is. Example 2: Input:  s = ""cabaabac"" Output:  0 Explanation:  An optimal sequence of operations is: - Take prefix = ""c"" and suffix = ""c"" and remove them, s = ""abaaba"". - Take prefix = ""a"" and suffix = ""a"" and remove them, s = ""baab"". - Take prefix = ""b"" and suffix = ""b"" and remove them, s = ""aa"". - Take prefix = ""a"" and suffix = ""a"" and remove them, s = """". Example 3: Input:  s = ""aabccabba"" Output:  3 Explanation:  An optimal sequence of operations is: - Take prefix = ""aa"" and suffix = ""a"" and remove them, s = ""bccabb"". - Take prefix = ""b"" and suffix = ""bb"" and remove them, s = ""cca"".   Constraints: 1 <= s.length <= 10 5 s  only consists of characters  'a' ,  'b' , and  'c' .","['Two Pointers', 'String']",Média,Two Pointers
1850,minimum-adjacent-swaps-to-reach-the-kth-smallest-number,https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/,Minimum Adjacent Swaps to Reach the Kth Smallest Number,"You are given a string  num , representing a large integer, and an integer  k . We call some integer  wonderful  if it is a  permutation  of the digits in  num  and is  greater in value  than  num . There can be many wonderful integers. However, we only care about the  smallest-valued  ones. For example, when  num = ""5489355142"" : 	 The 1 st  smallest wonderful integer is  ""5489355214"" . The 2 nd  smallest wonderful integer is  ""5489355241"" . The 3 rd  smallest wonderful integer is  ""5489355412"" . The 4 th  smallest wonderful integer is  ""5489355421"" . Return  the  minimum number of adjacent digit swaps  that needs to be applied to  num  to reach the  k th  smallest wonderful  integer . The tests are generated in such a way that  k th  smallest wonderful integer exists.   Example 1: Input:  num = ""5489355142"", k = 4 Output:  2 Explanation:  The 4 th  smallest wonderful number is ""5489355421"". To get this number: - Swap index 7 with index 8: ""5489355 14 2"" -> ""5489355 41 2"" - Swap index 8 with index 9: ""54893554 12 "" -> ""54893554 21 "" Example 2: Input:  num = ""11112"", k = 4 Output:  4 Explanation:  The 4 th  smallest wonderful number is ""21111"". To get this number: - Swap index 3 with index 4: ""111 12 "" -> ""111 21 "" - Swap index 2 with index 3: ""11 12 1"" -> ""11 21 1"" - Swap index 1 with index 2: ""1 12 11"" -> ""1 21 11"" - Swap index 0 with index 1: "" 12 111"" -> "" 21 111"" Example 3: Input:  num = ""00123"", k = 1 Output:  1 Explanation:  The 1 st  smallest wonderful number is ""00132"". To get this number: - Swap index 3 with index 4: ""001 23 "" -> ""001 32 ""   Constraints: 2 <= num.length <= 1000 1 <= k <= 1000 num  only consists of digits.","['Two Pointers', 'String', 'Greedy']",Média,Two Pointers
1963,minimum-number-of-swaps-to-make-the-string-balanced,https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/,Minimum Number of Swaps to Make the String Balanced,"You are given a  0-indexed  string  s  of  even  length  n . The string consists of  exactly   n / 2  opening brackets  '['  and  n / 2  closing brackets  ']' . A string is called  balanced  if and only if: It is the empty string, or It can be written as  AB , where both  A  and  B  are  balanced  strings, or It can be written as  [C] , where  C  is a  balanced  string. You may swap the brackets at  any  two indices  any  number of times. Return  the  minimum  number of swaps to make  s   balanced .   Example 1: Input:  s = ""][]["" Output:  1 Explanation:  You can make the string balanced by swapping index 0 with index 3. The resulting string is ""[[]]"". Example 2: Input:  s = ""]]][[["" Output:  2 Explanation:  You can do the following to make the string balanced: - Swap index 0 with index 4. s = ""[]][]["". - Swap index 1 with index 5. s = ""[[][]]"". The resulting string is ""[[][]]"". Example 3: Input:  s = ""[]"" Output:  0 Explanation:  The string is already balanced.   Constraints: n == s.length 2 <= n <= 10 6 n  is even. s[i]  is either  '['  or  ']' . The number of opening brackets  '['  equals  n / 2 , and the number of closing brackets  ']'  equals  n / 2 .","['Two Pointers', 'String', 'Stack', 'Greedy']",Média,Two Pointers
2825,make-string-a-subsequence-using-cyclic-increments,https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/,Make String a Subsequence Using Cyclic Increments,"You are given two  0-indexed  strings  str1  and  str2 . In an operation, you select a  set  of indices in  str1 , and for each index  i  in the set, increment  str1[i]  to the next character  cyclically . That is  'a'  becomes  'b' ,  'b'  becomes  'c' , and so on, and  'z'  becomes  'a' . Return  true   if it is possible to make  str2   a subsequence of  str1   by performing the operation  at most once ,  and   false   otherwise . Note:  A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.   Example 1: Input:  str1 = ""abc"", str2 = ""ad"" Output:  true Explanation:  Select index 2 in str1. Increment str1[2] to become 'd'.  Hence, str1 becomes ""abd"" and str2 is now a subsequence. Therefore, true is returned. Example 2: Input:  str1 = ""zc"", str2 = ""ad"" Output:  true Explanation:  Select indices 0 and 1 in str1.  Increment str1[0] to become 'a'.  Increment str1[1] to become 'd'.  Hence, str1 becomes ""ad"" and str2 is now a subsequence. Therefore, true is returned. Example 3: Input:  str1 = ""ab"", str2 = ""d"" Output:  false Explanation:  In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once.  Therefore, false is returned.   Constraints: 1 <= str1.length <= 10 5 1 <= str2.length <= 10 5 str1  and  str2  consist of only lowercase English letters.","['Two Pointers', 'String']",Média,Two Pointers
2938,separate-black-and-white-balls,https://leetcode.com/problems/separate-black-and-white-balls/,Separate Black and White Balls,"There are  n  balls on a table, each ball has a color black or white. You are given a  0-indexed  binary string  s  of length  n , where  1  and  0  represent black and white balls, respectively. In each step, you can choose two adjacent balls and swap them. Return  the  minimum  number of steps to group all the black balls to the right and all the white balls to the left .   Example 1: Input:  s = ""101"" Output:  1 Explanation:  We can group all the black balls to the right in the following way: - Swap s[0] and s[1], s = ""011"". Initially, 1s are not grouped together, requiring at least 1 step to group them to the right. Example 2: Input:  s = ""100"" Output:  2 Explanation:  We can group all the black balls to the right in the following way: - Swap s[0] and s[1], s = ""010"". - Swap s[1] and s[2], s = ""001"". It can be proven that the minimum number of steps needed is 2. Example 3: Input:  s = ""0111"" Output:  0 Explanation:  All the black balls are already grouped to the right.   Constraints: 1 <= n == s.length <= 10 5 s[i]  is either  '0'  or  '1' .","['Two Pointers', 'String', 'Greedy']",Média,Two Pointers
3006,find-beautiful-indices-in-the-given-array-i,https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/,Find Beautiful Indices in the Given Array I,"You are given a  0-indexed  string  s , a string  a , a string  b , and an integer  k . An index  i  is  beautiful  if: 0 <= i <= s.length - a.length s[i..(i + a.length - 1)] == a There exists an index  j  such that: 	 0 <= j <= s.length - b.length s[j..(j + b.length - 1)] == b |j - i| <= k Return  the array that contains beautiful indices in  sorted order from smallest to largest .   Example 1: Input:  s = ""isawsquirrelnearmysquirrelhouseohmy"", a = ""my"", b = ""squirrel"", k = 15 Output:  [16,33] Explanation:  There are 2 beautiful indices: [16,33]. - The index 16 is beautiful as s[16..17] == ""my"" and there exists an index 4 with s[4..11] == ""squirrel"" and |16 - 4| <= 15. - The index 33 is beautiful as s[33..34] == ""my"" and there exists an index 18 with s[18..25] == ""squirrel"" and |33 - 18| <= 15. Thus we return [16,33] as the result. Example 2: Input:  s = ""abcd"", a = ""a"", b = ""a"", k = 4 Output:  [0] Explanation:  There is 1 beautiful index: [0]. - The index 0 is beautiful as s[0..0] == ""a"" and there exists an index 0 with s[0..0] == ""a"" and |0 - 0| <= 4. Thus we return [0] as the result.   Constraints: 1 <= k <= s.length <= 10 5 1 <= a.length, b.length <= 10 s ,  a , and  b  contain only lowercase English letters.","['Two Pointers', 'String', 'Binary Search', 'Rolling Hash', 'String Matching', 'Hash Function']",Média,Two Pointers
3302,find-the-lexicographically-smallest-valid-sequence,https://leetcode.com/problems/find-the-lexicographically-smallest-valid-sequence/,Find the Lexicographically Smallest Valid Sequence,"You are given two strings  word1  and  word2 . A string  x  is called  almost equal  to  y  if you can change  at most  one character in  x  to make it  identical  to  y . A sequence of indices  seq  is called  valid  if: The indices are sorted in  ascending  order. Concatenating  the characters at these indices in  word1  in  the same  order results in a string that is  almost equal  to  word2 . Return an array of size  word2.length  representing the  lexicographically smallest   valid  sequence of indices. If no such sequence of indices exists, return an  empty  array. Note  that the answer must represent the  lexicographically smallest array ,  not  the corresponding string formed by those indices.   Example 1: Input:   word1 = ""vbcca"", word2 = ""abc"" Output:   [0,1,2] Explanation: The lexicographically smallest valid sequence of indices is  [0, 1, 2] : Change  word1[0]  to  'a' . word1[1]  is already  'b' . word1[2]  is already  'c' . Example 2: Input:   word1 = ""bacdc"", word2 = ""abc"" Output:   [1,2,4] Explanation: The lexicographically smallest valid sequence of indices is  [1, 2, 4] : word1[1]  is already  'a' . Change  word1[2]  to  'b' . word1[4]  is already  'c' . Example 3: Input:   word1 = ""aaaaaa"", word2 = ""aaabc"" Output:   [] Explanation: There is no valid sequence of indices. Example 4: Input:   word1 = ""abc"", word2 = ""ab"" Output:   [0,1]   Constraints: 1 <= word2.length < word1.length <= 3 * 10 5 word1  and  word2  consist only of lowercase English letters.","['Two Pointers', 'String', 'Dynamic Programming', 'Greedy']",Média,Two Pointers
3403,find-the-lexicographically-largest-string-from-the-box-i,https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i/,Find the Lexicographically Largest String From the Box I,"You are given a string  word , and an integer  numFriends . Alice is organizing a game for her  numFriends  friends. There are multiple rounds in the game, where in each round: word  is split into  numFriends   non-empty  strings, such that no previous round has had the  exact  same split. All the split words are put into a box. Find the  lexicographically largest  string from the box after all the rounds are finished.   Example 1: Input:   word = ""dbca"", numFriends = 2 Output:   ""dbc"" Explanation:   All possible splits are: ""d""  and  ""bca"" . ""db""  and  ""ca"" . ""dbc""  and  ""a"" . Example 2: Input:   word = ""gggg"", numFriends = 4 Output:   ""g"" Explanation:   The only possible split is:  ""g"" ,  ""g"" ,  ""g"" , and  ""g"" .   Constraints: 1 <= word.length <= 5 * 10 3 word  consists only of lowercase English letters. 1 <= numFriends <= word.length","['Two Pointers', 'String', 'Enumeration']",Média,Two Pointers
1489,find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/,Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree,"Given a weighted undirected connected graph with  n  vertices numbered from  0  to  n - 1 , and an array  edges  where  edges[i] = [a i , b i , weight i ]  represents a bidirectional and weighted edge between nodes  a i  and  b i . A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight. Find  all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST) . An MST edge whose deletion from the graph would cause the MST weight to increase is called a  critical edge . On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order.   Example 1: Input:  n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] Output:  [[0,1],[2,3,4,5]] Explanation:  The figure above describes the graph. The following figure shows all the possible MSTs: Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output. The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output. Example 2: Input:  n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] Output:  [[],[0,1,2,3]] Explanation:  We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.   Constraints: 2 <= n <= 100 1 <= edges.length <= min(200, n * (n - 1) / 2) edges[i].length == 3 0 <= a i  < b i  < n 1 <= weight i  <= 1000 All pairs  (a i , b i )  are  distinct .","['Union Find', 'Graph', 'Sorting', 'Minimum Spanning Tree', 'Strongly Connected Component']",Difícil,Union Find
1579,remove-max-number-of-edges-to-keep-graph-fully-traversable,https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/,Remove Max Number of Edges to Keep Graph Fully Traversable,"Alice and Bob have an undirected graph of  n  nodes and three types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can be traversed by both Alice and Bob. Given an array  edges  where  edges[i] = [type i , u i , v i ]  represents a bidirectional edge of type  type i  between nodes  u i  and  v i , find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return  the maximum number of edges you can remove, or return   -1   if Alice and Bob cannot fully traverse the graph.   Example 1: Input:  n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] Output:  2 Explanation:  If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. Example 2: Input:  n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] Output:  0 Explanation:  Notice that removing any edge will not make the graph fully traversable by Alice and Bob. Example 3: Input:  n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] Output:  -1 Explanation:  In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.     Constraints: 1 <= n <= 10 5 1 <= edges.length <= min(10 5 , 3 * n * (n - 1) / 2) edges[i].length == 3 1 <= type i  <= 3 1 <= u i  < v i  <= n All tuples  (type i , u i , v i )  are distinct.","['Union Find', 'Graph']",Difícil,Union Find
2076,process-restricted-friend-requests,https://leetcode.com/problems/process-restricted-friend-requests/,Process Restricted Friend Requests,"You are given an integer  n  indicating the number of people in a network. Each person is labeled from  0  to  n - 1 . You are also given a  0-indexed  2D integer array  restrictions , where  restrictions[i] = [x i , y i ]  means that person  x i  and person  y i   cannot  become  friends ,   either  directly  or  indirectly  through other people. Initially, no one is friends with each other. You are given a list of friend requests as a  0-indexed  2D integer array  requests , where  requests[j] = [u j , v j ]  is a friend request between person  u j  and person  v j . A friend request is  successful  if  u j  and  v j  can be  friends . Each friend request is processed in the given order (i.e.,  requests[j]  occurs before  requests[j + 1] ), and upon a successful request,  u j  and  v j   become direct friends  for all future friend requests. Return  a  boolean array   result ,  where each  result[j]  is  true  if the  j th  friend request is  successful  or  false  if it is not . Note:  If  u j  and  v j  are already direct friends, the request is still  successful .   Example 1: Input:  n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] Output:  [true,false] Explanation: Request 0: Person 0 and person 2 can be friends, so they become direct friends.  Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0). Example 2: Input:  n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] Output:  [true,false] Explanation: Request 0: Person 1 and person 2 can be friends, so they become direct friends. Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1). Example 3: Input:  n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] Output:  [true,false,true,false] Explanation: Request 0: Person 0 and person 4 can be friends, so they become direct friends. Request 1: Person 1 and person 2 cannot be friends since they are directly restricted. Request 2: Person 3 and person 1 can be friends, so they become direct friends. Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).   Constraints: 2 <= n <= 1000 0 <= restrictions.length <= 1000 restrictions[i].length == 2 0 <= x i , y i  <= n - 1 x i  != y i 1 <= requests.length <= 1000 requests[j].length == 2 0 <= u j , v j  <= n - 1 u j  != v j","['Union Find', 'Graph']",Difícil,Union Find
