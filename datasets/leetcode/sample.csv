ID,URL,Dificuldade,Tema Principal,Título,Enunciado
88,https://leetcode.com/problems/merge-sorted-array/,Fácil,Array,Merge Sorted Array,"You are given two integer arrays  nums1  and  nums2 , sorted in  non-decreasing order , and two integers  m  and  n , representing the number of elements in  nums1  and  nums2  respectively. Merge   nums1  and  nums2  into a single array sorted in  non-decreasing order . The final sorted array should not be returned by the function, but instead be  stored inside the array  nums1 . To accommodate this,  nums1  has a length of  m + n , where the first  m  elements denote the elements that should be merged, and the last  n  elements are set to  0  and should be ignored.  nums2  has a length of  n .   Example 1: Input:  nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output:  [1,2,2,3,5,6] Explanation:  The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [ 1 , 2 ,2, 3 ,5,6] with the underlined elements coming from nums1. Example 2: Input:  nums1 = [1], m = 1, nums2 = [], n = 0 Output:  [1] Explanation:  The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: Input:  nums1 = [0], m = 0, nums2 = [1], n = 1 Output:  [1] Explanation:  The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.   Constraints: nums1.length == m + n nums2.length == n 0 <= m, n <= 200 1 <= m + n <= 200 -10 9  <= nums1[i], nums2[j] <= 10 9   Follow up:  Can you come up with an algorithm that runs in  O(m + n)  time?"
303,https://leetcode.com/problems/range-sum-query-immutable/,Fácil,Array,Range Sum Query - Immutable,"Given an integer array  nums , handle multiple queries of the following type: Calculate the  sum  of the elements of  nums  between indices  left  and  right   inclusive  where  left <= right . Implement the  NumArray  class: NumArray(int[] nums)  Initializes the object with the integer array  nums . int sumRange(int left, int right)  Returns the  sum  of the elements of  nums  between indices  left  and  right   inclusive  (i.e.  nums[left] + nums[left + 1] + ... + nums[right] ).   Example 1: Input [""NumArray"", ""sumRange"", ""sumRange"", ""sumRange""] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] Output [null, 1, -1, -3] Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1 numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1 numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3   Constraints: 1 <= nums.length <= 10 4 -10 5  <= nums[i] <= 10 5 0 <= left <= right < nums.length At most  10 4  calls will be made to  sumRange ."
598,https://leetcode.com/problems/range-addition-ii/,Fácil,Array,Range Addition II,"You are given an  m x n  matrix  M  initialized with all  0 's and an array of operations  ops , where  ops[i] = [a i , b i ]  means  M[x][y]  should be incremented by one for all  0 <= x < a i  and  0 <= y < b i . Count and return  the number of maximum integers in the matrix after performing all the operations .   Example 1: Input:  m = 3, n = 3, ops = [[2,2],[3,3]] Output:  4 Explanation:  The maximum integer in M is 2, and there are four of it in M. So return 4. Example 2: Input:  m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]] Output:  4 Example 3: Input:  m = 3, n = 3, ops = [] Output:  9   Constraints: 1 <= m, n <= 4 * 10 4 0 <= ops.length <= 10 4 ops[i].length == 2 1 <= a i  <= m 1 <= b i  <= n"
628,https://leetcode.com/problems/maximum-product-of-three-numbers/,Fácil,Array,Maximum Product of Three Numbers,"Given an integer array  nums ,  find three numbers whose product is maximum and return the maximum product .   Example 1: Input:  nums = [1,2,3] Output:  6 Example 2: Input:  nums = [1,2,3,4] Output:  24 Example 3: Input:  nums = [-1,-2,-3] Output:  -6   Constraints: 3 <= nums.length <= 10 4 -1000 <= nums[i] <= 1000"
645,https://leetcode.com/problems/set-mismatch/,Fácil,Array,Set Mismatch,"You have a set of integers  s , which originally contains all the numbers from  1  to  n . Unfortunately, due to some error, one of the numbers in  s  got duplicated to another number in the set, which results in  repetition of one  number and  loss of another  number. You are given an integer array  nums  representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return  them in the form of an array .   Example 1: Input:  nums = [1,2,2,4] Output:  [2,3] Example 2: Input:  nums = [1,1] Output:  [1,2]   Constraints: 2 <= nums.length <= 10 4 1 <= nums[i] <= 10 4"
922,https://leetcode.com/problems/sort-array-by-parity-ii/,Fácil,Array,Sort Array By Parity II,"Given an array of integers  nums , half of the integers in  nums  are  odd , and the other half are  even . Sort the array so that whenever  nums[i]  is odd,  i  is  odd , and whenever  nums[i]  is even,  i  is  even . Return  any answer array that satisfies this condition .   Example 1: Input:  nums = [4,2,5,7] Output:  [4,5,2,7] Explanation:  [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Example 2: Input:  nums = [2,3] Output:  [2,3]   Constraints: 2 <= nums.length <= 2 * 10 4 nums.length  is even. Half of the integers in  nums  are even. 0 <= nums[i] <= 1000   Follow Up:  Could you solve it in-place?"
1260,https://leetcode.com/problems/shift-2d-grid/,Fácil,Array,Shift 2D Grid,"Given a 2D  grid  of size  m x n  and an integer  k . You need to shift the  grid   k  times. In one shift operation: Element at  grid[i][j]  moves to  grid[i][j + 1] . Element at  grid[i][n - 1]  moves to  grid[i + 1][0] . Element at  grid[m - 1][n - 1]  moves to  grid[0][0] . Return the  2D grid  after applying shift operation  k  times.   Example 1: Input:   grid  = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output:  [[9,1,2],[3,4,5],[6,7,8]] Example 2: Input:   grid  = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output:  [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: Input:   grid  = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output:  [[1,2,3],[4,5,6],[7,8,9]]   Constraints: m == grid.length n == grid[i].length 1 <= m <= 50 1 <= n <= 50 -1000 <= grid[i][j] <= 1000 0 <= k <= 100"
1403,https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/,Fácil,Array,Minimum Subsequence in Non-Increasing Order,"Given the array  nums , obtain a subsequence of the array whose sum of elements is  strictly greater  than the sum of the non included elements in such subsequence.  If there are multiple solutions, return the subsequence with  minimum size  and if there still exist multiple solutions, return the subsequence with the  maximum total sum  of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.  Note that the solution with the given constraints is guaranteed to be  unique . Also return the answer sorted in  non-increasing  order.   Example 1: Input:  nums = [4,3,10,9,8] Output:  [10,9]  Explanation:  The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements.  Example 2: Input:  nums = [4,4,7,6,7] Output:  [7,7,6]  Explanation:  The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order.     Constraints: 1 <= nums.length <= 500 1 <= nums[i] <= 100"
1450,https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/,Fácil,Array,Number of Students Doing Homework at a Given Time,"Given two integer arrays  startTime  and  endTime  and given an integer  queryTime . The  ith  student started doing their homework at the time  startTime[i]  and finished it at time  endTime[i] . Return  the number of students  doing their homework at time  queryTime . More formally, return the number of students where  queryTime  lays in the interval  [startTime[i], endTime[i]]  inclusive.   Example 1: Input:  startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 Output:  1 Explanation:  We have 3 students where: The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4. The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4. The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4. Example 2: Input:  startTime = [4], endTime = [4], queryTime = 4 Output:  1 Explanation:  The only student was doing their homework at the queryTime.   Constraints: startTime.length == endTime.length 1 <= startTime.length <= 100 1 <= startTime[i] <= endTime[i] <= 1000 1 <= queryTime <= 1000"
1460,https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays/,Fácil,Array,Make Two Arrays Equal by Reversing Subarrays,"You are given two integer arrays of equal length  target  and  arr . In one step, you can select any  non-empty subarray  of  arr  and reverse it. You are allowed to make any number of steps. Return  true   if you can make  arr  equal to  target  or  false  otherwise .   Example 1: Input:  target = [1,2,3,4], arr = [2,4,1,3] Output:  true Explanation:  You can follow the next steps to convert arr to target: 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3] 2- Reverse subarray [4,2], arr becomes [1,2,4,3] 3- Reverse subarray [4,3], arr becomes [1,2,3,4] There are multiple ways to convert arr to target, this is not the only way to do so. Example 2: Input:  target = [7], arr = [7] Output:  true Explanation:  arr is equal to target without any reverses. Example 3: Input:  target = [3,7,9], arr = [3,7,11] Output:  false Explanation:  arr does not have value 9 and it can never be converted to target.   Constraints: target.length == arr.length 1 <= target.length <= 1000 1 <= target[i] <= 1000 1 <= arr[i] <= 1000"
1464,https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/,Fácil,Array,Maximum Product of Two Elements in an Array,"Given the array of integers  nums , you will choose two different indices  i  and  j  of that array.  Return the maximum value of   (nums[i]-1)*(nums[j]-1) .   Example 1: Input:  nums = [3,4,5,2] Output:  12  Explanation:  If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.  Example 2: Input:  nums = [1,5,4,5] Output:  16 Explanation:  Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. Example 3: Input:  nums = [3,7] Output:  12   Constraints: 2 <= nums.length <= 500 1 <= nums[i] <= 10^3"
1470,https://leetcode.com/problems/shuffle-the-array/,Fácil,Array,Shuffle the Array,"Given the array  nums  consisting of  2n  elements in the form  [x 1 ,x 2 ,...,x n ,y 1 ,y 2 ,...,y n ] . Return the array in the form   [x 1 ,y 1 ,x 2 ,y 2 ,...,x n ,y n ] .   Example 1: Input:  nums = [2,5,1,3,4,7], n = 3 Output:  [2,3,5,4,1,7]  Explanation:  Since x 1 =2, x 2 =5, x 3 =1, y 1 =3, y 2 =4, y 3 =7 then the answer is [2,3,5,4,1,7]. Example 2: Input:  nums = [1,2,3,4,4,3,2,1], n = 4 Output:  [1,4,2,3,3,2,4,1] Example 3: Input:  nums = [1,1,2,2], n = 2 Output:  [1,2,1,2]   Constraints: 1 <= n <= 500 nums.length == 2n 1 <= nums[i] <= 10^3"
1588,https://leetcode.com/problems/sum-of-all-odd-length-subarrays/,Fácil,Array,Sum of All Odd Length Subarrays,"Given an array of positive integers  arr , return  the sum of all possible  odd-length subarrays  of  arr . A  subarray  is a contiguous subsequence of the array.   Example 1: Input:  arr = [1,4,2,5,3] Output:  58 Explanation:  The odd-length subarrays of arr and their sums are: [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 Example 2: Input:  arr = [1,2] Output:  3 Explanation:  There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3. Example 3: Input:  arr = [10,11,12] Output:  66   Constraints: 1 <= arr.length <= 100 1 <= arr[i] <= 1000   Follow up: Could you solve this problem in O(n) time complexity?"
1598,https://leetcode.com/problems/crawler-log-folder/,Fácil,Array,Crawler Log Folder,"The Leetcode file system keeps a log each time some user performs a  change folder  operation. The operations are described below: ""../""  : Move to the parent folder of the current folder. (If you are already in the main folder,  remain in the same folder ). ""./""  : Remain in the same folder. ""x/""  : Move to the child folder named  x  (This folder is  guaranteed to always exist ). You are given a list of strings  logs  where  logs[i]  is the operation performed by the user at the  i th  step. The file system starts in the main folder, then the operations in  logs  are performed. Return  the minimum number of operations needed to go back to the main folder after the change folder operations.   Example 1: Input:  logs = [""d1/"",""d2/"",""../"",""d21/"",""./""] Output:  2 Explanation:  Use this change folder operation ""../"" 2 times and go back to the main folder. Example 2: Input:  logs = [""d1/"",""d2/"",""./"",""d3/"",""../"",""d31/""] Output:  3 Example 3: Input:  logs = [""d1/"",""../"",""../"",""../""] Output:  0   Constraints: 1 <= logs.length <= 10 3 2 <= logs[i].length <= 10 logs[i]  contains lowercase English letters, digits,  '.' , and  '/' . logs[i]  follows the format described in the statement. Folder names consist of lowercase English letters and digits."
1646,https://leetcode.com/problems/get-maximum-in-generated-array/,Fácil,Array,Get Maximum in Generated Array,"You are given an integer  n . A  0-indexed  integer array  nums  of length  n + 1  is generated in the following way: nums[0] = 0 nums[1] = 1 nums[2 * i] = nums[i]  when  2 <= 2 * i <= n nums[2 * i + 1] = nums[i] + nums[i + 1]  when  2 <= 2 * i + 1 <= n Return   the  maximum  integer in the array  nums ​​​.   Example 1: Input:  n = 7 Output:  3 Explanation:  According to the given rules:   nums[0] = 0   nums[1] = 1   nums[(1 * 2) = 2] = nums[1] = 1   nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2   nums[(2 * 2) = 4] = nums[2] = 1   nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3   nums[(3 * 2) = 6] = nums[3] = 2   nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. Example 2: Input:  n = 2 Output:  1 Explanation:  According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1. Example 3: Input:  n = 3 Output:  2 Explanation:  According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.   Constraints: 0 <= n <= 100"
1652,https://leetcode.com/problems/defuse-the-bomb/,Fácil,Array,Defuse the Bomb,"You have a bomb to defuse, and your time is running out! Your informer will provide you with a  circular  array  code  of length of  n  and a key  k . To decrypt the code, you must replace every number. All the numbers are replaced  simultaneously . If  k > 0 , replace the  i th  number with the sum of the  next   k  numbers. If  k < 0 , replace the  i th  number with the sum of the  previous   k  numbers. If  k == 0 , replace the  i th  number with  0 . As  code  is circular, the next element of  code[n-1]  is  code[0] , and the previous element of  code[0]  is  code[n-1] . Given the  circular  array  code  and an integer key  k , return  the decrypted code to defuse the bomb !   Example 1: Input:  code = [5,7,1,4], k = 3 Output:  [12,10,16,13] Explanation:  Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around. Example 2: Input:  code = [1,2,3,4], k = 0 Output:  [0,0,0,0] Explanation:  When k is zero, the numbers are replaced by 0.  Example 3: Input:  code = [2,4,9,3], k = -2 Output:  [12,5,6,13] Explanation:  The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the  previous  numbers.   Constraints: n == code.length 1 <= n <= 100 1 <= code[i] <= 100 -(n - 1) <= k <= n - 1"
1656,https://leetcode.com/problems/design-an-ordered-stream/,Fácil,Array,Design an Ordered Stream,"There is a stream of  n   (idKey, value)  pairs arriving in an  arbitrary  order, where  idKey  is an integer between  1  and  n  and  value  is a string. No two pairs have the same  id . Design a stream that returns the values in  increasing order of their IDs  by returning a  chunk  (list) of values after each insertion. The concatenation of all the  chunks  should result in a list of the sorted values. Implement the  OrderedStream  class: OrderedStream(int n)  Constructs the stream to take  n  values. String[] insert(int idKey, String value)  Inserts the pair  (idKey, value)  into the stream, then returns the  largest possible chunk  of currently inserted values that appear next in the order.   Example: Input [""OrderedStream"", ""insert"", ""insert"", ""insert"", ""insert"", ""insert""] [[5], [3, ""ccccc""], [1, ""aaaaa""], [2, ""bbbbb""], [5, ""eeeee""], [4, ""ddddd""]] Output [null, [], [""aaaaa""], [""bbbbb"", ""ccccc""], [], [""ddddd"", ""eeeee""]] Explanation // Note that the values ordered by ID is [""aaaaa"", ""bbbbb"", ""ccccc"", ""ddddd"", ""eeeee""]. OrderedStream os = new OrderedStream(5); os.insert(3, ""ccccc""); // Inserts (3, ""ccccc""), returns []. os.insert(1, ""aaaaa""); // Inserts (1, ""aaaaa""), returns [""aaaaa""]. os.insert(2, ""bbbbb""); // Inserts (2, ""bbbbb""), returns [""bbbbb"", ""ccccc""]. os.insert(5, ""eeeee""); // Inserts (5, ""eeeee""), returns []. os.insert(4, ""ddddd""); // Inserts (4, ""ddddd""), returns [""ddddd"", ""eeeee""]. // Concatentating all the chunks returned: // [] + [""aaaaa""] + [""bbbbb"", ""ccccc""] + [] + [""ddddd"", ""eeeee""] = [""aaaaa"", ""bbbbb"", ""ccccc"", ""ddddd"", ""eeeee""] // The resulting order is the same as the order above.   Constraints: 1 <= n <= 1000 1 <= id <= n value.length == 5 value  consists only of lowercase letters. Each call to  insert  will have a unique  id. Exactly  n  calls will be made to  insert ."
1662,https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/,Fácil,Array,Check If Two String Arrays are Equivalent,"Given two string arrays  word1  and  word2 , return   true  if the two arrays  represent  the same string, and  false  otherwise. A string is  represented  by an array if the array elements concatenated  in order  forms the string.   Example 1: Input:  word1 = [""ab"", ""c""], word2 = [""a"", ""bc""] Output:  true Explanation: word1 represents string ""ab"" + ""c"" -> ""abc"" word2 represents string ""a"" + ""bc"" -> ""abc"" The strings are the same, so return true. Example 2: Input:  word1 = [""a"", ""cb""], word2 = [""ab"", ""c""] Output:  false Example 3: Input:  word1  = [""abc"", ""d"", ""defg""], word2 = [""abcddefg""] Output:  true   Constraints: 1 <= word1.length, word2.length <= 10 3 1 <= word1[i].length, word2[i].length <= 10 3 1 <= sum(word1[i].length), sum(word2[i].length) <= 10 3 word1[i]  and  word2[i]  consist of lowercase letters."
1748,https://leetcode.com/problems/sum-of-unique-elements/,Fácil,Array,Sum of Unique Elements,"You are given an integer array  nums . The unique elements of an array are the elements that appear  exactly once  in the array. Return  the  sum  of all the unique elements of  nums .   Example 1: Input:  nums = [1,2,3,2] Output:  4 Explanation:  The unique elements are [1,3], and the sum is 4. Example 2: Input:  nums = [1,1,1,1,1] Output:  0 Explanation:  There are no unique elements, and the sum is 0. Example 3: Input:  nums = [1,2,3,4,5] Output:  15 Explanation:  The unique elements are [1,2,3,4,5], and the sum is 15.   Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100"
1863,https://leetcode.com/problems/sum-of-all-subset-xor-totals/,Fácil,Array,Sum of All Subset XOR Totals,"The  XOR total  of an array is defined as the bitwise  XOR  of  all its elements , or  0  if the array is  empty . For example, the  XOR total  of the array  [2,5,6]  is  2 XOR 5 XOR 6 = 1 . Given an array  nums , return  the  sum  of all  XOR totals  for every  subset  of  nums .  Note:  Subsets with the  same  elements should be counted  multiple  times. An array  a  is a  subset  of an array  b  if  a  can be obtained from  b  by deleting some (possibly zero) elements of  b .   Example 1: Input:  nums = [1,3] Output:  6 Explanation:  The 4 subsets of [1,3] are: - The empty subset has an XOR total of 0. - [1] has an XOR total of 1. - [3] has an XOR total of 3. - [1,3] has an XOR total of 1 XOR 3 = 2. 0 + 1 + 3 + 2 = 6 Example 2: Input:  nums = [5,1,6] Output:  28 Explanation:  The 8 subsets of [5,1,6] are: - The empty subset has an XOR total of 0. - [5] has an XOR total of 5. - [1] has an XOR total of 1. - [6] has an XOR total of 6. - [5,1] has an XOR total of 5 XOR 1 = 4. - [5,6] has an XOR total of 5 XOR 6 = 3. - [1,6] has an XOR total of 1 XOR 6 = 7. - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2. 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 Example 3: Input:  nums = [3,4,5,6,7,8] Output:  480 Explanation:  The sum of all XOR totals for every subset is 480.   Constraints: 1 <= nums.length <= 12 1 <= nums[i] <= 20"
1967,https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/,Fácil,Array,Number of Strings That Appear as Substrings in Word,"Given an array of strings  patterns  and a string  word , return  the  number  of strings in  patterns  that exist as a  substring  in  word . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  patterns = [""a"",""abc"",""bc"",""d""], word = ""abc"" Output:  3 Explanation: - ""a"" appears as a substring in "" a bc"". - ""abc"" appears as a substring in "" abc "". - ""bc"" appears as a substring in ""a bc "". - ""d"" does not appear as a substring in ""abc"". 3 of the strings in patterns appear as a substring in word. Example 2: Input:  patterns = [""a"",""b"",""c""], word = ""aaaaabbbbb"" Output:  2 Explanation: - ""a"" appears as a substring in ""a a aaabbbbb"". - ""b"" appears as a substring in ""aaaaabbbb b "". - ""c"" does not appear as a substring in ""aaaaabbbbb"". 2 of the strings in patterns appear as a substring in word. Example 3: Input:  patterns = [""a"",""a"",""a""], word = ""ab"" Output:  3 Explanation:  Each of the patterns appears as a substring in word "" a b"".   Constraints: 1 <= patterns.length <= 100 1 <= patterns[i].length <= 100 1 <= word.length <= 100 patterns[i]  and  word  consist of lowercase English letters."
1984,https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/,Fácil,Array,Minimum Difference Between Highest and Lowest of K Scores,"You are given a  0-indexed  integer array  nums , where  nums[i]  represents the score of the  i th  student. You are also given an integer  k . Pick the scores of any  k  students from the array so that the  difference  between the  highest  and the  lowest  of the  k  scores is  minimized . Return  the  minimum  possible difference .   Example 1: Input:  nums = [90], k = 1 Output:  0 Explanation:  There is one way to pick score(s) of one student: - [ 90 ]. The difference between the highest and lowest score is 90 - 90 = 0. The minimum possible difference is 0. Example 2: Input:  nums = [9,4,1,7], k = 2 Output:  2 Explanation:  There are six ways to pick score(s) of two students: - [ 9 , 4 ,1,7]. The difference between the highest and lowest score is 9 - 4 = 5. - [ 9 ,4, 1 ,7]. The difference between the highest and lowest score is 9 - 1 = 8. - [ 9 ,4,1, 7 ]. The difference between the highest and lowest score is 9 - 7 = 2. - [9, 4 , 1 ,7]. The difference between the highest and lowest score is 4 - 1 = 3. - [9, 4 ,1, 7 ]. The difference between the highest and lowest score is 7 - 4 = 3. - [9,4, 1 , 7 ]. The difference between the highest and lowest score is 7 - 1 = 6. The minimum possible difference is 2.   Constraints: 1 <= k <= nums.length <= 1000 0 <= nums[i] <= 10 5"
2037,https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/,Fácil,Array,Minimum Number of Moves to Seat Everyone,"There are  n   availabe  seats and  n  students  standing  in a room. You are given an array  seats  of length  n , where  seats[i]  is the position of the  i th  seat. You are also given the array  students  of length  n , where  students[j]  is the position of the  j th  student. You may perform the following move any number of times: Increase or decrease the position of the  i th  student by  1  (i.e., moving the  i th  student from position  x  to  x + 1  or  x - 1 ) Return  the  minimum number of moves  required to move each student to a seat  such that no two students are in the same seat. Note that there may be  multiple  seats or students in the  same  position at the beginning.   Example 1: Input:  seats = [3,1,5], students = [2,7,4] Output:  4 Explanation:  The students are moved as follows: - The first student is moved from position 2 to position 1 using 1 move. - The second student is moved from position 7 to position 5 using 2 moves. - The third student is moved from position 4 to position 3 using 1 move. In total, 1 + 2 + 1 = 4 moves were used. Example 2: Input:  seats = [4,1,5,9], students = [1,3,2,6] Output:  7 Explanation:  The students are moved as follows: - The first student is not moved. - The second student is moved from position 3 to position 4 using 1 move. - The third student is moved from position 2 to position 5 using 3 moves. - The fourth student is moved from position 6 to position 9 using 3 moves. In total, 0 + 1 + 3 + 3 = 7 moves were used. Example 3: Input:  seats = [2,2,6,6], students = [1,3,2,6] Output:  4 Explanation:  Note that there are two seats at position 2 and two seats at position 6. The students are moved as follows: - The first student is moved from position 1 to position 2 using 1 move. - The second student is moved from position 3 to position 6 using 3 moves. - The third student is not moved. - The fourth student is not moved. In total, 1 + 3 + 0 + 0 = 4 moves were used.   Constraints: n == seats.length == students.length 1 <= n <= 100 1 <= seats[i], students[j] <= 100"
2144,https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/,Fácil,Array,Minimum Cost of Buying Candies With Discount,"A shop is selling candies at a discount. For  every two  candies sold, the shop gives a  third  candy for  free . The customer can choose  any  candy to take away for free as long as the cost of the chosen candy is less than or equal to the  minimum  cost of the two candies bought. For example, if there are  4  candies with costs  1 ,  2 ,  3 , and  4 , and the customer buys candies with costs  2  and  3 , they can take the candy with cost  1  for free, but not the candy with cost  4 . Given a  0-indexed  integer array  cost , where  cost[i]  denotes the cost of the  i th  candy, return  the  minimum cost  of buying  all  the candies .   Example 1: Input:  cost = [1,2,3] Output:  5 Explanation:  We buy the candies with costs 2 and 3, and take the candy with cost 1 for free. The total cost of buying all candies is 2 + 3 = 5. This is the  only  way we can buy the candies. Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free. The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies. Example 2: Input:  cost = [6,5,7,9,2,2] Output:  23 Explanation:  The way in which we can get the minimum cost is described below: - Buy candies with costs 9 and 7 - Take the candy with cost 6 for free - We buy candies with costs 5 and 2 - Take the last remaining candy with cost 2 for free Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23. Example 3: Input:  cost = [5,5] Output:  10 Explanation:  Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free. Hence, the minimum cost to buy all candies is 5 + 5 = 10.   Constraints: 1 <= cost.length <= 100 1 <= cost[i] <= 100"
2335,https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/,Fácil,Array,Minimum Amount of Time to Fill Cups,"You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up  2  cups with  different  types of water, or  1  cup of any type of water. You are given a  0-indexed  integer array  amount  of length  3  where  amount[0] ,  amount[1] , and  amount[2]  denote the number of cold, warm, and hot water cups you need to fill respectively. Return  the  minimum  number of seconds needed to fill up all the cups .   Example 1: Input:  amount = [1,4,2] Output:  4 Explanation:  One way to fill up the cups is: Second 1: Fill up a cold cup and a warm cup. Second 2: Fill up a warm cup and a hot cup. Second 3: Fill up a warm cup and a hot cup. Second 4: Fill up a warm cup. It can be proven that 4 is the minimum number of seconds needed. Example 2: Input:  amount = [5,4,4] Output:  7 Explanation:  One way to fill up the cups is: Second 1: Fill up a cold cup, and a hot cup. Second 2: Fill up a cold cup, and a warm cup. Second 3: Fill up a cold cup, and a warm cup. Second 4: Fill up a warm cup, and a hot cup. Second 5: Fill up a cold cup, and a hot cup. Second 6: Fill up a cold cup, and a warm cup. Second 7: Fill up a hot cup. Example 3: Input:  amount = [5,0,0] Output:  5 Explanation:  Every second, we fill up a cold cup.   Constraints: amount.length == 3 0 <= amount[i] <= 100"
2475,https://leetcode.com/problems/number-of-unequal-triplets-in-array/,Fácil,Array,Number of Unequal Triplets in Array,"You are given a  0-indexed  array of positive integers  nums . Find the number of triplets  (i, j, k)  that meet the following conditions: 0 <= i < j < k < nums.length nums[i] ,  nums[j] , and  nums[k]  are  pairwise distinct . 	 In other words,  nums[i] != nums[j] ,  nums[i] != nums[k] , and  nums[j] != nums[k] . Return  the number of triplets that meet the conditions.   Example 1: Input:  nums = [4,4,2,4,3] Output:  3 Explanation:  The following triplets meet the conditions: - (0, 2, 4) because 4 != 2 != 3 - (1, 2, 4) because 4 != 2 != 3 - (2, 3, 4) because 2 != 4 != 3 Since there are 3 triplets, we return 3. Note that (2, 0, 4) is not a valid triplet because 2 > 0. Example 2: Input:  nums = [1,1,1,1,1] Output:  0 Explanation:  No triplets meet the conditions so we return 0.   Constraints: 3 <= nums.length <= 100 1 <= nums[i] <= 1000"
2496,https://leetcode.com/problems/maximum-value-of-a-string-in-an-array/,Fácil,Array,Maximum Value of a String in an Array,"The  value  of an alphanumeric string can be defined as: The  numeric  representation of the string in base  10 , if it comprises of digits  only . The  length  of the string, otherwise. Given an array  strs  of alphanumeric strings, return  the  maximum value  of any string in  strs .   Example 1: Input:  strs = [""alic3"",""bob"",""3"",""4"",""00000""] Output:  5 Explanation:   - ""alic3"" consists of both letters and digits, so its value is its length, i.e. 5. - ""bob"" consists only of letters, so its value is also its length, i.e. 3. - ""3"" consists only of digits, so its value is its numeric equivalent, i.e. 3. - ""4"" also consists only of digits, so its value is 4. - ""00000"" consists only of digits, so its value is 0. Hence, the maximum value is 5, of ""alic3"". Example 2: Input:  strs = [""1"",""01"",""001"",""0001""] Output:  1 Explanation:   Each string in the array has value 1. Hence, we return 1.   Constraints: 1 <= strs.length <= 100 1 <= strs[i].length <= 9 strs[i]  consists of only lowercase English letters and digits."
2574,https://leetcode.com/problems/left-and-right-sum-differences/,Fácil,Array,Left and Right Sum Differences,"You are given a  0-indexed  integer array  nums  of size  n . Define two arrays  leftSum  and  rightSum  where: leftSum[i]  is the sum of elements to the left of the index  i  in the array  nums . If there is no such element,  leftSum[i] = 0 . rightSum[i]  is the sum of elements to the right of the index  i  in the array  nums . If there is no such element,  rightSum[i] = 0 . Return an integer array  answer  of size  n  where  answer[i] = |leftSum[i] - rightSum[i]| .   Example 1: Input:  nums = [10,4,8,3] Output:  [15,1,11,22] Explanation:  The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0]. The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22]. Example 2: Input:  nums = [1] Output:  [0] Explanation:  The array leftSum is [0] and the array rightSum is [0]. The array answer is [|0 - 0|] = [0].   Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 10 5"
2644,https://leetcode.com/problems/find-the-maximum-divisibility-score/,Fácil,Array,Find the Maximum Divisibility Score,"You are given two integer arrays  nums  and  divisors . The  divisibility score  of  divisors[i]  is the number of indices  j  such that  nums[j]  is divisible by  divisors[i] . Return the integer  divisors[i]  with the  maximum  divisibility score. If multiple integers have the maximum score, return the smallest one.   Example 1: Input:   nums = [2,9,15,50], divisors = [5,3,7,2] Output:   2 Explanation: The divisibility score of  divisors[0]  is 2 since  nums[2]  and  nums[3]  are divisible by 5. The divisibility score of  divisors[1]  is 2 since  nums[1]  and  nums[2]  are divisible by 3. The divisibility score of  divisors[2]  is 0 since none of the numbers in  nums  is divisible by 7. The divisibility score of  divisors[3]  is 2 since  nums[0]  and  nums[3]  are divisible by 2. As  divisors[0] ,  divisors[1] , and  divisors[3]  have the same divisibility score, we return the smaller one which is  divisors[3] . Example 2: Input:   nums = [4,7,9,3,9], divisors = [5,2,3] Output:   3 Explanation: The divisibility score of  divisors[0]  is 0 since none of numbers in  nums  is divisible by 5. The divisibility score of  divisors[1]  is 1 since only  nums[0]  is divisible by 2. The divisibility score of  divisors[2]  is 3 since  nums[2] ,  nums[3]  and  nums[4]  are divisible by 3. Example 3: Input:   nums = [20,14,21,10], divisors = [10,16,20] Output:   10 Explanation: The divisibility score of  divisors[0]  is 2 since  nums[0]  and  nums[3]  are divisible by 10. The divisibility score of  divisors[1]  is 0 since none of the numbers in  nums  is divisible by 16. The divisibility score of  divisors[2]  is 1 since  nums[0]  is divisible by 20.   Constraints: 1 <= nums.length, divisors.length <= 1000 1 <= nums[i], divisors[i] <= 10 9"
2656,https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/,Fácil,Array,Maximum Sum With Exactly K Elements,"You are given a  0-indexed  integer array  nums  and an integer  k . Your task is to perform the following operation  exactly   k  times in order to maximize your score: Select an element  m  from  nums . Remove the selected element  m  from the array. Add a new element with a value of  m + 1  to the array. Increase your score by  m . Return  the maximum score you can achieve after performing the operation exactly   k   times.   Example 1: Input:  nums = [1,2,3,4,5], k = 3 Output:  18 Explanation:  We need to choose exactly 3 elements from nums to maximize the sum. For the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6] For the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7] For the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8] So, we will return 18. It can be proven, that 18 is the maximum answer that we can achieve. Example 2: Input:  nums = [5,5,5], k = 2 Output:  11 Explanation:  We need to choose exactly 2 elements from nums to maximize the sum. For the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6] For the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7] So, we will return 11. It can be proven, that 11 is the maximum answer that we can achieve.   Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100 1 <= k <= 100"
2706,https://leetcode.com/problems/buy-two-chocolates/,Fácil,Array,Buy Two Chocolates,"You are given an integer array  prices  representing the prices of various chocolates in a store. You are also given a single integer  money , which represents your initial amount of money. You must buy  exactly  two chocolates in such a way that you still have some  non-negative  leftover money. You would like to minimize the sum of the prices of the two chocolates you buy. Return  the amount of money you will have leftover after buying the two chocolates . If there is no way for you to buy two chocolates without ending up in debt, return  money . Note that the leftover must be non-negative.   Example 1: Input:  prices = [1,2,2], money = 3 Output:  0 Explanation:  Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0. Example 2: Input:  prices = [3,2,3], money = 3 Output:  3 Explanation:  You cannot buy 2 chocolates without going in debt, so we return 3.   Constraints: 2 <= prices.length <= 50 1 <= prices[i] <= 100 1 <= money <= 100"
2748,https://leetcode.com/problems/number-of-beautiful-pairs/,Fácil,Array,Number of Beautiful Pairs,"You are given a  0-indexed  integer array  nums . A pair of indices  i ,  j  where  0 <= i < j < nums.length  is called beautiful if the  first digit  of  nums[i]  and the  last digit  of  nums[j]  are  coprime . Return  the total number of beautiful pairs in  nums . Two integers  x  and  y  are  coprime  if there is no integer greater than 1 that divides both of them. In other words,  x  and  y  are coprime if  gcd(x, y) == 1 , where  gcd(x, y)  is the  greatest common divisor  of  x  and  y .   Example 1: Input:  nums = [2,5,1,4] Output:  5 Explanation:  There are 5 beautiful pairs in nums: When i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1. When i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1. When i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1. When i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1. When i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1. Thus, we return 5. Example 2: Input:  nums = [11,21,12] Output:  2 Explanation:  There are 2 beautiful pairs: When i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1. When i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1. Thus, we return 2.   Constraints: 2 <= nums.length <= 100 1 <= nums[i] <= 9999 nums[i] % 10 != 0"
2899,https://leetcode.com/problems/last-visited-integers/,Fácil,Array,Last Visited Integers,"Given an integer array  nums  where  nums[i]  is either a positive integer or  -1 . We need to find for each  -1  the respective positive integer, which we call the last visited integer. To achieve this goal, let's define two empty arrays:  seen  and  ans . Start iterating from the beginning of the array  nums . If a positive integer is encountered, prepend it to the  front  of  seen . If  -1  is encountered, let  k  be the number of  consecutive   -1 s seen so far (including the current  -1 ), 	 If  k  is less than or equal to the length of  seen , append the  k -th element of  seen  to  ans . If  k  is strictly greater than the length of  seen , append  -1  to  ans . Return the array   ans .   Example 1: Input:   nums = [1,2,-1,-1,-1] Output:   [2,1,-1] Explanation: Start with  seen = []  and  ans = [] . Process  nums[0] : The first element in nums is  1 . We prepend it to the front of  seen . Now,  seen == [1] . Process  nums[1] : The next element is  2 . We prepend it to the front of  seen . Now,  seen == [2, 1] . Process  nums[2] : The next element is  -1 . This is the first occurrence of  -1 , so  k == 1 . We look for the first element in seen. We append  2  to  ans . Now,  ans == [2] . Process  nums[3] : Another  -1 . This is the second consecutive  -1 , so  k == 2 . The second element in  seen  is  1 , so we append  1  to  ans . Now,  ans == [2, 1] . Process  nums[4] : Another  -1 , the third in a row, making  k = 3 . However,  seen  only has two elements ( [2, 1] ). Since  k  is greater than the number of elements in  seen , we append  -1  to  ans . Finally,  ans == [2, 1, -1] . Example 2: Input:   nums = [1,-1,2,-1,-1] Output:  [1,2,1] Explanation: Start with  seen = []  and  ans = [] . Process  nums[0] : The first element in nums is  1 . We prepend it to the front of  seen . Now,  seen == [1] . Process  nums[1] : The next element is  -1 . This is the first occurrence of  -1 , so  k == 1 . We look for the first element in  seen , which is  1 . Append  1  to  ans . Now,  ans == [1] . Process  nums[2] : The next element is  2 . Prepend this to the front of  seen . Now,  seen == [2, 1] . Process  nums[3] : The next element is  -1 . This  -1  is not consecutive to the first  -1  since  2  was in between. Thus,  k  resets to  1 . The first element in  seen  is  2 , so append  2  to  ans . Now,  ans == [1, 2] . Process  nums[4] : Another  -1 . This is consecutive to the previous  -1 , so  k == 2 . The second element in  seen  is  1 , append  1  to  ans . Finally,  ans == [1, 2, 1] .   Constraints: 1 <= nums.length <= 100 nums[i] == -1  or  1 <= nums[i] <= 100"
2900,https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/,Fácil,Array,Longest Unequal Adjacent Groups Subsequence I,"You are given a string array  words  and a  binary  array  groups  both of length  n . A  subsequence  of  words  is  alternating  if for any two  consecutive  strings in the sequence, their corresponding elements at the  same  indices in  groups  are  different  (that is, there  cannot  be consecutive 0 or 1). Your task is to select the  longest alternating  subsequence from  words . Return  the selected subsequence. If there are multiple answers, return  any  of them. Note:  The elements in  words  are distinct.   Example 1: Input:   words = [""e"",""a"",""b""], groups = [0,0,1] Output:   [""e"",""b""] Explanation:  A subsequence that can be selected is  [""e"",""b""]  because  groups[0] != groups[2] . Another subsequence that can be selected is  [""a"",""b""]  because  groups[1] != groups[2] . It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is  2 . Example 2: Input:   words = [""a"",""b"",""c"",""d""], groups = [1,0,1,1] Output:   [""a"",""b"",""c""] Explanation:  A subsequence that can be selected is  [""a"",""b"",""c""]  because  groups[0] != groups[1]  and  groups[1] != groups[2] . Another subsequence that can be selected is  [""a"",""b"",""d""]  because  groups[0] != groups[1]  and  groups[1] != groups[3] . It can be shown that the length of the longest subsequence of indices that satisfies the condition is  3 .   Constraints: 1 <= n == words.length == groups.length <= 100 1 <= words[i].length <= 10 groups[i]  is either  0  or  1. words  consists of  distinct  strings. words[i]  consists of lowercase English letters."
2917,https://leetcode.com/problems/find-the-k-or-of-an-array/,Fácil,Array,Find the K-or of an Array,"You are given an integer array  nums , and an integer  k . Let's introduce  K-or  operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to  1  if at least  k  numbers in  nums  have a  1  in that position. Return  the K-or of   nums .   Example 1:  Input:  nums = [7,12,9,8,9,15], k = 4  Output:  9  Explanation:  Represent numbers in binary: Number Bit 3 Bit 2 Bit 1 Bit 0 7 0 1 1 1 12 1 1 0 0 9 1 0 0 1 8 1 0 0 0 9 1 0 0 1 15 1 1 1 1 Result = 9 1 0 0 1 Bit 0 is set in 7, 9, 9, and 15. Bit 3 is set in 12, 9, 8, 9, and 15. Only bits 0 and 3 qualify. The result is  (1001) 2  = 9 . Example 2:  Input:  nums = [2,12,1,11,4,5], k = 6  Output:  0  Explanation:  No bit appears as 1 in all six array numbers, as required for K-or with  k = 6 . Thus, the result is 0. Example 3:  Input:  nums = [10,8,5,9,11,6,8], k = 1  Output:  15  Explanation:   Since  k == 1 , the 1-or of the array is equal to the bitwise OR of all its elements. Hence, the answer is  10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15 .   Constraints: 1 <= nums.length <= 50 0 <= nums[i] < 2 31 1 <= k <= nums.length"
2970,https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/,Fácil,Array,Count the Number of Incremovable Subarrays I,"You are given a  0-indexed  array of  positive  integers  nums . A subarray of  nums  is called  incremovable  if  nums  becomes  strictly increasing  on removing the subarray. For example, the subarray  [3, 4]  is an incremovable subarray of  [5, 3, 4, 6, 7]  because removing this subarray changes the array  [5, 3, 4, 6, 7]  to  [5, 6, 7]  which is strictly increasing. Return  the total number of  incremovable  subarrays of   nums . Note  that an empty array is considered strictly increasing. A  subarray  is a contiguous non-empty sequence of elements within an array.   Example 1: Input:  nums = [1,2,3,4] Output:  10 Explanation:  The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray. Example 2: Input:  nums = [6,5,7,8] Output:  7 Explanation:  The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8]. It can be shown that there are only 7 incremovable subarrays in nums. Example 3: Input:  nums = [8,7,6,6] Output:  3 Explanation:  The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.   Constraints: 1 <= nums.length <= 50 1 <= nums[i] <= 50"
2996,https://leetcode.com/problems/smallest-missing-integer-greater-than-sequential-prefix-sum/,Fácil,Array,Smallest Missing Integer Greater Than Sequential Prefix Sum,"You are given a  0-indexed  array of integers  nums . A prefix  nums[0..i]  is  sequential  if, for all  1 <= j <= i ,  nums[j] = nums[j - 1] + 1 . In particular, the prefix consisting only of  nums[0]  is  sequential . Return  the  smallest  integer   x   missing from   nums   such that   x   is greater than or equal to the sum of the  longest  sequential prefix.   Example 1: Input:  nums = [1,2,3,2,5] Output:  6 Explanation:  The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix. Example 2: Input:  nums = [3,4,5,1,12,14,13] Output:  15 Explanation:  The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.   Constraints: 1 <= nums.length <= 50 1 <= nums[i] <= 50"
3028,https://leetcode.com/problems/ant-on-the-boundary/,Fácil,Array,Ant on the Boundary,"An ant is on a boundary. It sometimes goes  left  and sometimes  right . You are given an array of  non-zero  integers  nums . The ant starts reading  nums  from the first element of it to its end. At each step, it moves according to the value of the current element: If  nums[i] < 0 , it moves  left  by   -nums[i]  units. If  nums[i] > 0 , it moves  right  by  nums[i]  units. Return  the number of times the ant  returns  to the boundary. Notes: There is an infinite space on both sides of the boundary. We check whether the ant is on the boundary only after it has moved  |nums[i]|  units. In other words, if the ant crosses the boundary during its movement, it does not count.   Example 1: Input:  nums = [2,3,-5] Output:  1 Explanation:  After the first step, the ant is 2 steps to the right of the boundary . After the second step, the ant is 5 steps to the right of the boundary . After the third step, the ant is on the boundary. So the answer is 1. Example 2: Input:  nums = [3,2,-3,-4] Output:  0 Explanation:  After the first step, the ant is 3 steps to the right of the boundary . After the second step, the ant is 5 steps to the right of the boundary . After the third step, the ant is 2 steps to the right of the boundary . After the fourth step, the ant is 2 steps to the left of the boundary . The ant never returned to the boundary, so the answer is 0.   Constraints: 1 <= nums.length <= 100 -10 <= nums[i] <= 10 nums[i] != 0"
3038,https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-i/,Fácil,Array,Maximum Number of Operations With the Same Score I,"You are given an array of integers  nums . Consider the following operation: Delete the first two elements  nums  and define the  score  of the operation as the sum of these two elements. You can perform this operation until  nums  contains fewer than two elements. Additionally, the  same   score  must be achieved in  all  operations. Return the  maximum  number of operations you can perform.   Example 1: Input:   nums = [3,2,1,4,5] Output:   2 Explanation: We can perform the first operation with the score  3 + 2 = 5 . After this operation,  nums = [1,4,5] . We can perform the second operation as its score is  4 + 1 = 5 , the same as the previous operation. After this operation,  nums = [5] . As there are fewer than two elements, we can't perform more operations. Example 2: Input:   nums = [1,5,3,3,4,1,3,2,2,3] Output:   2 Explanation: We can perform the first operation with the score  1 + 5 = 6 . After this operation,  nums = [3,3,4,1,3,2,2,3] . We can perform the second operation as its score is  3 + 3 = 6 , the same as the previous operation. After this operation,  nums = [4,1,3,2,2,3] . We cannot perform the next operation as its score is  4 + 1 = 5 , which is different from the previous scores. Example 3: Input:   nums = [5,3] Output:   1   Constraints: 2 <= nums.length <= 100 1 <= nums[i] <= 1000"
3042,https://leetcode.com/problems/count-prefix-and-suffix-pairs-i/,Fácil,Array,Count Prefix and Suffix Pairs I,"You are given a  0-indexed  string array  words . Let's define a  boolean  function  isPrefixAndSuffix  that takes two strings,  str1  and  str2 : isPrefixAndSuffix(str1, str2)  returns  true  if  str1  is  both  a  prefix  and a  suffix  of  str2 , and  false  otherwise. For example,  isPrefixAndSuffix(""aba"", ""ababa"")  is  true  because  ""aba""  is a prefix of  ""ababa""  and also a suffix, but  isPrefixAndSuffix(""abc"", ""abcd"")  is  false . Return  an integer denoting the  number  of index pairs  (i, j)  such that  i < j , and  isPrefixAndSuffix(words[i], words[j])  is  true .   Example 1: Input:  words = [""a"",""aba"",""ababa"",""aa""] Output:  4 Explanation:  In this example, the counted index pairs are: i = 0 and j = 1 because isPrefixAndSuffix(""a"", ""aba"") is true. i = 0 and j = 2 because isPrefixAndSuffix(""a"", ""ababa"") is true. i = 0 and j = 3 because isPrefixAndSuffix(""a"", ""aa"") is true. i = 1 and j = 2 because isPrefixAndSuffix(""aba"", ""ababa"") is true. Therefore, the answer is 4. Example 2: Input:  words = [""pa"",""papa"",""ma"",""mama""] Output:  2 Explanation:  In this example, the counted index pairs are: i = 0 and j = 1 because isPrefixAndSuffix(""pa"", ""papa"") is true. i = 2 and j = 3 because isPrefixAndSuffix(""ma"", ""mama"") is true. Therefore, the answer is 2.   Example 3: Input:  words = [""abab"",""ab""] Output:  0 Explanation:  In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(""abab"", ""ab"") is false. Therefore, the answer is 0.   Constraints: 1 <= words.length <= 50 1 <= words[i].length <= 10 words[i]  consists only of lowercase English letters."
3242,https://leetcode.com/problems/design-neighbor-sum-service/,Fácil,Array,Design Neighbor Sum Service,"You are given a  n x n  2D array  grid  containing  distinct  elements in the range  [0, n 2  - 1] . Implement the  NeighborSum  class: NeighborSum(int [][]grid)  initializes the object. int adjacentSum(int value)  returns the  sum  of elements which are adjacent neighbors of  value , that is either to the top, left, right, or bottom of  value  in  grid . int diagonalSum(int value)  returns the  sum  of elements which are diagonal neighbors of  value , that is either to the top-left, top-right, bottom-left, or bottom-right of  value  in  grid .   Example 1: Input: [""NeighborSum"", ""adjacentSum"", ""adjacentSum"", ""diagonalSum"", ""diagonalSum""] [[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]] Output:  [null, 6, 16, 16, 4] Explanation: The adjacent neighbors of 1 are 0, 2, and 4. The adjacent neighbors of 4 are 1, 3, 5, and 7. The diagonal neighbors of 4 are 0, 2, 6, and 8. The diagonal neighbor of 8 is 4. Example 2: Input: [""NeighborSum"", ""adjacentSum"", ""diagonalSum""] [[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]] Output:  [null, 23, 45] Explanation: The adjacent neighbors of 15 are 0, 10, 7, and 6. The diagonal neighbors of 9 are 4, 12, 14, and 15.   Constraints: 3 <= n == grid.length == grid[0].length <= 10 0 <= grid[i][j] <= n 2  - 1 All  grid[i][j]  are distinct. value  in  adjacentSum  and  diagonalSum  will be in the range  [0, n 2  - 1] . At most  2 * n 2  calls will be made to  adjacentSum  and  diagonalSum ."
81,https://leetcode.com/problems/search-in-rotated-sorted-array-ii/,Média,Array,Search in Rotated Sorted Array II,"There is an integer array  nums  sorted in non-decreasing order (not necessarily with  distinct  values). Before being passed to your function,  nums  is  rotated  at an unknown pivot index  k  ( 0 <= k < nums.length ) such that the resulting array is  [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]  ( 0-indexed ). For example,  [0,1,2,4,4,4,5,6,6,7]  might be rotated at pivot index  5  and become  [4,5,6,6,7,0,1,2,4,4] . Given the array  nums   after  the rotation and an integer  target , return  true  if  target  is in  nums , or  false  if it is not in  nums . You must decrease the overall operation steps as much as possible.   Example 1: Input:  nums = [2,5,6,0,0,1,2], target = 0 Output:  true Example 2: Input:  nums = [2,5,6,0,0,1,2], target = 3 Output:  false   Constraints: 1 <= nums.length <= 5000 -10 4  <= nums[i] <= 10 4 nums  is guaranteed to be rotated at some pivot. -10 4  <= target <= 10 4   Follow up:  This problem is similar to  Search in Rotated Sorted Array , but  nums  may contain  duplicates . Would this affect the runtime complexity? How and why?"
152,https://leetcode.com/problems/maximum-product-subarray/,Média,Array,Maximum Product Subarray,"Given an integer array  nums , find a  subarray  that has the largest product, and return  the product . The test cases are generated so that the answer will fit in a  32-bit  integer.   Example 1: Input:  nums = [2,3,-2,4] Output:  6 Explanation:  [2,3] has the largest product 6. Example 2: Input:  nums = [-2,0,-1] Output:  0 Explanation:  The result cannot be 2, because [-2,-1] is not a subarray.   Constraints: 1 <= nums.length <= 2 * 10 4 -10 <= nums[i] <= 10 The product of any subarray of  nums  is  guaranteed  to fit in a  32-bit  integer."
200,https://leetcode.com/problems/number-of-islands/,Média,Array,Number of Islands,"Given an  m x n  2D binary grid  grid  which represents a map of  '1' s (land) and  '0' s (water), return  the number of islands . An  island  is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.   Example 1: Input:  grid = [   [""1"",""1"",""1"",""1"",""0""],   [""1"",""1"",""0"",""1"",""0""],   [""1"",""1"",""0"",""0"",""0""],   [""0"",""0"",""0"",""0"",""0""] ] Output:  1 Example 2: Input:  grid = [   [""1"",""1"",""0"",""0"",""0""],   [""1"",""1"",""0"",""0"",""0""],   [""0"",""0"",""1"",""0"",""0""],   [""0"",""0"",""0"",""1"",""1""] ] Output:  3   Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 300 grid[i][j]  is  '0'  or  '1' ."
213,https://leetcode.com/problems/house-robber-ii/,Média,Array,House Robber II,"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are  arranged in a circle.  That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and  it will automatically contact the police if two adjacent houses were broken into on the same night . Given an integer array  nums  representing the amount of money of each house, return  the maximum amount of money you can rob tonight  without alerting the police .   Example 1: Input:  nums = [2,3,2] Output:  3 Explanation:  You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: Input:  nums = [1,2,3,1] Output:  4 Explanation:  Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 3: Input:  nums = [1,2,3] Output:  3   Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 1000"
238,https://leetcode.com/problems/product-of-array-except-self/,Média,Array,Product of Array Except Self,"Given an integer array  nums , return  an array   answer   such that   answer[i]   is equal to the product of all the elements of   nums   except   nums[i] . The product of any prefix or suffix of  nums  is  guaranteed  to fit in a  32-bit  integer. You must write an algorithm that runs in  O(n)  time and without using the division operation.   Example 1: Input:  nums = [1,2,3,4] Output:  [24,12,8,6] Example 2: Input:  nums = [-1,1,0,-3,3] Output:  [0,0,9,0,0]   Constraints: 2 <= nums.length <= 10 5 -30 <= nums[i] <= 30 The input is generated such that  answer[i]  is  guaranteed  to fit in a  32-bit  integer.   Follow up:  Can you solve the problem in  O(1)  extra space complexity? (The output array  does not  count as extra space for space complexity analysis.)"
307,https://leetcode.com/problems/range-sum-query-mutable/,Média,Array,Range Sum Query - Mutable,"Given an integer array  nums , handle multiple queries of the following types: Update  the value of an element in  nums . Calculate the  sum  of the elements of  nums  between indices  left  and  right   inclusive  where  left <= right . Implement the  NumArray  class: NumArray(int[] nums)  Initializes the object with the integer array  nums . void update(int index, int val)   Updates  the value of  nums[index]  to be  val . int sumRange(int left, int right)  Returns the  sum  of the elements of  nums  between indices  left  and  right   inclusive  (i.e.  nums[left] + nums[left + 1] + ... + nums[right] ).   Example 1: Input [""NumArray"", ""sumRange"", ""update"", ""sumRange""] [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]] Output [null, 9, null, 8] Explanation NumArray numArray = new NumArray([1, 3, 5]); numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9 numArray.update(1, 2);   // nums = [1, 2, 5] numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8   Constraints: 1 <= nums.length <= 3 * 10 4 -100 <= nums[i] <= 100 0 <= index < nums.length -100 <= val <= 100 0 <= left <= right < nums.length At most  3 * 10 4  calls will be made to  update  and  sumRange ."
347,https://leetcode.com/problems/top-k-frequent-elements/,Média,Array,Top K Frequent Elements,"Given an integer array  nums  and an integer  k , return  the   k   most frequent elements . You may return the answer in  any order .   Example 1: Input:  nums = [1,1,1,2,2,3], k = 2 Output:  [1,2] Example 2: Input:  nums = [1], k = 1 Output:  [1]   Constraints: 1 <= nums.length <= 10 5 -10 4  <= nums[i] <= 10 4 k  is in the range  [1, the number of unique elements in the array] . It is  guaranteed  that the answer is  unique .   Follow up:  Your algorithm's time complexity must be better than  O(n log n) , where n is the array's size."
373,https://leetcode.com/problems/find-k-pairs-with-smallest-sums/,Média,Array,Find K Pairs with Smallest Sums,"You are given two integer arrays  nums1  and  nums2  sorted in  non-decreasing order  and an integer  k . Define a pair  (u, v)  which consists of one element from the first array and one element from the second array. Return  the   k   pairs   (u 1 , v 1 ), (u 2 , v 2 ), ..., (u k , v k )   with the smallest sums .   Example 1: Input:  nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output:  [[1,2],[1,4],[1,6]] Explanation:  The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input:  nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output:  [[1,1],[1,1]] Explanation:  The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]   Constraints: 1 <= nums1.length, nums2.length <= 10 5 -10 9  <= nums1[i], nums2[i] <= 10 9 nums1  and  nums2  both are sorted in  non-decreasing order . 1 <= k <= 10 4 k <= nums1.length * nums2.length"
378,https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/,Média,Array,Kth Smallest Element in a Sorted Matrix,"Given an  n x n   matrix  where each of the rows and columns is sorted in ascending order, return  the   k th   smallest element in the matrix . Note that it is the  k th  smallest element  in the sorted order , not the  k th   distinct  element. You must find a solution with a memory complexity better than  O(n 2 ) .   Example 1: Input:  matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 Output:  13 Explanation:  The elements in the matrix are [1,5,9,10,11,12,13, 13 ,15], and the 8 th  smallest number is 13 Example 2: Input:  matrix = [[-5]], k = 1 Output:  -5   Constraints: n == matrix.length == matrix[i].length 1 <= n <= 300 -10 9  <= matrix[i][j] <= 10 9 All the rows and columns of  matrix  are  guaranteed  to be sorted in  non-decreasing order . 1 <= k <= n 2   Follow up: Could you solve the problem with a constant memory (i.e.,  O(1)  memory complexity)? Could you solve the problem in  O(n)  time complexity? The solution may be too advanced for an interview but you may find reading  this paper  fun."
436,https://leetcode.com/problems/find-right-interval/,Média,Array,Find Right Interval,"You are given an array of  intervals , where  intervals[i] = [start i , end i ]  and each  start i  is  unique . The  right interval  for an interval  i  is an interval  j  such that  start j  >= end i  and  start j  is  minimized . Note that  i  may equal  j . Return  an array of  right interval  indices for each interval  i . If no  right interval  exists for interval  i , then put  -1  at index  i .   Example 1: Input:  intervals = [[1,2]] Output:  [-1] Explanation:  There is only one interval in the collection, so it outputs -1. Example 2: Input:  intervals = [[3,4],[2,3],[1,2]] Output:  [-1,0,1] Explanation:  There is no right interval for [3,4]. The right interval for [2,3] is [3,4] since start 0  = 3 is the smallest start that is >= end 1  = 3. The right interval for [1,2] is [2,3] since start 1  = 2 is the smallest start that is >= end 2  = 2. Example 3: Input:  intervals = [[1,4],[2,3],[3,4]] Output:  [-1,2,-1] Explanation:  There is no right interval for [1,4] and [3,4]. The right interval for [2,3] is [3,4] since start 2  = 3 is the smallest start that is >= end 1  = 3.   Constraints: 1 <= intervals.length <= 2 * 10 4 intervals[i].length == 2 -10 6  <= start i  <= end i  <= 10 6 The start point of each interval is  unique ."
442,https://leetcode.com/problems/find-all-duplicates-in-an-array/,Média,Array,Find All Duplicates in an Array,"Given an integer array  nums  of length  n  where all the integers of  nums  are in the range  [1, n]  and each integer appears  at most   twice , return  an array of all the integers that appears  twice . You must write an algorithm that runs in  O(n)  time and uses only  constant  auxiliary space, excluding the space needed to store the output   Example 1: Input:  nums = [4,3,2,7,8,2,3,1] Output:  [2,3] Example 2: Input:  nums = [1,1,2] Output:  [1] Example 3: Input:  nums = [1] Output:  []   Constraints: n == nums.length 1 <= n <= 10 5 1 <= nums[i] <= n Each element in  nums  appears  once  or  twice ."
473,https://leetcode.com/problems/matchsticks-to-square/,Média,Array,Matchsticks to Square,"You are given an integer array  matchsticks  where  matchsticks[i]  is the length of the  i th  matchstick. You want to use  all the matchsticks  to make one square. You  should not break  any stick, but you can link them up, and each matchstick must be used  exactly one time . Return  true  if you can make this square and  false  otherwise.   Example 1: Input:  matchsticks = [1,1,2,2,2] Output:  true Explanation:  You can form a square with length 2, one side of the square came two sticks with length 1. Example 2: Input:  matchsticks = [3,3,3,3,4] Output:  false Explanation:  You cannot find a way to form a square with all the matchsticks.   Constraints: 1 <= matchsticks.length <= 15 1 <= matchsticks[i] <= 10 8"
494,https://leetcode.com/problems/target-sum/,Média,Array,Target Sum,"You are given an integer array  nums  and an integer  target . You want to build an  expression  out of nums by adding one of the symbols  '+'  and  '-'  before each integer in nums and then concatenate all the integers. For example, if  nums = [2, 1] , you can add a  '+'  before  2  and a  '-'  before  1  and concatenate them to build the expression  ""+2-1"" . Return the number of different  expressions  that you can build, which evaluates to  target .   Example 1: Input:  nums = [1,1,1,1,1], target = 3 Output:  5 Explanation:  There are 5 ways to assign symbols to make the sum of nums be target 3. -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 Example 2: Input:  nums = [1], target = 1 Output:  1   Constraints: 1 <= nums.length <= 20 0 <= nums[i] <= 1000 0 <= sum(nums[i]) <= 1000 -1000 <= target <= 1000"
503,https://leetcode.com/problems/next-greater-element-ii/,Média,Array,Next Greater Element II,"Given a circular integer array  nums  (i.e., the next element of  nums[nums.length - 1]  is  nums[0] ), return  the  next greater number  for every element in   nums . The  next greater number  of a number  x  is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return  -1  for this number.   Example 1: Input:  nums = [1,2,1] Output:  [2,-1,2] Explanation: The first 1's next greater number is 2;  The number 2 can't find next greater number.  The second 1's next greater number needs to search circularly, which is also 2. Example 2: Input:  nums = [1,2,3,4,3] Output:  [2,3,4,-1,4]   Constraints: 1 <= nums.length <= 10 4 -10 9  <= nums[i] <= 10 9"
540,https://leetcode.com/problems/single-element-in-a-sorted-array/,Média,Array,Single Element in a Sorted Array,"You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return  the single element that appears only once . Your solution must run in  O(log n)  time and  O(1)  space.   Example 1: Input:  nums = [1,1,2,3,3,4,4,8,8] Output:  2 Example 2: Input:  nums = [3,3,7,7,10,11,11] Output:  10   Constraints: 1 <= nums.length <= 10 5 0 <= nums[i] <= 10 5"
636,https://leetcode.com/problems/exclusive-time-of-functions/,Média,Array,Exclusive Time of Functions,"On a  single-threaded  CPU, we execute a program containing  n  functions. Each function has a unique ID between  0  and  n-1 . Function calls are  stored in a  call stack : when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is  the current function being executed . Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list  logs , where  logs[i]  represents the  i th  log message formatted as a string  ""{function_id}:{""start"" | ""end""}:{timestamp}"" . For example,  ""0:start:3""  means a function call with function ID  0   started at the beginning  of timestamp  3 , and  ""1:end:2""  means a function call with function ID  1   ended at the end  of timestamp  2 . Note that a function can be called  multiple times, possibly recursively . A function's  exclusive time  is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for  2  time units and another call executing for  1  time unit, the  exclusive time  is  2 + 1 = 3 . Return  the  exclusive time  of each function in an array, where the value at the  i th  index represents the exclusive time for the function with ID  i .   Example 1: Input:  n = 2, logs = [""0:start:0"",""1:start:2"",""1:end:5"",""0:end:6""] Output:  [3,4] Explanation: Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1. Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5. Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time. So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing. Example 2: Input:  n = 1, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""0:start:6"",""0:end:6"",""0:end:7""] Output:  [8] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls itself again. Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time. Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time. So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing. Example 3: Input:  n = 2, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""1:start:6"",""1:end:6"",""0:end:7""] Output:  [7,1] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls function 1. Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6. Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time. So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.   Constraints: 1 <= n <= 100 2 <= logs.length <= 500 0 <= function_id < n 0 <= timestamp <= 10 9 No two start events will happen at the same timestamp. No two end events will happen at the same timestamp. Each function has an  ""end""  log for each  ""start""  log."
641,https://leetcode.com/problems/design-circular-deque/,Média,Array,Design Circular Deque,"Design your implementation of the circular double-ended queue (deque). Implement the  MyCircularDeque  class: MyCircularDeque(int k)  Initializes the deque with a maximum size of  k . boolean insertFront()  Adds an item at the front of Deque. Returns  true  if the operation is successful, or  false  otherwise. boolean insertLast()  Adds an item at the rear of Deque. Returns  true  if the operation is successful, or  false  otherwise. boolean deleteFront()  Deletes an item from the front of Deque. Returns  true  if the operation is successful, or  false  otherwise. boolean deleteLast()  Deletes an item from the rear of Deque. Returns  true  if the operation is successful, or  false  otherwise. int getFront()  Returns the front item from the Deque. Returns  -1  if the deque is empty. int getRear()  Returns the last item from Deque. Returns  -1  if the deque is empty. boolean isEmpty()  Returns  true  if the deque is empty, or  false  otherwise. boolean isFull()  Returns  true  if the deque is full, or  false  otherwise.   Example 1: Input [""MyCircularDeque"", ""insertLast"", ""insertLast"", ""insertFront"", ""insertFront"", ""getRear"", ""isFull"", ""deleteLast"", ""insertFront"", ""getFront""] [[3], [1], [2], [3], [4], [], [], [], [4], []] Output [null, true, true, true, false, 2, true, true, true, 4] Explanation MyCircularDeque myCircularDeque = new MyCircularDeque(3); myCircularDeque.insertLast(1);  // return True myCircularDeque.insertLast(2);  // return True myCircularDeque.insertFront(3); // return True myCircularDeque.insertFront(4); // return False, the queue is full. myCircularDeque.getRear();      // return 2 myCircularDeque.isFull();       // return True myCircularDeque.deleteLast();   // return True myCircularDeque.insertFront(4); // return True myCircularDeque.getFront();     // return 4   Constraints: 1 <= k <= 1000 0 <= value <= 1000 At most  2000  calls will be made to  insertFront ,  insertLast ,  deleteFront ,  deleteLast ,  getFront ,  getRear ,  isEmpty ,  isFull ."
690,https://leetcode.com/problems/employee-importance/,Média,Array,Employee Importance,"You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs. You are given an array of employees  employees  where: employees[i].id  is the ID of the  i th  employee. employees[i].importance  is the importance value of the  i th  employee. employees[i].subordinates  is a list of the IDs of the direct subordinates of the  i th  employee. Given an integer  id  that represents an employee's ID, return  the  total  importance value of this employee and all their direct and indirect subordinates .   Example 1: Input:  employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1 Output:  11 Explanation:  Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3. They both have an importance value of 3. Thus, the total importance value of employee 1 is 5 + 3 + 3 = 11. Example 2: Input:  employees = [[1,2,[5]],[5,-3,[]]], id = 5 Output:  -3 Explanation:  Employee 5 has an importance value of -3 and has no direct subordinates. Thus, the total importance value of employee 5 is -3.   Constraints: 1 <= employees.length <= 2000 1 <= employees[i].id <= 2000 All  employees[i].id  are  unique . -100 <= employees[i].importance <= 100 One employee has at most one direct leader and may have several subordinates. The IDs in  employees[i].subordinates  are valid IDs."
713,https://leetcode.com/problems/subarray-product-less-than-k/,Média,Array,Subarray Product Less Than K,"Given an array of integers  nums  and an integer  k , return  the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than  k .   Example 1: Input:  nums = [10,5,2,6], k = 100 Output:  8 Explanation:  The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6] Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Example 2: Input:  nums = [1,2,3], k = 0 Output:  0   Constraints: 1 <= nums.length <= 3 * 10 4 1 <= nums[i] <= 1000 0 <= k <= 10 6"
720,https://leetcode.com/problems/longest-word-in-dictionary/,Média,Array,Longest Word in Dictionary,"Given an array of strings  words  representing an English Dictionary, return  the longest word in   words   that can be built one character at a time by other words in   words . If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Note that the word should be built from left to right with each additional character being added to the end of a previous word.    Example 1: Input:  words = [""w"",""wo"",""wor"",""worl"",""world""] Output:  ""world"" Explanation:  The word ""world"" can be built one character at a time by ""w"", ""wo"", ""wor"", and ""worl"". Example 2: Input:  words = [""a"",""banana"",""app"",""appl"",""ap"",""apply"",""apple""] Output:  ""apple"" Explanation:  Both ""apply"" and ""apple"" can be built from other words in the dictionary. However, ""apple"" is lexicographically smaller than ""apply"".   Constraints: 1 <= words.length <= 1000 1 <= words[i].length <= 30 words[i]  consists of lowercase English letters."
721,https://leetcode.com/problems/accounts-merge/,Média,Array,Accounts Merge,"Given a list of  accounts  where each element  accounts[i]  is a list of strings, where the first element  accounts[i][0]  is a name, and the rest of the elements are  emails  representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails  in sorted order . The accounts themselves can be returned in  any order .   Example 1: Input:  accounts = [[""John"",""johnsmith@mail.com"",""john_newyork@mail.com""],[""John"",""johnsmith@mail.com"",""john00@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]] Output:  [[""John"",""john00@mail.com"",""john_newyork@mail.com"",""johnsmith@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]] Explanation: The first and second John's are the same person as they have the common email ""johnsmith@mail.com"". The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted. Example 2: Input:  accounts = [[""Gabe"",""Gabe0@m.co"",""Gabe3@m.co"",""Gabe1@m.co""],[""Kevin"",""Kevin3@m.co"",""Kevin5@m.co"",""Kevin0@m.co""],[""Ethan"",""Ethan5@m.co"",""Ethan4@m.co"",""Ethan0@m.co""],[""Hanzo"",""Hanzo3@m.co"",""Hanzo1@m.co"",""Hanzo0@m.co""],[""Fern"",""Fern5@m.co"",""Fern1@m.co"",""Fern0@m.co""]] Output:  [[""Ethan"",""Ethan0@m.co"",""Ethan4@m.co"",""Ethan5@m.co""],[""Gabe"",""Gabe0@m.co"",""Gabe1@m.co"",""Gabe3@m.co""],[""Hanzo"",""Hanzo0@m.co"",""Hanzo1@m.co"",""Hanzo3@m.co""],[""Kevin"",""Kevin0@m.co"",""Kevin3@m.co"",""Kevin5@m.co""],[""Fern"",""Fern0@m.co"",""Fern1@m.co"",""Fern5@m.co""]]   Constraints: 1 <= accounts.length <= 1000 2 <= accounts[i].length <= 10 1 <= accounts[i][j].length <= 30 accounts[i][0]  consists of English letters. accounts[i][j] (for j > 0)  is a valid email."
729,https://leetcode.com/problems/my-calendar-i/,Média,Array,My Calendar I,"You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a  double booking . A  double booking  happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers  startTime  and  endTime  that represents a booking on the half-open interval  [startTime, endTime) , the range of real numbers  x  such that  startTime <= x < endTime . Implement the  MyCalendar  class: MyCalendar()  Initializes the calendar object. boolean book(int startTime, int endTime)  Returns  true  if the event can be added to the calendar successfully without causing a  double booking . Otherwise, return  false  and do not add the event to the calendar.   Example 1: Input [""MyCalendar"", ""book"", ""book"", ""book""] [[], [10, 20], [15, 25], [20, 30]] Output [null, true, false, true] Explanation MyCalendar myCalendar = new MyCalendar(); myCalendar.book(10, 20); // return True myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event. myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.   Constraints: 0 <= start < end <= 10 9 At most  1000  calls will be made to  book ."
740,https://leetcode.com/problems/delete-and-earn/,Média,Array,Delete and Earn,"You are given an integer array  nums . You want to maximize the number of points you get by performing the following operation any number of times: Pick any  nums[i]  and delete it to earn  nums[i]  points. Afterwards, you must delete  every  element equal to  nums[i] - 1  and  every  element equal to  nums[i] + 1 . Return  the  maximum number of points  you can earn by applying the above operation some number of times .   Example 1: Input:  nums = [3,4,2] Output:  6 Explanation:  You can perform the following operations: - Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2]. - Delete 2 to earn 2 points. nums = []. You earn a total of 6 points. Example 2: Input:  nums = [2,2,3,3,3,4] Output:  9 Explanation:  You can perform the following operations: - Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3]. - Delete a 3 again to earn 3 points. nums = [3]. - Delete a 3 once more to earn 3 points. nums = []. You earn a total of 9 points.   Constraints: 1 <= nums.length <= 2 * 10 4 1 <= nums[i] <= 10 4"
781,https://leetcode.com/problems/rabbits-in-forest/,Média,Array,Rabbits in Forest,"There is a forest with an unknown number of rabbits. We asked n rabbits  ""How many rabbits have the same color as you?""  and collected the answers in an integer array  answers  where  answers[i]  is the answer of the  i th  rabbit. Given the array  answers , return  the minimum number of rabbits that could be in the forest .   Example 1: Input:  answers = [1,1,2] Output:  5 Explanation: The two rabbits that answered ""1"" could both be the same color, say red. The rabbit that answered ""2"" can't be red or the answers would be inconsistent. Say the rabbit that answered ""2"" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Example 2: Input:  answers = [10,10,10] Output:  11   Constraints: 1 <= answers.length <= 1000 0 <= answers[i] < 1000"
789,https://leetcode.com/problems/escape-the-ghosts/,Média,Array,Escape The Ghosts,"You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point  [0, 0] , and you are given a destination point  target = [x target , y target ]  that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array  ghosts , where  ghosts[i] = [x i , y i ]  represents the starting position of the  i th  ghost. All inputs are  integral coordinates . Each turn, you and all the ghosts may independently choose to either  move 1 unit  in any of the four cardinal directions: north, east, south, or west, or  stay still . All actions happen  simultaneously . You escape if and only if you can reach the target  before  any ghost reaches you. If you reach any square (including the target) at the  same time  as a ghost, it  does not  count as an escape. Return  true  if it is possible to escape regardless of how the ghosts move, otherwise return  false .   Example 1: Input:  ghosts = [[1,0],[0,3]], target = [0,1] Output:  true Explanation:  You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you. Example 2: Input:  ghosts = [[1,0]], target = [2,0] Output:  false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination. Example 3: Input:  ghosts = [[2,0]], target = [1,0] Output:  false Explanation:  The ghost can reach the target at the same time as you.   Constraints: 1 <= ghosts.length <= 100 ghosts[i].length == 2 -10 4  <= x i , y i  <= 10 4 There can be  multiple ghosts  in the same location. target.length == 2 -10 4  <= x target , y target  <= 10 4"
807,https://leetcode.com/problems/max-increase-to-keep-city-skyline/,Média,Array,Max Increase to Keep City Skyline,"There is a city composed of  n x n  blocks, where each block contains a single building shaped like a vertical square prism. You are given a  0-indexed   n x n  integer matrix  grid  where  grid[r][c]  represents the  height  of the building located in the block at row  r  and column  c . A city's  skyline  is the outer contour formed by all the building when viewing the side of the city from a distance. The  skyline  from each cardinal direction north, east, south, and west may be different. We are allowed to increase the height of  any number of buildings by any amount  (the amount can be different per building). The height of a  0 -height building can also be increased. However, increasing the height of a building should  not  affect the city's  skyline  from any cardinal direction. Return  the  maximum total sum  that the height of the buildings can be increased by  without  changing the city's  skyline  from any cardinal direction .   Example 1: Input:  grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output:  35 Explanation:  The building heights are shown in the center of the above image. The skylines when viewed from each cardinal direction are drawn in red. The grid after increasing the height of buildings without affecting skylines is: gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ] Example 2: Input:  grid = [[0,0,0],[0,0,0],[0,0,0]] Output:  0 Explanation:  Increasing the height of any building will result in the skyline changing.   Constraints: n == grid.length n == grid[r].length 2 <= n <= 50 0 <= grid[r][c] <= 100"
825,https://leetcode.com/problems/friends-of-appropriate-ages/,Média,Array,Friends Of Appropriate Ages,"There are  n  persons on a social media website. You are given an integer array  ages  where  ages[i]  is the age of the  i th  person. A Person  x  will not send a friend request to a person  y  ( x != y ) if any of the following conditions is true: age[y] <= 0.5 * age[x] + 7 age[y] > age[x] age[y] > 100 && age[x] < 100 Otherwise,  x  will send a friend request to  y . Note that if  x  sends a request to  y ,  y  will not necessarily send a request to  x . Also, a person will not send a friend request to themself. Return  the total number of friend requests made .   Example 1: Input:  ages = [16,16] Output:  2 Explanation:  2 people friend request each other. Example 2: Input:  ages = [16,17,18] Output:  2 Explanation:  Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input:  ages = [20,30,100,110,120] Output:  3 Explanation:  Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.   Constraints: n == ages.length 1 <= n <= 2 * 10 4 1 <= ages[i] <= 120"
845,https://leetcode.com/problems/longest-mountain-in-array/,Média,Array,Longest Mountain in Array,"You may recall that an array  arr  is a  mountain array  if and only if: arr.length >= 3 There exists some index  i  ( 0-indexed ) with  0 < i < arr.length - 1  such that: 	 arr[0] < arr[1] < ... < arr[i - 1] < arr[i] arr[i] > arr[i + 1] > ... > arr[arr.length - 1] Given an integer array  arr , return  the length of the longest subarray, which is a mountain . Return  0  if there is no mountain subarray.   Example 1: Input:  arr = [2,1,4,7,3,2,5] Output:  5 Explanation:  The largest mountain is [1,4,7,3,2] which has length 5. Example 2: Input:  arr = [2,2,2] Output:  0 Explanation:  There is no mountain.   Constraints: 1 <= arr.length <= 10 4 0 <= arr[i] <= 10 4   Follow up: Can you solve it using only one pass? Can you solve it in  O(1)  space?"
861,https://leetcode.com/problems/score-after-flipping-matrix/,Média,Array,Score After Flipping Matrix,"You are given an  m x n  binary matrix  grid . A  move  consists of choosing any row or column and toggling each value in that row or column (i.e., changing all  0 's to  1 's, and all  1 's to  0 's). Every row of the matrix is interpreted as a binary number, and the  score  of the matrix is the sum of these numbers. Return  the highest possible  score  after making any number of  moves  (including zero moves) .   Example 1: Input:  grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output:  39 Explanation:  0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2: Input:  grid = [[0]] Output:  1   Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 20 grid[i][j]  is either  0  or  1 ."
875,https://leetcode.com/problems/koko-eating-bananas/,Média,Array,Koko Eating Bananas,"Koko loves to eat bananas. There are  n  piles of bananas, the  i th  pile has  piles[i]  bananas. The guards have gone and will come back in  h  hours. Koko can decide her bananas-per-hour eating speed of  k . Each hour, she chooses some pile of bananas and eats  k  bananas from that pile. If the pile has less than  k  bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return  the minimum integer   k   such that she can eat all the bananas within   h   hours .   Example 1: Input:  piles = [3,6,7,11], h = 8 Output:  4 Example 2: Input:  piles = [30,11,23,4,20], h = 5 Output:  30 Example 3: Input:  piles = [30,11,23,4,20], h = 6 Output:  23   Constraints: 1 <= piles.length <= 10 4 piles.length <= h <= 10 9 1 <= piles[i] <= 10 9"
898,https://leetcode.com/problems/bitwise-ors-of-subarrays/,Média,Array,Bitwise ORs of Subarrays,"Given an integer array  arr , return  the number of distinct bitwise ORs of all the non-empty subarrays of   arr . The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer. A  subarray  is a contiguous non-empty sequence of elements within an array.   Example 1: Input:  arr = [0] Output:  1 Explanation:  There is only one possible result: 0. Example 2: Input:  arr = [1,1,2] Output:  3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3. Example 3: Input:  arr = [1,2,4] Output:  6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.   Constraints: 1 <= arr.length <= 5 * 10 4 0 <= arr[i] <= 10 9"
900,https://leetcode.com/problems/rle-iterator/,Média,Array,RLE Iterator,"We can use run-length encoding (i.e.,  RLE ) to encode a sequence of integers. In a run-length encoded array of even length  encoding  ( 0-indexed ), for all even  i ,  encoding[i]  tells us the number of times that the non-negative integer value  encoding[i + 1]  is repeated in the sequence. For example, the sequence  arr = [8,8,8,5,5]  can be encoded to be  encoding = [3,8,2,5] .  encoding = [3,8,0,9,2,5]  and  encoding = [2,8,1,8,2,5]  are also valid  RLE  of  arr . Given a run-length encoded array, design an iterator that iterates through it. Implement the  RLEIterator  class: RLEIterator(int[] encoded)  Initializes the object with the encoded array  encoded . int next(int n)  Exhausts the next  n  elements and returns the last element exhausted in this way. If there is no element left to exhaust, return  -1  instead.   Example 1: Input [""RLEIterator"", ""next"", ""next"", ""next"", ""next""] [[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]] Output [null, 8, 8, 5, -1] Explanation RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5]. rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5]. rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5]. rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5]. rLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5, but the second term did not exist. Since the last term exhausted does not exist, we return -1.   Constraints: 2 <= encoding.length <= 1000 encoding.length  is even. 0 <= encoding[i] <= 10 9 1 <= n <= 10 9 At most  1000  calls will be made to  next ."
907,https://leetcode.com/problems/sum-of-subarray-minimums/,Média,Array,Sum of Subarray Minimums,"Given an array of integers arr, find the sum of  min(b) , where  b  ranges over every (contiguous) subarray of  arr . Since the answer may be large, return the answer  modulo   10 9  + 7 .   Example 1: Input:  arr = [3,1,2,4] Output:  17 Explanation:   Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. Example 2: Input:  arr = [11,81,94,43,3] Output:  444   Constraints: 1 <= arr.length <= 3 * 10 4 1 <= arr[i] <= 3 * 10 4"
909,https://leetcode.com/problems/snakes-and-ladders/,Média,Array,Snakes and Ladders,"You are given an  n x n  integer matrix  board  where the cells are labeled from  1  to  n 2  in a  Boustrophedon style  starting from the bottom left of the board (i.e.  board[n - 1][0] ) and alternating direction each row. You start on square  1  of the board. In each move, starting from square  curr , do the following: Choose a destination square  next  with a label in the range  [curr + 1, min(curr + 6, n 2 )] . 	 This choice simulates the result of a standard  6-sided die roll : i.e., there are always at most 6 destinations, regardless of the size of the board. If  next  has a snake or ladder, you  must  move to the destination of that snake or ladder. Otherwise, you move to  next . The game ends when you reach the square  n 2 . A board square on row  r  and column  c  has a snake or ladder if  board[r][c] != -1 . The destination of that snake or ladder is  board[r][c] . Squares  1  and  n 2  are not the starting points of any snake or ladder. Note that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do  not  follow the subsequent snake or ladder. For example, suppose the board is  [[-1,4],[-1,3]] , and on the first move, your destination square is  2 . You follow the ladder to square  3 , but do  not  follow the subsequent ladder to  4 . Return  the least number of dice rolls required to reach the square  n 2 . If it is not possible to reach the square, return  -1 .   Example 1: Input:  board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]] Output:  4 Explanation:   In the beginning, you start at square 1 (at row 5, column 0). You decide to move to square 2 and must take the ladder to square 15. You then decide to move to square 17 and must take the snake to square 13. You then decide to move to square 14 and must take the ladder to square 35. You then decide to move to square 36, ending the game. This is the lowest possible number of moves to reach the last square, so return 4. Example 2: Input:  board = [[-1,-1],[-1,3]] Output:  1   Constraints: n == board.length == board[i].length 2 <= n <= 20 board[i][j]  is either  -1  or in the range  [1, n 2 ] . The squares labeled  1  and  n 2  are not the starting points of any snake or ladder."
932,https://leetcode.com/problems/beautiful-array/,Média,Array,Beautiful Array,"An array  nums  of length  n  is  beautiful  if: nums  is a permutation of the integers in the range  [1, n] . For every  0 <= i < j < n , there is no index  k  with  i < k < j  where  2 * nums[k] == nums[i] + nums[j] . Given the integer  n , return  any  beautiful  array  nums  of length  n . There will be at least one valid answer for the given  n .   Example 1: Input:  n = 4 Output:  [2,1,4,3] Example 2: Input:  n = 5 Output:  [3,1,2,5,4]   Constraints: 1 <= n <= 1000"
939,https://leetcode.com/problems/minimum-area-rectangle/,Média,Array,Minimum Area Rectangle,"You are given an array of points in the  X-Y  plane  points  where  points[i] = [x i , y i ] . Return  the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes . If there is not any such rectangle, return  0 .   Example 1: Input:  points = [[1,1],[1,3],[3,1],[3,3],[2,2]] Output:  4 Example 2: Input:  points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output:  2   Constraints: 1 <= points.length <= 500 points[i].length == 2 0 <= x i , y i  <= 4 * 10 4 All the given points are  unique ."
950,https://leetcode.com/problems/reveal-cards-in-increasing-order/,Média,Array,Reveal Cards In Increasing Order,"You are given an integer array  deck . There is a deck of cards where every card has a unique integer. The integer on the  i th  card is  deck[i] . You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return  an ordering of the deck that would reveal the cards in increasing order . Note  that the first entry in the answer is considered to be the top of the deck.   Example 1: Input:  deck = [17,13,11,2,3,5,7] Output:  [2,13,3,11,5,17,7] Explanation:   We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom.  The deck is now [13,17]. We reveal 13, and move 17 to the bottom.  The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Example 2: Input:  deck = [1,1000] Output:  [1,1000]   Constraints: 1 <= deck.length <= 1000 1 <= deck[i] <= 10 6 All the values of  deck  are  unique ."
963,https://leetcode.com/problems/minimum-area-rectangle-ii/,Média,Array,Minimum Area Rectangle II,"You are given an array of points in the  X-Y  plane  points  where  points[i] = [x i , y i ] . Return  the minimum area of any rectangle formed from these points, with sides  not necessarily parallel  to the X and Y axes . If there is not any such rectangle, return  0 . Answers within  10 -5  of the actual answer will be accepted.   Example 1: Input:  points = [[1,2],[2,1],[1,0],[0,1]] Output:  2.00000 Explanation:  The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2. Example 2: Input:  points = [[0,1],[2,1],[1,1],[1,0],[2,0]] Output:  1.00000 Explanation:  The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1. Example 3: Input:  points = [[0,3],[1,2],[3,1],[1,3],[2,1]] Output:  0 Explanation:  There is no possible rectangle to form from these points.   Constraints: 1 <= points.length <= 50 points[i].length == 2 0 <= x i , y i  <= 4 * 10 4 All the given points are  unique ."
1008,https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/,Média,Array,Construct Binary Search Tree from Preorder Traversal,"Given an array of integers preorder, which represents the  preorder traversal  of a BST (i.e.,  binary search tree ), construct the tree and return  its root . It is  guaranteed  that there is always possible to find a binary search tree with the given requirements for the given test cases. A  binary search tree  is a binary tree where for every node, any descendant of  Node.left  has a value  strictly less than   Node.val , and any descendant of  Node.right  has a value  strictly greater than   Node.val . A  preorder traversal  of a binary tree displays the value of the node first, then traverses  Node.left , then traverses  Node.right .   Example 1: Input:  preorder = [8,5,1,7,10,12] Output:  [8,5,10,1,7,null,12] Example 2: Input:  preorder = [1,3] Output:  [1,null,3]   Constraints: 1 <= preorder.length <= 100 1 <= preorder[i] <= 1000 All the values of  preorder  are  unique ."
1020,https://leetcode.com/problems/number-of-enclaves/,Média,Array,Number of Enclaves,"You are given an  m x n  binary matrix  grid , where  0  represents a sea cell and  1  represents a land cell. A  move  consists of walking from one land cell to another adjacent ( 4-directionally ) land cell or walking off the boundary of the  grid . Return  the number of land cells in   grid   for which we cannot walk off the boundary of the grid in any number of  moves .   Example 1: Input:  grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output:  3 Explanation:  There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. Example 2: Input:  grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output:  0 Explanation:  All 1s are either on the boundary or can reach the boundary.   Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 500 grid[i][j]  is either  0  or  1 ."
1043,https://leetcode.com/problems/partition-array-for-maximum-sum/,Média,Array,Partition Array for Maximum Sum,"Given an integer array  arr , partition the array into (contiguous) subarrays of length  at most   k . After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return  the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a  32-bit  integer.   Example 1: Input:  arr = [1,15,7,9,2,5,10], k = 3 Output:  84 Explanation:  arr becomes [15,15,15,9,10,10,10] Example 2: Input:  arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4 Output:  83 Example 3: Input:  arr = [1], k = 1 Output:  1   Constraints: 1 <= arr.length <= 500 0 <= arr[i] <= 10 9 1 <= k <= arr.length"
1131,https://leetcode.com/problems/maximum-of-absolute-value-expression/,Média,Array,Maximum of Absolute Value Expression,"Given two arrays of integers with equal lengths, return the maximum value of: |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| where the maximum is taken over all  0 <= i, j < arr1.length .   Example 1: Input:  arr1 = [1,2,3,4], arr2 = [-1,4,5,6] Output:  13 Example 2: Input:  arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4] Output:  20   Constraints: 2 <= arr1.length == arr2.length <= 40000 -10^6 <= arr1[i], arr2[i] <= 10^6"
1191,https://leetcode.com/problems/k-concatenation-maximum-sum/,Média,Array,K-Concatenation Maximum Sum,"Given an integer array  arr  and an integer  k , modify the array by repeating it  k  times. For example, if  arr = [1, 2]  and  k = 3  then the modified array will be  [1, 2, 1, 2, 1, 2] . Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be  0  and its sum in that case is  0 . As the answer can be very large, return the answer  modulo   10 9  + 7 .   Example 1: Input:  arr = [1,2], k = 3 Output:  9 Example 2: Input:  arr = [1,-2,1], k = 5 Output:  2 Example 3: Input:  arr = [-1,-2], k = 7 Output:  0   Constraints: 1 <= arr.length <= 10 5 1 <= k <= 10 5 -10 4  <= arr[i] <= 10 4"
1233,https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/,Média,Array,Remove Sub-Folders from the Filesystem,"Given a list of folders  folder , return  the folders after removing all  sub-folders  in those folders . You may return the answer in  any order . If a  folder[i]  is located within another  folder[j] , it is called a  sub-folder  of it. A sub-folder of  folder[j]  must start with  folder[j] , followed by a  ""/"" . For example,  ""/a/b""  is a sub-folder of  ""/a"" , but  ""/b""  is not a sub-folder of  ""/a/b/c"" . The format of a path is one or more concatenated strings of the form:  '/'  followed by one or more lowercase English letters. For example,  ""/leetcode""  and  ""/leetcode/problems""  are valid paths while an empty string and  ""/""  are not.   Example 1: Input:  folder = [""/a"",""/a/b"",""/c/d"",""/c/d/e"",""/c/f""] Output:  [""/a"",""/c/d"",""/c/f""] Explanation:  Folders ""/a/b"" is a subfolder of ""/a"" and ""/c/d/e"" is inside of folder ""/c/d"" in our filesystem. Example 2: Input:  folder = [""/a"",""/a/b/c"",""/a/b/d""] Output:  [""/a""] Explanation:  Folders ""/a/b/c"" and ""/a/b/d"" will be removed because they are subfolders of ""/a"". Example 3: Input:  folder = [""/a/b/c"",""/a/b/ca"",""/a/b/d""] Output:  [""/a/b/c"",""/a/b/ca"",""/a/b/d""]   Constraints: 1 <= folder.length <= 4 * 10 4 2 <= folder[i].length <= 100 folder[i]  contains only lowercase letters and  '/' . folder[i]  always starts with the character  '/' . Each folder name is  unique ."
1268,https://leetcode.com/problems/search-suggestions-system/,Média,Array,Search Suggestions System,"You are given an array of strings  products  and a string  searchWord . Design a system that suggests at most three product names from  products  after each character of  searchWord  is typed. Suggested products should have common prefix with  searchWord . If there are more than three products with a common prefix return the three lexicographically minimums products. Return  a list of lists of the suggested products after each character of  searchWord  is typed .   Example 1: Input:  products = [""mobile"",""mouse"",""moneypot"",""monitor"",""mousepad""], searchWord = ""mouse"" Output:  [[""mobile"",""moneypot"",""monitor""],[""mobile"",""moneypot"",""monitor""],[""mouse"",""mousepad""],[""mouse"",""mousepad""],[""mouse"",""mousepad""]] Explanation:  products sorted lexicographically = [""mobile"",""moneypot"",""monitor"",""mouse"",""mousepad""]. After typing m and mo all products match and we show user [""mobile"",""moneypot"",""monitor""]. After typing mou, mous and mouse the system suggests [""mouse"",""mousepad""]. Example 2: Input:  products = [""havana""], searchWord = ""havana"" Output:  [[""havana""],[""havana""],[""havana""],[""havana""],[""havana""],[""havana""]] Explanation:  The only word ""havana"" will be always suggested while typing the search word.   Constraints: 1 <= products.length <= 1000 1 <= products[i].length <= 3000 1 <= sum(products[i].length) <= 2 * 10 4 All the strings of  products  are  unique . products[i]  consists of lowercase English letters. 1 <= searchWord.length <= 1000 searchWord  consists of lowercase English letters."
1381,https://leetcode.com/problems/design-a-stack-with-increment-operation/,Média,Array,Design a Stack With Increment Operation,"Design a stack that supports increment operations on its elements. Implement the  CustomStack  class: CustomStack(int maxSize)  Initializes the object with  maxSize  which is the maximum number of elements in the stack. void push(int x)  Adds  x  to the top of the stack if the stack has not reached the  maxSize . int pop()  Pops and returns the top of the stack or  -1  if the stack is empty. void inc(int k, int val)  Increments the bottom  k  elements of the stack by  val . If there are less than  k  elements in the stack, increment all the elements in the stack.   Example 1: Input [""CustomStack"",""push"",""push"",""pop"",""push"",""push"",""push"",""increment"",""increment"",""pop"",""pop"",""pop"",""pop""] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] Output [null,null,null,2,null,null,null,null,null,103,202,201,-1] Explanation CustomStack stk = new CustomStack(3); // Stack is Empty [] stk.push(1);                          // stack becomes [1] stk.push(2);                          // stack becomes [1, 2] stk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1] stk.push(2);                          // stack becomes [1, 2] stk.push(3);                          // stack becomes [1, 2, 3] stk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4 stk.increment(5, 100);                // stack becomes [101, 102, 103] stk.increment(2, 100);                // stack becomes [201, 202, 103] stk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202] stk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201] stk.pop();                            // return 201 --> Return top of the stack 201, stack becomes [] stk.pop();                            // return -1 --> Stack is empty return -1.   Constraints: 1 <= maxSize, x, k <= 1000 0 <= val <= 100 At most  1000  calls will be made to each method of  increment ,  push  and  pop  each separately."
1508,https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/,Média,Array,Range Sum of Sorted Subarray Sums,"You are given the array  nums  consisting of  n  positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of  n * (n + 1) / 2  numbers. Return the sum of the numbers from index  left  to index  right  ( indexed from 1 ) , inclusive, in the new array.  Since the answer can be a huge number return it modulo  10 9  + 7 .   Example 1: Input:  nums = [1,2,3,4], n = 4, left = 1, right = 5 Output:  13  Explanation:  All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13.  Example 2: Input:  nums = [1,2,3,4], n = 4, left = 3, right = 4 Output:  6 Explanation:  The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6. Example 3: Input:  nums = [1,2,3,4], n = 4, left = 1, right = 10 Output:  50   Constraints: n == nums.length 1 <= nums.length <= 1000 1 <= nums[i] <= 100 1 <= left <= right <= n * (n + 1) / 2"
1509,https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/,Média,Array,Minimum Difference Between Largest and Smallest Value in Three Moves,"You are given an integer array  nums . In one move, you can choose one element of  nums  and change it to  any value . Return  the minimum difference between the largest and smallest value of  nums   after performing at most three moves .   Example 1: Input:  nums = [5,3,2,4] Output:  0 Explanation:  We can make at most 3 moves. In the first move, change 2 to 3. nums becomes [5,3,3,4]. In the second move, change 4 to 3. nums becomes [5,3,3,3]. In the third move, change 5 to 3. nums becomes [3,3,3,3]. After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0. Example 2: Input:  nums = [1,5,0,10,14] Output:  1 Explanation:  We can make at most 3 moves. In the first move, change 5 to 0. nums becomes [1,0,0,10,14]. In the second move, change 10 to 0. nums becomes [1,0,0,0,14]. In the third move, change 14 to 1. nums becomes [1,0,0,0,1]. After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1. It can be shown that there is no way to make the difference 0 in 3 moves. Example 3: Input:  nums = [3,100,20] Output:  0 Explanation:  We can make at most 3 moves. In the first move, change 100 to 7. nums becomes [3,7,20]. In the second move, change 20 to 7. nums becomes [3,7,7]. In the third move, change 3 to 7. nums becomes [7,7,7]. After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.   Constraints: 1 <= nums.length <= 10 5 -10 9  <= nums[i] <= 10 9"
1578,https://leetcode.com/problems/minimum-time-to-make-rope-colorful/,Média,Array,Minimum Time to Make Rope Colorful,"Alice has  n  balloons arranged on a rope. You are given a  0-indexed  string  colors  where  colors[i]  is the color of the  i th  balloon. Alice wants the rope to be  colorful . She does not want  two consecutive balloons  to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it  colorful . You are given a  0-indexed  integer array  neededTime  where  neededTime[i]  is the time (in seconds) that Bob needs to remove the  i th  balloon from the rope. Return  the  minimum time  Bob needs to make the rope  colorful .   Example 1: Input:  colors = ""abaac"", neededTime = [1,2,3,4,5] Output:  3 Explanation:  In the above image, 'a' is blue, 'b' is red, and 'c' is green. Bob can remove the blue balloon at index 2. This takes 3 seconds. There are no longer two consecutive balloons of the same color. Total time = 3. Example 2: Input:  colors = ""abc"", neededTime = [1,2,3] Output:  0 Explanation:  The rope is already colorful. Bob does not need to remove any balloons from the rope. Example 3: Input:  colors = ""aabaa"", neededTime = [1,2,3,4,1] Output:  2 Explanation:  Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove. There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.   Constraints: n == colors.length == neededTime.length 1 <= n <= 10 5 1 <= neededTime[i] <= 10 4 colors  contains only lowercase English letters."
1590,https://leetcode.com/problems/make-sum-divisible-by-p/,Média,Array,Make Sum Divisible by P,"Given an array of positive integers  nums , remove the  smallest  subarray (possibly  empty ) such that the  sum  of the remaining elements is divisible by  p . It is  not  allowed to remove the whole array. Return  the length of the smallest subarray that you need to remove, or  -1  if it's impossible . A  subarray  is defined as a contiguous block of elements in the array.   Example 1: Input:  nums = [3,1,4,2], p = 6 Output:  1 Explanation:  The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6. Example 2: Input:  nums = [6,3,5,2], p = 9 Output:  2 Explanation:  We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9. Example 3: Input:  nums = [1,2,3], p = 3 Output:  0 Explanation:  Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9 1 <= p <= 10 9"
1594,https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/,Média,Array,Maximum Non Negative Product in a Matrix,"You are given a  m x n  matrix  grid . Initially, you are located at the top-left corner  (0, 0) , and in each step, you can only  move right or down  in the matrix. Among all possible paths starting from the top-left corner  (0, 0)  and ending in the bottom-right corner  (m - 1, n - 1) , find the path with the  maximum non-negative product . The product of a path is the product of all integers in the grid cells visited along the path. Return the  maximum non-negative product  modulo   10 9  + 7 .  If the maximum product is  negative , return  -1 . Notice that the modulo is performed after getting the maximum product.   Example 1: Input:  grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]] Output:  -1 Explanation:  It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1. Example 2: Input:  grid = [[1,-2,1],[1,-2,1],[3,-4,1]] Output:  8 Explanation:  Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8). Example 3: Input:  grid = [[1,3],[0,-4]] Output:  0 Explanation:  Maximum non-negative product is shown (1 * 0 * -4 = 0).   Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 15 -4 <= grid[i][j] <= 4"
1626,https://leetcode.com/problems/best-team-with-no-conflicts/,Média,Array,Best Team With No Conflicts,"You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the  sum  of scores of all the players in the team. However, the basketball team is not allowed to have  conflicts . A  conflict  exists if a younger player has a  strictly higher  score than an older player. A conflict does  not  occur between players of the same age. Given two lists,  scores  and  ages , where each  scores[i]  and  ages[i]  represents the score and age of the  i th  player, respectively, return  the highest overall score of all possible basketball teams .   Example 1: Input:  scores = [1,3,5,10,15], ages = [1,2,3,4,5] Output:  34 Explanation:  You can choose all the players. Example 2: Input:  scores = [4,5,6,5], ages = [2,1,2,1] Output:  16 Explanation:  It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age. Example 3: Input:  scores = [1,2,3,5], ages = [8,9,10,1] Output:  6 Explanation:  It is best to choose the first 3 players.    Constraints: 1 <= scores.length, ages.length <= 1000 scores.length == ages.length 1 <= scores[i] <= 10 6 1 <= ages[i] <= 1000"
1670,https://leetcode.com/problems/design-front-middle-back-queue/,Média,Array,Design Front Middle Back Queue,"Design a queue that supports  push  and  pop  operations in the front, middle, and back. Implement the  FrontMiddleBack  class: FrontMiddleBack()  Initializes the queue. void pushFront(int val)  Adds  val  to the  front  of the queue. void pushMiddle(int val)  Adds  val  to the  middle  of the queue. void pushBack(int val)  Adds  val  to the  back  of the queue. int popFront()  Removes the  front  element of the queue and returns it. If the queue is empty, return  -1 . int popMiddle()  Removes the  middle  element of the queue and returns it. If the queue is empty, return  -1 . int popBack()  Removes the  back  element of the queue and returns it. If the queue is empty, return  -1 . Notice  that when there are  two  middle position choices, the operation is performed on the  frontmost  middle position choice. For example: Pushing  6  into the middle of  [1, 2, 3, 4, 5]  results in  [1, 2,  6 , 3, 4, 5] . Popping the middle from  [1, 2,  3 , 4, 5, 6]  returns  3  and results in  [1, 2, 4, 5, 6] .   Example 1: Input: [""FrontMiddleBackQueue"", ""pushFront"", ""pushBack"", ""pushMiddle"", ""pushMiddle"", ""popFront"", ""popMiddle"", ""popMiddle"", ""popBack"", ""popFront""] [[], [1], [2], [3], [4], [], [], [], [], []] Output: [null, null, null, null, null, 1, 3, 4, 2, -1] Explanation: FrontMiddleBackQueue q = new FrontMiddleBackQueue(); q.pushFront(1);   // [ 1 ] q.pushBack(2);    // [1,  2 ] q.pushMiddle(3);  // [1,  3 , 2] q.pushMiddle(4);  // [1,  4 , 3, 2] q.popFront();     // return 1 -> [4, 3, 2] q.popMiddle();    // return 3 -> [4, 2] q.popMiddle();    // return 4 -> [2] q.popBack();      // return 2 -> [] q.popFront();     // return -1 -> [] (The queue is empty)   Constraints: 1 <= val <= 10 9 At most  1000  calls will be made to  pushFront ,  pushMiddle ,  pushBack ,  popFront ,  popMiddle , and  popBack ."
1679,https://leetcode.com/problems/max-number-of-k-sum-pairs/,Média,Array,Max Number of K-Sum Pairs,"You are given an integer array  nums  and an integer  k . In one operation, you can pick two numbers from the array whose sum equals  k  and remove them from the array. Return  the maximum number of operations you can perform on the array .   Example 1: Input:  nums = [1,2,3,4], k = 5 Output:  2 Explanation:  Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Example 2: Input:  nums = [3,1,3,4,3], k = 6 Output:  1 Explanation:  Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9 1 <= k <= 10 9"
1705,https://leetcode.com/problems/maximum-number-of-eaten-apples/,Média,Array,Maximum Number of Eaten Apples,"There is a special kind of apple tree that grows apples every day for  n  days. On the  i th  day, the tree grows  apples[i]  apples that will rot after  days[i]  days, that is on day  i + days[i]  the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by  apples[i] == 0  and  days[i] == 0 . You decided to eat  at most  one apple a day (to keep the doctors away). Note that you can keep eating after the first  n  days. Given two integer arrays  days  and  apples  of length  n , return  the maximum number of apples you can eat.   Example 1: Input:  apples = [1,2,3,5,2], days = [3,2,1,4,2] Output:  7 Explanation:  You can eat 7 apples: - On the first day, you eat an apple that grew on the first day. - On the second day, you eat an apple that grew on the second day. - On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot. - On the fourth to the seventh days, you eat apples that grew on the fourth day. Example 2: Input:  apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] Output:  5 Explanation:  You can eat 5 apples: - On the first to the third day you eat apples that grew on the first day. - Do nothing on the fouth and fifth days. - On the sixth and seventh days you eat apples that grew on the sixth day.   Constraints: n == apples.length == days.length 1 <= n <= 2 * 10 4 0 <= apples[i], days[i] <= 2 * 10 4 days[i] = 0  if and only if  apples[i] = 0 ."
1738,https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/,Média,Array,Find Kth Largest XOR Coordinate Value,"You are given a 2D  matrix  of size  m x n , consisting of non-negative integers. You are also given an integer  k . The  value  of coordinate  (a, b)  of the matrix is the XOR of all  matrix[i][j]  where  0 <= i <= a < m  and  0 <= j <= b < n   (0-indexed) . Find the  k th  largest value  (1-indexed)  of all the coordinates of  matrix .   Example 1: Input:  matrix = [[5,2],[1,6]], k = 1 Output:  7 Explanation:  The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value. Example 2: Input:  matrix = [[5,2],[1,6]], k = 2 Output:  5 Explanation:  The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value. Example 3: Input:  matrix = [[5,2],[1,6]], k = 3 Output:  4 Explanation:  The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.   Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 1000 0 <= matrix[i][j] <= 10 6 1 <= k <= m * n"
1749,https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/,Média,Array,Maximum Absolute Sum of Any Subarray,"You are given an integer array  nums . The  absolute sum  of a subarray  [nums l , nums l+1 , ..., nums r-1 , nums r ]  is  abs(nums l  + nums l+1  + ... + nums r-1  + nums r ) . Return  the  maximum  absolute sum of any  (possibly empty)  subarray of  nums . Note that  abs(x)  is defined as follows: If  x  is a negative integer, then  abs(x) = -x . If  x  is a non-negative integer, then  abs(x) = x .   Example 1: Input:  nums = [1,-3,2,3,-4] Output:  5 Explanation:  The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5. Example 2: Input:  nums = [2,-5,1,-4,3,-2] Output:  8 Explanation:  The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.   Constraints: 1 <= nums.length <= 10 5 -10 4  <= nums[i] <= 10 4"
1818,https://leetcode.com/problems/minimum-absolute-sum-difference/,Média,Array,Minimum Absolute Sum Difference,"You are given two positive integer arrays  nums1  and  nums2 , both of length  n . The  absolute sum difference  of arrays  nums1  and  nums2  is defined as the  sum  of  |nums1[i] - nums2[i]|  for each  0 <= i < n  ( 0-indexed ). You can replace  at most one  element of  nums1  with  any  other element in  nums1  to  minimize  the absolute sum difference. Return the  minimum absolute sum difference  after  replacing at most one   element in the array  nums1 .  Since the answer may be large, return it  modulo   10 9  + 7 . |x|  is defined as: x  if  x >= 0 , or -x  if  x < 0 .   Example 1: Input:  nums1 = [1,7,5], nums2 = [2,3,5] Output:  3 Explanation:  There are two possible optimal solutions: - Replace the second element with the first: [1, 7 ,5] => [1, 1 ,5], or - Replace the second element with the third: [1, 7 ,5] => [1, 5 ,5]. Both will yield an absolute sum difference of  |1-2| + (|1-3| or |5-3|) + |5-5| =  3. Example 2: Input:  nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10] Output:  0 Explanation:  nums1 is equal to nums2 so no replacement is needed. This will result in an  absolute sum difference of 0. Example 3: Input:  nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4] Output:  20 Explanation:  Replace the first element with the second: [ 1 ,10,4,4,2,7] => [ 10 ,10,4,4,2,7]. This yields an absolute sum difference of  |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20   Constraints: n == nums1.length n == nums2.length 1 <= n <= 10 5 1 <= nums1[i], nums2[i] <= 10 5"
1833,https://leetcode.com/problems/maximum-ice-cream-bars/,Média,Array,Maximum Ice Cream Bars,"It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are  n  ice cream bars. You are given an array  costs  of length  n , where  costs[i]  is the price of the  i th  ice cream bar in coins. The boy initially has  coins  coins to spend, and he wants to buy as many ice cream bars as possible.  Note:  The boy can buy the ice cream bars in any order. Return  the  maximum  number of ice cream bars the boy can buy with  coins  coins. You must solve the problem by counting sort.   Example 1: Input:  costs = [1,3,2,4,1], coins = 7 Output:  4 Explanation:  The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. Example 2: Input:  costs = [10,6,8,7,7,8], coins = 5 Output:  0 Explanation:  The boy cannot afford any of the ice cream bars. Example 3: Input:  costs = [1,6,3,1,2,5], coins = 20 Output:  6 Explanation:  The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.   Constraints: costs.length == n 1 <= n <= 10 5 1 <= costs[i] <= 10 5 1 <= coins <= 10 8"
1834,https://leetcode.com/problems/single-threaded-cpu/,Média,Array,Single-Threaded CPU,"You are given  n ​​​​​​ tasks labeled from  0  to  n - 1  represented by a 2D integer array  tasks , where  tasks[i] = [enqueueTime i , processingTime i ]  means that the  i ​​​​​​th ​​​​ task will be available to process at  enqueueTime i  and will take  processingTime i   to finish processing. You have a single-threaded CPU that can process  at most one  task at a time and will act in the following way: If the CPU is idle and there are no available tasks to process, the CPU remains idle. If the CPU is idle and there are available tasks, the CPU will choose the one with the  shortest processing time . If multiple tasks have the same shortest processing time, it will choose the task with the smallest index. Once a task is started, the CPU will  process the entire task  without stopping. The CPU can finish a task then start a new one instantly. Return  the order in which the CPU will process the tasks.   Example 1: Input:  tasks = [[1,2],[2,4],[3,2],[4,1]] Output:  [0,2,3,1] Explanation:  The events go as follows:  - At time = 1, task 0 is available to process. Available tasks = {0}. - Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}. - At time = 2, task 1 is available to process. Available tasks = {1}. - At time = 3, task 2 is available to process. Available tasks = {1, 2}. - Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}. - At time = 4, task 3 is available to process. Available tasks = {1, 3}. - At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}. - At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}. - At time = 10, the CPU finishes task 1 and becomes idle. Example 2: Input:  tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] Output:  [4,3,2,0,1] Explanation :  The events go as follows: - At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}. - Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}. - At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}. - At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}. - At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}. - At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}. - At time = 40, the CPU finishes task 1 and becomes idle.   Constraints: tasks.length == n 1 <= n <= 10 5 1 <= enqueueTime i , processingTime i  <= 10 9"
1911,https://leetcode.com/problems/maximum-alternating-subsequence-sum/,Média,Array,Maximum Alternating Subsequence Sum,"The  alternating sum  of a  0-indexed  array is defined as the  sum  of the elements at  even  indices  minus  the  sum  of the elements at  odd  indices. For example, the alternating sum of  [4,2,5,3]  is  (4 + 5) - (2 + 3) = 4 . Given an array  nums , return  the  maximum alternating sum  of any subsequence of  nums  (after  reindexing  the elements of the subsequence) . A  subsequence  of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example,  [2,7,4]  is a subsequence of  [4, 2 ,3, 7 ,2,1, 4 ]  (the underlined elements), while  [2,4,2]  is not.   Example 1: Input:  nums = [ 4 , 2 , 5 ,3] Output:  7 Explanation:  It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7. Example 2: Input:  nums = [5,6,7, 8 ] Output:  8 Explanation:  It is optimal to choose the subsequence [8] with alternating sum 8. Example 3: Input:  nums = [ 6 ,2, 1 ,2,4, 5 ] Output:  10 Explanation:  It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 5"
1914,https://leetcode.com/problems/cyclically-rotating-a-grid/,Média,Array,Cyclically Rotating a Grid,"You are given an  m x n  integer matrix  grid ​​​, where  m  and  n  are both  even  integers, and an integer  k . The matrix is composed of several layers, which is shown in the below image, where each color is its own layer: A cyclic rotation of the matrix is done by cyclically rotating  each layer  in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the  counter-clockwise  direction. An example rotation is shown below: Return  the matrix after applying  k   cyclic rotations to it .   Example 1: Input:  grid = [[40,10],[30,20]], k = 1 Output:  [[10,20],[40,30]] Explanation:  The figures above represent the grid at every state. Example 2:     Input:  grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2 Output:  [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] Explanation:  The figures above represent the grid at every state.   Constraints: m == grid.length n == grid[i].length 2 <= m, n <= 50 Both  m  and  n  are  even  integers. 1 <= grid[i][j] <=   5000 1 <= k <= 10 9"
1926,https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/,Média,Array,Nearest Exit from Entrance in Maze,"You are given an  m x n  matrix  maze  ( 0-indexed ) with empty cells (represented as  '.' ) and walls (represented as  '+' ). You are also given the  entrance  of the maze, where  entrance = [entrance row , entrance col ]  denotes the row and column of the cell you are initially standing at. In one step, you can move one cell  up ,  down ,  left , or  right . You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the  nearest exit  from the  entrance . An  exit  is defined as an  empty cell  that is at the  border  of the  maze . The  entrance   does not count  as an exit. Return  the  number of steps  in the shortest path from the  entrance  to the nearest exit, or  -1  if no such path exists .   Example 1: Input:  maze = [[""+"",""+"",""."",""+""],[""."",""."",""."",""+""],[""+"",""+"",""+"","".""]], entrance = [1,2] Output:  1 Explanation:  There are 3 exits in this maze at [1,0], [0,2], and [2,3]. Initially, you are at the entrance cell [1,2]. - You can reach [1,0] by moving 2 steps left. - You can reach [0,2] by moving 1 step up. It is impossible to reach [2,3] from the entrance. Thus, the nearest exit is [0,2], which is 1 step away. Example 2: Input:  maze = [[""+"",""+"",""+""],[""."",""."","".""],[""+"",""+"",""+""]], entrance = [1,0] Output:  2 Explanation:  There is 1 exit in this maze at [1,2]. [1,0] does not count as an exit since it is the entrance cell. Initially, you are at the entrance cell [1,0]. - You can reach [1,2] by moving 2 steps right. Thus, the nearest exit is [1,2], which is 2 steps away. Example 3: Input:  maze = [[""."",""+""]], entrance = [0,0] Output:  -1 Explanation:  There are no exits in this maze.   Constraints: maze.length == m maze[i].length == n 1 <= m, n <= 100 maze[i][j]  is either  '.'  or  '+' . entrance.length == 2 0 <= entrance row  < m 0 <= entrance col  < n entrance  will always be an empty cell."
1937,https://leetcode.com/problems/maximum-number-of-points-with-cost/,Média,Array,Maximum Number of Points with Cost,"You are given an  m x n  integer matrix  points  ( 0-indexed ). Starting with  0  points, you want to  maximize  the number of points you can get from the matrix. To gain points, you must pick one cell in  each row . Picking the cell at coordinates  (r, c)  will  add   points[r][c]  to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows  r  and  r + 1  (where  0 <= r < m - 1 ), picking cells at coordinates  (r, c 1 )  and  (r + 1, c 2 )  will  subtract   abs(c 1  - c 2 )  from your score. Return  the  maximum  number of points you can achieve . abs(x)  is defined as: x  for  x >= 0 . -x  for  x < 0 .   Example 1:   Input:  points = [[1,2,3],[1,5,1],[3,1,1]] Output:  9 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9. Example 2: Input:  points = [[1,5],[2,3],[4,2]] Output:  11 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12 to your score. However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score. Your final score is 12 - 1 = 11.   Constraints: m == points.length n == points[r].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 0 <= points[r][c] <= 10 5"
1946,https://leetcode.com/problems/largest-number-after-mutating-substring/,Média,Array,Largest Number After Mutating Substring,"You are given a string  num , which represents a large integer. You are also given a  0-indexed  integer array  change  of length  10  that maps each digit  0-9  to another digit. More formally, digit  d  maps to digit  change[d] . You may  choose  to  mutate a single substring  of  num . To mutate a substring, replace each digit  num[i]  with the digit it maps to in  change  (i.e. replace  num[i]  with  change[num[i]] ). Return  a string representing the  largest  possible integer after  mutating  (or choosing not to) a  single substring  of  num . A  substring  is a contiguous sequence of characters within the string.   Example 1: Input:  num = "" 1 32"", change = [9,8,5,0,3,6,4,2,6,8] Output:  "" 8 32"" Explanation:  Replace the substring ""1"": - 1 maps to change[1] = 8. Thus, "" 1 32"" becomes "" 8 32"". ""832"" is the largest number that can be created, so return it. Example 2: Input:  num = "" 021 "", change = [9,4,3,5,7,2,1,9,0,6] Output:  "" 934 "" Explanation:  Replace the substring ""021"": - 0 maps to change[0] = 9. - 2 maps to change[2] = 3. - 1 maps to change[1] = 4. Thus, "" 021 "" becomes "" 934 "". ""934"" is the largest number that can be created, so return it. Example 3: Input:  num = ""5"", change = [1,4,7,5,3,2,5,6,9,4] Output:  ""5"" Explanation:  ""5"" is already the largest number that can be created, so return it.   Constraints: 1 <= num.length <= 10 5 num  consists of only digits  0-9 . change.length == 10 0 <= change[d] <= 9"
1962,https://leetcode.com/problems/remove-stones-to-minimize-the-total/,Média,Array,Remove Stones to Minimize the Total,"You are given a  0-indexed  integer array  piles , where  piles[i]  represents the number of stones in the  i th  pile, and an integer  k . You should apply the following operation  exactly   k  times: Choose any  piles[i]  and  remove   ceil(piles[i] / 2)  stones from it. Notice  that you can apply the operation on the  same  pile more than once. Return  the  minimum  possible total number of stones remaining after applying the  k  operations . ceil(x)  is the  smallest  integer that is  greater  than or  equal  to  x  (i.e., rounds  x  up).   Example 1: Input:  piles = [5,4,9], k = 2 Output:  12 Explanation:  Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [5,4, 5 ]. - Apply the operation on pile 0. The resulting piles are [ 3 ,4,5]. The total number of stones in [3,4,5] is 12. Example 2: Input:  piles = [4,3,6,7], k = 3 Output:  12 Explanation:  Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [4,3, 3 ,7]. - Apply the operation on pile 3. The resulting piles are [4,3,3, 4 ]. - Apply the operation on pile 0. The resulting piles are [ 2 ,3,3,4]. The total number of stones in [2,3,3,4] is 12.   Constraints: 1 <= piles.length <= 10 5 1 <= piles[i] <= 10 4 1 <= k <= 10 5"
1985,https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/,Média,Array,Find the Kth Largest Integer in the Array,"You are given an array of strings  nums  and an integer  k . Each string in  nums  represents an integer without leading zeros. Return  the string that represents the  k th  largest integer  in  nums . Note : Duplicate numbers should be counted distinctly. For example, if  nums  is  [""1"",""2"",""2""] ,  ""2""  is the first largest integer,  ""2""  is the second-largest integer, and  ""1""  is the third-largest integer.   Example 1: Input:  nums = [""3"",""6"",""7"",""10""], k = 4 Output:  ""3"" Explanation: The numbers in nums sorted in non-decreasing order are [""3"",""6"",""7"",""10""]. The 4 th  largest integer in nums is ""3"". Example 2: Input:  nums = [""2"",""21"",""12"",""1""], k = 3 Output:  ""2"" Explanation: The numbers in nums sorted in non-decreasing order are [""1"",""2"",""12"",""21""]. The 3 rd  largest integer in nums is ""2"". Example 3: Input:  nums = [""0"",""0""], k = 2 Output:  ""0"" Explanation: The numbers in nums sorted in non-decreasing order are [""0"",""0""]. The 2 nd  largest integer in nums is ""0"".   Constraints: 1 <= k <= nums.length <= 10 4 1 <= nums[i].length <= 100 nums[i]  consists of only digits. nums[i]  will not have any leading zeros."
1992,https://leetcode.com/problems/find-all-groups-of-farmland/,Média,Array,Find All Groups of Farmland,"You are given a  0-indexed   m x n  binary matrix  land  where a  0  represents a hectare of forested land and a  1  represents a hectare of farmland. To keep the land organized, there are designated rectangular areas of hectares that consist  entirely  of farmland. These rectangular areas are called  groups . No two groups are adjacent, meaning farmland in one group is  not  four-directionally adjacent to another farmland in a different group. land  can be represented by a coordinate system where the top left corner of  land  is  (0, 0)  and the bottom right corner of  land  is  (m-1, n-1) . Find the coordinates of the top left and bottom right corner of each  group  of farmland. A  group  of farmland with a top left corner at  (r 1 , c 1 )  and a bottom right corner at  (r 2 , c 2 )  is represented by the 4-length array  [r 1 , c 1 , r 2 , c 2 ]. Return  a 2D array containing the 4-length arrays described above for each  group  of farmland in  land . If there are no groups of farmland, return an empty array. You may return the answer in  any order .   Example 1: Input:  land = [[1,0,0],[0,1,1],[0,1,1]] Output:  [[0,0,0,0],[1,1,2,2]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. Example 2: Input:  land = [[1,1],[1,1]] Output:  [[0,0,1,1]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. Example 3: Input:  land = [[0]] Output:  [] Explanation: There are no groups of farmland.   Constraints: m == land.length n == land[i].length 1 <= m, n <= 300 land  consists of only  0 's and  1 's. Groups of farmland are  rectangular  in shape."
1997,https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/,Média,Array,First Day Where You Have Been in All the Rooms,"There are  n  rooms you need to visit, labeled from  0  to  n - 1 . Each day is labeled, starting from  0 . You will go in and visit one room a day. Initially on day  0 , you visit room  0 . The  order  you visit the rooms for the coming days is determined by the following  rules  and a given  0-indexed  array  nextVisit  of length  n : Assuming that on a day, you visit room  i , if you have been in room  i  an  odd  number of times ( including  the current visit), on the  next  day you will visit a room with a  lower or equal room number  specified by  nextVisit[i]  where  0 <= nextVisit[i] <= i ; if you have been in room  i  an  even  number of times ( including  the current visit), on the  next  day you will visit room  (i + 1) mod n . Return  the label of the  first  day where you have been in  all  the rooms . It can be shown that such a day exists. Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  nextVisit = [0,0] Output:  2 Explanation: - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.   On the next day you will visit room nextVisit[0] = 0 - On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.   On the next day you will visit room (0 + 1) mod 2 = 1 - On day 2, you visit room 1. This is the first day where you have been in all the rooms. Example 2: Input:  nextVisit = [0,0,2] Output:  6 Explanation: Your room visiting order for each day is: [0,0,1,0,0,1,2,...]. Day 6 is the first day where you have been in all the rooms. Example 3: Input:  nextVisit = [0,1,2,0] Output:  6 Explanation: Your room visiting order for each day is: [0,0,1,1,2,2,3,...]. Day 6 is the first day where you have been in all the rooms.   Constraints: n == nextVisit.length 2 <= n <= 10 5 0 <= nextVisit[i] <= i"
2049,https://leetcode.com/problems/count-nodes-with-the-highest-score/,Média,Array,Count Nodes With the Highest Score,"There is a  binary  tree rooted at  0  consisting of  n  nodes. The nodes are labeled from  0  to  n - 1 . You are given a  0-indexed  integer array  parents  representing the tree, where  parents[i]  is the parent of node  i . Since node  0  is the root,  parents[0] == -1 . Each node has a  score . To find the score of a node, consider if the node and the edges connected to it were  removed . The tree would become one or more  non-empty  subtrees. The  size  of a subtree is the number of the nodes in it. The  score  of the node is the  product of the sizes  of all those subtrees. Return  the  number  of nodes that have the  highest score .   Example 1: Input:  parents = [-1,2,0,2,0] Output:  3 Explanation: - The score of node 0 is: 3 * 1 = 3 - The score of node 1 is: 4 = 4 - The score of node 2 is: 1 * 1 * 2 = 2 - The score of node 3 is: 4 = 4 - The score of node 4 is: 4 = 4 The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score. Example 2: Input:  parents = [-1,2,0] Output:  2 Explanation: - The score of node 0 is: 2 = 2 - The score of node 1 is: 2 = 2 - The score of node 2 is: 1 * 1 = 1 The highest score is 2, and two nodes (node 0 and node 1) have the highest score.   Constraints: n == parents.length 2 <= n <= 10 5 parents[0] == -1 0 <= parents[i] <= n - 1  for  i != 0 parents  represents a valid binary tree."
2079,https://leetcode.com/problems/watering-plants/,Média,Array,Watering Plants,"You want to water  n  plants in your garden with a watering can. The plants are arranged in a row and are labeled from  0  to  n - 1  from left to right where the  i th  plant is located at  x = i . There is a river at  x = -1  that you can refill your watering can at. Each plant needs a specific amount of water. You will water the plants in the following way: Water the plants in order from left to right. After watering the current plant, if you do not have enough water to  completely  water the next plant, return to the river to fully refill the watering can. You  cannot  refill the watering can early. You are initially at the river (i.e.,  x = -1 ). It takes  one step  to move  one unit  on the x-axis. Given a  0-indexed  integer array  plants  of  n  integers, where  plants[i]  is the amount of water the  i th  plant needs, and an integer  capacity  representing the watering can capacity, return  the  number of steps  needed to water all the plants .   Example 1: Input:  plants = [2,2,3,3], capacity = 5 Output:  14 Explanation:  Start at the river with a full watering can: - Walk to plant 0 (1 step) and water it. Watering can has 3 units of water. - Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water. - Since you cannot completely water plant 2, walk back to the river to refill (2 steps). - Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water. - Since you cannot completely water plant 3, walk back to the river to refill (3 steps). - Walk to plant 3 (4 steps) and water it. Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14. Example 2: Input:  plants = [1,1,1,4,2,3], capacity = 4 Output:  30 Explanation:  Start at the river with a full watering can: - Water plants 0, 1, and 2 (3 steps). Return to river (3 steps). - Water plant 3 (4 steps). Return to river (4 steps). - Water plant 4 (5 steps). Return to river (5 steps). - Water plant 5 (6 steps). Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30. Example 3: Input:  plants = [7,7,7,7,7,7,7], capacity = 8 Output:  49 Explanation:  You have to refill before watering each plant. Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.   Constraints: n == plants.length 1 <= n <= 1000 1 <= plants[i] <= 10 6 max(plants[i]) <= capacity <= 10 9"
2080,https://leetcode.com/problems/range-frequency-queries/,Média,Array,Range Frequency Queries,"Design a data structure to find the  frequency  of a given value in a given subarray. The  frequency  of a value in a subarray is the number of occurrences of that value in the subarray. Implement the  RangeFreqQuery  class: RangeFreqQuery(int[] arr)  Constructs an instance of the class with the given  0-indexed  integer array  arr . int query(int left, int right, int value)  Returns the  frequency  of  value  in the subarray  arr[left...right] . A  subarray  is a contiguous sequence of elements within an array.  arr[left...right]  denotes the subarray that contains the elements of  nums  between indices  left  and  right  ( inclusive ).   Example 1: Input [""RangeFreqQuery"", ""query"", ""query""] [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]] Output [null, 1, 2] Explanation RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]); rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4] rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.   Constraints: 1 <= arr.length <= 10 5 1 <= arr[i], value <= 10 4 0 <= left <= right < arr.length At most  10 5  calls will be made to  query"
2090,https://leetcode.com/problems/k-radius-subarray-averages/,Média,Array,K Radius Subarray Averages,"You are given a  0-indexed  array  nums  of  n  integers, and an integer  k . The  k-radius average  for a subarray of  nums   centered  at some index  i  with the  radius   k  is the average of  all  elements in  nums  between the indices  i - k  and  i + k  ( inclusive ). If there are less than  k  elements before  or  after the index  i , then the  k-radius average  is  -1 . Build and return  an array  avgs  of length  n  where  avgs[i]  is the  k-radius average  for the subarray centered at index  i . The  average  of  x  elements is the sum of the  x  elements divided by  x , using  integer division . The integer division truncates toward zero, which means losing its fractional part. For example, the average of four elements  2 ,  3 ,  1 , and  5  is  (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75 , which truncates to  2 .   Example 1: Input:  nums = [7,4,3,9,1,8,5,2,6], k = 3 Output:  [-1,-1,-1,5,4,4,-1,-1,-1] Explanation: - avg[0], avg[1], and avg[2] are -1 because there are less than k elements  before  each index. - The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.   Using  integer division , avg[3] = 37 / 7 = 5. - For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. - For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. - avg[6], avg[7], and avg[8] are -1 because there are less than k elements  after  each index. Example 2: Input:  nums = [100000], k = 0 Output:  [100000] Explanation: - The sum of the subarray centered at index 0 with radius 0 is: 100000.   avg[0] = 100000 / 1 = 100000. Example 3: Input:  nums = [8], k = 100000 Output:  [-1] Explanation:   - avg[0] is -1 because there are less than k elements before and after index 0.   Constraints: n == nums.length 1 <= n <= 10 5 0 <= nums[i], k <= 10 5"
2115,https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/,Média,Array,Find All Possible Recipes from Given Supplies,"You have information about  n  different recipes. You are given a string array  recipes  and a 2D string array  ingredients . The  i th  recipe has the name  recipes[i] , and you can  create  it if you have  all  the needed ingredients from  ingredients[i] . A recipe can also be an ingredient for  other  recipes, i.e.,  ingredients[i]  may contain a string that is in  recipes . You are also given a string array  supplies  containing all the ingredients that you initially have, and you have an infinite supply of all of them. Return  a list of all the recipes that you can create.  You may return the answer in  any order . Note that two recipes may contain each other in their ingredients.   Example 1: Input:  recipes = [""bread""], ingredients = [[""yeast"",""flour""]], supplies = [""yeast"",""flour"",""corn""] Output:  [""bread""] Explanation: We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"". Example 2: Input:  recipes = [""bread"",""sandwich""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""]], supplies = [""yeast"",""flour"",""meat""] Output:  [""bread"",""sandwich""] Explanation: We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"". We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"". Example 3: Input:  recipes = [""bread"",""sandwich"",""burger""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""],[""sandwich"",""meat"",""bread""]], supplies = [""yeast"",""flour"",""meat""] Output:  [""bread"",""sandwich"",""burger""] Explanation: We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"". We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"". We can create ""burger"" since we have the ingredient ""meat"" and can create the ingredients ""bread"" and ""sandwich"".   Constraints: n == recipes.length == ingredients.length 1 <= n <= 100 1 <= ingredients[i].length, supplies.length <= 100 1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10 recipes[i], ingredients[i][j] , and  supplies[k]  consist only of lowercase English letters. All the values of  recipes  and  supplies  combined are unique. Each  ingredients[i]  does not contain any duplicate values."
2135,https://leetcode.com/problems/count-words-obtained-after-adding-a-letter/,Média,Array,Count Words Obtained After Adding a Letter,"You are given two  0-indexed  arrays of strings  startWords  and  targetWords . Each string consists of  lowercase English letters  only. For each string in  targetWords , check if it is possible to choose a string from  startWords  and perform a  conversion operation  on it to be equal to that from  targetWords . The  conversion operation  is described in the following two steps: Append  any lowercase letter that is  not present  in the string to its end. 	 For example, if the string is  ""abc"" , the letters  'd' ,  'e' , or  'y'  can be added to it, but not  'a' . If  'd'  is added, the resulting string will be  ""abcd"" . Rearrange  the letters of the new string in  any  arbitrary order. 	 For example,  ""abcd""  can be rearranged to  ""acbd"" ,  ""bacd"" ,  ""cbda"" , and so on. Note that it can also be rearranged to  ""abcd""  itself. Return  the  number of strings  in  targetWords  that can be obtained by performing the operations on  any  string of  startWords . Note  that you will only be verifying if the string in  targetWords  can be obtained from a string in  startWords  by performing the operations. The strings in  startWords   do not  actually change during this process.   Example 1: Input:  startWords = [""ant"",""act"",""tack""], targetWords = [""tack"",""act"",""acti""] Output:  2 Explanation: - In order to form targetWords[0] = ""tack"", we use startWords[1] = ""act"", append 'k' to it, and rearrange ""actk"" to ""tack"". - There is no string in startWords that can be used to obtain targetWords[1] = ""act"".   Note that ""act"" does exist in startWords, but we  must  append one letter to the string before rearranging it. - In order to form targetWords[2] = ""acti"", we use startWords[1] = ""act"", append 'i' to it, and rearrange ""acti"" to ""acti"" itself. Example 2: Input:  startWords = [""ab"",""a""], targetWords = [""abc"",""abcd""] Output:  1 Explanation: - In order to form targetWords[0] = ""abc"", we use startWords[0] = ""ab"", add 'c' to it, and rearrange it to ""abc"". - There is no string in startWords that can be used to obtain targetWords[1] = ""abcd"".   Constraints: 1 <= startWords.length, targetWords.length <= 5 * 10 4 1 <= startWords[i].length, targetWords[j].length <= 26 Each string of  startWords  and  targetWords  consists of lowercase English letters only. No letter occurs more than once in any string of  startWords  or  targetWords ."
2146,https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/,Média,Array,K Highest Ranked Items Within a Price Range,"You are given a  0-indexed  2D integer array  grid  of size  m x n  that represents a map of the items in a shop. The integers in the grid represent the following: 0  represents a wall that you cannot pass through. 1  represents an empty cell that you can freely move to and from. All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells. It takes  1  step to travel between adjacent grid cells. You are also given integer arrays  pricing  and  start  where  pricing = [low, high]  and  start = [row, col]  indicates that you start at the position  (row, col)  and are interested only in items with a price in the range of  [low, high]  ( inclusive ). You are further given an integer  k . You are interested in the  positions  of the  k   highest-ranked  items whose prices are  within  the given price range. The rank is determined by the  first  of these criteria that is different: Distance, defined as the length of the shortest path from the  start  ( shorter  distance has a higher rank). Price ( lower  price has a higher rank, but it must be  in the price range ). The row number ( smaller  row number has a higher rank). The column number ( smaller  column number has a higher rank). Return  the  k  highest-ranked items within the price range  sorted  by their rank (highest to lowest) . If there are fewer than  k  reachable items within the price range, return  all  of them .   Example 1: Input:  grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3 Output:  [[0,1],[1,1],[2,1]] Explanation:  You start at (0,0). With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2). The ranks of these items are: - (0,1) with distance 1 - (1,1) with distance 2 - (2,1) with distance 3 - (2,2) with distance 4 Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1). Example 2: Input:  grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2 Output:  [[2,1],[1,2]] Explanation:  You start at (2,3). With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1). The ranks of these items are: - (2,1) with distance 2, price 2 - (1,2) with distance 2, price 3 - (1,1) with distance 3 - (0,1) with distance 4 Thus, the 2 highest ranked items in the price range are (2,1) and (1,2). Example 3: Input:  grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3 Output:  [[2,1],[2,0]] Explanation:  You start at (0,0). With a price range of [2,3], we can take items from (2,0) and (2,1).  The ranks of these items are:  - (2,1) with distance 5 - (2,0) with distance 6 Thus, the 2 highest ranked items in the price range are (2,1) and (2,0).  Note that k = 3 but there are only 2 reachable items within the price range.   Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 0 <= grid[i][j] <= 10 5 pricing.length == 2 2 <= low <= high <= 10 5 start.length == 2 0 <= row <= m - 1 0 <= col <= n - 1 grid[row][col] > 0 1 <= k <= m * n"
2187,https://leetcode.com/problems/minimum-time-to-complete-trips/,Média,Array,Minimum Time to Complete Trips,"You are given an array  time  where  time[i]  denotes the time taken by the  i th  bus to complete  one trip . Each bus can make multiple trips  successively ; that is, the next trip can start  immediately after  completing the current trip. Also, each bus operates  independently ; that is, the trips of one bus do not influence the trips of any other bus. You are also given an integer  totalTrips , which denotes the number of trips all buses should make  in total . Return  the  minimum time  required for all buses to complete  at least   totalTrips  trips .   Example 1: Input:  time = [1,2,3], totalTrips = 5 Output:  3 Explanation: - At time t = 1, the number of trips completed by each bus are [1,0,0].    The total number of trips completed is 1 + 0 + 0 = 1. - At time t = 2, the number of trips completed by each bus are [2,1,0].    The total number of trips completed is 2 + 1 + 0 = 3. - At time t = 3, the number of trips completed by each bus are [3,1,1].    The total number of trips completed is 3 + 1 + 1 = 5. So the minimum time needed for all buses to complete at least 5 trips is 3. Example 2: Input:  time = [2], totalTrips = 1 Output:  2 Explanation: There is only one bus, and it will complete its first trip at t = 2. So the minimum time needed to complete 1 trip is 2.   Constraints: 1 <= time.length <= 10 5 1 <= time[i], totalTrips <= 10 7"
2216,https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/,Média,Array,Minimum Deletions to Make Array Beautiful,"You are given a  0-indexed  integer array  nums . The array  nums  is  beautiful  if: nums.length  is even. nums[i] != nums[i + 1]  for all  i % 2 == 0 . Note that an empty array is considered beautiful. You can delete any number of elements from  nums . When you delete an element, all the elements to the right of the deleted element will be  shifted one unit to the left  to fill the gap created and all the elements to the left of the deleted element will remain  unchanged . Return  the  minimum  number of elements to delete from  nums  to make it  beautiful.   Example 1: Input:  nums = [1,1,2,3,5] Output:  1 Explanation:  You can delete either  nums[0]  or  nums[1]  to make  nums  = [1,2,3,5] which is beautiful. It can be proven you need at least 1 deletion to make  nums  beautiful. Example 2: Input:  nums = [1,1,2,2,3,3] Output:  2 Explanation:  You can delete  nums[0]  and  nums[5]  to make nums = [1,2,2,3] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.   Constraints: 1 <= nums.length <= 10 5 0 <= nums[i] <= 10 5"
2225,https://leetcode.com/problems/find-players-with-zero-or-one-losses/,Média,Array,Find Players With Zero or One Losses,"You are given an integer array  matches  where  matches[i] = [winner i , loser i ]  indicates that the player  winner i  defeated player  loser i  in a match. Return  a list  answer  of size  2  where: answer[0]  is a list of all players that have  not  lost any matches. answer[1]  is a list of all players that have lost exactly  one  match. The values in the two lists should be returned in  increasing  order. Note: You should only consider the players that have played  at least one  match. The testcases will be generated such that  no  two matches will have the  same  outcome.   Example 1: Input:  matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]] Output:  [[1,2,10],[4,5,7,8]] Explanation: Players 1, 2, and 10 have not lost any matches. Players 4, 5, 7, and 8 each have lost one match. Players 3, 6, and 9 each have lost two matches. Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8]. Example 2: Input:  matches = [[2,3],[1,3],[5,4],[6,4]] Output:  [[1,2,5,6],[]] Explanation: Players 1, 2, 5, and 6 have not lost any matches. Players 3 and 4 each have lost two matches. Thus, answer[0] = [1,2,5,6] and answer[1] = [].   Constraints: 1 <= matches.length <= 10 5 matches[i].length == 2 1 <= winner i , loser i  <= 10 5 winner i  != loser i All  matches[i]  are  unique ."
2245,https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/,Média,Array,Maximum Trailing Zeros in a Cornered Path,"You are given a 2D integer array  grid  of size  m x n , where each cell contains a positive integer. A  cornered path  is defined as a set of adjacent cells with  at most  one turn. More specifically, the path should exclusively move either  horizontally  or  vertically  up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the  alternate  direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell. The  product  of a path is defined as the product of all the values in the path. Return  the  maximum  number of  trailing zeros  in the product of a cornered path found in  grid . Note: Horizontal  movement means moving in either the left or right direction. Vertical  movement means moving in either the up or down direction.   Example 1: Input:  grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]] Output:  3 Explanation:  The grid on the left shows a valid cornered path. It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros. It can be shown that this is the maximum trailing zeros in the product of a cornered path. The grid in the middle is not a cornered path as it has more than one turn. The grid on the right is not a cornered path as it requires a return to a previously visited cell. Example 2: Input:  grid = [[4,3,2],[7,6,1],[8,8,8]] Output:  0 Explanation:  The grid is shown in the figure above. There are no cornered paths in the grid that result in a product with a trailing zero.   Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 1 <= grid[i][j] <= 1000"
2274,https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/,Média,Array,Maximum Consecutive Floors Without Special Floors,"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be  special floors , used for relaxation only. You are given two integers  bottom  and  top , which denote that Alice has rented all the floors from  bottom  to  top  ( inclusive ). You are also given the integer array  special , where  special[i]  denotes a special floor that Alice has designated for relaxation. Return  the  maximum  number of consecutive floors without a special floor .   Example 1: Input:  bottom = 2, top = 9, special = [4,6] Output:  3 Explanation:  The following are the ranges (inclusive) of consecutive floors without a special floor: - (2, 3) with a total amount of 2 floors. - (5, 5) with a total amount of 1 floor. - (7, 9) with a total amount of 3 floors. Therefore, we return the maximum number which is 3 floors. Example 2: Input:  bottom = 6, top = 8, special = [7,6,8] Output:  0 Explanation:  Every floor rented is a special floor, so we return 0.   Constraints: 1 <= special.length <= 10 5 1 <= bottom <= special[i] <= top <= 10 9 All the values of  special  are  unique ."
2300,https://leetcode.com/problems/successful-pairs-of-spells-and-potions/,Média,Array,Successful Pairs of Spells and Potions,"You are given two positive integer arrays  spells  and  potions , of length  n  and  m  respectively, where  spells[i]  represents the strength of the  i th  spell and  potions[j]  represents the strength of the  j th  potion. You are also given an integer  success . A spell and potion pair is considered  successful  if the  product  of their strengths is  at least   success . Return  an integer array  pairs  of length  n  where  pairs[i]  is the number of  potions  that will form a successful pair with the  i th  spell.   Example 1: Input:  spells = [5,1,3], potions = [1,2,3,4,5], success = 7 Output:  [4,0,3] Explanation: - 0 th  spell: 5 * [1,2,3,4,5] = [5, 10 , 15 , 20 , 25 ]. 4 pairs are successful. - 1 st  spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful. - 2 nd  spell: 3 * [1,2,3,4,5] = [3,6, 9 , 12 , 15 ]. 3 pairs are successful. Thus, [4,0,3] is returned. Example 2: Input:  spells = [3,1,2], potions = [8,5,8], success = 16 Output:  [2,0,2] Explanation: - 0 th  spell: 3 * [8,5,8] = [ 24 ,15, 24 ]. 2 pairs are successful. - 1 st  spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful.  - 2 nd  spell: 2 * [8,5,8] = [ 16 ,10, 16 ]. 2 pairs are successful.  Thus, [2,0,2] is returned.   Constraints: n == spells.length m == potions.length 1 <= n, m <= 10 5 1 <= spells[i], potions[i] <= 10 5 1 <= success <= 10 10"
2305,https://leetcode.com/problems/fair-distribution-of-cookies/,Média,Array,Fair Distribution of Cookies,"You are given an integer array  cookies , where  cookies[i]  denotes the number of cookies in the  i th  bag. You are also given an integer  k  that denotes the number of children to distribute  all  the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up. The  unfairness  of a distribution is defined as the  maximum   total  cookies obtained by a single child in the distribution. Return  the  minimum  unfairness of all distributions .   Example 1: Input:  cookies = [8,15,10,20,8], k = 2 Output:  31 Explanation:  One optimal distribution is [8,15,8] and [10,20] - The 1 st  child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies. - The 2 nd  child receives [10,20] which has a total of 10 + 20 = 30 cookies. The unfairness of the distribution is max(31,30) = 31. It can be shown that there is no distribution with an unfairness less than 31. Example 2: Input:  cookies = [6,1,3,2,2,4,1,2], k = 3 Output:  7 Explanation:  One optimal distribution is [6,1], [3,2,2], and [4,1,2] - The 1 st  child receives [6,1] which has a total of 6 + 1 = 7 cookies. - The 2 nd  child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies. - The 3 rd  child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies. The unfairness of the distribution is max(7,7,7) = 7. It can be shown that there is no distribution with an unfairness less than 7.   Constraints: 2 <= cookies.length <= 8 1 <= cookies[i] <= 10 5 2 <= k <= cookies.length"
2332,https://leetcode.com/problems/the-latest-time-to-catch-a-bus/,Média,Array,The Latest Time to Catch a Bus,"You are given a  0-indexed  integer array  buses  of length  n , where  buses[i]  represents the departure time of the  i th  bus. You are also given a  0-indexed  integer array  passengers  of length  m , where  passengers[j]  represents the arrival time of the  j th  passenger. All bus departure times are unique. All passenger arrival times are unique. You are given an integer  capacity , which represents the  maximum  number of passengers that can get on each bus. When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at  x  minutes if you arrive at  y  minutes where  y <= x , and the bus is not full. Passengers with the  earliest  arrival times get on the bus first. More formally when a bus arrives, either: If  capacity  or fewer passengers are waiting for a bus, they will  all  get on the bus, or The  capacity  passengers with the  earliest  arrival times will get on the bus. Return  the latest time you may arrive at the bus station to catch a bus . You  cannot  arrive at the same time as another passenger. Note:  The arrays  buses  and  passengers  are not necessarily sorted.   Example 1: Input:  buses = [10,20], passengers = [2,17,18,19], capacity = 2 Output:  16 Explanation:  Suppose you arrive at time 16. At time 10, the first bus departs with the 0 th  passenger.  At time 20, the second bus departs with you and the 1 st  passenger. Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1 st  passenger to catch the bus. Example 2: Input:  buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2 Output:  20 Explanation:  Suppose you arrive at time 20. At time 10, the first bus departs with the 3 rd  passenger.  At time 20, the second bus departs with the 5 th  and 1 st  passengers. At time 30, the third bus departs with the 0 th  passenger and you. Notice if you had arrived any later, then the 6 th  passenger would have taken your seat on the third bus.   Constraints: n == buses.length m == passengers.length 1 <= n, m, capacity <= 10 5 2 <= buses[i], passengers[i] <= 10 9 Each element in  buses  is  unique . Each element in  passengers  is  unique ."
2365,https://leetcode.com/problems/task-scheduler-ii/,Média,Array,Task Scheduler II,"You are given a  0-indexed  array of positive integers  tasks , representing tasks that need to be completed  in order , where  tasks[i]  represents the  type  of the  i th  task. You are also given a positive integer  space , which represents the  minimum  number of days that must pass  after  the completion of a task before another task of the  same  type can be performed. Each day, until all tasks have been completed, you must either: Complete the next task from  tasks , or Take a break. Return  the  minimum  number of days needed to complete all tasks .   Example 1: Input:  tasks = [1,2,1,2,3,1], space = 3 Output:  9 Explanation: One way to complete all tasks in 9 days is as follows: Day 1: Complete the 0th task. Day 2: Complete the 1st task. Day 3: Take a break. Day 4: Take a break. Day 5: Complete the 2nd task. Day 6: Complete the 3rd task. Day 7: Take a break. Day 8: Complete the 4th task. Day 9: Complete the 5th task. It can be shown that the tasks cannot be completed in less than 9 days. Example 2: Input:  tasks = [5,8,8,5], space = 2 Output:  6 Explanation: One way to complete all tasks in 6 days is as follows: Day 1: Complete the 0th task. Day 2: Complete the 1st task. Day 3: Take a break. Day 4: Take a break. Day 5: Complete the 2nd task. Day 6: Complete the 3rd task. It can be shown that the tasks cannot be completed in less than 6 days.   Constraints: 1 <= tasks.length <= 10 5 1 <= tasks[i] <= 10 9 1 <= space <= tasks.length"
2397,https://leetcode.com/problems/maximum-rows-covered-by-columns/,Média,Array,Maximum Rows Covered by Columns,"You are given an  m x n  binary matrix  matrix  and an integer  numSelect . Your goal is to select exactly  numSelect   distinct  columns from  matrix  such that you cover as many rows as possible. A row is considered  covered  if all the  1 's in that row are also part of a column that you have selected. If a row does not have any  1 s, it is also considered covered. More formally, let us consider  selected = {c 1 , c 2 , ...., c numSelect }  as the set of columns selected by you. A row  i  is  covered  by  selected  if: For each cell where  matrix[i][j] == 1 , the column  j  is in  selected . Or, no cell in row  i  has a value of  1 . Return the  maximum  number of rows that can be  covered  by a set of  numSelect  columns.   Example 1: Input:   matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2 Output:   3 Explanation: One possible way to cover 3 rows is shown in the diagram above. We choose s = {0, 2}. - Row 0 is covered because it has no occurrences of 1. - Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s. - Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s. - Row 3 is covered because matrix[2][2] == 1 and 2 is present in s. Thus, we can cover three rows. Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered. Example 2: Input:   matrix = [[1],[0]], numSelect = 1 Output:   2 Explanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.   Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 12 matrix[i][j]  is either  0  or  1 . 1 <= numSelect <= n"
2401,https://leetcode.com/problems/longest-nice-subarray/,Média,Array,Longest Nice Subarray,"You are given an array  nums  consisting of  positive  integers. We call a subarray of  nums   nice  if the bitwise  AND  of every pair of elements that are in  different  positions in the subarray is equal to  0 . Return  the length of the  longest  nice subarray . A  subarray  is a  contiguous  part of an array. Note  that subarrays of length  1  are always considered nice.   Example 1: Input:  nums = [1,3,8,48,10] Output:  3 Explanation:  The longest nice subarray is [3,8,48]. This subarray satisfies the conditions: - 3 AND 8 = 0. - 3 AND 48 = 0. - 8 AND 48 = 0. It can be proven that no longer nice subarray can be obtained, so we return 3. Example 2: Input:  nums = [3,1,5,11,13] Output:  1 Explanation:  The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9"
2411,https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/,Média,Array,Smallest Subarrays With Maximum Bitwise OR,"You are given a  0-indexed  array  nums  of length  n , consisting of non-negative integers. For each index  i  from  0  to  n - 1 , you must determine the size of the  minimum sized  non-empty subarray of  nums  starting at  i  ( inclusive ) that has the  maximum  possible  bitwise OR . In other words, let  B ij  be the bitwise OR of the subarray  nums[i...j] . You need to find the smallest subarray starting at  i , such that bitwise OR of this subarray is equal to  max(B ik )  where  i <= k <= n - 1 . The bitwise OR of an array is the bitwise OR of all the numbers in it. Return  an integer array  answer  of size  n  where  answer[i]  is the length of the  minimum  sized subarray starting at  i  with  maximum  bitwise OR. A  subarray  is a contiguous non-empty sequence of elements within an array.   Example 1: Input:  nums = [1,0,2,1,3] Output:  [3,3,2,2,1] Explanation: The maximum possible bitwise OR starting at any index is 3.  - Starting at index 0, the shortest subarray that yields it is [1,0,2]. - Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1]. - Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1]. - Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3]. - Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3]. Therefore, we return [3,3,2,2,1].  Example 2: Input:  nums = [1,2] Output:  [2,1] Explanation: Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2. Starting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1. Therefore, we return [2,1].   Constraints: n == nums.length 1 <= n <= 10 5 0 <= nums[i] <= 10 9"
2428,https://leetcode.com/problems/maximum-sum-of-an-hourglass/,Média,Array,Maximum Sum of an Hourglass,"You are given an  m x n  integer matrix  grid . We define an  hourglass  as a part of the matrix with the following form: Return  the  maximum  sum of the elements of an hourglass . Note  that an hourglass cannot be rotated and must be entirely contained within the matrix.   Example 1: Input:  grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]] Output:  30 Explanation:  The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30. Example 2: Input:  grid = [[1,2,3],[4,5,6],[7,8,9]] Output:  35 Explanation:  There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.   Constraints: m == grid.length n == grid[i].length 3 <= m, n <= 150 0 <= grid[i][j] <= 10 6"
2456,https://leetcode.com/problems/most-popular-video-creator/,Média,Array,Most Popular Video Creator,"You are given two string arrays  creators  and  ids , and an integer array  views , all of length  n . The  i th  video on a platform was created by  creators[i] , has an id of  ids[i] , and has  views[i]  views. The  popularity  of a creator is the  sum  of the number of views on  all  of the creator's videos. Find the creator with the  highest  popularity and the id of their  most  viewed video. If multiple creators have the highest popularity, find all of them. If multiple videos have the highest view count for a creator, find the lexicographically  smallest  id. Note: It is possible for different videos to have the same  id , meaning that  id s do not uniquely identify a video. For example, two videos with the same ID are considered as distinct videos with their own viewcount. Return   a  2D array  of  strings   answer  where  answer[i] = [creators i , id i ]  means that  creators i  has the  highest  popularity and  id i  is the  id  of their most  popular  video. The answer can be returned in any order.   Example 1: Input:   creators = [""alice"",""bob"",""alice"",""chris""], ids = [""one"",""two"",""three"",""four""], views = [5,10,5,4] Output:   [[""alice"",""one""],[""bob"",""two""]] Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob is 10. The popularity of chris is 4. alice and bob are the most popular creators. For bob, the video with the highest view count is ""two"". For alice, the videos with the highest view count are ""one"" and ""three"". Since ""one"" is lexicographically smaller than ""three"", it is included in the answer. Example 2: Input:   creators = [""alice"",""alice"",""alice""], ids = [""a"",""b"",""c""], views = [1,2,2] Output:   [[""alice"",""b""]] Explanation: The videos with id ""b"" and ""c"" have the highest view count. Since ""b"" is lexicographically smaller than ""c"", it is included in the answer.   Constraints: n == creators.length == ids.length == views.length 1 <= n <= 10 5 1 <= creators[i].length, ids[i].length <= 5 creators[i]  and  ids[i]  consist only of lowercase English letters. 0 <= views[i] <= 10 5"
2476,https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/,Média,Array,Closest Nodes Queries in a Binary Search Tree,"You are given the  root  of a  binary search tree  and an array  queries  of size  n  consisting of positive integers. Find a  2D  array  answer  of size  n  where  answer[i] = [min i , max i ] : min i  is the  largest  value in the tree that is smaller than or equal to  queries[i] . If a such value does not exist, add  -1  instead. max i  is the  smallest  value in the tree that is greater than or equal to  queries[i] . If a such value does not exist, add  -1  instead. Return  the array   answer .   Example 1: Input:  root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16] Output:  [[2,2],[4,6],[15,-1]] Explanation:  We answer the queries in the following way: - The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2]. - The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6]. - The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1]. Example 2: Input:  root = [4,null,9], queries = [3] Output:  [[-1,4]] Explanation:  The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].   Constraints: The number of nodes in the tree is in the range  [2, 10 5 ] . 1 <= Node.val <= 10 6 n == queries.length 1 <= n <= 10 5 1 <= queries[i] <= 10 6"
2512,https://leetcode.com/problems/reward-top-k-students/,Média,Array,Reward Top K Students,"You are given two string arrays  positive_feedback  and  negative_feedback , containing the words denoting positive and negative feedback, respectively. Note that  no  word is both positive and negative. Initially every student has  0  points. Each positive word in a feedback report  increases  the points of a student by  3 , whereas each negative word  decreases  the points by  1 . You are given  n  feedback reports, represented by a  0-indexed  string array  report  and a  0-indexed  integer array  student_id , where  student_id[i]  represents the ID of the student who has received the feedback report  report[i] . The ID of each student is  unique . Given an integer  k , return  the top  k  students after ranking them in  non-increasing  order by their points . In case more than one student has the same points, the one with the lower ID ranks higher.   Example 1: Input:  positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is studious"",""the student is smart""], student_id = [1,2], k = 2 Output:  [1,2] Explanation:   Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher. Example 2: Input:  positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is not studious"",""the student is smart""], student_id = [1,2], k = 2 Output:  [2,1] Explanation:   - The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points.  - The student with ID 2 has 1 positive feedback, so he has 3 points.  Since student 2 has more points, [2,1] is returned.   Constraints: 1 <= positive_feedback.length, negative_feedback.length <= 10 4 1 <= positive_feedback[i].length, negative_feedback[j].length <= 100 Both  positive_feedback[i]  and  negative_feedback[j]  consists of lowercase English letters. No word is present in both  positive_feedback  and  negative_feedback . n == report.length == student_id.length 1 <= n <= 10 4 report[i]  consists of lowercase English letters and spaces  ' ' . There is a single space between consecutive words of  report[i] . 1 <= report[i].length <= 100 1 <= student_id[i] <= 10 9 All the values of  student_id[i]  are  unique . 1 <= k <= n"
2517,https://leetcode.com/problems/maximum-tastiness-of-candy-basket/,Média,Array,Maximum Tastiness of Candy Basket,"You are given an array of positive integers  price  where  price[i]  denotes the price of the  i th  candy and a positive integer  k . The store sells baskets of  k   distinct  candies. The  tastiness  of a candy basket is the smallest absolute difference of the  prices  of any two candies in the basket. Return  the  maximum  tastiness of a candy basket.   Example 1: Input:  price = [13,5,1,8,21,2], k = 3 Output:  8 Explanation:  Choose the candies with the prices [13,5,21]. The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can be proven that 8 is the maximum tastiness that can be achieved. Example 2: Input:  price = [1,3,1], k = 2 Output:  2 Explanation:  Choose the candies with the prices [1,3]. The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven that 2 is the maximum tastiness that can be achieved. Example 3: Input:  price = [7,7,7,7], k = 2 Output:  0 Explanation:  Choosing any two distinct candies from the candies we have will result in a tastiness of 0.   Constraints: 2 <= k <= price.length <= 10 5 1 <= price[i] <= 10 9"
2568,https://leetcode.com/problems/minimum-impossible-or/,Média,Array,Minimum Impossible OR,"You are given a  0-indexed  integer array  nums . We say that an integer x is  expressible  from  nums  if there exist some integers  0 <= index 1  < index 2  < ... < index k  < nums.length  for which  nums[index 1 ] | nums[index 2 ] | ... | nums[index k ] = x . In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of  nums . Return  the minimum  positive non-zero integer  that is not  expressible from  nums .   Example 1: Input:  nums = [2,1] Output:  4 Explanation:  1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4. Example 2: Input:  nums = [5,3,2] Output:  1 Explanation:  We can show that 1 is the smallest number that is not expressible.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9"
2601,https://leetcode.com/problems/prime-subtraction-operation/,Média,Array,Prime Subtraction Operation,"You are given a  0-indexed  integer array  nums  of length  n . You can perform the following operation as many times as you want: Pick an index  i  that you haven’t picked before, and pick a prime  p   strictly less than   nums[i] , then subtract  p  from  nums[i] . Return  true if you can make  nums  a strictly increasing array using the above operation and false otherwise. A  strictly increasing array  is an array whose each element is strictly greater than its preceding element.   Example 1: Input:  nums = [4,9,6,10] Output:  true Explanation:  In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10]. In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10]. After the second operation, nums is sorted in strictly increasing order, so the answer is true. Example 2: Input:  nums = [6,8,11,12] Output:  true Explanation:  Initially nums is sorted in strictly increasing order, so we don't need to make any operations. Example 3: Input:  nums = [5,8,3] Output:  false Explanation:  It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.   Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 1000 nums.length == n"
2653,https://leetcode.com/problems/sliding-subarray-beauty/,Média,Array,Sliding Subarray Beauty,"Given an integer array  nums  containing  n  integers, find the  beauty  of each subarray of size  k . The  beauty  of a subarray is the  x th  smallest integer  in the subarray if it is  negative , or  0  if there are fewer than  x  negative integers. Return  an integer array containing  n - k + 1   integers, which denote the  beauty  of the subarrays  in order  from the first index in the array. A subarray is a contiguous  non-empty  sequence of elements within an array.   Example 1: Input:  nums = [1,-1,-3,-2,3], k = 3, x = 2 Output:  [-1,-2,-2] Explanation:  There are 3 subarrays with size k = 3.  The first subarray is  [1, -1, -3]  and the 2 nd  smallest negative integer is -1.  The second subarray is  [-1, -3, -2]  and the 2 nd  smallest negative integer is -2.  The third subarray is  [-3, -2, 3]  and the 2 nd  smallest negative integer is -2. Example 2: Input:  nums = [-1,-2,-3,-4,-5], k = 2, x = 2 Output:  [-1,-2,-3,-4] Explanation:  There are 4 subarrays with size k = 2. For  [-1, -2] , the 2 nd  smallest negative integer is -1. For  [-2, -3] , the 2 nd  smallest negative integer is -2. For  [-3, -4] , the 2 nd  smallest negative integer is -3. For  [-4, -5] , the 2 nd  smallest negative integer is -4.  Example 3: Input:  nums = [-3,1,2,-3,0,-3], k = 2, x = 1 Output:  [-3,0,-3,-3,-3] Explanation:  There are 5 subarrays with size k = 2 . For  [-3, 1] , the 1 st  smallest negative integer is -3. For  [1, 2] , there is no negative integer so the beauty is 0. For  [2, -3] , the 1 st  smallest negative integer is -3. For  [-3, 0] , the 1 st  smallest negative integer is -3. For  [0, -3] , the 1 st  smallest negative integer is -3.   Constraints: n == nums.length  1 <= n <= 10 5 1 <= k <= n 1 <= x <= k  -50 <= nums[i] <= 50"
2662,https://leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/,Média,Array,Minimum Cost of a Path With Special Roads,"You are given an array  start  where  start = [startX, startY]  represents your initial position  (startX, startY)  in a 2D space. You are also given the array  target  where  target = [targetX, targetY]  represents your target position  (targetX, targetY) . The  cost  of going from a position  (x1, y1)  to any other position in the space  (x2, y2)  is  |x2 - x1| + |y2 - y1| . There are also some  special roads . You are given a 2D array  specialRoads  where  specialRoads[i] = [x1 i , y1 i , x2 i , y2 i , cost i ]  indicates that the  i th  special road goes in  one direction  from  (x1 i , y1 i )  to  (x2 i , y2 i )  with a cost equal to  cost i . You can use each special road any number of times. Return the  minimum  cost required to go from  (startX, startY)  to  (targetX, targetY) .   Example 1: Input:   start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]] Output:   5 Explanation: (1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1. (1,2) to (3,3). Use  specialRoads[0]  with  the cost 2. (3,3) to (3,4) with a cost of |3 - 3| + |4 - 3| = 1. (3,4) to (4,5). Use  specialRoads[1]  with the cost  1. So the total cost is 1 + 2 + 1 + 1 = 5. Example 2: Input:   start = [3,2], target = [5,7], specialRoads = [[5,7,3,2,1],[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]] Output:   7 Explanation: It is optimal not to use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7. Note that the  specialRoads[0]  is directed from (5,7) to (3,2). Example 3: Input:   start = [1,1], target = [10,4], specialRoads = [[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]] Output:   8 Explanation: (1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1. (1,2) to (7,4). Use  specialRoads[1]  with the cost  4. (7,4) to (10,4) with a cost of |10 - 7| + |4 - 4| = 3.   Constraints: start.length == target.length == 2 1 <= startX <= targetX <= 10 5 1 <= startY <= targetY <= 10 5 1 <= specialRoads.length <= 200 specialRoads[i].length == 5 startX <= x1 i , x2 i  <= targetX startY <= y1 i , y2 i  <= targetY 1 <= cost i  <= 10 5"
2708,https://leetcode.com/problems/maximum-strength-of-a-group/,Média,Array,Maximum Strength of a Group,"You are given a  0-indexed  integer array  nums  representing the score of students in an exam. The teacher would like to form one  non-empty  group of students with maximal  strength , where the strength of a group of students of indices  i 0 ,  i 1 ,  i 2 , ... ,  i k  is defined as  nums[i 0 ] * nums[i 1 ] * nums[i 2 ] * ... * nums[i k ​] . Return  the maximum strength of a group the teacher can create .   Example 1: Input:  nums = [3,-1,-5,2,5,-9] Output:  1350 Explanation:  One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal. Example 2: Input:  nums = [-4,-5,-4] Output:  20 Explanation:  Group the students at indices [0, 1] . Then, we’ll have a resulting strength of 20. We cannot achieve greater strength.   Constraints: 1 <= nums.length <= 13 -9 <= nums[i] <= 9"
2731,https://leetcode.com/problems/movement-of-robots/,Média,Array,Movement of Robots,"Some robots are standing on an infinite number line with their initial coordinates given by a  0-indexed  integer array  nums  and will start moving once given the command to move. The robots will move a unit distance each second. You are given a string  s  denoting the direction in which robots will move on command.  'L'  means the robot will move towards the left side or negative side of the number line, whereas  'R'  means the robot will move towards the right side or positive side of the number line. If two robots collide, they will start moving in opposite directions. Return  the sum of distances between all the pairs of robots  d   seconds after the command.  Since the sum can be very large, return it modulo  10 9  + 7 . Note:  For two robots at the index  i  and  j , pair  (i,j)  and pair  (j,i)  are considered the same pair. When robots collide, they  instantly change  their directions without wasting any time. Collision happens when two robots share the same place in a moment. 	 For example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they'll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right. For example, if a robot is positioned in 0 going to the right and another is positioned in 1 going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.   Example 1: Input:  nums = [-2,0,2], s = ""RLL"", d = 3 Output:  8 Explanation:   After 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right. After 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right. After 3 seconds, the positions are [-3,-1,1]. The distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2. The distance between the robot at index 0 and 2 is abs(-3 - 1) = 4. The distance between the robot at index 1 and 2 is abs(-1 - 1) = 2. The sum of the pairs of all distances = 2 + 4 + 2 = 8. Example 2: Input:  nums = [1,0], s = ""RL"", d = 2 Output:  5 Explanation:   After 1 second, the positions are [2,-1]. After 2 seconds, the positions are [3,-2]. The distance between the two robots is abs(-2 - 3) = 5.   Constraints: 2 <= nums.length <= 10 5 -2 * 10 9  <= nums[i] <= 2 * 10 9 0 <= d <= 10 9 nums.length == s.length  s  consists of 'L' and 'R' only nums[i]  will be unique."
2735,https://leetcode.com/problems/collecting-chocolates/,Média,Array,Collecting Chocolates,"You are given a  0-indexed  integer array  nums  of size  n  representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index  i  is  nums[i] . Each chocolate is of a different type, and initially, the chocolate at the index  i  is of  i th  type. In one operation, you can do the following with an incurred  cost  of  x : Simultaneously change the chocolate of  i th  type to  ((i + 1) mod n) th  type for all chocolates. Return  the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.   Example 1: Input:  nums = [20,1,15], x = 5 Output:  13 Explanation:  Initially, the chocolate types are [0,1,2]. We will buy the 1 st  type of chocolate at a cost of 1. Now, we will perform the operation at a cost of 5, and the types of chocolates will become [1,2,0]. We will buy the 2 nd   type of chocolate at a cost of 1. Now, we will again perform the operation at a cost of 5, and the chocolate types will become [2,0,1]. We will buy the 0 th  type of chocolate at a cost of 1.  Thus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We can prove that this is optimal. Example 2: Input:  nums = [1,2,3], x = 4 Output:  6 Explanation:  We will collect all three types of chocolates at their own price without performing any operations. Therefore, the total cost is 1 + 2 + 3 = 6.   Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 10 9 1 <= x <= 10 9"
2768,https://leetcode.com/problems/number-of-black-blocks/,Média,Array,Number of Black Blocks,"You are given two integers  m  and  n  representing the dimensions of a  0-indexed   m x n  grid. You are also given a  0-indexed  2D integer matrix  coordinates , where  coordinates[i] = [x, y]  indicates that the cell with coordinates  [x, y]  is colored  black . All cells in the grid that do not appear in  coordinates  are  white . A block is defined as a  2 x 2  submatrix of the grid. More formally, a block with cell  [x, y]  as its top-left corner where  0 <= x < m - 1  and  0 <= y < n - 1  contains the coordinates  [x, y] ,  [x + 1, y] ,  [x, y + 1] , and  [x + 1, y + 1] . Return  a  0-indexed  integer array   arr   of size   5   such that   arr[i]   is the number of blocks that contains exactly   i   black  cells .   Example 1: Input:  m = 3, n = 3, coordinates = [[0,0]] Output:  [3,1,0,0,0] Explanation:  The grid looks like this: There is only 1 block with one black cell, and it is the block starting with cell [0,0]. The other 3 blocks start with cells [0,1], [1,0] and [1,1]. They all have zero black cells.  Thus, we return [3,1,0,0,0].  Example 2: Input:  m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]] Output:  [0,2,2,0,0] Explanation:  The grid looks like this: There are 2 blocks with two black cells (the ones starting with cell coordinates [0,0] and [0,1]). The other 2 blocks have starting cell coordinates of [1,0] and [1,1]. They both have 1 black cell. Therefore, we return [0,2,2,0,0].   Constraints: 2 <= m <= 10 5 2 <= n <= 10 5 0 <= coordinates.length <= 10 4 coordinates[i].length == 2 0 <= coordinates[i][0] < m 0 <= coordinates[i][1] < n It is guaranteed that  coordinates  contains pairwise distinct coordinates."
2789,https://leetcode.com/problems/largest-element-in-an-array-after-merge-operations/,Média,Array,Largest Element in an Array after Merge Operations,"You are given a  0-indexed  array  nums  consisting of positive integers. You can do the following operation on the array  any  number of times: Choose an integer  i  such that  0 <= i < nums.length - 1  and  nums[i] <= nums[i + 1] . Replace the element  nums[i + 1]  with  nums[i] + nums[i + 1]  and delete the element  nums[i]  from the array. Return  the value of the  largest  element that you can possibly obtain in the final array.   Example 1: Input:  nums = [2,3,7,9,3] Output:  21 Explanation:  We can apply the following operations on the array: - Choose i = 0. The resulting array will be nums = [ 5 ,7,9,3]. - Choose i = 1. The resulting array will be nums = [5, 16 ,3]. - Choose i = 0. The resulting array will be nums = [ 21 ,3]. The largest element in the final array is 21. It can be shown that we cannot obtain a larger element. Example 2: Input:  nums = [5,3,3] Output:  11 Explanation:  We can do the following operations on the array: - Choose i = 1. The resulting array will be nums = [5, 6 ]. - Choose i = 0. The resulting array will be nums = [ 11 ]. There is only one element in the final array, which is 11.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 6"
2831,https://leetcode.com/problems/find-the-longest-equal-subarray/,Média,Array,Find the Longest Equal Subarray,"You are given a  0-indexed  integer array  nums  and an integer  k . A subarray is called  equal  if all of its elements are equal. Note that the empty subarray is an  equal  subarray. Return  the length of the  longest  possible equal subarray after deleting  at most   k  elements from  nums . A  subarray  is a contiguous, possibly empty sequence of elements within an array.   Example 1: Input:  nums = [1,3,2,3,1,3], k = 3 Output:  3 Explanation:  It's optimal to delete the elements at index 2 and index 4. After deleting them, nums becomes equal to [1, 3, 3, 3]. The longest equal subarray starts at i = 1 and ends at j = 3 with length equal to 3. It can be proven that no longer equal subarrays can be created. Example 2: Input:  nums = [1,1,2,2,1,1], k = 2 Output:  4 Explanation:  It's optimal to delete the elements at index 2 and index 3. After deleting them, nums becomes equal to [1, 1, 1, 1]. The array itself is an equal subarray, so the answer is 4. It can be proven that no longer equal subarrays can be created.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= nums.length 0 <= k <= nums.length"
2865,https://leetcode.com/problems/beautiful-towers-i/,Média,Array,Beautiful Towers I,"You are given an array  heights  of  n  integers representing the number of bricks in  n  consecutive towers. Your task is to remove some bricks to form a  mountain-shaped  tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing. Return the  maximum possible sum  of heights of a mountain-shaped tower arrangement.   Example 1: Input:   heights = [5,3,4,1,1] Output:   13 Explanation: We remove some bricks to make  heights = [5,3,3,1,1] , the peak is at index 0. Example 2: Input:   heights = [6,5,3,9,2,7] Output:   22 Explanation: We remove some bricks to make  heights = [3,3,3,9,2,2] , the peak is at index 3. Example 3: Input:   heights = [3,2,5,5,2,3] Output:   18 Explanation: We remove some bricks to make  heights = [2,2,5,5,2,2] , the peak is at index 2 or 3.   Constraints: 1 <= n == heights.length <= 10 3 1 <= heights[i] <= 10 9"
3020,https://leetcode.com/problems/find-the-maximum-number-of-elements-in-subset/,Média,Array,Find the Maximum Number of Elements in Subset,"You are given an array of  positive  integers  nums . You need to select a  subset  of  nums  which satisfies the following condition: You can place the selected elements in a  0-indexed  array such that it follows the pattern:  [x, x 2 , x 4 , ..., x k/2 , x k , x k/2 , ..., x 4 , x 2 , x]  ( Note  that  k  can be be any  non-negative  power of  2 ). For example,  [2, 4, 16, 4, 2]  and  [3, 9, 3]  follow the pattern while  [2, 4, 8, 4, 2]  does not. Return  the  maximum  number of elements in a subset that satisfies these conditions.   Example 1: Input:  nums = [5,4,1,2,2] Output:  3 Explanation:  We can select the subset {4,2,2}, which can be placed in the array as [2,4,2] which follows the pattern and 2 2  == 4. Hence the answer is 3. Example 2: Input:  nums = [1,3,2,4] Output:  1 Explanation:  We can select the subset {1}, which can be placed in the array as [1] which follows the pattern. Hence the answer is 1. Note that we could have also selected the subsets {2}, {3}, or {4}, there may be multiple subsets which provide the same answer.    Constraints: 2 <= nums.length <= 10 5 1 <= nums[i] <= 10 9"
3030,https://leetcode.com/problems/find-the-grid-of-region-average/,Média,Array,Find the Grid of Region Average,"You are given  m x n  grid  image  which represents a grayscale image, where  image[i][j]  represents a pixel with intensity in the range  [0..255] . You are also given a  non-negative  integer  threshold . Two pixels are  adjacent  if they share an edge. A  region  is a  3 x 3  subgrid where the  absolute difference  in intensity between any two  adjacent  pixels is  less than or equal to   threshold . All pixels in a region belong to that region, note that a pixel can belong to  multiple  regions. You need to calculate a  m x n  grid  result , where  result[i][j]  is the  average  intensity of the regions to which  image[i][j]  belongs,  rounded down  to the nearest integer. If  image[i][j]  belongs to multiple regions,  result[i][j]  is the  average  of the  rounded-down average  intensities of these regions,  rounded down  to the nearest integer. If  image[i][j]  does  not  belong to any region,  result[i][j]  is  equal to   image[i][j] . Return the grid  result .   Example 1: Input:   image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3 Output:   [[9,9,9,9],[9,9,9,9],[9,9,9,9]] Explanation: There are two regions as illustrated above. The average intensity of the first region is 9, while the average intensity of the second region is 9.67 which is rounded down to 9. The average intensity of both of the regions is (9 + 9) / 2 = 9. As all the pixels belong to either region 1, region 2, or both of them, the intensity of every pixel in the result is 9. Please note that the rounded-down values are used when calculating the average of multiple regions, hence the calculation is done using 9 as the average intensity of region 2, not 9.67. Example 2: Input:   image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12 Output:   [[25,25,25],[27,27,27],[27,27,27],[30,30,30]] Explanation: There are two regions as illustrated above. The average intensity of the first region is 25, while the average intensity of the second region is 30. The average intensity of both of the regions is (25 + 30) / 2 = 27.5 which is rounded down to 27. All the pixels in row 0 of the image belong to region 1, hence all the pixels in row 0 in the result are 25. Similarly, all the pixels in row 3 in the result are 30. The pixels in rows 1 and 2 of the image belong to region 1 and region 2, hence their assigned value is 27 in the result. Example 3: Input:   image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1 Output:   [[5,6,7],[8,9,10],[11,12,13]] Explanation: There is only one  3 x 3  subgrid, while it does not have the condition on difference of adjacent pixels, for example, the difference between  image[0][0]  and  image[1][0]  is  |5 - 8| = 3 > threshold = 1 . None of them belong to any valid regions, so the  result  should be the same as  image .   Constraints: 3 <= n, m <= 500 0 <= image[i][j] <= 255 0 <= threshold <= 255"
3034,https://leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/,Média,Array,Number of Subarrays That Match a Pattern I,"You are given a  0-indexed  integer array  nums  of size  n , and a  0-indexed  integer array  pattern  of size  m  consisting of integers  -1 ,  0 , and  1 . A  subarray   nums[i..j]  of size  m + 1  is said to match the  pattern  if the following conditions hold for each element  pattern[k] : nums[i + k + 1] > nums[i + k]  if  pattern[k] == 1 . nums[i + k + 1] == nums[i + k]  if  pattern[k] == 0 . nums[i + k + 1] < nums[i + k]  if  pattern[k] == -1 . Return  the  count  of subarrays in   nums   that match the   pattern .   Example 1: Input:  nums = [1,2,3,4,5,6], pattern = [1,1] Output:  4 Explanation:  The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern. Hence, there are 4 subarrays in nums that match the pattern. Example 2: Input:  nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1] Output:  2 Explanation:  Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern. Hence, there are 2 subarrays in nums that match the pattern.   Constraints: 2 <= n == nums.length <= 100 1 <= nums[i] <= 10 9 1 <= m == pattern.length < n -1 <= pattern[i] <= 1"
3148,https://leetcode.com/problems/maximum-difference-score-in-a-grid/,Média,Array,Maximum Difference Score in a Grid,"You are given an  m x n  matrix  grid  consisting of  positive  integers. You can move from a cell in the matrix to  any  other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value  c1  to a cell with the value  c2  is  c2 - c1 . You can start at  any  cell, and you have to make  at least  one move. Return the  maximum  total score you can achieve.   Example 1: Input:   grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]] Output:   9 Explanation:  We start at the cell  (0, 1) , and we perform the following moves: - Move from the cell  (0, 1)  to  (2, 1)  with a score of  7 - 5 = 2 . - Move from the cell  (2, 1)  to  (2, 2)  with a score of  14 - 7 = 7 . The total score is  2 + 7 = 9 . Example 2: Input:   grid = [[4,3,2],[3,2,1]] Output:   -1 Explanation:  We start at the cell  (0, 0) , and we perform one move:  (0, 0)  to  (0, 1) . The score is  3 - 4 = -1 .   Constraints: m == grid.length n == grid[i].length 2 <= m, n <= 1000 4 <= m * n <= 10 5 1 <= grid[i][j] <= 10 5"
3159,https://leetcode.com/problems/find-occurrences-of-an-element-in-an-array/,Média,Array,Find Occurrences of an Element in an Array,"You are given an integer array  nums , an integer array  queries , and an integer  x . For each  queries[i] , you need to find the index of the  queries[i] th  occurrence of  x  in the  nums  array. If there are fewer than  queries[i]  occurrences of  x , the answer should be -1 for that query. Return an integer array  answer  containing the answers to all queries.   Example 1: Input:   nums = [1,3,1,7], queries = [1,3,2,4], x = 1 Output:   [0,-1,2,-1] Explanation: For the 1 st  query, the first occurrence of 1 is at index 0. For the 2 nd  query, there are only two occurrences of 1 in  nums , so the answer is -1. For the 3 rd  query, the second occurrence of 1 is at index 2. For the 4 th  query, there are only two occurrences of 1 in  nums , so the answer is -1. Example 2: Input:   nums = [1,2,3], queries = [10], x = 5 Output:   [-1] Explanation: For the 1 st  query, 5 doesn't exist in  nums , so the answer is -1.   Constraints: 1 <= nums.length, queries.length <= 10 5 1 <= queries[i] <= 10 5 1 <= nums[i], x <= 10 4"
3239,https://leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-i/,Média,Array,Minimum Number of Flips to Make Binary Grid Palindromic I,"You are given an  m x n  binary matrix  grid . A row or column is considered  palindromic  if its values read the same forward and backward. You can  flip  any number of cells in  grid  from  0  to  1 , or from  1  to  0 . Return the  minimum  number of cells that need to be flipped to make  either  all rows  palindromic  or all columns  palindromic .   Example 1: Input:   grid = [[1,0,0],[0,0,0],[0,0,1]] Output:   2 Explanation: Flipping the highlighted cells makes all the rows palindromic. Example 2: Input:   grid =  [[0,1],[0,1],[0,0]] Output:   1 Explanation: Flipping the highlighted cell makes all the columns palindromic. Example 3: Input:   grid = [[1],[0]] Output:   0 Explanation: All rows are already palindromic.   Constraints: m == grid.length n == grid[i].length 1 <= m * n <= 2 * 10 5 0 <= grid[i][j] <= 1"
3282,https://leetcode.com/problems/reach-end-of-array-with-max-score/,Média,Array,Reach End of Array With Max Score,"You are given an integer array  nums  of length  n . Your goal is to start at index  0  and reach index  n - 1 . You can only jump to indices  greater  than your current index. The score for a jump from index  i  to index  j  is calculated as  (j - i) * nums[i] . Return the  maximum  possible  total score  by the time you reach the last index.   Example 1: Input:   nums = [1,3,1,5] Output:  7 Explanation: First, jump to index 1 and then jump to the last index. The final score is  1 * 1 + 2 * 3 = 7 . Example 2: Input:   nums = [4,3,1,3,2] Output:  16 Explanation: Jump directly to the last index. The final score is  4 * 4 = 16 .   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 5"
3301,https://leetcode.com/problems/maximize-the-total-height-of-unique-towers/,Média,Array,Maximize the Total Height of Unique Towers,"You are given an array  maximumHeight , where  maximumHeight[i]  denotes the  maximum  height the  i th  tower can be assigned. Your task is to assign a height to each tower so that: The height of the  i th  tower is a positive integer and does not exceed  maximumHeight[i] . No two towers have the same height. Return the  maximum  possible total sum of the tower heights. If it's not possible to assign heights, return  -1 .   Example 1: Input:  maximumHeight  = [2,3,4,3] Output:   10 Explanation: We can assign heights in the following way:  [1, 2, 4, 3] . Example 2: Input:  maximumHeight  = [15,10] Output:   25 Explanation: We can assign heights in the following way:  [15, 10] . Example 3: Input:  maximumHeight  = [2,2,1] Output:   -1 Explanation: It's impossible to assign positive heights to each index so that no two towers have the same height.   Constraints: 1 <= maximumHeight.length <= 10 5 1 <= maximumHeight[i] <= 10 9"
3331,https://leetcode.com/problems/find-subtree-sizes-after-changes/,Média,Array,Find Subtree Sizes After Changes,"You are given a tree rooted at node 0 that consists of  n  nodes numbered from  0  to  n - 1 . The tree is represented by an array  parent  of size  n , where  parent[i]  is the parent of node  i . Since node 0 is the root,  parent[0] == -1 . You are also given a string  s  of length  n , where  s[i]  is the character assigned to node  i . We make the following changes on the tree  one  time  simultaneously  for all nodes  x  from  1  to  n - 1 : Find the  closest  node  y  to node  x  such that  y  is an ancestor of  x , and  s[x] == s[y] . If node  y  does not exist, do nothing. Otherwise,  remove  the edge between  x  and its current parent and make node  y  the new parent of  x  by adding an edge between them. Return an array  answer  of size  n  where  answer[i]  is the  size  of the  subtree  rooted at node  i  in the  final  tree.   Example 1: Input:   parent = [-1,0,0,1,1,1], s = ""abaabc"" Output:   [6,3,1,1,1,1] Explanation: The parent of node 3 will change from node 1 to node 0. Example 2: Input:   parent = [-1,0,4,0,1], s = ""abbba"" Output:   [5,2,1,1,1] Explanation: The following changes will happen at the same time: The parent of node 4 will change from node 1 to node 0. The parent of node 2 will change from node 4 to node 1.   Constraints: n == parent.length == s.length 1 <= n <= 10 5 0 <= parent[i] <= n - 1  for all  i >= 1 . parent[0] == -1 parent  represents a valid tree. s  consists only of lowercase English letters."
3334,https://leetcode.com/problems/find-the-maximum-factor-score-of-array/,Média,Array,Find the Maximum Factor Score of Array,"You are given an integer array  nums . The  factor score  of an array is defined as the  product  of the LCM and GCD of all elements of that array. Return the  maximum factor score  of  nums  after removing  at most  one element from it. Note  that  both  the  LCM  and  GCD  of a single number are the number itself, and the  factor score  of an  empty  array is 0.   Example 1: Input:   nums = [2,4,8,16] Output:   64 Explanation: On removing 2, the GCD of the rest of the elements is 4 while the LCM is 16, which gives a maximum factor score of  4 * 16 = 64 . Example 2: Input:   nums = [1,2,3,4,5] Output:   60 Explanation: The maximum factor score of 60 can be obtained without removing any elements. Example 3: Input:   nums = [3] Output:  9   Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 30"
3355,https://leetcode.com/problems/zero-array-transformation-i/,Média,Array,Zero Array Transformation I,"You are given an integer array  nums  of length  n  and a 2D array  queries , where  queries[i] = [l i , r i ] . For each  queries[i] : Select a  subset  of indices within the range  [l i , r i ]  in  nums . Decrement the values at the selected indices by 1. A  Zero Array  is an array where all elements are equal to 0. Return  true  if it is  possible  to transform  nums  into a  Zero Array  after processing all the queries sequentially, otherwise return  false .   Example 1: Input:   nums = [1,0,1], queries = [[0,2]] Output:   true Explanation: For i = 0: Select the subset of indices as  [0, 2]  and decrement the values at these indices by 1. The array will become  [0, 0, 0] , which is a Zero Array. Example 2: Input:   nums = [4,3,2,1], queries = [[1,3],[0,2]] Output:   false Explanation: For i = 0: Select the subset of indices as  [1, 2, 3]  and decrement the values at these indices by 1. The array will become  [4, 2, 1, 0] . For i = 1: Select the subset of indices as  [0, 1, 2]  and decrement the values at these indices by 1. The array will become  [3, 1, 0, 0] , which is not a Zero Array.   Constraints: 1 <= nums.length <= 10 5 0 <= nums[i] <= 10 5 1 <= queries.length <= 10 5 queries[i].length == 2 0 <= l i  <= r i  < nums.length"
3447,https://leetcode.com/problems/assign-elements-to-groups-with-constraints/,Média,Array,Assign Elements to Groups with Constraints,"You are given an integer array  groups , where  groups[i]  represents the size of the  i th  group. You are also given an integer array  elements . Your task is to assign  one  element to each group based on the following rules: An element at index  j  can be assigned to a group  i  if  groups[i]  is  divisible  by  elements[j] . If there are multiple elements that can be assigned, assign the element with the  smallest index   j . If no element satisfies the condition for a group, assign -1 to that group. Return an integer array  assigned , where  assigned[i]  is the index of the element chosen for group  i , or -1 if no suitable element exists. Note : An element may be assigned to more than one group.   Example 1: Input:   groups = [8,4,3,2,4], elements = [4,2] Output:   [0,0,-1,1,0] Explanation: elements[0] = 4  is assigned to groups 0, 1, and 4. elements[1] = 2  is assigned to group 3. Group 2 cannot be assigned any element. Example 2: Input:   groups = [2,3,5,7], elements = [5,3,3] Output:   [-1,1,0,-1] Explanation: elements[1] = 3  is assigned to group 1. elements[0] = 5  is assigned to group 2. Groups 0 and 3 cannot be assigned any element. Example 3: Input:   groups = [10,21,30,41], elements = [2,1] Output:   [0,1,0,1] Explanation: elements[0] = 2  is assigned to the groups with even values, and  elements[1] = 1  is assigned to the groups with odd values.   Constraints: 1 <= groups.length <= 10 5 1 <= elements.length <= 10 5 1 <= groups[i] <= 10 5 1 <= elements[i] <= 10 5"
3453,https://leetcode.com/problems/separate-squares-i/,Média,Array,Separate Squares I,"You are given a 2D integer array  squares . Each  squares[i] = [x i , y i , l i ]  represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis. Find the  minimum  y-coordinate value of a horizontal line such that the total area of the squares above the line  equals  the total area of the squares below the line. Answers within  10 -5  of the actual answer will be accepted. Note : Squares  may  overlap. Overlapping areas should be counted  multiple times .   Example 1: Input:   squares = [[0,0,1],[2,2,1]] Output:   1.00000 Explanation: Any horizontal line between  y = 1  and  y = 2  will have 1 square unit above it and 1 square unit below it. The lowest option is 1. Example 2: Input:   squares = [[0,0,2],[1,1,1]] Output:   1.16667 Explanation: The areas are: Below the line:  7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5 . Above the line:  5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5 . Since the areas above and below the line are equal, the output is  7/6 = 1.16667 .   Constraints: 1 <= squares.length <= 5 * 10 4 squares[i] = [x i , y i , l i ] squares[i].length == 3 0 <= x i , y i  <= 10 9 1 <= l i  <= 10 9 The total area of all the squares will not exceed  10 12 ."
3513,https://leetcode.com/problems/number-of-unique-xor-triplets-i/,Média,Array,Number of Unique XOR Triplets I,"You are given an integer array  nums  of length  n , where  nums  is a  permutation  of the numbers in the range  [1, n] . A  XOR triplet  is defined as the XOR of three elements  nums[i] XOR nums[j] XOR nums[k]  where  i <= j <= k . Return the number of  unique  XOR triplet values from all possible triplets  (i, j, k) .   Example 1: Input:   nums = [1,2] Output:   2 Explanation: The possible XOR triplet values are: (0, 0, 0) → 1 XOR 1 XOR 1 = 1 (0, 0, 1) → 1 XOR 1 XOR 2 = 2 (0, 1, 1) → 1 XOR 2 XOR 2 = 1 (1, 1, 1) → 2 XOR 2 XOR 2 = 2 The unique XOR values are  {1, 2} , so the output is 2. Example 2: Input:   nums = [3,1,2] Output:   4 Explanation: The possible XOR triplet values include: (0, 0, 0) → 3 XOR 3 XOR 3 = 3 (0, 0, 1) → 3 XOR 3 XOR 1 = 1 (0, 0, 2) → 3 XOR 3 XOR 2 = 2 (0, 1, 2) → 3 XOR 1 XOR 2 = 0 The unique XOR values are  {0, 1, 2, 3} , so the output is 4.   Constraints: 1 <= n == nums.length <= 10 5 1 <= nums[i] <= n nums  is a permutation of integers from  1  to  n ."
3523,https://leetcode.com/problems/make-array-non-decreasing/,Média,Array,Make Array Non-decreasing,"You are given an integer array  nums . In one operation, you can select a  subarray  and replace it with a single element equal to its  maximum  value. Return the  maximum possible size  of the array after performing zero or more operations such that the resulting array is  non-decreasing .   Example 1: Input:   nums = [4,2,5,3,5] Output:   3 Explanation: One way to achieve the maximum size is: Replace subarray  nums[1..2] = [2, 5]  with  5  →  [4, 5, 3, 5] . Replace subarray  nums[2..3] = [3, 5]  with  5  →  [4, 5, 5] . The final array  [4, 5, 5]  is non-decreasing with size  3. Example 2: Input:   nums = [1,2,3] Output:   3 Explanation: No operation is needed as the array  [1,2,3]  is already non-decreasing.   Constraints: 1 <= nums.length <= 2 * 10 5 1 <= nums[i] <= 2 * 10 5"
3546,https://leetcode.com/problems/equal-sum-grid-partition-i/,Média,Array,Equal Sum Grid Partition I,"You are given an  m x n  matrix  grid  of positive integers. Your task is to determine if it is possible to make  either one horizontal or one vertical cut  on the grid such that: Each of the two resulting sections formed by the cut is  non-empty . The sum of the elements in both sections is  equal . Return  true  if such a partition exists; otherwise return  false .   Example 1: Input:   grid = [[1,4],[2,3]] Output:   true Explanation: A horizontal cut between row 0 and row 1 results in two non-empty sections, each with a sum of 5. Thus, the answer is  true . Example 2: Input:   grid = [[1,3],[2,4]] Output:   false Explanation: No horizontal or vertical cut results in two non-empty sections with equal sums. Thus, the answer is  false .   Constraints: 1 <= m == grid.length <= 10 5 1 <= n == grid[i].length <= 10 5 2 <= m * n <= 10 5 1 <= grid[i][j] <= 10 5"
3551,https://leetcode.com/problems/minimum-swaps-to-sort-by-digit-sum/,Média,Array,Minimum Swaps to Sort by Digit Sum,"You are given an array  nums  of  distinct  positive integers. You need to sort the array in  increasing  order based on the sum of the digits of each number. If two numbers have the same digit sum, the  smaller  number appears first in the sorted order. Return the  minimum  number of swaps required to rearrange  nums  into this sorted order. A  swap  is defined as exchanging the values at two distinct positions in the array.   Example 1: Input:   nums = [37,100] Output:   1 Explanation: Compute the digit sum for each integer:  [3 + 7 = 10, 1 + 0 + 0 = 1] → [10, 1] Sort the integers based on digit sum:  [100, 37] . Swap  37  with  100  to obtain the sorted order. Thus, the minimum number of swaps required to rearrange  nums  is 1. Example 2: Input:   nums = [22,14,33,7] Output:   0 Explanation: Compute the digit sum for each integer:  [2 + 2 = 4, 1 + 4 = 5, 3 + 3 = 6, 7 = 7] → [4, 5, 6, 7] Sort the integers based on digit sum:  [22, 14, 33, 7] . The array is already sorted. Thus, the minimum number of swaps required to rearrange  nums  is 0. Example 3: Input:   nums = [18,43,34,16] Output:   2 Explanation: Compute the digit sum for each integer:  [1 + 8 = 9, 4 + 3 = 7, 3 + 4 = 7, 1 + 6 = 7] → [9, 7, 7, 7] Sort the integers based on digit sum:  [16, 34, 43, 18] . Swap  18  with  16 , and swap  43  with  34  to obtain the sorted order. Thus, the minimum number of swaps required to rearrange  nums  is 2.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9 nums  consists of  distinct  positive integers."
84,https://leetcode.com/problems/largest-rectangle-in-histogram/,Difícil,Array,Largest Rectangle in Histogram,"Given an array of integers  heights  representing the histogram's bar height where the width of each bar is  1 , return  the area of the largest rectangle in the histogram .   Example 1: Input:  heights = [2,1,5,6,2,3] Output:  10 Explanation:  The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Example 2: Input:  heights = [2,4] Output:  4   Constraints: 1 <= heights.length <= 10 5 0 <= heights[i] <= 10 4"
329,https://leetcode.com/problems/longest-increasing-path-in-a-matrix/,Difícil,Array,Longest Increasing Path in a Matrix,"Given an  m x n  integers  matrix , return  the length of the longest increasing path in  matrix . From each cell, you can either move in four directions: left, right, up, or down. You  may not  move  diagonally  or move  outside the boundary  (i.e., wrap-around is not allowed).   Example 1: Input:  matrix = [[9,9,4],[6,6,8],[2,1,1]] Output:  4 Explanation:  The longest increasing path is  [1, 2, 6, 9] . Example 2: Input:  matrix = [[3,4,5],[3,2,6],[2,2,1]] Output:  4 Explanation:  The longest increasing path is  [3, 4, 5, 6] . Moving diagonally is not allowed. Example 3: Input:  matrix = [[1]] Output:  1   Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 200 0 <= matrix[i][j] <= 2 31  - 1"
363,https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/,Difícil,Array,Max Sum of Rectangle No Larger Than K,"Given an  m x n  matrix  matrix  and an integer  k , return  the max sum of a rectangle in the matrix such that its sum is no larger than   k . It is  guaranteed  that there will be a rectangle with a sum no larger than  k .   Example 1: Input:  matrix = [[1,0,1],[0,-2,3]], k = 2 Output:  2 Explanation:  Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2). Example 2: Input:  matrix = [[2,2,-1]], k = 3 Output:  3   Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 100 -100 <= matrix[i][j] <= 100 -10 5  <= k <= 10 5   Follow up:  What if the number of rows is much larger than the number of columns?"
381,https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/,Difícil,Array,Insert Delete GetRandom O(1) - Duplicates allowed,"RandomizedCollection  is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element. Implement the  RandomizedCollection  class: RandomizedCollection()  Initializes the empty  RandomizedCollection  object. bool insert(int val)  Inserts an item  val  into the multiset, even if the item is already present. Returns  true  if the item is not present,  false  otherwise. bool remove(int val)  Removes an item  val  from the multiset if present. Returns  true  if the item is present,  false  otherwise. Note that if  val  has multiple occurrences in the multiset, we only remove one of them. int getRandom()  Returns a random element from the current multiset of elements. The probability of each element being returned is  linearly related  to the number of the same values the multiset contains. You must implement the functions of the class such that each function works on  average   O(1)  time complexity. Note:  The test cases are generated such that  getRandom  will only be called if there is  at least one  item in the  RandomizedCollection .   Example 1: Input [""RandomizedCollection"", ""insert"", ""insert"", ""insert"", ""getRandom"", ""remove"", ""getRandom""] [[], [1], [1], [2], [], [1], []] Output [null, true, false, true, 2, true, 1] Explanation RandomizedCollection randomizedCollection = new RandomizedCollection(); randomizedCollection.insert(1);   // return true since the collection does not contain 1.                                   // Inserts 1 into the collection. randomizedCollection.insert(1);   // return false since the collection contains 1.                                   // Inserts another 1 into the collection. Collection now contains [1,1]. randomizedCollection.insert(2);   // return true since the collection does not contain 2.                                   // Inserts 2 into the collection. Collection now contains [1,1,2]. randomizedCollection.getRandom(); // getRandom should:                                   // - return 1 with probability 2/3, or                                   // - return 2 with probability 1/3. randomizedCollection.remove(1);   // return true since the collection contains 1.                                   // Removes 1 from the collection. Collection now contains [1,2]. randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.   Constraints: -2 31  <= val <= 2 31  - 1 At most  2 * 10 5  calls  in total  will be made to  insert ,  remove , and  getRandom . There will be  at least one  element in the data structure when  getRandom  is called."
407,https://leetcode.com/problems/trapping-rain-water-ii/,Difícil,Array,Trapping Rain Water II,"Given an  m x n  integer matrix  heightMap  representing the height of each unit cell in a 2D elevation map, return  the volume of water it can trap after raining .   Example 1: Input:  heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] Output:  4 Explanation:  After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4. Example 2: Input:  heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] Output:  10   Constraints: m == heightMap.length n == heightMap[i].length 1 <= m, n <= 200 0 <= heightMap[i][j] <= 2 * 10 4"
675,https://leetcode.com/problems/cut-off-trees-for-golf-event/,Difícil,Array,Cut Off Trees for Golf Event,"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an  m x n  matrix. In this matrix: 0  means the cell cannot be walked through. 1  represents an empty cell that can be walked through. A number greater than  1  represents a tree in a cell that can be walked through, and this number is the tree's height. In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off. You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes  1  (an empty cell). Starting from the point  (0, 0) , return  the minimum steps you need to walk to cut off all the trees . If you cannot cut off all the trees, return  -1 . Note:  The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.   Example 1: Input:  forest = [[1,2,3],[0,0,4],[7,6,5]] Output:  6 Explanation:  Following the path above allows you to cut off the trees from shortest to tallest in 6 steps. Example 2: Input:  forest = [[1,2,3],[0,0,0],[7,6,5]] Output:  -1 Explanation:  The trees in the bottom row cannot be accessed as the middle row is blocked. Example 3: Input:  forest = [[2,3,4],[0,0,5],[8,7,6]] Output:  6 Explanation:  You can follow the same path as Example 1 to cut off all the trees. Note that you can cut off the first tree at (0, 0) before making any steps.   Constraints: m == forest.length n == forest[i].length 1 <= m, n <= 50 0 <= forest[i][j] <= 10 9 Heights of all trees are  distinct ."
773,https://leetcode.com/problems/sliding-puzzle/,Difícil,Array,Sliding Puzzle,"On an  2 x 3  board, there are five tiles labeled from  1  to  5 , and an empty square represented by  0 . A  move  consists of choosing  0  and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is  [[1,2,3],[4,5,0]] . Given the puzzle board  board , return  the least number of moves required so that the state of the board is solved . If it is impossible for the state of the board to be solved, return  -1 .   Example 1: Input:  board = [[1,2,3],[4,0,5]] Output:  1 Explanation:  Swap the 0 and the 5 in one move. Example 2: Input:  board = [[1,2,3],[5,4,0]] Output:  -1 Explanation:  No number of moves will make the board solved. Example 3: Input:  board = [[4,1,2],[5,0,3]] Output:  5 Explanation:  5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]]   Constraints: board.length == 2 board[i].length == 3 0 <= board[i][j] <= 5 Each value  board[i][j]  is  unique ."
801,https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/,Difícil,Array,Minimum Swaps To Make Sequences Increasing,"You are given two integer arrays of the same length  nums1  and  nums2 . In one operation, you are allowed to swap  nums1[i]  with  nums2[i] . For example, if  nums1 = [1,2,3, 8 ] , and  nums2 = [5,6,7, 4 ] , you can swap the element at  i = 3  to obtain  nums1 = [1,2,3,4]  and  nums2 = [5,6,7,8] . Return  the minimum number of needed operations to make  nums1  and  nums2   strictly increasing . The test cases are generated so that the given input always makes it possible. An array  arr  is  strictly increasing  if and only if  arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1] .   Example 1: Input:  nums1 = [1,3,5,4], nums2 = [1,2,3,7] Output:  1 Explanation:   Swap nums1[3] and nums2[3]. Then the sequences are: nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4] which are both strictly increasing. Example 2: Input:  nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9] Output:  1   Constraints: 2 <= nums1.length <= 10 5 nums2.length == nums1.length 0 <= nums1[i], nums2[i] <= 2 * 10 5"
891,https://leetcode.com/problems/sum-of-subsequence-widths/,Difícil,Array,Sum of Subsequence Widths,"The  width  of a sequence is the difference between the maximum and minimum elements in the sequence. Given an array of integers  nums , return  the sum of the  widths  of all the non-empty  subsequences  of  nums . Since the answer may be very large, return it  modulo   10 9  + 7 . A  subsequence  is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example,  [3,6,2,7]  is a subsequence of the array  [0,3,1,6,2,2,7] .   Example 1: Input:  nums = [2,1,3] Output:  6 Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. Example 2: Input:  nums = [2] Output:  0   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 5"
1284,https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/,Difícil,Array,Minimum Number of Flips to Convert Binary Matrix to Zero Matrix,"Given a  m x n  binary matrix  mat . In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing  1  to  0  and  0  to  1 ). A pair of cells are called neighbors if they share one edge. Return the  minimum number of steps  required to convert  mat  to a zero matrix or  -1  if you cannot. A  binary matrix  is a matrix with all cells equal to  0  or  1  only. A  zero matrix  is a matrix with all cells equal to  0 .   Example 1: Input:  mat = [[0,0],[0,1]] Output:  3 Explanation:  One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown. Example 2: Input:  mat = [[0]] Output:  0 Explanation:  Given matrix is a zero matrix. We do not need to change it. Example 3: Input:  mat = [[1,0,0],[1,0,0]] Output:  -1 Explanation:  Given matrix cannot be a zero matrix.   Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 3 mat[i][j]  is either  0  or  1 ."
1326,https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/,Difícil,Array,Minimum Number of Taps to Open to Water a Garden,"There is a one-dimensional garden on the x-axis. The garden starts at the point  0  and ends at the point  n . (i.e., the length of the garden is  n ). There are  n + 1  taps located at points  [0, 1, ..., n]  in the garden. Given an integer  n  and an integer array  ranges  of length  n + 1  where  ranges[i]  (0-indexed) means the  i-th  tap can water the area  [i - ranges[i], i + ranges[i]]  if it was open. Return  the minimum number of taps  that should be open to water the whole garden, If the garden cannot be watered return  -1 .   Example 1: Input:  n = 5, ranges = [3,4,1,1,0,0] Output:  1 Explanation:  The tap at point 0 can cover the interval [-3,3] The tap at point 1 can cover the interval [-3,5] The tap at point 2 can cover the interval [1,3] The tap at point 3 can cover the interval [2,4] The tap at point 4 can cover the interval [4,4] The tap at point 5 can cover the interval [5,5] Opening Only the second tap will water the whole garden [0,5] Example 2: Input:  n = 3, ranges = [0,0,0,0] Output:  -1 Explanation:  Even if you activate all the four taps you cannot water the whole garden.   Constraints: 1 <= n <= 10 4 ranges.length == n + 1 0 <= ranges[i] <= 100"
1434,https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/,Difícil,Array,Number of Ways to Wear Different Hats to Each Other,"There are  n  people and  40  types of hats labeled from  1  to  40 . Given a 2D integer array  hats , where  hats[i]  is a list of all hats preferred by the  i th  person. Return the number of ways that  n  people can wear  different  hats from each other. Since the answer may be too large, return it modulo  10 9  + 7 .   Example 1: Input:  hats = [[3,4],[4,5],[5]] Output:  1 Explanation:  There is only one way to choose hats given the conditions.  First person choose hat 3, Second person choose hat 4 and last one hat 5. Example 2: Input:  hats = [[3,5,1],[3,5]] Output:  4 Explanation:  There are 4 ways to choose hats: (3,5), (5,3), (1,3) and (1,5) Example 3: Input:  hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]] Output:  24 Explanation:  Each person can choose hats labeled from 1 to 4. Number of Permutations of (1,2,3,4) = 24.   Constraints: n == hats.length 1 <= n <= 10 1 <= hats[i].length <= 40 1 <= hats[i][j] <= 40 hats[i]  contains a list of  unique  integers."
1444,https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/,Difícil,Array,Number of Ways of Cutting a Pizza,"Given a rectangular pizza represented as a  rows x cols  matrix containing the following characters:  'A'  (an apple) and  '.'  (empty cell) and given the integer  k . You have to cut the pizza into  k  pieces using  k-1  cuts.  For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person. Return the number of ways of cutting the pizza such that each piece contains  at least  one apple.  Since the answer can be a huge number, return this modulo 10^9 + 7.   Example 1: Input:  pizza = [""A.."",""AAA"",""...""], k = 3 Output:  3  Explanation:  The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple. Example 2: Input:  pizza = [""A.."",""AA."",""...""], k = 3 Output:  1 Example 3: Input:  pizza = [""A.."",""A.."",""...""], k = 1 Output:  1   Constraints: 1 <= rows, cols <= 50 rows == pizza.length cols == pizza[i].length 1 <= k <= 10 pizza  consists of characters  'A'  and  '.'  only."
1478,https://leetcode.com/problems/allocate-mailboxes/,Difícil,Array,Allocate Mailboxes,"Given the array  houses  where  houses[i]  is the location of the  i th  house along a street and an integer  k , allocate  k  mailboxes in the street. Return  the  minimum  total distance between each house and its nearest mailbox . The test cases are generated so that the answer fits in a 32-bit integer.   Example 1: Input:  houses = [1,4,8,10,20], k = 3 Output:  5 Explanation:  Allocate mailboxes in position 3, 9 and 20. Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5  Example 2: Input:  houses = [2,3,5,12,18], k = 2 Output:  9 Explanation:  Allocate mailboxes in position 3 and 14. Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.   Constraints: 1 <= k <= houses.length <= 100 1 <= houses[i] <= 10 4 All the integers of  houses  are  unique ."
1575,https://leetcode.com/problems/count-all-possible-routes/,Difícil,Array,Count All Possible Routes,"You are given an array of  distinct  positive integers locations where  locations[i]  represents the position of city  i . You are also given integers  start ,  finish  and  fuel  representing the starting city, ending city, and the initial amount of fuel you have, respectively. At each step, if you are at city  i , you can pick any city  j  such that  j != i  and  0 <= j < locations.length  and move to city  j . Moving from city  i  to city  j  reduces the amount of fuel you have by  |locations[i] - locations[j]| . Please notice that  |x|  denotes the absolute value of  x . Notice that  fuel   cannot  become negative at any point in time, and that you are  allowed  to visit any city more than once (including  start  and  finish ). Return  the count of all possible routes from  start   to   finish . Since the answer may be too large, return it modulo  10 9  + 7 .   Example 1: Input:  locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5 Output:  4 Explanation:  The following are all possible routes, each uses 5 units of fuel: 1 -> 3 1 -> 2 -> 3 1 -> 4 -> 3 1 -> 4 -> 2 -> 3 Example 2: Input:  locations = [4,3,1], start = 1, finish = 0, fuel = 6 Output:  5 Explanation:  The following are all possible routes: 1 -> 0, used fuel = 1 1 -> 2 -> 0, used fuel = 5 1 -> 2 -> 1 -> 0, used fuel = 5 1 -> 0 -> 1 -> 0, used fuel = 3 1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5 Example 3: Input:  locations = [5,2,1], start = 0, finish = 2, fuel = 3 Output:  0 Explanation:  It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.   Constraints: 2 <= locations.length <= 100 1 <= locations[i] <= 10 9 All integers in  locations  are  distinct . 0 <= start, finish < locations.length 1 <= fuel <= 200"
1655,https://leetcode.com/problems/distribute-repeating-integers/,Difícil,Array,Distribute Repeating Integers,"You are given an array of  n  integers,  nums , where there are at most  50  unique values in the array. You are also given an array of  m  customer order quantities,  quantity , where  quantity[i]  is the amount of integers the  i th  customer ordered. Determine if it is possible to distribute  nums  such that: The  i th  customer gets  exactly   quantity[i]  integers, The integers the  i th  customer gets are  all equal , and Every customer is satisfied. Return  true  if it is possible to distribute  nums  according to the above conditions .   Example 1: Input:  nums = [1,2,3,4], quantity = [2] Output:  false Explanation:  The 0 th  customer cannot be given two different integers. Example 2: Input:  nums = [1,2,3,3], quantity = [2] Output:  true Explanation:  The 0 th  customer is given [3,3]. The integers [1,2] are not used. Example 3: Input:  nums = [1,1,2,2], quantity = [2,2] Output:  true Explanation:  The 0 th  customer is given [1,1], and the 1st customer is given [2,2].   Constraints: n == nums.length 1 <= n <= 10 5 1 <= nums[i] <= 1000 m == quantity.length 1 <= m <= 10 1 <= quantity[i] <= 10 5 There are at most  50  unique values in  nums ."
1691,https://leetcode.com/problems/maximum-height-by-stacking-cuboids/,Difícil,Array,Maximum Height by Stacking Cuboids,"Given  n   cuboids  where the dimensions of the  i th  cuboid is  cuboids[i] = [width i , length i , height i ]  ( 0-indexed ). Choose a  subset  of  cuboids  and place them on each other. You can place cuboid  i  on cuboid  j  if  width i  <= width j  and  length i  <= length j  and  height i  <= height j . You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid. Return  the  maximum height  of the stacked   cuboids .   Example 1: Input:  cuboids = [[50,45,20],[95,37,53],[45,23,12]] Output:  190 Explanation: Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95. Cuboid 0 is placed next with the 45x20 side facing down with height 50. Cuboid 2 is placed next with the 23x12 side facing down with height 45. The total height is 95 + 50 + 45 = 190. Example 2: Input:  cuboids = [[38,25,45],[76,35,3]] Output:  76 Explanation: You can't place any of the cuboids on the other. We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76. Example 3: Input:  cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]] Output:  102 Explanation: After rearranging the cuboids, you can see that all cuboids have the same dimension. You can place the 11x7 side down on all cuboids so their heights are 17. The maximum height of stacked cuboids is 6 * 17 = 102.   Constraints: n == cuboids.length 1 <= n <= 100 1 <= width i , length i , height i  <= 100"
1770,https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/,Difícil,Array,Maximum Score from Performing Multiplication Operations,"You are given two  0-indexed  integer arrays  nums  and  multipliers   of size  n  and  m  respectively, where  n >= m . You begin with a score of  0 . You want to perform  exactly   m  operations. On the  i th  operation ( 0-indexed ) you will: Choose one integer  x  from  either the start or the end  of the array  nums . Add  multipliers[i] * x  to your score.      Note that  multipliers[0]  corresponds to the first operation,  multipliers[1]  to the second operation, and so on. Remove  x  from  nums . Return  the  maximum  score after performing  m   operations.   Example 1: Input:  nums = [1,2,3], multipliers = [3,2,1] Output:  14 Explanation:  An optimal solution is as follows: - Choose from the end, [1,2, 3 ], adding 3 * 3 = 9 to the score. - Choose from the end, [1, 2 ], adding 2 * 2 = 4 to the score. - Choose from the end, [ 1 ], adding 1 * 1 = 1 to the score. The total score is 9 + 4 + 1 = 14. Example 2: Input:  nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] Output:  102 Explanation:  An optimal solution is as follows: - Choose from the start, [ -5 ,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score. - Choose from the start, [ -3 ,-3,-2,7,1], adding -3 * -5 = 15 to the score. - Choose from the start, [ -3 ,-2,7,1], adding -3 * 3 = -9 to the score. - Choose from the end, [-2,7, 1 ], adding 1 * 4 = 4 to the score. - Choose from the end, [-2, 7 ], adding 7 * 6 = 42 to the score.  The total score is 50 + 15 - 9 + 4 + 42 = 102.   Constraints: n == nums.length m == multipliers.length 1 <= m <= 300 m <= n <= 10 5   -1000 <= nums[i], multipliers[i] <= 1000"
1793,https://leetcode.com/problems/maximum-score-of-a-good-subarray/,Difícil,Array,Maximum Score of a Good Subarray,"You are given an array of integers  nums   (0-indexed)  and an integer  k . The  score  of a subarray  (i, j)  is defined as  min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) . A  good  subarray is a subarray where  i <= k <= j . Return  the maximum possible  score  of a  good  subarray.   Example 1: Input:  nums = [1,4,3,7,4,5], k = 3 Output:  15 Explanation:  The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15.  Example 2: Input:  nums = [5,5,4,5,4,1,1,1], k = 0 Output:  20 Explanation:  The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 2 * 10 4 0 <= k < nums.length"
1819,https://leetcode.com/problems/number-of-different-subsequences-gcds/,Difícil,Array,Number of Different Subsequences GCDs,"You are given an array  nums  that consists of positive integers. The  GCD  of a sequence of numbers is defined as the greatest integer that divides  all  the numbers in the sequence evenly. For example, the GCD of the sequence  [4,6,16]  is  2 . A  subsequence  of an array is a sequence that can be formed by removing some elements (possibly none) of the array. For example,  [2,5,10]  is a subsequence of  [1,2,1, 2 ,4,1, 5 , 10 ] . Return  the  number  of  different  GCDs among all  non-empty  subsequences of   nums .   Example 1: Input:  nums = [6,10,3] Output:  5 Explanation:  The figure shows all the non-empty subsequences and their GCDs. The different GCDs are 6, 10, 3, 2, and 1. Example 2: Input:  nums = [5,15,40,5,6] Output:  7   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 2 * 10 5"
1840,https://leetcode.com/problems/maximum-building-height/,Difícil,Array,Maximum Building Height,"You want to build  n  new buildings in a city. The new buildings will be built in a line and are labeled from  1  to  n . However, there are city restrictions on the heights of the new buildings: The height of each building must be a non-negative integer. The height of the first building  must  be  0 . The height difference between any two adjacent buildings  cannot exceed   1 . Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array  restrictions  where  restrictions[i] = [id i , maxHeight i ]  indicates that building  id i  must have a height  less than or equal to   maxHeight i . It is guaranteed that each building will appear  at most once  in  restrictions , and building  1  will  not  be in  restrictions . Return  the  maximum possible height  of the  tallest  building .   Example 1: Input:  n = 5, restrictions = [[2,1],[4,1]] Output:  2 Explanation:  The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2. Example 2: Input:  n = 6, restrictions = [] Output:  5 Explanation:  The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5. Example 3: Input:  n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]] Output:  5 Explanation:  The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5.   Constraints: 2 <= n <= 10 9 0 <= restrictions.length <= min(n - 1, 10 5 ) 2 <= id i  <= n id i  is  unique . 0 <= maxHeight i  <= 10 9"
1862,https://leetcode.com/problems/sum-of-floored-pairs/,Difícil,Array,Sum of Floored Pairs,"Given an integer array  nums , return the sum of  floor(nums[i] / nums[j])  for all pairs of indices  0 <= i, j < nums.length  in the array. Since the answer may be too large, return it  modulo   10 9  + 7 . The  floor()  function returns the integer part of the division.   Example 1: Input:  nums = [2,5,9] Output:  10 Explanation: floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0 floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1 floor(5 / 2) = 2 floor(9 / 2) = 4 floor(9 / 5) = 1 We calculate the floor of the division for every pair of indices in the array then sum them up. Example 2: Input:  nums = [7,7,7,7,7,7,7] Output:  49   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 5"
1872,https://leetcode.com/problems/stone-game-viii/,Difícil,Array,Stone Game VIII,"Alice and Bob take turns playing a game, with  Alice starting first . There are  n  stones arranged in a row. On each player's turn, while the number of stones is  more than one , they will do the following: Choose an integer  x > 1 , and  remove  the leftmost  x  stones from the row. Add the  sum  of the  removed  stones' values to the player's score. Place a  new stone , whose value is equal to that sum, on the left side of the row. The game stops when  only   one  stone is left in the row. The  score difference  between Alice and Bob is  (Alice's score - Bob's score) . Alice's goal is to  maximize  the score difference, and Bob's goal is the  minimize  the score difference. Given an integer array  stones  of length  n  where  stones[i]  represents the value of the  i th  stone  from the left , return  the  score difference  between Alice and Bob if they both play  optimally .   Example 1: Input:  stones = [-1,2,-3,4,-5] Output:  5 Explanation: - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of   value 2 on the left. stones = [2,-5]. - Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on   the left. stones = [-3]. The difference between their scores is 2 - (-3) = 5. Example 2: Input:  stones = [7,-6,5,10,5,-2,-6] Output:  13 Explanation: - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a   stone of value 13 on the left. stones = [13]. The difference between their scores is 13 - 0 = 13. Example 3: Input:  stones = [-10,-12] Output:  -22 Explanation: - Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her   score and places a stone of value -22 on the left. stones = [-22]. The difference between their scores is (-22) - 0 = -22.   Constraints: n == stones.length 2 <= n <= 10 5 -10 4  <= stones[i] <= 10 4"
1883,https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/,Difícil,Array,Minimum Skips to Arrive at Meeting On Time,"You are given an integer  hoursBefore , the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through  n  roads. The road lengths are given as an integer array  dist  of length  n , where  dist[i]  describes the length of the  i th  road in  kilometers . In addition, you are given an integer  speed , which is the speed (in  km/h ) you will travel at. After you travel road  i , you must rest and wait for the  next integer hour  before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting. For example, if traveling a road takes  1.4  hours, you must wait until the  2  hour mark before traveling the next road. If traveling a road takes exactly  2  hours, you do not need to wait. However, you are allowed to  skip  some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks. For example, suppose traveling the first road takes  1.4  hours and traveling the second road takes  0.6  hours. Skipping the rest after the first road will mean you finish traveling the second road right at the  2  hour mark, letting you start traveling the third road immediately. Return  the  minimum number of skips required  to arrive at the meeting on time, or   -1  if it is  impossible .   Example 1: Input:  dist = [1,3,2], speed = 4, hoursBefore = 2 Output:  1 Explanation: Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours. You can skip the first rest to arrive in ((1/4 +  0 ) + (3/4 + 0)) + (2/4) = 1.5 hours. Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest. Example 2: Input:  dist = [7,3,5,5], speed = 2, hoursBefore = 10 Output:  2 Explanation: Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours. You can skip the first and third rest to arrive in ((7/2 +  0 ) + (3/2 + 0)) + ((5/2 +  0 ) + (5/2)) = 10 hours. Example 3: Input:  dist = [7,3,5,5], speed = 1, hoursBefore = 10 Output:  -1 Explanation:  It is impossible to arrive at the meeting on time even if you skip all the rests.   Constraints: n == dist.length 1 <= n <= 1000 1 <= dist[i] <= 10 5 1 <= speed <= 10 6 1 <= hoursBefore <= 10 7"
2111,https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/,Difícil,Array,Minimum Operations to Make the Array K-Increasing,"You are given a  0-indexed  array  arr  consisting of  n  positive integers, and a positive integer  k . The array  arr  is called  K-increasing  if  arr[i-k] <= arr[i]  holds for every index  i , where  k <= i <= n-1 . For example,  arr = [4, 1, 5, 2, 6, 2]  is K-increasing for  k = 2  because: 	 arr[0] <= arr[2] (4 <= 5) arr[1] <= arr[3] (1 <= 2) arr[2] <= arr[4] (5 <= 6) arr[3] <= arr[5] (2 <= 2) However, the same  arr  is not K-increasing for  k = 1  (because  arr[0] > arr[1] ) or  k = 3  (because  arr[0] > arr[3] ). In one  operation , you can choose an index  i  and  change   arr[i]  into  any  positive integer. Return  the  minimum number of operations  required to make the array K-increasing for the given  k .   Example 1: Input:  arr = [5,4,3,2,1], k = 1 Output:  4 Explanation: For k = 1, the resultant array has to be non-decreasing. Some of the K-increasing arrays that can be formed are [5, 6 , 7 , 8 , 9 ], [ 1 , 1 , 1 , 1 ,1], [ 2 , 2 ,3, 4 , 4 ]. All of them require 4 operations. It is suboptimal to change the array to, for example, [ 6 , 7 , 8 , 9 , 10 ] because it would take 5 operations. It can be shown that we cannot make the array K-increasing in less than 4 operations. Example 2: Input:  arr = [4,1,5,2,6,2], k = 2 Output:  0 Explanation: This is the same example as the one in the problem description. Here, for every index i where 2 <= i <= 5, arr[i-2] <=   arr[i]. Since the given array is already K-increasing, we do not need to perform any operations. Example 3: Input:  arr = [4,1,5,2,6,2], k = 3 Output:  2 Explanation: Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5. One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5. The array will now be [4,1,5, 4 ,6, 5 ]. Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations.   Constraints: 1 <= arr.length <= 10 5 1 <= arr[i], k <= arr.length"
2163,https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/,Difícil,Array,Minimum Difference in Sums After Removal of Elements,"You are given a  0-indexed  integer array  nums  consisting of  3 * n  elements. You are allowed to remove any  subsequence  of elements of size  exactly   n  from  nums . The remaining  2 * n  elements will be divided into two  equal  parts: The first  n  elements belonging to the first part and their sum is  sum first . The next  n  elements belonging to the second part and their sum is  sum second . The  difference in sums  of the two parts is denoted as  sum first  - sum second . For example, if  sum first  = 3  and  sum second  = 2 , their difference is  1 . Similarly, if  sum first  = 2  and  sum second  = 3 , their difference is  -1 . Return  the  minimum difference  possible between the sums of the two parts after the removal of  n  elements .   Example 1: Input:  nums = [3,1,2] Output:  -1 Explanation:  Here, nums has 3 elements, so n = 1.  Thus we have to remove 1 element from nums and divide the array into two equal parts. - If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1. - If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1. - If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2. The minimum difference between sums of the two parts is min(-1,1,2) = -1.  Example 2: Input:  nums = [7,9,5,8,1,3] Output:  1 Explanation:  Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each. If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12. To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1. It can be shown that it is not possible to obtain a difference smaller than 1.   Constraints: nums.length == 3 * n 1 <= n <= 10 5 1 <= nums[i] <= 10 5"
2197,https://leetcode.com/problems/replace-non-coprime-numbers-in-array/,Difícil,Array,Replace Non-Coprime Numbers in Array,"You are given an array of integers  nums . Perform the following steps: Find  any  two  adjacent  numbers in  nums  that are  non-coprime . If no such numbers are found,  stop  the process. Otherwise, delete the two numbers and  replace  them with their  LCM (Least Common Multiple) . Repeat  this process as long as you keep finding two adjacent non-coprime numbers. Return  the  final  modified array.  It can be shown that replacing adjacent non-coprime numbers in  any  arbitrary order will lead to the same result. The test cases are generated such that the values in the final array are  less than or equal  to  10 8 . Two values  x  and  y  are  non-coprime  if  GCD(x, y) > 1  where  GCD(x, y)  is the  Greatest Common Divisor  of  x  and  y .   Example 1: Input:  nums = [6,4,3,2,7,6,2] Output:  [12,7,6] Explanation:   - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [ 12 ,3,2,7,6,2]. - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [ 12 ,2,7,6,2]. - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [ 12 ,7,6,2]. - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7, 6 ]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [12,7,6]. Note that there are other ways to obtain the same resultant array. Example 2: Input:  nums = [2,2,1,1,3,3,3] Output:  [2,1,1,3] Explanation:   - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1, 3 ,3]. - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1, 3 ]. - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [ 2 ,1,1,3]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [2,1,1,3]. Note that there are other ways to obtain the same resultant array.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 5 The test cases are generated such that the values in the final array are  less than or equal  to  10 8 ."
2213,https://leetcode.com/problems/longest-substring-of-one-repeating-character/,Difícil,Array,Longest Substring of One Repeating Character,"You are given a  0-indexed  string  s . You are also given a  0-indexed  string  queryCharacters  of length  k  and a  0-indexed  array of integer  indices   queryIndices  of length  k , both of which are used to describe  k  queries. The  i th  query updates the character in  s  at index  queryIndices[i]  to the character  queryCharacters[i] . Return  an array   lengths   of length  k  where   lengths[i]   is the  length  of the  longest substring  of  s  consisting of  only one repeating  character  after  the   i th   query  is performed.   Example 1: Input:  s = ""babacc"", queryCharacters = ""bcb"", queryIndices = [1,3,3] Output:  [3,3,4] Explanation:   - 1 st  query updates s = "" b b b acc"". The longest substring consisting of one repeating character is ""bbb"" with length 3. - 2 nd  query updates s = ""bbb c cc "".    The longest substring consisting of one repeating character can be ""bbb"" or ""ccc"" with length 3. - 3 rd  query updates s = "" bbb b cc"". The longest substring consisting of one repeating character is ""bbbb"" with length 4. Thus, we return [3,3,4]. Example 2: Input:  s = ""abyzz"", queryCharacters = ""aa"", queryIndices = [2,1] Output:  [2,3] Explanation: - 1 st  query updates s = ""ab a zz "". The longest substring consisting of one repeating character is ""zz"" with length 2. - 2 nd  query updates s = "" a a a zz"". The longest substring consisting of one repeating character is ""aaa"" with length 3. Thus, we return [2,3].   Constraints: 1 <= s.length <= 10 5 s  consists of lowercase English letters. k == queryCharacters.length == queryIndices.length 1 <= k <= 10 5 queryCharacters  consists of lowercase English letters. 0 <= queryIndices[i] < s.length"
2218,https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/,Difícil,Array,Maximum Value of K Coins From Piles,"There are  n   piles  of coins on a table. Each pile consists of a  positive number  of coins of assorted denominations. In one move, you can choose any coin on  top  of any pile, remove it, and add it to your wallet. Given a list  piles , where  piles[i]  is a list of integers denoting the composition of the  i th  pile from  top to bottom , and a positive integer  k , return  the  maximum total value  of coins you can have in your wallet if you choose  exactly   k   coins optimally .   Example 1: Input:  piles = [[1,100,3],[7,8,9]], k = 2 Output:  101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. Example 2: Input:  piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output:  706 Explanation: The maximum total can be obtained if we choose all coins from the last pile.   Constraints: n == piles.length 1 <= n <= 1000 1 <= piles[i][j] <= 10 5 1 <= k <= sum(piles[i].length) <= 2000"
2306,https://leetcode.com/problems/naming-a-company/,Difícil,Array,Naming a Company,"You are given an array of strings  ideas  that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows: Choose 2  distinct  names from  ideas , call them  idea A  and  idea B . Swap the first letters of  idea A  and  idea B  with each other. If  both  of the new names are not found in the original  ideas , then the name  idea A  idea B  (the  concatenation  of  idea A  and  idea B , separated by a space) is a valid company name. Otherwise, it is not a valid name. Return  the number of  distinct  valid names for the company .   Example 1: Input:  ideas = [""coffee"",""donuts"",""time"",""toffee""] Output:  6 Explanation:  The following selections are valid: - (""coffee"", ""donuts""): The company name created is ""doffee conuts"". - (""donuts"", ""coffee""): The company name created is ""conuts doffee"". - (""donuts"", ""time""): The company name created is ""tonuts dime"". - (""donuts"", ""toffee""): The company name created is ""tonuts doffee"". - (""time"", ""donuts""): The company name created is ""dime tonuts"". - (""toffee"", ""donuts""): The company name created is ""doffee tonuts"". Therefore, there are a total of 6 distinct company names. The following are some examples of invalid selections: - (""coffee"", ""time""): The name ""toffee"" formed after swapping already exists in the original array. - (""time"", ""toffee""): Both names are still the same after swapping and exist in the original array. - (""coffee"", ""toffee""): Both names formed after swapping already exist in the original array. Example 2: Input:  ideas = [""lack"",""back""] Output:  0 Explanation:  There are no valid selections. Therefore, 0 is returned.   Constraints: 2 <= ideas.length <= 5 * 10 4 1 <= ideas[i].length <= 10 ideas[i]  consists of lowercase English letters. All the strings in  ideas  are  unique ."
2392,https://leetcode.com/problems/build-a-matrix-with-conditions/,Difícil,Array,Build a Matrix With Conditions,"You are given a  positive  integer  k . You are also given: a 2D integer array  rowConditions  of size  n  where  rowConditions[i] = [above i , below i ] , and a 2D integer array  colConditions  of size  m  where  colConditions[i] = [left i , right i ] . The two arrays contain integers from  1  to  k . You have to build a  k x k  matrix that contains each of the numbers from  1  to  k   exactly once . The remaining cells should have the value  0 . The matrix should also satisfy the following conditions: The number  above i  should appear in a  row  that is strictly  above  the row at which the number  below i  appears for all  i  from  0  to  n - 1 . The number  left i  should appear in a  column  that is strictly  left  of the column at which the number  right i  appears for all  i  from  0  to  m - 1 . Return  any  matrix that satisfies the conditions . If no answer exists, return an empty matrix.   Example 1: Input:  k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]] Output:  [[3,0,0],[0,0,1],[0,2,0]] Explanation:  The diagram above shows a valid example of a matrix that satisfies all the conditions. The row conditions are the following: - Number 1 is in row  1 , and number 2 is in row  2 , so 1 is above 2 in the matrix. - Number 3 is in row  0 , and number 2 is in row  2 , so 3 is above 2 in the matrix. The column conditions are the following: - Number 2 is in column  1 , and number 1 is in column  2 , so 2 is left of 1 in the matrix. - Number 3 is in column  0 , and number 2 is in column  1 , so 3 is left of 2 in the matrix. Note that there may be multiple correct answers. Example 2: Input:  k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]] Output:  [] Explanation:  From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied. No matrix can satisfy all the conditions, so we return the empty matrix.   Constraints: 2 <= k <= 400 1 <= rowConditions.length, colConditions.length <= 10 4 rowConditions[i].length == colConditions[i].length == 2 1 <= above i , below i , left i , right i  <= k above i  != below i left i  != right i"
2538,https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/,Difícil,Array,Difference Between Maximum and Minimum Price Sum,"There exists an undirected and initially unrooted tree with  n  nodes indexed from  0  to  n - 1 . You are given the integer  n  and a 2D integer array  edges  of length  n - 1 , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. Each node has an associated price. You are given an integer array  price , where  price[i]  is the price of the  i th  node. The  price sum  of a given path is the sum of the prices of all nodes lying on that path. The tree can be rooted at any node  root  of your choice. The incurred  cost  after choosing  root  is the difference between the maximum and minimum  price sum  amongst all paths starting at  root . Return  the  maximum  possible  cost   amongst all possible root choices .   Example 1: Input:  n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] Output:  24 Explanation:  The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum. - The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31. - The second path contains the node [2] with the price [7]. The difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost. Example 2: Input:  n = 3, edges = [[0,1],[1,2]], price = [1,1,1] Output:  2 Explanation:  The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum. - The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3. - The second path contains node [0] with a price [1]. The difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.   Constraints: 1 <= n <= 10 5 edges.length == n - 1 0 <= a i , b i  <= n - 1 edges  represents a valid tree. price.length == n 1 <= price[i] <= 10 5"
2581,https://leetcode.com/problems/count-number-of-possible-root-nodes/,Difícil,Array,Count Number of Possible Root Nodes,"Alice has an undirected tree with  n  nodes labeled from  0  to  n - 1 . The tree is represented as a 2D integer array  edges  of length  n - 1  where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. Alice wants Bob to find the root of the tree. She allows Bob to make several  guesses  about her tree. In one guess, he does the following: Chooses two  distinct  integers  u  and  v  such that there exists an edge  [u, v]  in the tree. He tells Alice that  u  is the  parent  of  v  in the tree. Bob's guesses are represented by a 2D integer array  guesses  where  guesses[j] = [u j , v j ]  indicates Bob guessed  u j  to be the parent of  v j . Alice being lazy, does not reply to each of Bob's guesses, but just says that  at least   k  of his guesses are  true . Given the 2D integer arrays  edges ,  guesses  and the integer  k , return  the  number of possible nodes  that can be the root of Alice's tree . If there is no such tree, return  0 .   Example 1: Input:  edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3 Output:  3 Explanation:   Root = 0, correct guesses = [1,3], [0,1], [2,4] Root = 1, correct guesses = [1,3], [1,0], [2,4] Root = 2, correct guesses = [1,3], [1,0], [2,4] Root = 3, correct guesses = [1,0], [2,4] Root = 4, correct guesses = [1,3], [1,0] Considering 0, 1, or 2 as root node leads to 3 correct guesses. Example 2: Input:  edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1 Output:  5 Explanation:   Root = 0, correct guesses = [3,4] Root = 1, correct guesses = [1,0], [3,4] Root = 2, correct guesses = [1,0], [2,1], [3,4] Root = 3, correct guesses = [1,0], [2,1], [3,2], [3,4] Root = 4, correct guesses = [1,0], [2,1], [3,2] Considering any node as root will give at least 1 correct guess.    Constraints: edges.length == n - 1 2 <= n <= 10 5 1 <= guesses.length <= 10 5 0 <= a i , b i , u j , v j  <= n - 1 a i  != b i u j  != v j edges  represents a valid tree. guesses[j]  is an edge of the tree. guesses  is unique. 0 <= k <= guesses.length"
2659,https://leetcode.com/problems/make-array-empty/,Difícil,Array,Make Array Empty,"You are given an integer array  nums  containing  distinct  numbers, and you can perform the following operations  until the array is empty : If the first element has the  smallest  value, remove it Otherwise, put the first element at the  end  of the array. Return  an integer denoting the number of operations it takes to make  nums  empty.   Example 1: Input:  nums = [3,4,-1] Output:  5 Operation Array 1 [4, -1, 3] 2 [-1, 3, 4] 3 [3, 4] 4 [4] 5 [] Example 2: Input:  nums = [1,2,4,3] Output:  5 Operation Array 1 [2, 4, 3] 2 [4, 3] 3 [3, 4] 4 [4] 5 [] Example 3: Input:  nums = [1,2,3] Output:  3 Operation Array 1 [2, 3] 2 [3] 3 []   Constraints: 1 <= nums.length <= 10 5 -10 9  <= nums[i] <= 10 9 All values in  nums  are  distinct ."
2836,https://leetcode.com/problems/maximize-value-of-function-in-a-ball-passing-game/,Difícil,Array,Maximize Value of Function in a Ball Passing Game,"You are given an integer array  receiver  of length  n  and an integer  k .  n  players are playing a ball-passing game. You choose the starting player,  i . The game proceeds as follows: player  i  passes the ball to player  receiver[i] , who then passes it to  receiver[receiver[i]] , and so on, for  k  passes in total. The game's score is the sum of the indices of the players who touched the ball, including repetitions, i.e.  i + receiver[i] + receiver[receiver[i]] + ... + receiver (k) [i] . Return the  maximum  possible score. Notes: receiver  may contain duplicates. receiver[i]  may be equal to  i .   Example 1: Input:   receiver = [2,0,1], k = 4 Output:   6 Explanation: Starting with player  i = 2  the initial score is 2: Pass Sender Index Receiver Index Score 1 2 1 3 2 1 0 3 3 0 2 5 4 2 1 6 Example 2: Input:   receiver = [1,1,1,2,3], k = 3 Output:   10 Explanation: Starting with player  i = 4  the initial score is 4: Pass Sender Index Receiver Index Score 1 4 3 7 2 3 2 9 3 2 1 10   Constraints: 1 <= receiver.length == n <= 10 5 0 <= receiver[i] <= n - 1 1 <= k <= 10 10"
2897,https://leetcode.com/problems/apply-operations-on-array-to-maximize-sum-of-squares/,Difícil,Array,Apply Operations on Array to Maximize Sum of Squares,"You are given a  0-indexed  integer array  nums  and a  positive  integer  k . You can do the following operation on the array  any  number of times: Choose any two distinct indices  i  and  j  and  simultaneously  update the values of  nums[i]  to  (nums[i] AND nums[j])  and  nums[j]  to  (nums[i] OR nums[j]) . Here,  OR  denotes the bitwise  OR  operation, and  AND  denotes the bitwise  AND  operation. You have to choose  k  elements from the final array and calculate the sum of their  squares . Return  the  maximum  sum of squares you can achieve . Since the answer can be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  nums = [2,6,5,8], k = 2 Output:  261 Explanation:  We can do the following operations on the array: - Choose i = 0 and j = 3, then change nums[0] to (2 AND 8) = 0 and nums[3] to (2 OR 8) = 10. The resulting array is nums = [0,6,5,10]. - Choose i = 2 and j = 3, then change nums[2] to (5 AND 10) = 0 and nums[3] to (5 OR 10) = 15. The resulting array is nums = [0,6,0,15]. We can choose the elements 15 and 6 from the final array. The sum of squares is 15 2  + 6 2  = 261. It can be shown that this is the maximum value we can get. Example 2: Input:  nums = [4,5,4,7], k = 3 Output:  90 Explanation:  We do not need to apply any operations. We can choose the elements 7, 5, and 4 with a sum of squares: 7 2  + 5 2  + 4 2  = 90. It can be shown that this is the maximum value we can get.   Constraints: 1 <= k <= nums.length <= 10 5 1 <= nums[i] <= 10 9"
2920,https://leetcode.com/problems/maximum-points-after-collecting-coins-from-all-nodes/,Difícil,Array,Maximum Points After Collecting Coins From All Nodes,"There exists an undirected tree rooted at node  0  with  n  nodes labeled from  0  to  n - 1 . You are given a 2D  integer  array  edges  of length  n - 1 , where  edges[i] = [a i , b i ]  indicates that there is an edge between nodes  a i  and  b i  in the tree. You are also given a  0-indexed  array  coins  of size  n  where  coins[i]  indicates the number of coins in the vertex  i , and an integer  k . Starting from the root, you have to collect all the coins such that the coins at a node can only be collected if the coins of its ancestors have been already collected. Coins at  node i  can be collected in one of the following ways: Collect all the coins, but you will get  coins[i] - k  points. If  coins[i] - k  is negative then you will lose  abs(coins[i] - k)  points. Collect all the coins, but you will get  floor(coins[i] / 2)  points. If this way is used, then for all the  node j  present in the subtree of  node i ,  coins[j]  will get reduced to  floor(coins[j] / 2) . Return  the  maximum points  you can get after collecting the coins from  all  the tree nodes.   Example 1: Input:  edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5 Output:  11                         Explanation:   Collect all the coins from node 0 using the first way. Total points = 10 - 5 = 5. Collect all the coins from node 1 using the first way. Total points = 5 + (10 - 5) = 10. Collect all the coins from node 2 using the second way so coins left at node 3 will be floor(3 / 2) = 1. Total points = 10 + floor(3 / 2) = 11. Collect all the coins from node 3 using the second way. Total points = 11 + floor(1 / 2) = 11. It can be shown that the maximum points we can get after collecting coins from all the nodes is 11.  Example 2:   Input:  edges = [[0,1],[0,2]], coins = [8,4,4], k = 0 Output:  16 Explanation:   Coins will be collected from all the nodes using the first way. Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.   Constraints: n == coins.length 2 <= n <= 10 5 0 <= coins[i] <= 10 4 edges.length == n - 1 0 <= edges[i][0], edges[i][1] < n 0 <= k <= 10 4"
2926,https://leetcode.com/problems/maximum-balanced-subsequence-sum/,Difícil,Array,Maximum Balanced Subsequence Sum,"You are given a  0-indexed  integer array  nums . A  subsequence  of  nums  having length  k  and consisting of  indices   i 0  < i 1  < ... < i k-1  is  balanced  if the following holds: nums[i j ] - nums[i j-1 ] >= i j  - i j-1 , for every  j  in the range  [1, k - 1] . A  subsequence  of  nums  having length  1  is considered balanced. Return  an integer denoting the  maximum  possible  sum of elements  in a  balanced  subsequence of  nums . A  subsequence  of an array is a new  non-empty  array that is formed from the original array by deleting some ( possibly none ) of the elements without disturbing the relative positions of the remaining elements.   Example 1: Input:  nums = [3,3,5,6] Output:  14 Explanation:  In this example, the subsequence [3,5,6] consisting of indices 0, 2, and 3 can be selected. nums[2] - nums[0] >= 2 - 0. nums[3] - nums[2] >= 3 - 2. Hence, it is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums. The subsequence consisting of indices 1, 2, and 3 is also valid. It can be shown that it is not possible to get a balanced subsequence with a sum greater than 14. Example 2: Input:  nums = [5,-1,-3,8] Output:  13 Explanation:  In this example, the subsequence [5,8] consisting of indices 0 and 3 can be selected. nums[3] - nums[0] >= 3 - 0. Hence, it is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums. It can be shown that it is not possible to get a balanced subsequence with a sum greater than 13. Example 3: Input:  nums = [-2,-1] Output:  -1 Explanation:  In this example, the subsequence [-1] can be selected. It is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums.   Constraints: 1 <= nums.length <= 10 5 -10 9  <= nums[i] <= 10 9"
2945,https://leetcode.com/problems/find-maximum-non-decreasing-array-length/,Difícil,Array,Find Maximum Non-decreasing Array Length,"You are given a  0-indexed  integer array  nums . You can perform any number of operations, where each operation involves selecting a  subarray  of the array and replacing it with the  sum  of its elements. For example, if the given array is  [1,3,5,6]  and you select subarray  [3,5]  the array will convert to  [1,8,6] . Return  the  maximum  length of a  non-decreasing  array that can be made after applying operations. A  subarray  is a contiguous  non-empty  sequence of elements within an array.   Example 1: Input:  nums = [5,2,2] Output:  1 Explanation:  This array with length 3 is not non-decreasing. We have two ways to make the array length two. First, choosing subarray [2,2] converts the array to [5,4]. Second, choosing subarray [5,2] converts the array to [7,2]. In these two ways the array is not non-decreasing. And if we choose subarray [5,2,2] and replace it with [9] it becomes non-decreasing.  So the answer is 1. Example 2: Input:  nums = [1,2,3,4] Output:  4 Explanation:  The array is non-decreasing. So the answer is 4. Example 3: Input:  nums = [4,3,2,6] Output:  3 Explanation:  Replacing [3,2] with [5] converts the given array to [4,5,6] that is non-decreasing. Because the given array is not non-decreasing, the maximum  possible answer is 3.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 5"
2968,https://leetcode.com/problems/apply-operations-to-maximize-frequency-score/,Difícil,Array,Apply Operations to Maximize Frequency Score,"You are given a  0-indexed  integer array  nums  and an integer  k . You can perform the following operation on the array  at most   k  times: Choose any index  i  from the array and  increase  or  decrease   nums[i]  by  1 . The score of the final array is the  frequency  of the most frequent element in the array. Return  the  maximum  score you can achieve . The frequency of an element is the number of occurences of that element in the array.   Example 1: Input:  nums = [1,2,6,4], k = 3 Output:  3 Explanation:  We can do the following operations on the array: - Choose i = 0, and increase the value of nums[0] by 1. The resulting array is [2,2,6,4]. - Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,3]. - Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,2]. The element 2 is the most frequent in the final array so our score is 3. It can be shown that we cannot achieve a better score. Example 2: Input:  nums = [1,4,4,2,4], k = 0 Output:  3 Explanation:  We cannot apply any operations so our score will be the frequency of the most frequent element in the original array, which is 3.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9 0 <= k <= 10 14"
3045,https://leetcode.com/problems/count-prefix-and-suffix-pairs-ii/,Difícil,Array,Count Prefix and Suffix Pairs II,"You are given a  0-indexed  string array  words . Let's define a  boolean  function  isPrefixAndSuffix  that takes two strings,  str1  and  str2 : isPrefixAndSuffix(str1, str2)  returns  true  if  str1  is  both  a  prefix  and a  suffix  of  str2 , and  false  otherwise. For example,  isPrefixAndSuffix(""aba"", ""ababa"")  is  true  because  ""aba""  is a prefix of  ""ababa""  and also a suffix, but  isPrefixAndSuffix(""abc"", ""abcd"")  is  false . Return  an integer denoting the  number  of index pairs  (i ,  j)  such that  i < j , and  isPrefixAndSuffix(words[i], words[j])  is  true .   Example 1: Input:  words = [""a"",""aba"",""ababa"",""aa""] Output:  4 Explanation:  In this example, the counted index pairs are: i = 0 and j = 1 because isPrefixAndSuffix(""a"", ""aba"") is true. i = 0 and j = 2 because isPrefixAndSuffix(""a"", ""ababa"") is true. i = 0 and j = 3 because isPrefixAndSuffix(""a"", ""aa"") is true. i = 1 and j = 2 because isPrefixAndSuffix(""aba"", ""ababa"") is true. Therefore, the answer is 4. Example 2: Input:  words = [""pa"",""papa"",""ma"",""mama""] Output:  2 Explanation:  In this example, the counted index pairs are: i = 0 and j = 1 because isPrefixAndSuffix(""pa"", ""papa"") is true. i = 2 and j = 3 because isPrefixAndSuffix(""ma"", ""mama"") is true. Therefore, the answer is 2.   Example 3: Input:  words = [""abab"",""ab""] Output:  0 Explanation:  In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(""abab"", ""ab"") is false. Therefore, the answer is 0.   Constraints: 1 <= words.length <= 10 5 1 <= words[i].length <= 10 5 words[i]  consists only of lowercase English letters. The sum of the lengths of all  words[i]  does not exceed  5 * 10 5 ."
3049,https://leetcode.com/problems/earliest-second-to-mark-indices-ii/,Difícil,Array,Earliest Second to Mark Indices II,"You are given two  1-indexed  integer arrays,  nums  and,  changeIndices , having lengths  n  and  m , respectively. Initially, all indices in  nums  are unmarked. Your task is to mark  all  indices in  nums . In each second,  s , in order from  1  to  m  ( inclusive ), you can perform  one  of the following operations: Choose an index  i  in the range  [1, n]  and  decrement   nums[i]  by  1 . Set  nums[changeIndices[s]]  to any  non-negative  value. Choose an index  i  in the range  [1, n] , where  nums[i]  is  equal  to  0 , and  mark  index  i . Do nothing. Return  an integer denoting the  earliest second  in the range  [1, m]  when  all  indices in  nums  can be marked by choosing operations optimally, or  -1  if it is impossible.   Example 1: Input:  nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3] Output:  6 Explanation:  In this example, we have 7 seconds. The following operations can be performed to mark all indices: Second 1: Set nums[changeIndices[1]] to 0. nums becomes [0,2,3]. Second 2: Set nums[changeIndices[2]] to 0. nums becomes [0,2,0]. Second 3: Set nums[changeIndices[3]] to 0. nums becomes [0,0,0]. Second 4: Mark index 1, since nums[1] is equal to 0. Second 5: Mark index 2, since nums[2] is equal to 0. Second 6: Mark index 3, since nums[3] is equal to 0. Now all indices have been marked. It can be shown that it is not possible to mark all indices earlier than the 6th second. Hence, the answer is 6. Example 2: Input:  nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2] Output:  7 Explanation:  In this example, we have 8 seconds. The following operations can be performed to mark all indices: Second 1: Mark index 1, since nums[1] is equal to 0. Second 2: Mark index 2, since nums[2] is equal to 0. Second 3: Decrement index 4 by one. nums becomes [0,0,1,1]. Second 4: Decrement index 4 by one. nums becomes [0,0,1,0]. Second 5: Decrement index 3 by one. nums becomes [0,0,0,0]. Second 6: Mark index 3, since nums[3] is equal to 0. Second 7: Mark index 4, since nums[4] is equal to 0. Now all indices have been marked. It can be shown that it is not possible to mark all indices earlier than the 7th second. Hence, the answer is 7. Example 3: Input:  nums = [1,2,3], changeIndices = [1,2,3] Output:  -1 Explanation:  In this example, it can be shown that it is impossible to mark all indices, as we don't have enough seconds.  Hence, the answer is -1.   Constraints: 1 <= n == nums.length <= 5000 0 <= nums[i] <= 10 9 1 <= m == changeIndices.length <= 5000 1 <= changeIndices[i] <= n"
3072,https://leetcode.com/problems/distribute-elements-into-two-arrays-ii/,Difícil,Array,Distribute Elements Into Two Arrays II,"You are given a  1-indexed  array of integers  nums  of length  n . We define a function  greaterCount  such that  greaterCount(arr, val)  returns the number of elements in  arr  that are  strictly greater  than  val . You need to distribute all the elements of  nums  between two arrays  arr1  and  arr2  using  n  operations. In the first operation, append  nums[1]  to  arr1 . In the second operation, append  nums[2]  to  arr2 . Afterwards, in the  i th  operation: If  greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]) , append  nums[i]  to  arr1 . If  greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]) , append  nums[i]  to  arr2 . If  greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]) , append  nums[i]  to the array with a  lesser  number of elements. If there is still a tie, append  nums[i]  to  arr1 . The array  result  is formed by concatenating the arrays  arr1  and  arr2 . For example, if  arr1 == [1,2,3]  and  arr2 == [4,5,6] , then  result = [1,2,3,4,5,6] . Return  the integer array   result .   Example 1: Input:  nums = [2,1,3,3] Output:  [2,3,1,3] Explanation:  After the first 2 operations, arr1 = [2] and arr2 = [1]. In the 3 rd  operation, the number of elements greater than 3 is zero in both arrays. Also, the lengths are equal, hence, append nums[3] to arr1. In the 4 th  operation, the number of elements greater than 3 is zero in both arrays. As the length of arr2 is lesser, hence, append nums[4] to arr2. After 4 operations, arr1 = [2,3] and arr2 = [1,3]. Hence, the array result formed by concatenation is [2,3,1,3]. Example 2: Input:  nums = [5,14,3,1,2] Output:  [5,3,1,2,14] Explanation:  After the first 2 operations, arr1 = [5] and arr2 = [14]. In the 3 rd  operation, the number of elements greater than 3 is one in both arrays. Also, the lengths are equal, hence, append nums[3] to arr1. In the 4 th  operation, the number of elements greater than 1 is greater in arr1 than arr2 (2 > 1). Hence, append nums[4] to arr1. In the 5 th  operation, the number of elements greater than 2 is greater in arr1 than arr2 (2 > 1). Hence, append nums[5] to arr1. After 5 operations, arr1 = [5,3,1,2] and arr2 = [14]. Hence, the array result formed by concatenation is [5,3,1,2,14]. Example 3: Input:  nums = [3,3,3,3] Output:  [3,3,3,3] Explanation:  At the end of 4 operations, arr1 = [3,3] and arr2 = [3,3]. Hence, the array result formed by concatenation is [3,3,3,3].   Constraints: 3 <= n <= 10 5 1 <= nums[i] <= 10 9"
3082,https://leetcode.com/problems/find-the-sum-of-the-power-of-all-subsequences/,Difícil,Array,Find the Sum of the Power of All Subsequences,"You are given an integer array  nums  of length  n  and a  positive  integer  k . The  power  of an array of integers is defined as the number of  subsequences  with their sum  equal  to  k . Return  the  sum  of  power  of all subsequences of   nums . Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:     nums = [1,2,3], k = 3  Output:     6  Explanation: There are  5  subsequences of nums with non-zero power: The subsequence  [ 1 , 2 , 3 ]  has  2  subsequences with  sum == 3 :  [1,2, 3 ]  and  [ 1 , 2 ,3] . The subsequence  [ 1 ,2, 3 ]  has  1  subsequence with  sum == 3 :  [1,2, 3 ] . The subsequence  [1, 2 , 3 ]  has  1  subsequence with  sum == 3 :  [1,2, 3 ] . The subsequence  [ 1 , 2 ,3]  has  1  subsequence with  sum == 3 :  [ 1 , 2 ,3] . The subsequence  [1,2, 3 ]  has  1  subsequence with  sum == 3 :  [1,2, 3 ] . Hence the answer is  2 + 1 + 1 + 1 + 1 = 6 . Example 2: Input:     nums = [2,3,3], k = 5  Output:     4  Explanation: There are  3  subsequences of nums with non-zero power: The subsequence  [ 2 , 3 , 3 ]  has 2 subsequences with  sum == 5 :  [ 2 ,3, 3 ]  and  [ 2 , 3 ,3] . The subsequence  [ 2 ,3, 3 ]  has 1 subsequence with  sum == 5 :  [ 2 ,3, 3 ] . The subsequence  [ 2 , 3 ,3]  has 1 subsequence with  sum == 5 :  [ 2 , 3 ,3] . Hence the answer is  2 + 1 + 1 = 4 . Example 3: Input:     nums = [1,2,3], k = 7  Output:     0  Explanation:  There exists no subsequence with sum  7 . Hence all subsequences of nums have  power = 0 .   Constraints: 1 <= n <= 100 1 <= nums[i] <= 10 4 1 <= k <= 100"
3113,https://leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/,Difícil,Array,Find the Number of Subarrays Where Boundary Elements Are Maximum,"You are given an array of  positive  integers  nums . Return the number of  subarrays  of  nums , where the  first  and the  last  elements of the subarray are  equal  to the  largest  element in the subarray.   Example 1: Input:   nums = [1,4,3,3,2] Output:   6 Explanation: There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray: subarray  [ 1 ,4,3,3,2] , with its largest element 1. The first element is 1 and the last element is also 1. subarray  [1, 4 ,3,3,2] , with its largest element 4. The first element is 4 and the last element is also 4. subarray  [1,4, 3 ,3,2] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [1,4,3, 3 ,2] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [1,4,3,3, 2 ] , with its largest element 2. The first element is 2 and the last element is also 2. subarray  [1,4, 3,3 ,2] , with its largest element 3. The first element is 3 and the last element is also 3. Hence, we return 6. Example 2: Input:   nums = [3,3,3] Output:   6 Explanation: There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray: subarray  [ 3 ,3,3] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [3, 3 ,3] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [3,3, 3 ] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [ 3,3 ,3] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [3, 3,3 ] , with its largest element 3. The first element is 3 and the last element is also 3. subarray  [ 3,3,3 ] , with its largest element 3. The first element is 3 and the last element is also 3. Hence, we return 6. Example 3: Input:   nums = [1] Output:   1 Explanation: There is a single subarray of  nums  which is  [ 1 ] , with its largest element 1. The first element is 1 and the last element is also 1. Hence, we return 1.   Constraints: 1 <= nums.length <= 10 5 1 <= nums[i] <= 10 9"
3165,https://leetcode.com/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/,Difícil,Array,Maximum Sum of Subsequence With Non-adjacent Elements,"You are given an array  nums  consisting of integers. You are also given a 2D array  queries , where  queries[i] = [pos i , x i ] . For query  i , we first set  nums[pos i ]  equal to  x i , then we calculate the answer to query  i  which is the  maximum  sum of a  subsequence  of  nums  where  no two adjacent elements are selected . Return the  sum  of the answers to all queries. Since the final answer may be very large, return it  modulo   10 9  + 7 . A  subsequence  is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.   Example 1: Input:   nums = [3,5,9], queries = [[1,-2],[0,-3]] Output:   21 Explanation: After the 1 st  query,  nums = [3,-2,9]  and the maximum sum of a subsequence with non-adjacent elements is  3 + 9 = 12 . After the 2 nd  query,  nums = [-3,-2,9]  and the maximum sum of a subsequence with non-adjacent elements is 9. Example 2: Input:   nums = [0,-1], queries = [[0,-5]] Output:   0 Explanation: After the 1 st  query,  nums = [-5,-1]  and the maximum sum of a subsequence with non-adjacent elements is 0 (choosing an empty subsequence).   Constraints: 1 <= nums.length <= 5 * 10 4 -10 5  <= nums[i] <= 10 5 1 <= queries.length <= 5 * 10 4 queries[i] == [pos i , x i ] 0 <= pos i  <= nums.length - 1 -10 5  <= x i  <= 10 5"
3219,https://leetcode.com/problems/minimum-cost-for-cutting-cake-ii/,Difícil,Array,Minimum Cost for Cutting Cake II,"There is an  m x n  cake that needs to be cut into  1 x 1  pieces. You are given integers  m ,  n , and two arrays: horizontalCut  of size  m - 1 , where  horizontalCut[i]  represents the cost to cut along the horizontal line  i . verticalCut  of size  n - 1 , where  verticalCut[j]  represents the cost to cut along the vertical line  j . In one operation, you can choose any piece of cake that is not yet a  1 x 1  square and perform one of the following cuts: Cut along a horizontal line  i  at a cost of  horizontalCut[i] . Cut along a vertical line  j  at a cost of  verticalCut[j] . After the cut, the piece of cake is divided into two distinct pieces. The cost of a cut depends only on the initial cost of the line and does not change. Return the  minimum  total cost to cut the entire cake into  1 x 1  pieces.   Example 1: Input:   m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5] Output:   13 Explanation: Perform a cut on the vertical line 0 with cost 5, current total cost is 5. Perform a cut on the horizontal line 0 on  3 x 1  subgrid with cost 1. Perform a cut on the horizontal line 0 on  3 x 1  subgrid with cost 1. Perform a cut on the horizontal line 1 on  2 x 1  subgrid with cost 3. Perform a cut on the horizontal line 1 on  2 x 1  subgrid with cost 3. The total cost is  5 + 1 + 1 + 3 + 3 = 13 . Example 2: Input:   m = 2, n = 2, horizontalCut = [7], verticalCut = [4] Output:   15 Explanation: Perform a cut on the horizontal line 0 with cost 7. Perform a cut on the vertical line 0 on  1 x 2  subgrid with cost 4. Perform a cut on the vertical line 0 on  1 x 2  subgrid with cost 4. The total cost is  7 + 4 + 4 = 15 .   Constraints: 1 <= m, n <= 10 5 horizontalCut.length == m - 1 verticalCut.length == n - 1 1 <= horizontalCut[i], verticalCut[i] <= 10 3"
3225,https://leetcode.com/problems/maximum-score-from-grid-operations/,Difícil,Array,Maximum Score From Grid Operations,"You are given a 2D matrix  grid  of size  n x n . Initially, all cells of the grid are colored white. In one operation, you can select any cell of indices  (i, j) , and color black all the cells of the  j th  column starting from the top row down to the  i th  row. The grid score is the sum of all  grid[i][j]  such that cell  (i, j)  is white and it has a horizontally adjacent black cell. Return the  maximum  score that can be achieved after some number of operations.   Example 1: Input:   grid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]] Output:   11 Explanation: In the first operation, we color all cells in column 1 down to row 3, and in the second operation, we color all cells in column 4 down to the last row. The score of the resulting grid is  grid[3][0] + grid[1][2] + grid[3][3]  which is equal to 11. Example 2: Input:   grid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]] Output:   94 Explanation: We perform operations on 1, 2, and 3 down to rows 1, 4, and 0, respectively. The score of the resulting grid is  grid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3] + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4]  which is equal to 94.   Constraints: 1 <= n == grid.length <= 100 n == grid[i].length 0 <= grid[i][j] <= 10 9"
3229,https://leetcode.com/problems/minimum-operations-to-make-array-equal-to-target/,Difícil,Array,Minimum Operations to Make Array Equal to Target,"You are given two positive integer arrays  nums  and  target , of the same length. In a single operation, you can select any subarray of  nums  and increment each element within that subarray by 1 or decrement each element within that subarray by 1. Return the  minimum  number of operations required to make  nums  equal to the array  target .   Example 1: Input:   nums = [3,5,1,2], target = [4,6,2,4] Output:   2 Explanation: We will perform the following operations to make  nums  equal to  target : - Increment  nums[0..3]  by 1,  nums = [4,6,2,3] . - Increment  nums[3..3]  by 1,  nums = [4,6,2,4] . Example 2: Input:   nums = [1,3,2], target = [2,1,4] Output:   5 Explanation: We will perform the following operations to make  nums  equal to  target : - Increment  nums[0..0]  by 1,  nums = [2,3,2] . - Decrement  nums[1..1]  by 1,  nums = [2,2,2] . - Decrement  nums[1..1]  by 1,  nums = [2,1,2] . - Increment  nums[2..2]  by 1,  nums = [2,1,3] . - Increment  nums[2..2]  by 1,  nums = [2,1,4] .   Constraints: 1 <= nums.length == target.length <= 10 5 1 <= nums[i], target[i] <= 10 8"
3256,https://leetcode.com/problems/maximum-value-sum-by-placing-three-rooks-i/,Difícil,Array,Maximum Value Sum by Placing Three Rooks I,"You are given a  m x n  2D array  board  representing a chessboard, where  board[i][j]  represents the  value  of the cell  (i, j) . Rooks in the  same  row or column  attack  each other. You need to place  three  rooks on the chessboard such that the rooks  do not   attack  each other. Return the  maximum  sum of the cell  values  on which the rooks are placed.   Example 1: Input:   board =  [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]] Output:  4 Explanation: We can place the rooks in the cells  (0, 2) ,  (1, 3) , and  (2, 1)  for a sum of  1 + 1 + 2 = 4 . Example 2: Input:   board = [[1,2,3],[4,5,6],[7,8,9]] Output:   15 Explanation: We can place the rooks in the cells  (0, 0) ,  (1, 1) , and  (2, 2)  for a sum of  1 + 5 + 9 = 15 . Example 3: Input:   board = [[1,1,1],[1,1,1],[1,1,1]] Output:   3 Explanation: We can place the rooks in the cells  (0, 2) ,  (1, 1) , and  (2, 0)  for a sum of  1 + 1 + 1 = 3 .   Constraints: 3 <= m == board.length <= 100 3 <= n == board[i].length <= 100 -10 9  <= board[i][j] <= 10 9"
3273,https://leetcode.com/problems/minimum-amount-of-damage-dealt-to-bob/,Difícil,Array,Minimum Amount of Damage Dealt to Bob,"You are given an integer  power  and two integer arrays  damage  and  health , both having length  n . Bob has  n  enemies, where enemy  i  will deal Bob  damage[i]   points  of damage per second while they are  alive  (i.e.  health[i] > 0 ). Every second,  after  the enemies deal damage to Bob, he chooses  one  of the enemies that is still  alive  and deals  power  points of damage to them. Determine the  minimum  total amount of damage points that will be dealt to Bob before  all   n  enemies are  dead .   Example 1: Input:   power = 4, damage = [1,2,3,4], health = [4,5,6,8] Output:   39 Explanation: Attack enemy 3 in the first two seconds, after which enemy 3 will go down, the number of damage points dealt to Bob is  10 + 10 = 20  points. Attack enemy 2 in the next two seconds, after which enemy 2 will go down, the number of damage points dealt to Bob is  6 + 6 = 12  points. Attack enemy 0 in the next second, after which enemy 0 will go down, the number of damage points dealt to Bob is  3  points. Attack enemy 1 in the next two seconds, after which enemy 1 will go down, the number of damage points dealt to Bob is  2 + 2 = 4  points. Example 2: Input:   power = 1, damage = [1,1,1,1], health = [1,2,3,4] Output:   20 Explanation: Attack enemy 0 in the first second, after which enemy 0 will go down, the number of damage points dealt to Bob is  4  points. Attack enemy 1 in the next two seconds, after which enemy 1 will go down, the number of damage points dealt to Bob is  3 + 3 = 6  points. Attack enemy 2 in the next three seconds, after which enemy 2 will go down, the number of damage points dealt to Bob is  2 + 2 + 2 = 6  points. Attack enemy 3 in the next four seconds, after which enemy 3 will go down, the number of damage points dealt to Bob is  1 + 1 + 1 + 1 = 4  points. Example 3: Input:   power = 8, damage = [40], health = [59] Output:   320   Constraints: 1 <= power <= 10 4 1 <= n == damage.length == health.length <= 10 5 1 <= damage[i], health[i] <= 10 4"
3277,https://leetcode.com/problems/maximum-xor-score-subarray-queries/,Difícil,Array,Maximum XOR Score Subarray Queries,"You are given an array  nums  of  n  integers, and a 2D integer array  queries  of size  q , where  queries[i] = [l i , r i ] . For each query, you must find the  maximum XOR score  of any  subarray  of  nums[l i ..r i ] . The  XOR score  of an array  a  is found by repeatedly applying the following operations on  a  so that only one element remains, that is the  score : Simultaneously replace  a[i]  with  a[i] XOR a[i + 1]  for all indices  i  except the last one. Remove the last element of  a . Return an array  answer  of size  q  where  answer[i]  is the answer to query  i .   Example 1: Input:   nums = [2,8,4,32,16,1], queries = [[0,2],[1,4],[0,5]] Output:   [12,60,60] Explanation: In the first query,  nums[0..2]  has 6 subarrays  [2] ,  [8] ,  [4] ,  [2, 8] ,  [8, 4] , and  [2, 8, 4]  each with a respective XOR score of 2, 8, 4, 10, 12, and 6. The answer for the query is 12, the largest of all XOR scores. In the second query, the subarray of  nums[1..4]  with the largest XOR score is  nums[1..4]  with a score of 60. In the third query, the subarray of  nums[0..5]  with the largest XOR score is  nums[1..4]  with a score of 60. Example 2: Input:   nums = [0,7,3,2,8,5,1], queries = [[0,3],[1,5],[2,4],[2,6],[5,6]] Output:   [7,14,11,14,5] Explanation: Index nums[l i ..r i ] Maximum XOR Score Subarray Maximum Subarray XOR Score 0 [0, 7, 3, 2] [7] 7 1 [7, 3, 2, 8, 5] [7, 3, 2, 8] 14 2 [3, 2, 8] [3, 2, 8] 11 3 [3, 2, 8, 5, 1] [2, 8, 5, 1] 14 4 [5, 1] [5] 5   Constraints: 1 <= n == nums.length <= 2000 0 <= nums[i] <= 2 31  - 1 1 <= q == queries.length <= 10 5 queries[i].length == 2  queries[i] = [l i , r i ] 0 <= l i  <= r i  <= n - 1"
3287,https://leetcode.com/problems/find-the-maximum-sequence-value-of-array/,Difícil,Array,Find the Maximum Sequence Value of Array,"You are given an integer array  nums  and a  positive  integer  k . The  value  of a sequence  seq  of size  2 * x  is defined as: (seq[0] OR seq[1] OR ... OR seq[x - 1]) XOR (seq[x] OR seq[x + 1] OR ... OR seq[2 * x - 1]) . Return the  maximum   value  of any  subsequence  of  nums  having size  2 * k .   Example 1: Input:   nums = [2,6,7], k = 1 Output:   5 Explanation: The subsequence  [2, 7]  has the maximum value of  2 XOR 7 = 5 . Example 2: Input:   nums = [4,2,5,6,7], k = 2 Output:   2 Explanation: The subsequence  [4, 5, 6, 7]  has the maximum value of  (4 OR 5) XOR (6 OR 7) = 2 .   Constraints: 2 <= nums.length <= 400 1 <= nums[i] < 2 7 1 <= k <= nums.length / 2"
3311,https://leetcode.com/problems/construct-2d-grid-matching-graph-layout/,Difícil,Array,Construct 2D Grid Matching Graph Layout,"You are given a 2D integer array  edges  representing an  undirected  graph having  n  nodes, where  edges[i] = [u i , v i ]  denotes an edge between nodes  u i  and  v i . Construct a 2D grid that satisfies these conditions: The grid contains  all nodes  from  0  to  n - 1  in its cells, with each node appearing exactly  once . Two nodes should be in adjacent grid cells ( horizontally  or  vertically )  if and only if  there is an edge between them in  edges . It is guaranteed that  edges  can form a 2D grid that satisfies the conditions. Return a 2D integer array satisfying the conditions above. If there are multiple solutions, return  any  of them.   Example 1: Input:   n = 4, edges = [[0,1],[0,2],[1,3],[2,3]] Output:   [[3,1],[2,0]] Explanation: Example 2: Input:   n = 5, edges = [[0,1],[1,3],[2,3],[2,4]] Output:   [[4,2,3,1,0]] Explanation: Example 3: Input:   n = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]] Output:   [[8,6,3],[7,4,2],[1,0,5]] Explanation:   Constraints: 2 <= n <= 5 * 10 4 1 <= edges.length <= 10 5 edges[i] = [u i , v i ] 0 <= u i  < v i  < n All the edges are distinct. The input is generated such that  edges  can form a 2D grid that satisfies the conditions."
3363,https://leetcode.com/problems/find-the-maximum-number-of-fruits-collected/,Difícil,Array,Find the Maximum Number of Fruits Collected,"There is a game dungeon comprised of  n x n  rooms arranged in a grid. You are given a 2D array  fruits  of size  n x n , where  fruits[i][j]  represents the number of fruits in the room  (i, j) . Three children will play in the game dungeon, with  initial  positions at the corner rooms  (0, 0) ,  (0, n - 1) , and  (n - 1, 0) . The children will make  exactly   n - 1  moves according to the following rules to reach the room  (n - 1, n - 1) : The child starting from  (0, 0)  must move from their current room  (i, j)  to one of the rooms  (i + 1, j + 1) ,  (i + 1, j) , and  (i, j + 1)  if the target room exists. The child starting from  (0, n - 1)  must move from their current room  (i, j)  to one of the rooms  (i + 1, j - 1) ,  (i + 1, j) , and  (i + 1, j + 1)  if the target room exists. The child starting from  (n - 1, 0)  must move from their current room  (i, j)  to one of the rooms  (i - 1, j + 1) ,  (i, j + 1) , and  (i + 1, j + 1)  if the target room exists. When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave. Return the  maximum  number of fruits the children can collect from the dungeon.   Example 1: Input:   fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]] Output:   100 Explanation: In this example: The 1 st  child (green) moves on the path  (0,0) -> (1,1) -> (2,2) -> (3, 3) . The 2 nd  child (red) moves on the path  (0,3) -> (1,2) -> (2,3) -> (3, 3) . The 3 rd  child (blue) moves on the path  (3,0) -> (3,1) -> (3,2) -> (3, 3) . In total they collect  1 + 6 + 11 + 16 + 4 + 8 + 12 + 13 + 14 + 15 = 100  fruits. Example 2: Input:   fruits = [[1,1],[1,1]] Output:   4 Explanation: In this example: The 1 st  child moves on the path  (0,0) -> (1,1) . The 2 nd  child moves on the path  (0,1) -> (1,1) . The 3 rd  child moves on the path  (1,0) -> (1,1) . In total they collect  1 + 1 + 1 + 1 = 4  fruits.   Constraints: 2 <= n == fruits.length == fruits[i].length <= 1000 0 <= fruits[i][j] <= 1000"
3500,https://leetcode.com/problems/minimum-cost-to-divide-array-into-subarrays/,Difícil,Array,Minimum Cost to Divide Array Into Subarrays,"You are given two integer arrays,  nums  and  cost , of the same size, and an integer  k . You can divide  nums  into  subarrays . The cost of the  i th  subarray consisting of elements  nums[l..r]  is: (nums[0] + nums[1] + ... + nums[r] + k * i) * (cost[l] + cost[l + 1] + ... + cost[r]) . Note  that  i  represents the order of the subarray: 1 for the first subarray, 2 for the second, and so on. Return the  minimum  total cost possible from any valid division.   Example 1: Input:   nums = [3,1,4], cost = [4,6,6], k = 1 Output:   110 Explanation: The minimum total cost possible can be achieved by dividing  nums  into subarrays  [3, 1]  and  [4] . The cost of the first subarray  [3,1]  is  (3 + 1 + 1 * 1) * (4 + 6) = 50 . The cost of the second subarray  [4]  is  (3 + 1 + 4 + 1 * 2) * 6 = 60 . Example 2: Input:   nums = [4,8,5,1,14,2,2,12,1], cost = [7,2,8,4,2,2,1,1,2], k = 7 Output:  985 Explanation: The minimum total cost possible can be achieved by dividing  nums  into subarrays  [4, 8, 5, 1] ,  [14, 2, 2] , and  [12, 1] . The cost of the first subarray  [4, 8, 5, 1]  is  (4 + 8 + 5 + 1 + 7 * 1) * (7 + 2 + 8 + 4) = 525 . The cost of the second subarray  [14, 2, 2]  is  (4 + 8 + 5 + 1 + 14 + 2 + 2 + 7 * 2) * (2 + 2 + 1) = 250 . The cost of the third subarray  [12, 1]  is  (4 + 8 + 5 + 1 + 14 + 2 + 2 + 12 + 1 + 7 * 3) * (1 + 2) = 210 .   Constraints: 1 <= nums.length <= 1000 cost.length == nums.length 1 <= nums[i], cost[i] <= 1000 1 <= k <= 1000"
113,https://leetcode.com/problems/path-sum-ii/,Média,Backtracking,Path Sum II,"Given the  root  of a binary tree and an integer  targetSum , return  all  root-to-leaf  paths where the sum of the node values in the path equals  targetSum . Each path should be returned as a list of the node  values , not node references . A  root-to-leaf  path is a path starting from the root and ending at any leaf node. A  leaf  is a node with no children.   Example 1: Input:  root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output:  [[5,4,11,2],[5,8,4,5]] Explanation:  There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 Example 2: Input:  root = [1,2,3], targetSum = 5 Output:  [] Example 3: Input:  root = [1,2], targetSum = 0 Output:  []   Constraints: The number of nodes in the tree is in the range  [0, 5000] . -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000"
797,https://leetcode.com/problems/all-paths-from-source-to-target/,Média,Backtracking,All Paths From Source to Target,"Given a directed acyclic graph ( DAG ) of  n  nodes labeled from  0  to  n - 1 , find all possible paths from node  0  to node  n - 1  and return them in  any order . The graph is given as follows:  graph[i]  is a list of all nodes you can visit from node  i  (i.e., there is a directed edge from node  i  to node  graph[i][j] ).   Example 1: Input:  graph = [[1,2],[3],[3],[]] Output:  [[0,1,3],[0,2,3]] Explanation:  There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3. Example 2: Input:  graph = [[4,3,1],[3,2,4],[3],[4],[]] Output:  [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]   Constraints: n == graph.length 2 <= n <= 15 0 <= graph[i][j] < n graph[i][j] != i  (i.e., there will be no self-loops). All the elements of  graph[i]  are  unique . The input graph is  guaranteed  to be a  DAG ."
222,https://leetcode.com/problems/count-complete-tree-nodes/,Fácil,Binary Search,Count Complete Tree Nodes,"Given the  root  of a  complete  binary tree, return the number of the nodes in the tree. According to  Wikipedia , every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between  1  and  2 h  nodes inclusive at the last level  h . Design an algorithm that runs in less than  O(n)  time complexity.   Example 1: Input:  root = [1,2,3,4,5,6] Output:  6 Example 2: Input:  root = [] Output:  0 Example 3: Input:  root = [1] Output:  1   Constraints: The number of nodes in the tree is in the range  [0, 5 * 10 4 ] . 0 <= Node.val <= 5 * 10 4 The tree is guaranteed to be  complete ."
3419,https://leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/,Média,Binary Search,Minimize the Maximum Edge Weight of Graph,"You are given two integers,  n  and  threshold , as well as a  directed  weighted graph of  n  nodes numbered from 0 to  n - 1 . The graph is represented by a  2D  integer array  edges , where  edges[i] = [A i , B i , W i ]  indicates that there is an edge going from node  A i  to node  B i  with weight  W i . You have to remove some edges from this graph (possibly  none ), so that it satisfies the following conditions: Node 0 must be reachable from all other nodes. The  maximum  edge weight in the resulting graph is  minimized . Each node has  at most   threshold  outgoing edges. Return the  minimum  possible value of the  maximum  edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.   Example 1: Input:   n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2 Output:   1 Explanation: Remove the edge  2 -> 0 . The maximum weight among the remaining edges is 1. Example 2: Input:   n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1 Output:   -1 Explanation:   It is impossible to reach node 0 from node 2. Example 3: Input:   n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1 Output:   2 Explanation:   Remove the edges  1 -> 3  and  1 -> 4 . The maximum weight among the remaining edges is 2. Example 4: Input:   n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1 Output:   -1   Constraints: 2 <= n <= 10 5 1 <= threshold <= n - 1 1 <= edges.length <= min(10 5 , n * (n - 1) / 2). edges[i].length == 3 0 <= A i , B i  < n A i  != B i 1 <= W i  <= 10 6 There  may be  multiple edges between a pair of nodes, but they must have unique weights."
2959,https://leetcode.com/problems/number-of-possible-sets-of-closing-branches/,Difícil,Bit Manipulation,Number of Possible Sets of Closing Branches,"There is a company with  n  branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads. The company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches ( possibly none ). However, they want to ensure that the remaining branches have a distance of at most  maxDistance  from each other. The  distance  between two branches is the  minimum  total traveled length needed to reach one branch from another. You are given integers  n ,  maxDistance , and a  0-indexed  2D array  roads , where  roads[i] = [u i , v i , w i ]  represents the  undirected  road between branches  u i  and  v i  with length  w i . Return  the number of possible sets of closing branches, so that any branch has a distance of at most  maxDistance  from any other . Note  that, after closing a branch, the company will no longer have access to any roads connected to it. Note  that, multiple roads are allowed.   Example 1: Input:  n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]] Output:  5 Explanation:  The possible sets of closing branches are: - The set [2], after closing, active branches are [0,1] and they are reachable to each other within distance 2. - The set [0,1], after closing, the active branch is [2]. - The set [1,2], after closing, the active branch is [0]. - The set [0,2], after closing, the active branch is [1]. - The set [0,1,2], after closing, there are no active branches. It can be proven, that there are only 5 possible sets of closing branches. Example 2: Input:  n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]] Output:  7 Explanation:  The possible sets of closing branches are: - The set [], after closing, active branches are [0,1,2] and they are reachable to each other within distance 4. - The set [0], after closing, active branches are [1,2] and they are reachable to each other within distance 2. - The set [1], after closing, active branches are [0,2] and they are reachable to each other within distance 2. - The set [0,1], after closing, the active branch is [2]. - The set [1,2], after closing, the active branch is [0]. - The set [0,2], after closing, the active branch is [1]. - The set [0,1,2], after closing, there are no active branches. It can be proven, that there are only 7 possible sets of closing branches. Example 3: Input:  n = 1, maxDistance = 10, roads = [] Output:  2 Explanation:  The possible sets of closing branches are: - The set [], after closing, the active branch is [0]. - The set [0], after closing, there are no active branches. It can be proven, that there are only 2 possible sets of closing branches.   Constraints: 1 <= n <= 10 1 <= maxDistance <= 10 5 0 <= roads.length <= 1000 roads[i].length == 3 0 <= u i , v i  <= n - 1 u i  != v i 1 <= w i  <= 1000 All branches are reachable from each other by traveling some roads."
3015,https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-i/,Média,Breadth-First Search,Count the Number of Houses at a Certain Distance I,"You are given three  positive  integers  n ,  x , and  y . In a city, there exist houses numbered  1  to  n  connected by  n  streets. There is a street connecting the house numbered  i  with the house numbered  i + 1  for all  1 <= i <= n - 1  . An additional street connects the house numbered  x  with the house numbered  y . For each  k , such that  1 <= k <= n , you need to find the number of  pairs of houses   (house 1 , house 2 )  such that the  minimum  number of streets that need to be traveled to reach  house 2  from  house 1  is  k . Return  a  1-indexed  array  result  of length  n  where  result[k]  represents the  total  number of pairs of houses such that the  minimum  streets required to reach one house from the other is  k . Note  that  x  and  y  can be  equal .   Example 1: Input:  n = 3, x = 1, y = 3 Output:  [6,0,0] Explanation:  Let's look at each pair of houses: - For the pair (1, 2), we can go from house 1 to house 2 directly. - For the pair (2, 1), we can go from house 2 to house 1 directly. - For the pair (1, 3), we can go from house 1 to house 3 directly. - For the pair (3, 1), we can go from house 3 to house 1 directly. - For the pair (2, 3), we can go from house 2 to house 3 directly. - For the pair (3, 2), we can go from house 3 to house 2 directly. Example 2: Input:  n = 5, x = 2, y = 4 Output:  [10,8,2,0,0] Explanation:  For each distance k the pairs are: - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4). - For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3). - For k == 3, the pairs are (1, 5), and (5, 1). - For k == 4 and k == 5, there are no pairs. Example 3: Input:  n = 4, x = 1, y = 1 Output:  [6,4,2,0] Explanation:  For each distance k the pairs are: - For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3). - For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2). - For k == 3, the pairs are (1, 4), and (4, 1). - For k == 4, there are no pairs.   Constraints: 2 <= n <= 100 1 <= x, y <= n"
1971,https://leetcode.com/problems/find-if-path-exists-in-graph/,Fácil,Depth-First Search,Find if Path Exists in Graph,"There is a  bi-directional  graph with  n  vertices, where each vertex is labeled from  0  to  n - 1  ( inclusive ). The edges in the graph are represented as a 2D integer array  edges , where each  edges[i] = [u i , v i ]  denotes a bi-directional edge between vertex  u i  and vertex  v i . Every vertex pair is connected by  at most one  edge, and no vertex has an edge to itself. You want to determine if there is a  valid path  that exists from vertex  source  to vertex  destination . Given  edges  and the integers  n ,  source , and  destination , return  true  if there is a  valid path  from  source  to  destination , or  false  otherwise .   Example 1: Input:  n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output:  true Explanation:  There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2: Input:  n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output:  false Explanation:  There is no path from vertex 0 to vertex 5.   Constraints: 1 <= n <= 2 * 10 5 0 <= edges.length <= 2 * 10 5 edges[i].length == 2 0 <= u i , v i  <= n - 1 u i  != v i 0 <= source, destination <= n - 1 There are no duplicate edges. There are no self edges."
3310,https://leetcode.com/problems/remove-methods-from-project/,Média,Depth-First Search,Remove Methods From Project,"You are maintaining a project that has  n  methods numbered from  0  to  n - 1 . You are given two integers  n  and  k , and a 2D integer array  invocations , where  invocations[i] = [a i , b i ]  indicates that method  a i  invokes method  b i . There is a known bug in method  k . Method  k , along with any method invoked by it, either  directly  or  indirectly , are considered  suspicious  and we aim to remove them. A group of methods can only be removed if no method  outside  the group invokes any methods  within  it. Return an array containing all the remaining methods after removing all the  suspicious  methods. You may return the answer in  any order . If it is not possible to remove  all  the suspicious methods,  none  should be removed.   Example 1: Input:   n = 4, k = 1, invocations = [[1,2],[0,1],[3,2]] Output:   [0,1,2,3] Explanation: Method 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything. Example 2: Input:   n = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]] Output:   [3,4] Explanation: Methods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them. Example 3: Input:   n = 3, k = 2, invocations = [[1,2],[0,1],[2,0]] Output:   [] Explanation: All methods are suspicious. We can remove them.   Constraints: 1 <= n <= 10 5 0 <= k <= n - 1 0 <= invocations.length <= 2 * 10 5 invocations[i] == [a i , b i ] 0 <= a i , b i  <= n - 1 a i  != b i invocations[i] != invocations[j]"
1203,https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/,Difícil,Depth-First Search,Sort Items by Groups Respecting Dependencies,"There are  n  items each belonging to zero or one of  m  groups where  group[i]  is the group that the  i -th item belongs to and it's equal to  -1  if the  i -th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that: The items that belong to the same group are next to each other in the sorted list. There are some relations between these items where  beforeItems[i]  is a list containing all the items that should come before the  i -th item in the sorted array (to the left of the  i -th item). Return any solution if there is more than one solution and return an  empty list  if there is no solution.   Example 1: Input:  n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]] Output:  [6,3,4,1,5,2,0,7] Example 2: Input:  n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]] Output:  [] Explanation:  This is the same as example 1 except that 4 needs to be before 6 in the sorted list.   Constraints: 1 <= m <= n <= 3 * 10 4 group.length == beforeItems.length == n -1 <= group[i] <= m - 1 0 <= beforeItems[i].length <= n - 1 0 <= beforeItems[i][j] <= n - 1 i != beforeItems[i][j] beforeItems[i]  does not contain duplicates elements."
2493,https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/,Difícil,Depth-First Search,Divide Nodes Into the Maximum Number of Groups,"You are given a positive integer  n  representing the number of nodes in an  undirected  graph. The nodes are labeled from  1  to  n . You are also given a 2D integer array  edges , where  edges[i] = [a i,  b i ]  indicates that there is a  bidirectional  edge between nodes  a i  and  b i .  Notice  that the given graph may be disconnected. Divide the nodes of the graph into  m  groups ( 1-indexed ) such that: Each node in the graph belongs to exactly one group. For every pair of nodes in the graph that are connected by an edge  [a i,  b i ] , if  a i  belongs to the group with index  x , and  b i  belongs to the group with index  y , then  |y - x| = 1 . Return  the maximum number of groups (i.e., maximum  m ) into which you can divide the nodes . Return  -1   if it is impossible to group the nodes with the given conditions .   Example 1: Input:  n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]] Output:  4 Explanation:  As shown in the image we: - Add node 5 to the first group. - Add node 1 to the second group. - Add nodes 2 and 4 to the third group. - Add nodes 3 and 6 to the fourth group. We can see that every edge is satisfied. It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied. Example 2: Input:  n = 3, edges = [[1,2],[2,3],[3,1]] Output:  -1 Explanation:  If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied. It can be shown that no grouping is possible.   Constraints: 1 <= n <= 500 1 <= edges.length <= 10 4 edges[i].length == 2 1 <= a i , b i  <= n a i  != b i There is at most one edge between any pair of vertices."
933,https://leetcode.com/problems/number-of-recent-calls/,Fácil,Design,Number of Recent Calls,"You have a  RecentCounter  class which counts the number of recent requests within a certain time frame. Implement the  RecentCounter  class: RecentCounter()  Initializes the counter with zero recent requests. int ping(int t)  Adds a new request at time  t , where  t  represents some time in milliseconds, and returns the number of requests that has happened in the past  3000  milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range  [t - 3000, t] . It is  guaranteed  that every call to  ping  uses a strictly larger value of  t  than the previous call.   Example 1: Input [""RecentCounter"", ""ping"", ""ping"", ""ping"", ""ping""] [[], [1], [100], [3001], [3002]] Output [null, 1, 2, 3, 3] Explanation RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1);     // requests = [ 1 ], range is [-2999,1], return 1 recentCounter.ping(100);   // requests = [ 1 ,  100 ], range is [-2900,100], return 2 recentCounter.ping(3001);  // requests = [ 1 ,  100 ,  3001 ], range is [1,3001], return 3 recentCounter.ping(3002);  // requests = [1,  100 ,  3001 ,  3002 ], range is [2,3002], return 3   Constraints: 1 <= t <= 10 9 Each test case will call  ping  with  strictly increasing  values of  t . At most  10 4  calls will be made to  ping ."
2320,https://leetcode.com/problems/count-number-of-ways-to-place-houses/,Média,Dynamic Programming,Count Number of Ways to Place Houses,"There is a street with  n * 2   plots , where there are  n  plots on each side of the street. The plots on each side are numbered from  1  to  n . On each plot, a house can be placed. Return  the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street . Since the answer may be very large, return it  modulo   10 9  + 7 . Note that if a house is placed on the  i th  plot on one side of the street, a house can also be placed on the  i th  plot on the other side of the street.   Example 1: Input:  n = 1 Output:  4 Explanation:   Possible arrangements: 1. All plots are empty. 2. A house is placed on one side of the street. 3. A house is placed on the other side of the street. 4. Two houses are placed, one on each side of the street. Example 2: Input:  n = 2 Output:  9 Explanation:  The 9 possible arrangements are shown in the diagram above.   Constraints: 1 <= n <= 10 4"
847,https://leetcode.com/problems/shortest-path-visiting-all-nodes/,Difícil,Dynamic Programming,Shortest Path Visiting All Nodes,"You have an undirected, connected graph of  n  nodes labeled from  0  to  n - 1 . You are given an array  graph  where  graph[i]  is a list of all the nodes connected with node  i  by an edge. Return  the length of the shortest path that visits every node . You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.   Example 1: Input:  graph = [[1,2,3],[0],[0],[0]] Output:  4 Explanation:  One possible path is [1,0,2,0,3] Example 2: Input:  graph = [[1],[0,2,4],[1,3,4],[2],[1,2]] Output:  4 Explanation:  One possible path is [0,1,4,2,3]   Constraints: n == graph.length 1 <= n <= 12 0 <= graph[i].length < n graph[i]  does not contain  i . If  graph[a]  contains  b , then  graph[b]  contains  a . The input graph is always connected."
1269,https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/,Difícil,Dynamic Programming,Number of Ways to Stay in the Same Place After Some Steps,"You have a pointer at index  0  in an array of size  arrLen . At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time). Given two integers  steps  and  arrLen , return the number of ways such that your pointer is still at index  0  after  exactly   steps  steps. Since the answer may be too large, return it  modulo   10 9  + 7 .   Example 1: Input:  steps = 3, arrLen = 2 Output:  4 Explanation:  There are 4 differents ways to stay at index 0 after 3 steps. Right, Left, Stay Stay, Right, Left Right, Stay, Left Stay, Stay, Stay Example 2: Input:  steps = 2, arrLen = 4 Output:  2 Explanation:  There are 2 differents ways to stay at index 0 after 2 steps Right, Left Stay, Stay Example 3: Input:  steps = 4, arrLen = 2 Output:  8   Constraints: 1 <= steps <= 500 1 <= arrLen <= 10 6"
1373,https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/,Difícil,Dynamic Programming,Maximum Sum BST in Binary Tree,"Given a  binary tree   root , return  the maximum sum of all keys of  any  sub-tree which is also a Binary Search Tree (BST) . Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys  less than  the node's key. The right subtree of a node contains only nodes with keys  greater than  the node's key. Both the left and right subtrees must also be binary search trees.   Example 1: Input:  root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6] Output:  20 Explanation:  Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3. Example 2: Input:  root = [4,3,null,1,2] Output:  2 Explanation:  Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2. Example 3: Input:  root = [-4,-2,-5] Output:  0 Explanation:  All values are negatives. Return an empty BST.   Constraints: The number of nodes in the tree is in the range  [1, 4 * 10 4 ] . -4 * 10 4  <= Node.val <= 4 * 10 4"
1617,https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/,Difícil,Dynamic Programming,Count Subtrees With Max Distance Between Cities,"There are  n  cities numbered from  1  to  n . You are given an array  edges  of size  n-1 , where  edges[i] = [u i , v i ]  represents a bidirectional edge between cities  u i  and  v i . There exists a unique path between each pair of cities. In other words, the cities form a  tree . A  subtree  is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other. For each  d  from  1  to  n-1 , find the number of subtrees in which the  maximum distance  between any two cities in the subtree is equal to  d . Return  an array of size   n-1   where the  d th   element  (1-indexed)  is the number of subtrees in which the  maximum distance  between any two cities is equal to  d . Notice  that the  distance  between the two cities is the number of edges in the path between them.   Example 1: Input:  n = 4, edges = [[1,2],[2,3],[2,4]] Output:  [3,4,0] Explanation: The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1. The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2. No subtree has two nodes where the max distance between them is 3. Example 2: Input:  n = 2, edges = [[1,2]] Output:  [1] Example 3: Input:  n = 3, edges = [[1,2],[2,3]] Output:  [2,1]   Constraints: 2 <= n <= 15 edges.length == n-1 edges[i].length == 2 1 <= u i , v i  <= n All pairs  (u i , v i )  are distinct."
389,https://leetcode.com/problems/find-the-difference/,Fácil,Hash Table,Find the Difference,"You are given two strings  s  and  t . String  t  is generated by random shuffling string  s  and then add one more letter at a random position. Return the letter that was added to  t .   Example 1: Input:  s = ""abcd"", t = ""abcde"" Output:  ""e"" Explanation:  'e' is the letter that was added. Example 2: Input:  s = """", t = ""y"" Output:  ""y""   Constraints: 0 <= s.length <= 1000 t.length == s.length + 1 s  and  t  consist of lowercase English letters."
1370,https://leetcode.com/problems/increasing-decreasing-string/,Fácil,Hash Table,Increasing Decreasing String,"You are given a string  s . Reorder the string using the following algorithm: Remove the  smallest  character from  s  and  append  it to the result. Remove the  smallest  character from  s  that is greater than the last appended character, and  append  it to the result. Repeat step 2 until no more characters can be removed. Remove the  largest  character from  s  and  append  it to the result. Remove the  largest  character from  s  that is smaller than the last appended character, and  append  it to the result. Repeat step 5 until no more characters can be removed. Repeat steps 1 through 6 until all characters from  s  have been removed. If the smallest or largest character appears more than once, you may choose any occurrence to append to the result. Return the resulting string after reordering  s  using this algorithm.   Example 1: Input:  s = ""aaaabbbbcccc"" Output:  ""abccbaabccba"" Explanation:  After steps 1, 2 and 3 of the first iteration, result = ""abc"" After steps 4, 5 and 6 of the first iteration, result = ""abccba"" First iteration is done. Now s = ""aabbcc"" and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = ""abccbaabc"" After steps 4, 5 and 6 of the second iteration, result = ""abccbaabccba"" Example 2: Input:  s = ""rat"" Output:  ""art"" Explanation:  The word ""rat"" becomes ""art"" after re-ordering it with the mentioned algorithm.   Constraints: 1 <= s.length <= 500 s  consists of only lowercase English letters."
1496,https://leetcode.com/problems/path-crossing/,Fácil,Hash Table,Path Crossing,"Given a string  path , where  path[i] = 'N' ,  'S' ,  'E'  or  'W' , each representing moving one unit north, south, east, or west, respectively. You start at the origin  (0, 0)  on a 2D plane and walk on the path specified by  path . Return  true   if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited . Return  false  otherwise.   Example 1: Input:  path = ""NES"" Output:  false  Explanation:  Notice that the path doesn't cross any point more than once. Example 2: Input:  path = ""NESWW"" Output:  true Explanation:  Notice that the path visits the origin twice.   Constraints: 1 <= path.length <= 10 4 path[i]  is either  'N' ,  'S' ,  'E' , or  'W' ."
2103,https://leetcode.com/problems/rings-and-rods/,Fácil,Hash Table,Rings and Rods,"There are  n  rings and each ring is either red, green, or blue. The rings are distributed  across ten rods  labeled from  0  to  9 . You are given a string  rings  of length  2n  that describes the  n  rings that are placed onto the rods. Every two characters in  rings  forms a  color-position pair  that is used to describe each ring where: The  first  character of the  i th  pair denotes the  i th  ring's  color  ( 'R' ,  'G' ,  'B' ). The  second  character of the  i th  pair denotes the  rod  that the  i th  ring is placed on ( '0'  to  '9' ). For example,  ""R3G2B1""  describes  n == 3  rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1. Return  the number of rods that have  all three colors  of rings on them.   Example 1: Input:  rings = ""B0B6G0R6R0R6G9"" Output:  1 Explanation:   - The rod labeled 0 holds 3 rings with all colors: red, green, and blue. - The rod labeled 6 holds 3 rings, but it only has red and blue. - The rod labeled 9 holds only a green ring. Thus, the number of rods with all three colors is 1. Example 2: Input:  rings = ""B0R0G0R9R0B0G0"" Output:  1 Explanation:   - The rod labeled 0 holds 6 rings with all colors: red, green, and blue. - The rod labeled 9 holds only a red ring. Thus, the number of rods with all three colors is 1. Example 3: Input:  rings = ""G4"" Output:  0 Explanation:   Only one ring is given. Thus, no rods have all three colors.   Constraints: rings.length == 2 * n 1 <= n <= 100 rings[i]  where  i  is  even  is either  'R' ,  'G' , or  'B'  ( 0-indexed ). rings[i]  where  i  is  odd  is a digit from  '0'  to  '9'  ( 0-indexed )."
3083,https://leetcode.com/problems/existence-of-a-substring-in-a-string-and-its-reverse/,Fácil,Hash Table,Existence of a Substring in a String and Its Reverse,"Given a   string  s , find any  substring  of length  2  which is also present in the reverse of  s . Return  true  if such a substring exists, and  false  otherwise.   Example 1: Input:  s = ""leetcode"" Output:  true Explanation:  Substring  ""ee""  is of length  2  which is also present in  reverse(s) == ""edocteel"" . Example 2: Input:  s = ""abcba"" Output:  true Explanation:  All of the substrings of length  2   ""ab"" ,  ""bc"" ,  ""cb"" ,  ""ba""  are also present in  reverse(s) == ""abcba"" . Example 3: Input:  s = ""abcd"" Output:  false Explanation:  There is no substring of length  2  in  s , which is also present in the reverse of  s .   Constraints: 1 <= s.length <= 100 s  consists only of lowercase English letters."
3120,https://leetcode.com/problems/count-the-number-of-special-characters-i/,Fácil,Hash Table,Count the Number of Special Characters I,"You are given a string  word . A letter is called  special  if it appears  both  in lowercase and uppercase in  word . Return the number of   special  letters in   word .   Example 1: Input:   word = ""aaAbcBC"" Output:   3 Explanation: The special characters in  word  are  'a' ,  'b' , and  'c' . Example 2: Input:   word = ""abc"" Output:   0 Explanation: No character in  word  appears in uppercase. Example 3: Input:   word = ""abBCab"" Output:  1 Explanation: The only special character in  word  is  'b' .   Constraints: 1 <= word.length <= 50 word  consists of only lowercase and uppercase English letters."
3146,https://leetcode.com/problems/permutation-difference-between-two-strings/,Fácil,Hash Table,Permutation Difference between Two Strings,"You are given two strings  s  and  t  such that every character occurs at most once in  s  and  t  is a permutation of  s . The  permutation difference  between  s  and  t  is defined as the  sum  of the absolute difference between the index of the occurrence of each character in  s  and the index of the occurrence of the same character in  t . Return the  permutation difference  between  s  and  t .   Example 1: Input:   s = ""abc"", t = ""bac"" Output:   2 Explanation: For  s = ""abc""  and  t = ""bac"" , the permutation difference of  s  and  t  is equal to the sum of: The absolute difference between the index of the occurrence of  ""a""  in  s  and the index of the occurrence of  ""a""  in  t . The absolute difference between the index of the occurrence of  ""b""  in  s  and the index of the occurrence of  ""b""  in  t . The absolute difference between the index of the occurrence of  ""c""  in  s  and the index of the occurrence of  ""c""  in  t . That is, the permutation difference between  s  and  t  is equal to  |0 - 1| + |1 - 0| + |2 - 2| = 2 . Example 2: Input:   s = ""abcde"", t = ""edbac"" Output:   12 Explanation:  The permutation difference between  s  and  t  is equal to  |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12 .   Constraints: 1 <= s.length <= 26 Each character occurs at most once in  s . t  is a permutation of  s . s  consists only of lowercase English letters."
3,https://leetcode.com/problems/longest-substring-without-repeating-characters/,Média,Hash Table,Longest Substring Without Repeating Characters,"Given a string  s , find the length of the  longest   substring  without duplicate characters.   Example 1: Input:  s = ""abcabcbb"" Output:  3 Explanation:  The answer is ""abc"", with the length of 3. Example 2: Input:  s = ""bbbbb"" Output:  1 Explanation:  The answer is ""b"", with the length of 1. Example 3: Input:  s = ""pwwkew"" Output:  3 Explanation:  The answer is ""wke"", with the length of 3. Notice that the answer must be a substring, ""pwke"" is a subsequence and not a substring.   Constraints: 0 <= s.length <= 5 * 10 4 s  consists of English letters, digits, symbols and spaces."
12,https://leetcode.com/problems/integer-to-roman/,Média,Hash Table,Integer to Roman,"Seven different symbols represent Roman numerals with the following values: Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules: If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral. If the value starts with 4 or 9 use the  subtractive form  representing one symbol subtracted from the following symbol, for example, 4 is 1 ( I ) less than 5 ( V ):  IV  and 9 is 1 ( I ) less than 10 ( X ):  IX . Only the following subtractive forms are used: 4 ( IV ), 9 ( IX ), 40 ( XL ), 90 ( XC ), 400 ( CD ) and 900 ( CM ). Only powers of 10 ( I ,  X ,  C ,  M ) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 ( V ), 50 ( L ), or 500 ( D ) multiple times. If you need to append a symbol 4 times use the  subtractive form . Given an integer, convert it to a Roman numeral.   Example 1: Input:   num = 3749 Output:   ""MMMDCCXLIX"" Explanation: 3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)  700 = DCC as 500 (D) + 100 (C) + 100 (C)   40 = XL as 10 (X) less of 50 (L)    9 = IX as 1 (I) less of 10 (X) Note: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places Example 2: Input:   num = 58 Output:   ""LVIII"" Explanation: 50 = L  8 = VIII Example 3: Input:   num = 1994 Output:   ""MCMXCIV"" Explanation: 1000 = M  900 = CM   90 = XC    4 = IV   Constraints: 1 <= num <= 3999"
355,https://leetcode.com/problems/design-twitter/,Média,Hash Table,Design Twitter,"Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the  10  most recent tweets in the user's news feed. Implement the  Twitter  class: Twitter()  Initializes your twitter object. void postTweet(int userId, int tweetId)  Composes a new tweet with ID  tweetId  by the user  userId . Each call to this function will be made with a unique  tweetId . List<Integer> getNewsFeed(int userId)  Retrieves the  10  most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be  ordered from most recent to least recent . void follow(int followerId, int followeeId)  The user with ID  followerId  started following the user with ID  followeeId . void unfollow(int followerId, int followeeId)  The user with ID  followerId  started unfollowing the user with ID  followeeId .   Example 1: Input [""Twitter"", ""postTweet"", ""getNewsFeed"", ""follow"", ""postTweet"", ""getNewsFeed"", ""unfollow"", ""getNewsFeed""] [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]] Output [null, null, [5], null, null, [6, 5], null, [5]] Explanation Twitter twitter = new Twitter(); twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5). twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5] twitter.follow(1, 2);    // User 1 follows user 2. twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6). twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.unfollow(1, 2);  // User 1 unfollows user 2. twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.   Constraints: 1 <= userId, followerId, followeeId <= 500 0 <= tweetId <= 10 4 All the tweets have  unique  IDs. At most  3 * 10 4  calls will be made to  postTweet ,  getNewsFeed ,  follow , and  unfollow . A user cannot follow himself."
676,https://leetcode.com/problems/implement-magic-dictionary/,Média,Hash Table,Implement Magic Dictionary,"Design a data structure that is initialized with a list of  different  words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure. Implement the  MagicDictionary  class: MagicDictionary()  Initializes the object. void buildDict(String[] dictionary)  Sets the data structure with an array of distinct strings  dictionary . bool search(String searchWord)  Returns  true  if you can change  exactly one character  in  searchWord  to match any string in the data structure, otherwise returns  false .   Example 1: Input [""MagicDictionary"", ""buildDict"", ""search"", ""search"", ""search"", ""search""] [[], [[""hello"", ""leetcode""]], [""hello""], [""hhllo""], [""hell""], [""leetcoded""]] Output [null, null, false, true, false, false] Explanation MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([""hello"", ""leetcode""]); magicDictionary.search(""hello""); // return False magicDictionary.search(""hhllo""); // We can change the second 'h' to 'e' to match ""hello"" so we return True magicDictionary.search(""hell""); // return False magicDictionary.search(""leetcoded""); // return False   Constraints: 1 <= dictionary.length <= 100 1 <= dictionary[i].length <= 100 dictionary[i]  consists of only lower-case English letters. All the strings in  dictionary  are  distinct . 1 <= searchWord.length <= 100 searchWord  consists of only lower-case English letters. buildDict  will be called only once before  search . At most  100  calls will be made to  search ."
791,https://leetcode.com/problems/custom-sort-string/,Média,Hash Table,Custom Sort String,"You are given two strings  order  and  s . All the characters of  order  are  unique  and were sorted in some custom order previously. Permute the characters of  s  so that they match the order that  order  was sorted. More specifically, if a character  x  occurs before a character  y  in  order , then  x  should occur before  y  in the permuted string. Return  any permutation of  s  that satisfies this property .   Example 1: Input:     order = ""cba"", s = ""abcd""  Output:     ""cbad""  Explanation:    ""a"" ,  ""b"" ,  ""c""  appear in order, so the order of  ""a"" ,  ""b"" ,  ""c""  should be  ""c"" ,  ""b"" , and  ""a"" . Since  ""d""  does not appear in  order , it can be at any position in the returned string.  ""dcba"" ,  ""cdba"" ,  ""cbda""  are also valid outputs. Example 2: Input:     order = ""bcafg"", s = ""abcd""  Output:     ""bcad""  Explanation:   The characters  ""b"" ,  ""c"" , and  ""a""  from  order  dictate the order for the characters in  s . The character  ""d""  in  s  does not appear in  order , so its position is flexible. Following the order of appearance in  order ,  ""b"" ,  ""c"" , and  ""a""  from  s  should be arranged as  ""b"" ,  ""c"" ,  ""a"" .  ""d""  can be placed at any position since it's not in order. The output  ""bcad""  correctly follows this rule. Other arrangements like  ""dbca""  or  ""bcda""  would also be valid, as long as  ""b"" ,  ""c"" ,  ""a""  maintain their order.   Constraints: 1 <= order.length <= 26 1 <= s.length <= 200 order  and  s  consist of lowercase English letters. All the characters of  order  are  unique ."
1348,https://leetcode.com/problems/tweet-counts-per-frequency/,Média,Hash Table,Tweet Counts Per Frequency,"A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller  time chunks  based on a certain frequency (every  minute ,  hour , or  day ). For example, the period  [10, 10000]  (in  seconds ) would be partitioned into the following  time chunks  with these frequencies: Every  minute  (60-second chunks):  [10,69] ,  [70,129] ,  [130,189] ,  ... ,  [9970,10000] Every  hour  (3600-second chunks):  [10,3609] ,  [3610,7209] ,  [7210,10000] Every  day  (86400-second chunks):  [10,10000] Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period ( 10000  in the above example). Design and implement an API to help the company with their analysis. Implement the  TweetCounts  class: TweetCounts()  Initializes the  TweetCounts  object. void recordTweet(String tweetName, int time)  Stores the  tweetName  at the recorded  time  (in  seconds ). List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)  Returns a list of integers representing the number of tweets with  tweetName  in each  time chunk  for the given period of time  [startTime, endTime]  (in  seconds ) and frequency  freq . 	 freq  is one of  ""minute"" ,  ""hour"" , or  ""day""  representing a frequency of every  minute ,  hour , or  day  respectively.   Example: Input [""TweetCounts"",""recordTweet"",""recordTweet"",""recordTweet"",""getTweetCountsPerFrequency"",""getTweetCountsPerFrequency"",""recordTweet"",""getTweetCountsPerFrequency""] [[],[""tweet3"",0],[""tweet3"",60],[""tweet3"",10],[""minute"",""tweet3"",0,59],[""minute"",""tweet3"",0,60],[""tweet3"",120],[""hour"",""tweet3"",0,210]] Output [null,null,null,null,[2],[2,1],null,[4]] Explanation TweetCounts tweetCounts = new TweetCounts(); tweetCounts.recordTweet(""tweet3"", 0);                              // New tweet ""tweet3"" at time 0 tweetCounts.recordTweet(""tweet3"", 60);                             // New tweet ""tweet3"" at time 60 tweetCounts.recordTweet(""tweet3"", 10);                             // New tweet ""tweet3"" at time 10 tweetCounts.getTweetCountsPerFrequency(""minute"", ""tweet3"", 0, 59); // return [2]; chunk [0,59] had 2 tweets tweetCounts.getTweetCountsPerFrequency(""minute"", ""tweet3"", 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet tweetCounts.recordTweet(""tweet3"", 120);                            // New tweet ""tweet3"" at time 120 tweetCounts.getTweetCountsPerFrequency(""hour"", ""tweet3"", 0, 210);  // return [4]; chunk [0,210] had 4 tweets   Constraints: 0 <= time, startTime, endTime <= 10 9 0 <= endTime - startTime <= 10 4 There will be at most  10 4  calls  in total  to  recordTweet  and  getTweetCountsPerFrequency ."
1593,https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/,Média,Hash Table,Split a String Into the Max Number of Unique Substrings,"Given a string  s ,  return  the maximum number of unique substrings that the given string can be split into . You can split string  s  into any list of  non-empty substrings , where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are  unique . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""ababccc"" Output:  5 Explanation : One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times. Example 2: Input:  s = ""aba"" Output:  2 Explanation : One way to split maximally is ['a', 'ba']. Example 3: Input:  s = ""aa"" Output:  1 Explanation : It is impossible to split the string any further.   Constraints: 1 <= s.length <= 16 s  contains only lower case English letters."
2182,https://leetcode.com/problems/construct-string-with-repeat-limit/,Média,Hash Table,Construct String With Repeat Limit,"You are given a string  s  and an integer  repeatLimit . Construct a new string  repeatLimitedString  using the characters of  s  such that no letter appears  more than   repeatLimit  times  in a row . You do  not  have to use all characters from  s . Return  the  lexicographically largest   repeatLimitedString   possible . A string  a  is  lexicographically larger  than a string  b  if in the first position where  a  and  b  differ, string  a  has a letter that appears later in the alphabet than the corresponding letter in  b . If the first  min(a.length, b.length)  characters do not differ, then the longer string is the lexicographically larger one.   Example 1: Input:  s = ""cczazcc"", repeatLimit = 3 Output:  ""zzcccac"" Explanation:  We use all of the characters from s to construct the repeatLimitedString ""zzcccac"". The letter 'a' appears at most 1 time in a row. The letter 'c' appears at most 3 times in a row. The letter 'z' appears at most 2 times in a row. Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString. The string is the lexicographically largest repeatLimitedString possible so we return ""zzcccac"". Note that the string ""zzcccca"" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString. Example 2: Input:  s = ""aababab"", repeatLimit = 2 Output:  ""bbabaa"" Explanation:  We use only some of the characters from s to construct the repeatLimitedString ""bbabaa"".  The letter 'a' appears at most 2 times in a row. The letter 'b' appears at most 2 times in a row. Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString. The string is the lexicographically largest repeatLimitedString possible so we return ""bbabaa"". Note that the string ""bbabaaa"" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString.   Constraints: 1 <= repeatLimit <= s.length <= 10 5 s  consists of lowercase English letters."
2266,https://leetcode.com/problems/count-number-of-texts/,Média,Hash Table,Count Number of Texts,"Alice is texting Bob using her phone. The  mapping  of digits to letters is shown in the figure below. In order to  add  a letter, Alice has to  press  the key of the corresponding digit  i  times, where  i  is the position of the letter in the key. For example, to add the letter  's' , Alice has to press  '7'  four times. Similarly, to add the letter  'k' , Alice has to press  '5'  twice. Note that the digits  '0'  and  '1'  do not map to any letters, so Alice  does not  use them. However, due to an error in transmission, Bob did not receive Alice's text message but received a  string of pressed keys  instead. For example, when Alice sent the message  ""bob"" , Bob received the string  ""2266622"" . Given a string  pressedKeys  representing the string received by Bob, return  the  total number of possible text messages  Alice could have sent . Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  pressedKeys = ""22233"" Output:  8 Explanation: The possible text messages Alice could have sent are: ""aaadd"", ""abdd"", ""badd"", ""cdd"", ""aaae"", ""abe"", ""bae"", and ""ce"". Since there are 8 possible messages, we return 8. Example 2: Input:  pressedKeys = ""222222222222222222222222222222222222"" Output:  82876089 Explanation: There are 2082876103 possible text messages Alice could have sent. Since we need to return the answer modulo 10 9  + 7, we return 2082876103 % (10 9  + 7) = 82876089.   Constraints: 1 <= pressedKeys.length <= 10 5 pressedKeys  only consists of digits from  '2'  -  '9' ."
3305,https://leetcode.com/problems/count-of-substrings-containing-every-vowel-and-k-consonants-i/,Média,Hash Table,Count of Substrings Containing Every Vowel and K Consonants I,"You are given a string  word  and a  non-negative  integer  k . Return the total number of  substrings  of  word  that contain every vowel ( 'a' ,  'e' ,  'i' ,  'o' , and  'u' )  at least  once and  exactly   k  consonants.   Example 1: Input:   word = ""aeioqq"", k = 1 Output:   0 Explanation: There is no substring with every vowel. Example 2: Input:   word = ""aeiou"", k = 0 Output:   1 Explanation: The only substring with every vowel and zero consonants is  word[0..4] , which is  ""aeiou"" . Example 3: Input:   word = "" ieaouqqieaouqq "", k = 1 Output:  3 Explanation: The substrings with every vowel and one consonant are: word[0..5] , which is  ""ieaouq"" . word[6..11] , which is  ""qieaou"" . word[7..12] , which is  ""ieaouq"" .   Constraints: 5 <= word.length <= 250 word  consists only of lowercase English letters. 0 <= k <= word.length - 5"
3306,https://leetcode.com/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/,Média,Hash Table,Count of Substrings Containing Every Vowel and K Consonants II,"You are given a string  word  and a  non-negative  integer  k . Return the total number of  substrings  of  word  that contain every vowel ( 'a' ,  'e' ,  'i' ,  'o' , and  'u' )  at least  once and  exactly   k  consonants.   Example 1: Input:   word = ""aeioqq"", k = 1 Output:   0 Explanation: There is no substring with every vowel. Example 2: Input:   word = ""aeiou"", k = 0 Output:   1 Explanation: The only substring with every vowel and zero consonants is  word[0..4] , which is  ""aeiou"" . Example 3: Input:   word = "" ieaouqqieaouqq "", k = 1 Output:  3 Explanation: The substrings with every vowel and one consonant are: word[0..5] , which is  ""ieaouq"" . word[6..11] , which is  ""qieaou"" . word[7..12] , which is  ""ieaouq"" .   Constraints: 5 <= word.length <= 2 * 10 5 word  consists only of lowercase English letters. 0 <= k <= word.length - 5"
726,https://leetcode.com/problems/number-of-atoms/,Difícil,Hash Table,Number of Atoms,"Given a string  formula  representing a chemical formula, return  the count of each atom . The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element's count may follow if the count is greater than  1 . If the count is  1 , no digits will follow. For example,  ""H2O""  and  ""H2O2""  are possible, but  ""H1O2""  is impossible. Two formulas are concatenated together to produce another formula. For example,  ""H2O2He3Mg4""  is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula. For example,  ""(H2O2)""  and  ""(H2O2)3""  are formulas. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than  1 ), followed by the second name (in sorted order), followed by its count (if that count is more than  1 ), and so on. The test cases are generated so that all the values in the output fit in a  32-bit  integer.   Example 1: Input:  formula = ""H2O"" Output:  ""H2O"" Explanation:  The count of elements are {'H': 2, 'O': 1}. Example 2: Input:  formula = ""Mg(OH)2"" Output:  ""H2MgO2"" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}. Example 3: Input:  formula = ""K4(ON(SO3)2)2"" Output:  ""K4N2O14S4"" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Constraints: 1 <= formula.length <= 1000 formula  consists of English letters, digits,  '(' , and  ')' . formula  is always valid."
1172,https://leetcode.com/problems/dinner-plate-stacks/,Difícil,Hash Table,Dinner Plate Stacks,"You have an infinite number of stacks arranged in a row and numbered (left to right) from  0 , each of the stacks has the same maximum capacity. Implement the  DinnerPlates  class: DinnerPlates(int capacity)  Initializes the object with the maximum capacity of the stacks  capacity . void push(int val)  Pushes the given integer  val  into the leftmost stack with a size less than  capacity . int pop()  Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns  -1  if all the stacks are empty. int popAtStack(int index)  Returns the value at the top of the stack with the given index  index  and removes it from that stack or returns  -1  if the stack with that given index is empty.   Example 1: Input [""DinnerPlates"", ""push"", ""push"", ""push"", ""push"", ""push"", ""popAtStack"", ""push"", ""push"", ""popAtStack"", ""popAtStack"", ""pop"", ""pop"", ""pop"", ""pop"", ""pop""] [[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []] Output [null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1] Explanation:   DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5);         // The stacks are now:  2  4                                            1  3  5                                            ﹈ ﹈ ﹈ D.popAtStack(0);   // Returns 2.  The stacks are now:     4                                                        1  3  5                                                        ﹈ ﹈ ﹈ D.push(20);        // The stacks are now: 20  4                                            1  3  5                                            ﹈ ﹈ ﹈ D.push(21);        // The stacks are now: 20  4 21                                            1  3  5                                            ﹈ ﹈ ﹈ D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21                                                         1  3  5                                                         ﹈ ﹈ ﹈ D.popAtStack(2);   // Returns 21.  The stacks are now:     4                                                         1  3  5                                                         ﹈ ﹈ ﹈  D.pop()            // Returns 5.  The stacks are now:      4                                                         1  3                                                          ﹈ ﹈   D.pop()            // Returns 4.  The stacks are now:   1  3                                                          ﹈ ﹈    D.pop()            // Returns 3.  The stacks are now:   1                                                          ﹈    D.pop()            // Returns 1.  There are no stacks. D.pop()            // Returns -1.  There are still no stacks.   Constraints: 1 <= capacity <= 2 * 10 4 1 <= val <= 2 * 10 4 0 <= index <= 10 5 At most  2 * 10 5  calls will be made to  push ,  pop , and  popAtStack ."
2262,https://leetcode.com/problems/total-appeal-of-a-string/,Difícil,Hash Table,Total Appeal of A String,"The  appeal  of a string is the number of  distinct  characters found in the string. For example, the appeal of  ""abbca""  is  3  because it has  3  distinct characters:  'a' ,  'b' , and  'c' . Given a string  s , return  the  total appeal of all of its  substrings . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""abbca"" Output:  28 Explanation:  The following are the substrings of ""abbca"": - Substrings of length 1: ""a"", ""b"", ""b"", ""c"", ""a"" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5. - Substrings of length 2: ""ab"", ""bb"", ""bc"", ""ca"" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7. - Substrings of length 3: ""abb"", ""bbc"", ""bca"" have an appeal of 2, 2, and 3 respectively. The sum is 7. - Substrings of length 4: ""abbc"", ""bbca"" have an appeal of 3 and 3 respectively. The sum is 6. - Substrings of length 5: ""abbca"" has an appeal of 3. The sum is 3. The total sum is 5 + 7 + 7 + 6 + 3 = 28. Example 2: Input:  s = ""code"" Output:  20 Explanation:  The following are the substrings of ""code"": - Substrings of length 1: ""c"", ""o"", ""d"", ""e"" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4. - Substrings of length 2: ""co"", ""od"", ""de"" have an appeal of 2, 2, and 2 respectively. The sum is 6. - Substrings of length 3: ""cod"", ""ode"" have an appeal of 3 and 3 respectively. The sum is 6. - Substrings of length 4: ""code"" has an appeal of 4. The sum is 4. The total sum is 4 + 6 + 6 + 4 = 20.   Constraints: 1 <= s.length <= 10 5 s  consists of lowercase English letters."
2953,https://leetcode.com/problems/count-complete-substrings/,Difícil,Hash Table,Count Complete Substrings,"You are given a string  word  and an integer  k . A substring  s  of  word  is  complete  if: Each character in  s  occurs  exactly   k  times. The difference between two adjacent characters is  at most   2 . That is, for any two adjacent characters  c1  and  c2  in  s , the absolute difference in their positions in the alphabet is  at most   2 . Return  the number of  complete  substrings of   word . A  substring  is a  non-empty  contiguous sequence of characters in a string.   Example 1: Input:  word = ""igigee"", k = 2 Output:  3 Explanation:  The complete substrings where each character appears exactly twice and the difference between adjacent characters is at most 2 are:  igig ee, igig ee ,  igigee . Example 2: Input:  word = ""aaabbbccc"", k = 3 Output:  6 Explanation:  The complete substrings where each character appears exactly three times and the difference between adjacent characters is at most 2 are:  aaa bbbccc, aaa bbb ccc, aaabbb ccc ,  aaabbb ccc, aaa bbbccc ,  aaabbbccc .   Constraints: 1 <= word.length <= 10 5 word  consists only of lowercase English letters. 1 <= k <= word.length"
2983,https://leetcode.com/problems/palindrome-rearrangement-queries/,Difícil,Hash Table,Palindrome Rearrangement Queries,"You are given a  0-indexed  string  s  having an  even  length  n . You are also given a  0-indexed  2D integer array,  queries , where  queries[i] = [a i , b i , c i , d i ] . For each query  i , you are allowed to perform the following operations: Rearrange the characters within the  substring   s[a i :b i ] , where  0 <= a i  <= b i  < n / 2 . Rearrange the characters within the  substring   s[c i :d i ] , where  n / 2 <= c i  <= d i  < n . For each query, your task is to determine whether it is possible to make  s  a  palindrome  by performing the operations. Each query is answered  independently  of the others. Return  a  0-indexed  array  answer , where  answer[i] == true  if it is possible to make  s  a palindrome by performing operations specified by the  i th  query, and  false  otherwise. A  substring  is a contiguous sequence of characters within a string. s[x:y]  represents the substring consisting of characters from the index  x  to index  y  in  s ,  both inclusive .   Example 1: Input:  s = ""abcabc"", queries = [[1,1,3,5],[0,2,5,5]] Output:  [true,true] Explanation:  In this example, there are two queries: In the first query: - a 0  = 1, b 0  = 1, c 0  = 3, d 0  = 5. - So, you are allowed to rearrange s[1:1] => a b cabc and s[3:5] => abc abc . - To make s a palindrome, s[3:5] can be rearranged to become => abc cba . - Now, s is a palindrome. So, answer[0] = true. In the second query: - a 1  = 0, b 1  = 2, c 1  = 5, d 1  = 5. - So, you are allowed to rearrange s[0:2] =>  abc abc and s[5:5] => abcab c . - To make s a palindrome, s[0:2] can be rearranged to become =>  cba abc. - Now, s is a palindrome. So, answer[1] = true. Example 2: Input:  s = ""abbcdecbba"", queries = [[0,2,7,9]] Output:  [false] Explanation:  In this example, there is only one query. a 0  = 0, b 0  = 2, c 0  = 7, d 0  = 9. So, you are allowed to rearrange s[0:2] =>  abb cdecbba and s[7:9] => abbcdec bba . It is not possible to make s a palindrome by rearranging these substrings because s[3:6] is not a palindrome. So, answer[0] = false. Example 3: Input:  s = ""acbcab"", queries = [[1,2,4,5]] Output:  [true] Explanation:  In this example, there is only one query. a 0  = 1, b 0  = 2, c 0  = 4, d 0  = 5. So, you are allowed to rearrange s[1:2] => a cb cab and s[4:5] => acbc ab . To make s a palindrome s[1:2] can be rearranged to become a bc cab. Then, s[4:5] can be rearranged to become abcc ba . Now, s is a palindrome. So, answer[0] = true.   Constraints: 2 <= n == s.length <= 10 5 1 <= queries.length <= 10 5 queries[i].length == 4 a i  == queries[i][0], b i  == queries[i][1] c i  == queries[i][2], d i  == queries[i][3] 0 <= a i  <= b i  < n / 2 n / 2 <= c i  <= d i  < n  n  is even. s  consists of only lowercase English letters."
206,https://leetcode.com/problems/reverse-linked-list/,Fácil,Linked List,Reverse Linked List,"Given the  head  of a singly linked list, reverse the list, and return  the reversed list .   Example 1: Input:  head = [1,2,3,4,5] Output:  [5,4,3,2,1] Example 2: Input:  head = [1,2] Output:  [2,1] Example 3: Input:  head = [] Output:  []   Constraints: The number of nodes in the list is the range  [0, 5000] . -5000 <= Node.val <= 5000   Follow up:  A linked list can be reversed either iteratively or recursively. Could you implement both?"
876,https://leetcode.com/problems/middle-of-the-linked-list/,Fácil,Linked List,Middle of the Linked List,"Given the  head  of a singly linked list, return  the middle node of the linked list . If there are two middle nodes, return  the second middle  node.   Example 1: Input:  head = [1,2,3,4,5] Output:  [3,4,5] Explanation:  The middle node of the list is node 3. Example 2: Input:  head = [1,2,3,4,5,6] Output:  [4,5,6] Explanation:  Since the list has two middle nodes with values 3 and 4, we return the second one.   Constraints: The number of nodes in the list is in the range  [1, 100] . 1 <= Node.val <= 100"
24,https://leetcode.com/problems/swap-nodes-in-pairs/,Média,Linked List,Swap Nodes in Pairs,"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)   Example 1: Input:   head = [1,2,3,4] Output:   [2,1,4,3] Explanation: Example 2: Input:   head = [] Output:   [] Example 3: Input:   head = [1] Output:   [1] Example 4: Input:   head = [1,2,3] Output:   [2,1,3]   Constraints: The number of nodes in the list is in the range  [0, 100] . 0 <= Node.val <= 100"
114,https://leetcode.com/problems/flatten-binary-tree-to-linked-list/,Média,Linked List,Flatten Binary Tree to Linked List,"Given the  root  of a binary tree, flatten the tree into a ""linked list"": The ""linked list"" should use the same  TreeNode  class where the  right  child pointer points to the next node in the list and the  left  child pointer is always  null . The ""linked list"" should be in the same order as a  pre-order  traversal  of the binary tree.   Example 1: Input:  root = [1,2,5,3,4,null,6] Output:  [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input:  root = [] Output:  [] Example 3: Input:  root = [0] Output:  [0]   Constraints: The number of nodes in the tree is in the range  [0, 2000] . -100 <= Node.val <= 100   Follow up:  Can you flatten the tree in-place (with  O(1)  extra space)?"
143,https://leetcode.com/problems/reorder-list/,Média,Linked List,Reorder List,"You are given the head of a singly linked-list. The list can be represented as: L 0  → L 1  → … → L n - 1  → L n Reorder the list to be on the following form: L 0  → L n  → L 1  → L n - 1  → L 2  → L n - 2  → … You may not modify the values in the list's nodes. Only nodes themselves may be changed.   Example 1: Input:  head = [1,2,3,4] Output:  [1,4,2,3] Example 2: Input:  head = [1,2,3,4,5] Output:  [1,5,2,4,3]   Constraints: The number of nodes in the list is in the range  [1, 5 * 10 4 ] . 1 <= Node.val <= 1000"
148,https://leetcode.com/problems/sort-list/,Média,Linked List,Sort List,"Given the  head  of a linked list, return  the list after sorting it in  ascending order .   Example 1: Input:  head = [4,2,1,3] Output:  [1,2,3,4] Example 2: Input:  head = [-1,5,3,4,0] Output:  [-1,0,3,4,5] Example 3: Input:  head = [] Output:  []   Constraints: The number of nodes in the list is in the range  [0, 5 * 10 4 ] . -10 5  <= Node.val <= 10 5   Follow up:  Can you sort the linked list in  O(n logn)  time and  O(1)  memory (i.e. constant space)?"
2074,https://leetcode.com/problems/reverse-nodes-in-even-length-groups/,Média,Linked List,Reverse Nodes in Even Length Groups,"You are given the  head  of a linked list. The nodes in the linked list are  sequentially  assigned to  non-empty  groups whose lengths form the sequence of the natural numbers ( 1, 2, 3, 4, ... ). The  length  of a group is the number of nodes assigned to it. In other words, The  1 st  node is assigned to the first group. The  2 nd  and the  3 rd  nodes are assigned to the second group. The  4 th ,  5 th , and  6 th  nodes are assigned to the third group, and so on. Note that the length of the last group may be less than or equal to  1 + the length of the second to last group . Reverse  the nodes in each group with an  even  length, and return  the   head   of the modified linked list .   Example 1: Input:  head = [5,2,6,3,9,1,7,3,8,4] Output:  [5,6,2,3,9,1,4,8,3,7] Explanation: - The length of the first group is 1, which is odd, hence no reversal occurs. - The length of the second group is 2, which is even, hence the nodes are reversed. - The length of the third group is 3, which is odd, hence no reversal occurs. - The length of the last group is 4, which is even, hence the nodes are reversed. Example 2: Input:  head = [1,1,0,6] Output:  [1,0,1,6] Explanation: - The length of the first group is 1. No reversal occurs. - The length of the second group is 2. The nodes are reversed. - The length of the last group is 1. No reversal occurs. Example 3: Input:  head = [1,1,0,6,5] Output:  [1,0,1,5,6] Explanation: - The length of the first group is 1. No reversal occurs. - The length of the second group is 2. The nodes are reversed. - The length of the last group is 2. The nodes are reversed.   Constraints: The number of nodes in the list is in the range  [1, 10 5 ] . 0 <= Node.val <= 10 5"
70,https://leetcode.com/problems/climbing-stairs/,Fácil,Math,Climbing Stairs,You are climbing a staircase. It takes  n  steps to reach the top. Each time you can either climb  1  or  2  steps. In how many distinct ways can you climb to the top?   Example 1: Input:  n = 2 Output:  2 Explanation:  There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input:  n = 3 Output:  3 Explanation:  There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step   Constraints: 1 <= n <= 45
263,https://leetcode.com/problems/ugly-number/,Fácil,Math,Ugly Number,"An  ugly number  is a  positive  integer which does not have a prime factor other than 2, 3, and 5. Given an integer  n , return  true   if   n   is an  ugly number .   Example 1: Input:  n = 6 Output:  true Explanation:  6 = 2 × 3 Example 2: Input:  n = 1 Output:  true Explanation:  1 has no prime factors. Example 3: Input:  n = 14 Output:  false Explanation:  14 is not ugly since it includes the prime factor 7.   Constraints: -2 31  <= n <= 2 31  - 1"
326,https://leetcode.com/problems/power-of-three/,Fácil,Math,Power of Three,"Given an integer  n , return  true  if it is a power of three. Otherwise, return  false . An integer  n  is a power of three, if there exists an integer  x  such that  n == 3 x .   Example 1: Input:  n = 27 Output:  true Explanation:  27 = 3 3 Example 2: Input:  n = 0 Output:  false Explanation:  There is no x where 3 x  = 0. Example 3: Input:  n = -1 Output:  false Explanation:  There is no x where 3 x  = (-1).   Constraints: -2 31  <= n <= 2 31  - 1   Follow up:  Could you solve it without loops/recursion?"
415,https://leetcode.com/problems/add-strings/,Fácil,Math,Add Strings,"Given two non-negative integers,  num1  and  num2  represented as string, return  the sum of   num1   and   num2   as a string . You must solve the problem without using any built-in library for handling large integers (such as  BigInteger ). You must also not convert the inputs to integers directly.   Example 1: Input:  num1 = ""11"", num2 = ""123"" Output:  ""134"" Example 2: Input:  num1 = ""456"", num2 = ""77"" Output:  ""533"" Example 3: Input:  num1 = ""0"", num2 = ""0"" Output:  ""0""   Constraints: 1 <= num1.length, num2.length <= 10 4 num1  and  num2  consist of only digits. num1  and  num2  don't have any leading zeros except for the zero itself."
504,https://leetcode.com/problems/base-7/,Fácil,Math,Base 7,"Given an integer  num , return  a string of its  base 7  representation .   Example 1: Input:  num = 100 Output:  ""202"" Example 2: Input:  num = -7 Output:  ""-10""   Constraints: -10 7  <= num <= 10 7"
1175,https://leetcode.com/problems/prime-arrangements/,Fácil,Math,Prime Arrangements,"Return the number of permutations of 1 to  n  so that prime numbers are at prime indices (1-indexed.) (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.) Since the answer may be large, return the answer  modulo  10^9 + 7 .   Example 1: Input:  n = 5 Output:  12 Explanation:  For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1. Example 2: Input:  n = 100 Output:  682289015   Constraints: 1 <= n <= 100"
1716,https://leetcode.com/problems/calculate-money-in-leetcode-bank/,Fácil,Math,Calculate Money in Leetcode Bank,"Hercy wants to save money for his first car. He puts money in the Leetcode bank  every day . He starts by putting in  $1  on Monday, the first day. Every day from Tuesday to Sunday, he will put in  $1  more than the day before. On every subsequent Monday, he will put in  $1  more than the  previous Monday .   Given  n , return  the total amount of money he will have in the Leetcode bank at the end of the  n th  day.   Example 1: Input:  n = 4 Output:  10 Explanation:  After the 4 th  day, the total is 1 + 2 + 3 + 4 = 10. Example 2: Input:  n = 10 Output:  37 Explanation:  After the 10 th  day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2 nd  Monday, Hercy only puts in $2. Example 3: Input:  n = 20 Output:  96 Explanation:  After the 20 th  day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.   Constraints: 1 <= n <= 1000"
2652,https://leetcode.com/problems/sum-multiples/,Fácil,Math,Sum Multiples,"Given a positive integer  n , find the sum of all integers in the range  [1, n]   inclusive  that are divisible by  3 ,  5 , or  7 . Return  an integer denoting the sum of all numbers in the given range satisfying the constraint.   Example 1: Input:  n = 7 Output:  21 Explanation:  Numbers in the range  [1, 7]  that are divisible by  3 ,  5,  or  7  are  3, 5, 6, 7 . The sum of these numbers is  21 . Example 2: Input:  n = 10 Output:  40 Explanation:  Numbers in the range  [1, 10] that are  divisible by  3 ,  5,  or  7  are  3, 5, 6, 7, 9, 10 . The sum of these numbers is 40. Example 3: Input:  n = 9 Output:  30 Explanation:  Numbers in the range  [1, 9]  that are divisible by  3 ,  5 , or  7  are  3, 5, 6, 7, 9 . The sum of these numbers is  30 .   Constraints: 1 <= n <= 10 3"
2894,https://leetcode.com/problems/divisible-and-non-divisible-sums-difference/,Fácil,Math,Divisible and Non-divisible Sums Difference,"You are given positive integers  n  and  m . Define two integers as follows: num1 : The sum of all integers in the range  [1, n]  (both  inclusive ) that are  not divisible  by  m . num2 : The sum of all integers in the range  [1, n]  (both  inclusive ) that are  divisible  by  m . Return  the integer   num1 - num2 .   Example 1: Input:  n = 10, m = 3 Output:  19 Explanation:  In the given example: - Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37. - Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18. We return 37 - 18 = 19 as the answer. Example 2: Input:  n = 5, m = 6 Output:  15 Explanation:  In the given example: - Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15. - Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0. We return 15 - 0 = 15 as the answer. Example 3: Input:  n = 5, m = 1 Output:  -15 Explanation:  In the given example: - Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0. - Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15. We return 0 - 15 = -15 as the answer.   Constraints: 1 <= n, m <= 1000"
223,https://leetcode.com/problems/rectangle-area/,Média,Math,Rectangle Area,"Given the coordinates of two  rectilinear  rectangles in a 2D plane, return  the total area covered by the two rectangles . The first rectangle is defined by its  bottom-left  corner  (ax1, ay1)  and its  top-right  corner  (ax2, ay2) . The second rectangle is defined by its  bottom-left  corner  (bx1, by1)  and its  top-right  corner  (bx2, by2) .   Example 1: Input:  ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output:  45 Example 2: Input:  ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2 Output:  16   Constraints: -10 4  <= ax1 <= ax2 <= 10 4 -10 4  <= ay1 <= ay2 <= 10 4 -10 4  <= bx1 <= bx2 <= 10 4 -10 4  <= by1 <= by2 <= 10 4"
478,https://leetcode.com/problems/generate-random-point-in-a-circle/,Média,Math,Generate Random Point in a Circle,"Given the radius and the position of the center of a circle, implement the function  randPoint  which generates a uniform random point inside the circle. Implement the  Solution  class: Solution(double radius, double x_center, double y_center)  initializes the object with the radius of the circle  radius  and the position of the center  (x_center, y_center) . randPoint()  returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array  [x, y] .   Example 1: Input [""Solution"", ""randPoint"", ""randPoint"", ""randPoint""] [[1.0, 0.0, 0.0], [], [], []] Output [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]] Explanation Solution solution = new Solution(1.0, 0.0, 0.0); solution.randPoint(); // return [-0.02493, -0.38077] solution.randPoint(); // return [0.82314, 0.38945] solution.randPoint(); // return [0.36572, 0.17248]   Constraints: 0 < radius <= 10 8 -10 7  <= x_center, y_center <= 10 7 At most  3 * 10 4  calls will be made to  randPoint ."
738,https://leetcode.com/problems/monotone-increasing-digits/,Média,Math,Monotone Increasing Digits,"An integer has  monotone increasing digits  if and only if each pair of adjacent digits  x  and  y  satisfy  x <= y . Given an integer  n , return  the largest number that is less than or equal to  n  with  monotone increasing digits .   Example 1: Input:  n = 10 Output:  9 Example 2: Input:  n = 1234 Output:  1234 Example 3: Input:  n = 332 Output:  299   Constraints: 0 <= n <= 10 9"
1201,https://leetcode.com/problems/ugly-number-iii/,Média,Math,Ugly Number III,"An  ugly number  is a positive integer that is divisible by  a ,  b , or  c . Given four integers  n ,  a ,  b , and  c , return the  n th   ugly number .   Example 1: Input:  n = 3, a = 2, b = 3, c = 5 Output:  4 Explanation:  The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3 rd  is 4. Example 2: Input:  n = 4, a = 2, b = 3, c = 4 Output:  6 Explanation:  The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4 th  is 6. Example 3: Input:  n = 5, a = 2, b = 11, c = 13 Output:  10 Explanation:  The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5 th  is 10.   Constraints: 1 <= n, a, b, c <= 10 9 1 <= a * b * c <= 10 18 It is guaranteed that the result will be in range  [1, 2 * 10 9 ] ."
1904,https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/,Média,Math,The Number of Full Rounds You Have Played,"You are participating in an online chess tournament. There is a chess round that starts every  15  minutes. The first round of the day starts at  00:00 , and after every  15  minutes, a new round starts. For example, the second round starts at  00:15 , the fourth round starts at  00:45 , and the seventh round starts at  01:30 . You are given two strings  loginTime  and  logoutTime  where: loginTime  is the time you will login to the game, and logoutTime  is the time you will logout from the game. If  logoutTime  is  earlier  than  loginTime , this means you have played from  loginTime  to midnight and from midnight to  logoutTime . Return  the number of full chess rounds you have played in the tournament . Note:  All the given times follow the 24-hour clock. That means the first round of the day starts at  00:00  and the last round of the day starts at  23:45 .   Example 1: Input:  loginTime = ""09:31"", logoutTime = ""10:14"" Output:  1 Explanation:  You played one full round from 09:45 to 10:00. You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began. You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended. Example 2: Input:  loginTime = ""21:30"", logoutTime = ""03:00"" Output:  22 Explanation:  You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00. 10 + 12 = 22.   Constraints: loginTime  and  logoutTime  are in the format  hh:mm . 00 <= hh <= 23 00 <= mm <= 59 loginTime  and  logoutTime  are not equal."
2139,https://leetcode.com/problems/minimum-moves-to-reach-target-score/,Média,Math,Minimum Moves to Reach Target Score,"You are playing a game with integers. You start with the integer  1  and you want to reach the integer  target . In one move, you can either: Increment  the current integer by one (i.e.,  x = x + 1 ). Double  the current integer (i.e.,  x = 2 * x ). You can use the  increment  operation  any  number of times, however, you can only use the  double  operation  at most   maxDoubles  times. Given the two integers  target  and  maxDoubles , return  the minimum number of moves needed to reach  target  starting with  1 .   Example 1: Input:  target = 5, maxDoubles = 0 Output:  4 Explanation:  Keep incrementing by 1 until you reach target. Example 2: Input:  target = 19, maxDoubles = 2 Output:  7 Explanation:  Initially, x = 1 Increment 3 times so x = 4 Double once so x = 8 Increment once so x = 9 Double again so x = 18 Increment once so x = 19 Example 3: Input:  target = 10, maxDoubles = 4 Output:  4 Explanation:   Initially, x = 1 Increment once so x = 2 Double once so x = 4 Increment once so x = 5 Double again so x = 10   Constraints: 1 <= target <= 10 9 0 <= maxDoubles <= 100"
2310,https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/,Média,Math,Sum of Numbers With Units Digit K,"Given two integers  num  and  k , consider a set of positive integers with the following properties: The units digit of each integer is  k . The sum of the integers is  num . Return  the  minimum  possible size of such a set, or  -1  if no such set exists. Note: The set can contain multiple instances of the same integer, and the sum of an empty set is considered  0 . The  units digit  of a number is the rightmost digit of the number.   Example 1: Input:  num = 58, k = 9 Output:  2 Explanation: One valid set is [9,49], as the sum is 58 and each integer has a units digit of 9. Another valid set is [19,39]. It can be shown that 2 is the minimum possible size of a valid set. Example 2: Input:  num = 37, k = 2 Output:  -1 Explanation:  It is not possible to obtain a sum of 37 using only integers that have a units digit of 2. Example 3: Input:  num = 0, k = 7 Output:  0 Explanation:  The sum of an empty set is considered 0.   Constraints: 0 <= num <= 3000 0 <= k <= 9"
2834,https://leetcode.com/problems/find-the-minimum-possible-sum-of-a-beautiful-array/,Média,Math,Find the Minimum Possible Sum of a Beautiful Array,"You are given positive integers  n  and  target . An array  nums  is  beautiful  if it meets the following conditions: nums.length == n . nums  consists of pairwise  distinct   positive  integers. There doesn't exist two  distinct  indices,  i  and  j , in the range  [0, n - 1] , such that  nums[i] + nums[j] == target . Return  the  minimum  possible sum that a beautiful array could have modulo  10 9  + 7 .   Example 1: Input:  n = 2, target = 3 Output:  4 Explanation:  We can see that nums = [1,3] is beautiful. - The array nums has length n = 2. - The array nums consists of pairwise distinct positive integers. - There doesn't exist two distinct indices, i and j, with nums[i] + nums[j] == 3. It can be proven that 4 is the minimum possible sum that a beautiful array could have. Example 2: Input:  n = 3, target = 3 Output:  8 Explanation:  We can see that nums = [1,3,4] is beautiful. - The array nums has length n = 3. - The array nums consists of pairwise distinct positive integers. - There doesn't exist two distinct indices, i and j, with nums[i] + nums[j] == 3. It can be proven that 8 is the minimum possible sum that a beautiful array could have. Example 3: Input:  n = 1, target = 1 Output:  1 Explanation:  We can see, that nums = [1] is beautiful.   Constraints: 1 <= n <= 10 9 1 <= target <= 10 9"
2930,https://leetcode.com/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/,Média,Math,Number of Strings Which Can Be Rearranged to Contain Substring,"You are given an integer  n . A string  s  is called  good  if it contains only lowercase English characters  and  it is possible to rearrange the characters of  s  such that the new string contains  ""leet""  as a  substring . For example: The string  ""lteer""  is good because we can rearrange it to form  ""leetr""  . ""letl""  is not good because we cannot rearrange it to contain  ""leet""  as a substring. Return  the  total  number of good strings of length  n . Since the answer may be large, return it  modulo  10 9  + 7 . A  substring  is a contiguous sequence of characters within a string.     Example 1: Input:  n = 4 Output:  12 Explanation:  The 12 strings which can be rearranged to have ""leet"" as a substring are: ""eelt"", ""eetl"", ""elet"", ""elte"", ""etel"", ""etle"", ""leet"", ""lete"", ""ltee"", ""teel"", ""tele"", and ""tlee"". Example 2: Input:  n = 10 Output:  83943898 Explanation:  The number of strings with length 10 which can be rearranged to have ""leet"" as a substring is 526083947580. Hence the answer is 526083947580 % (10 9  + 7) = 83943898.   Constraints: 1 <= n <= 10 5"
3084,https://leetcode.com/problems/count-substrings-starting-and-ending-with-given-character/,Média,Math,Count Substrings Starting and Ending with Given Character,"You are given a string  s  and a character  c . Return  the total number of  substrings  of  s  that start and end with  c .   Example 1: Input:  s = ""abada"", c = ""a"" Output:  6 Explanation:  Substrings starting and ending with  ""a""  are:  "" a bada"" ,  "" aba da"" ,  "" abada "" ,  ""ab a da"" ,  ""ab ada "" ,  ""abad a "" . Example 2: Input:  s = ""zzz"", c = ""z"" Output:  6 Explanation:  There are a total of  6  substrings in  s  and all start and end with  ""z"" .   Constraints: 1 <= s.length <= 10 5 s  and  c  consist only of lowercase English letters."
3100,https://leetcode.com/problems/water-bottles-ii/,Média,Math,Water Bottles II,"You are given two integers  numBottles  and  numExchange . numBottles  represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations: Drink any number of full water bottles turning them into empty bottles. Exchange  numExchange  empty bottles with one full water bottle. Then, increase  numExchange  by one. Note that you cannot exchange multiple batches of empty bottles for the same value of  numExchange . For example, if  numBottles == 3  and  numExchange == 1 , you cannot exchange  3  empty water bottles for  3  full bottles. Return  the  maximum  number of water bottles you can drink .   Example 1: Input:  numBottles = 13, numExchange = 6 Output:  15 Explanation:  The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk. Example 2: Input:  numBottles = 10, numExchange = 3 Output:  13 Explanation:  The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.   Constraints: 1 <= numBottles <= 100  1 <= numExchange <= 100"
282,https://leetcode.com/problems/expression-add-operators/,Difícil,Math,Expression Add Operators,"Given a string  num  that contains only digits and an integer  target , return  all possibilities  to insert the binary operators  '+' ,  '-' , and/or  '*'  between the digits of  num  so that the resultant expression evaluates to the  target  value . Note that operands in the returned expressions  should not  contain leading zeros.   Example 1: Input:  num = ""123"", target = 6 Output:  [""1*2*3"",""1+2+3""] Explanation:  Both ""1*2*3"" and ""1+2+3"" evaluate to 6. Example 2: Input:  num = ""232"", target = 8 Output:  [""2*3+2"",""2+3*2""] Explanation:  Both ""2*3+2"" and ""2+3*2"" evaluate to 8. Example 3: Input:  num = ""3456237490"", target = 9191 Output:  [] Explanation:  There are no expressions that can be created from ""3456237490"" to evaluate to 9191.   Constraints: 1 <= num.length <= 10 num  consists of only digits. -2 31  <= target <= 2 31  - 1"
793,https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/,Difícil,Math,Preimage Size of Factorial Zeroes Function,"Let  f(x)  be the number of zeroes at the end of  x! . Recall that  x! = 1 * 2 * 3 * ... * x  and by convention,  0! = 1 . For example,  f(3) = 0  because  3! = 6  has no zeroes at the end, while  f(11) = 2  because  11! = 39916800  has two zeroes at the end. Given an integer  k , return the number of non-negative integers  x  have the property that  f(x) = k .   Example 1: Input:  k = 0 Output:  5 Explanation:  0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes. Example 2: Input:  k = 5 Output:  0 Explanation:  There is no x such that x! ends in k = 5 zeroes. Example 3: Input:  k = 3 Output:  5   Constraints: 0 <= k <= 10 9"
3317,https://leetcode.com/problems/find-the-number-of-possible-ways-for-an-event/,Difícil,Math,Find the Number of Possible Ways for an Event,"You are given three integers  n ,  x , and  y . An event is being held for  n  performers. When a performer arrives, they are  assigned  to one of the  x  stages. All performers assigned to the  same  stage will perform together as a band, though some stages  might  remain  empty . After all performances are completed, the jury will  award  each band a score in the range  [1, y] . Return the  total  number of possible ways the event can take place. Since the answer may be very large, return it  modulo   10 9  + 7 . Note  that two events are considered to have been held  differently  if  either  of the following conditions is satisfied: Any  performer is  assigned  a different stage. Any  band is  awarded  a different score.   Example 1: Input:   n = 1, x = 2, y = 3 Output:   6 Explanation: There are 2 ways to assign a stage to the performer. The jury can award a score of either 1, 2, or 3 to the only band. Example 2: Input:   n = 5, x = 2, y = 1 Output:  32 Explanation: Each performer will be assigned either stage 1 or stage 2. All bands will be awarded a score of 1. Example 3: Input:   n = 3, x = 3, y = 4 Output:  684   Constraints: 1 <= n, x, y <= 1000"
2231,https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/,Fácil,Sorting,Largest Number After Digit Swaps by Parity,"You are given a positive integer  num . You may swap any two digits of  num  that have the same  parity  (i.e. both odd digits or both even digits). Return  the  largest  possible value of  num  after  any  number of swaps.   Example 1: Input:  num = 1234 Output:  3412 Explanation:  Swap the digit 3 with the digit 1, this results in the number 3214. Swap the digit 2 with the digit 4, this results in the number 3412. Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number. Also note that we may not swap the digit 4 with the digit 1 since they are of different parities. Example 2: Input:  num = 65875 Output:  87655 Explanation:  Swap the digit 8 with the digit 6, this results in the number 85675. Swap the first digit 5 with the digit 7, this results in the number 87655. Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.   Constraints: 1 <= num <= 10 9"
341,https://leetcode.com/problems/flatten-nested-list-iterator/,Média,Stack,Flatten Nested List Iterator,"You are given a nested list of integers  nestedList . Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the  NestedIterator  class: NestedIterator(List<NestedInteger> nestedList)  Initializes the iterator with the nested list  nestedList . int next()  Returns the next integer in the nested list. boolean hasNext()  Returns  true  if there are still some integers in the nested list and  false  otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedList res = [] while iterator.hasNext()     append iterator.next() to the end of res return res If  res  matches the expected flattened list, then your code will be judged as correct.   Example 1: Input:  nestedList = [[1,1],2,[1,1]] Output:  [1,1,2,1,1] Explanation:  By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Input:  nestedList = [1,[4,[6]]] Output:  [1,4,6] Explanation:  By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].   Constraints: 1 <= nestedList.length <= 500 The values of the integers in the nested list is in the range  [-10 6 , 10 6 ] ."
482,https://leetcode.com/problems/license-key-formatting/,Fácil,String,License Key Formatting,"You are given a license key represented as a string  s  that consists of only alphanumeric characters and dashes. The string is separated into  n + 1  groups by  n  dashes. You are also given an integer  k . We want to reformat the string  s  such that each group contains exactly  k  characters, except for the first group, which could be shorter than  k  but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return  the reformatted license key .   Example 1: Input:  s = ""5F3Z-2e-9-w"", k = 4 Output:  ""5F3Z-2E9W"" Explanation:  The string s has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed. Example 2: Input:  s = ""2-5g-3-J"", k = 2 Output:  ""2-5G-3J"" Explanation:  The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.   Constraints: 1 <= s.length <= 10 5 s  consists of English letters, digits, and dashes  '-' . 1 <= k <= 10 4"
551,https://leetcode.com/problems/student-attendance-record-i/,Fácil,String,Student Attendance Record I,"You are given a string  s  representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: 'A' : Absent. 'L' : Late. 'P' : Present. The student is eligible for an attendance award if they meet  both  of the following criteria: The student was absent ( 'A' ) for  strictly  fewer than 2 days  total . The student was  never  late ( 'L' ) for 3 or more  consecutive  days. Return  true  if the student is eligible for an attendance award, or  false  otherwise .   Example 1: Input:  s = ""PPALLP"" Output:  true Explanation:  The student has fewer than 2 absences and was never late 3 or more consecutive days. Example 2: Input:  s = ""PPALLL"" Output:  false Explanation:  The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.   Constraints: 1 <= s.length <= 1000 s[i]  is either  'A' ,  'L' , or  'P' ."
796,https://leetcode.com/problems/rotate-string/,Fácil,String,Rotate String,"Given two strings  s  and  goal , return  true   if and only if   s   can become   goal   after some number of  shifts  on   s . A  shift  on  s  consists of moving the leftmost character of  s  to the rightmost position. For example, if  s = ""abcde"" , then it will be  ""bcdea""  after one shift.   Example 1: Input:  s = ""abcde"", goal = ""cdeab"" Output:  true Example 2: Input:  s = ""abcde"", goal = ""abced"" Output:  false   Constraints: 1 <= s.length, goal.length <= 100 s  and  goal  consist of lowercase English letters."
830,https://leetcode.com/problems/positions-of-large-groups/,Fácil,String,Positions of Large Groups,"In a string  s  of lowercase letters, these letters form consecutive groups of the same character. For example, a string like  s = ""abbxxxxzyy""  has the groups  ""a"" ,  ""bb"" ,  ""xxxx"" ,  ""z"" , and  ""yy"" . A group is identified by an interval  [start, end] , where  start  and  end  denote the start and end indices (inclusive) of the group. In the above example,  ""xxxx""  has the interval  [3,6] . A group is considered  large  if it has 3 or more characters. Return  the intervals of every  large  group sorted in  increasing order by start index .   Example 1: Input:  s = ""abbxxxxzzy"" Output:  [[3,6]] Explanation:   ""xxxx"" is the only  large group with start index 3 and end index 6. Example 2: Input:  s = ""abc"" Output:  [] Explanation:  We have groups ""a"", ""b"", and ""c"", none of which are large groups. Example 3: Input:  s = ""abcdddeeeeaabbbcd"" Output:  [[3,5],[6,9],[12,14]] Explanation:  The large groups are ""ddd"", ""eeee"", and ""bbb"".   Constraints: 1 <= s.length <= 1000 s  contains lowercase English letters only."
1047,https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/,Fácil,String,Remove All Adjacent Duplicates In String,"You are given a string  s  consisting of lowercase English letters. A  duplicate removal  consists of choosing two  adjacent  and  equal  letters and removing them. We repeatedly make  duplicate removals  on  s  until we no longer can. Return  the final string after all such duplicate removals have been made . It can be proven that the answer is  unique .   Example 1: Input:  s = ""abbaca"" Output:  ""ca"" Explanation:   For example, in ""abbaca"" we could remove ""bb"" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is ""aaca"", of which only ""aa"" is possible, so the final string is ""ca"". Example 2: Input:  s = ""azxxzy"" Output:  ""ay""   Constraints: 1 <= s.length <= 10 5 s  consists of lowercase English letters."
1078,https://leetcode.com/problems/occurrences-after-bigram/,Fácil,String,Occurrences After Bigram,"Given two strings  first  and  second , consider occurrences in some text of the form  ""first second third"" , where  second  comes immediately after  first , and  third  comes immediately after  second . Return  an array of all the words   third   for each occurrence of   ""first second third"" .   Example 1: Input:  text = ""alice is a good girl she is a good student"", first = ""a"", second = ""good"" Output:  [""girl"",""student""] Example 2: Input:  text = ""we will we will rock you"", first = ""we"", second = ""will"" Output:  [""we"",""rock""]   Constraints: 1 <= text.length <= 1000 text  consists of lowercase English letters and spaces. All the words in  text  are separated by  a single space . 1 <= first.length, second.length <= 10 first  and  second  consist of lowercase English letters. text  will not have any leading or trailing spaces."
1108,https://leetcode.com/problems/defanging-an-ip-address/,Fácil,String,Defanging an IP Address,"Given a valid (IPv4) IP  address , return a defanged version of that IP address. A  defanged IP address  replaces every period  "".""  with  ""[.]"" .   Example 1: Input:  address = ""1.1.1.1"" Output:  ""1[.]1[.]1[.]1"" Example 2: Input:  address = ""255.100.50.0"" Output:  ""255[.]100[.]50[.]0""   Constraints: The given  address  is a valid IPv4 address."
2047,https://leetcode.com/problems/number-of-valid-words-in-a-sentence/,Fácil,String,Number of Valid Words in a Sentence,"A sentence consists of lowercase letters ( 'a'  to  'z' ), digits ( '0'  to  '9' ), hyphens ( '-' ), punctuation marks ( '!' ,  '.' , and  ',' ), and spaces ( ' ' ) only. Each sentence can be broken down into  one or more tokens  separated by one or more spaces  ' ' . A token is a valid word if  all three  of the following are true: It only contains lowercase letters, hyphens, and/or punctuation ( no  digits). There is  at most one  hyphen  '-' . If present, it  must  be surrounded by lowercase characters ( ""a-b""  is valid, but  ""-ab""  and  ""ab-""  are not valid). There is  at most one  punctuation mark. If present, it  must  be at the  end  of the token ( ""ab,"" ,  ""cd!"" , and  "".""  are valid, but  ""a!b""  and  ""c.,""  are not valid). Examples of valid words include  ""a-b."" ,  ""afad"" ,  ""ba-c"" ,  ""a!"" , and  ""!"" . Given a string  sentence , return  the  number  of valid words in  sentence .   Example 1: Input:  sentence = "" cat   and    dog "" Output:  3 Explanation:  The valid words in the sentence are ""cat"", ""and"", and ""dog"". Example 2: Input:  sentence = ""!this  1-s b8d!"" Output:  0 Explanation:  There are no valid words in the sentence. ""!this"" is invalid because it starts with a punctuation mark. ""1-s"" and ""b8d"" are invalid because they contain digits. Example 3: Input:  sentence = "" alice   and    bob   are   playing  stone-game10"" Output:  5 Explanation:  The valid words in the sentence are ""alice"", ""and"", ""bob"", ""are"", and ""playing"". ""stone-game10"" is invalid because it contains digits.   Constraints: 1 <= sentence.length <= 1000 sentence  only contains lowercase English letters, digits,  ' ' ,  '-' ,  '!' ,  '.' , and  ',' . There will be at least  1  token."
2124,https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/,Fácil,String,Check if All A's Appears Before All B's,"Given a string  s  consisting of  only  the characters  'a'  and  'b' , return  true   if  every   'a'   appears before  every   'b'  in the string . Otherwise, return  false .   Example 1: Input:  s = ""aaabbb"" Output:  true Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true. Example 2: Input:  s = ""abab"" Output:  false Explanation: There is an 'a' at index 2 and a 'b' at index 1. Hence, not every 'a' appears before every 'b' and we return false. Example 3: Input:  s = ""bbb"" Output:  true Explanation: There are no 'a's, hence, every 'a' appears before every 'b' and we return true.   Constraints: 1 <= s.length <= 100 s[i]  is either  'a'  or  'b' ."
2609,https://leetcode.com/problems/find-the-longest-balanced-substring-of-a-binary-string/,Fácil,String,Find the Longest Balanced Substring of a Binary String,"You are given a binary string  s  consisting only of zeroes and ones. A substring of  s  is considered balanced if  all zeroes are before ones  and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring. Return  the length of the longest balanced substring of  s . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""01000111"" Output:  6 Explanation:  The longest balanced substring is ""000111"", which has length 6. Example 2: Input:  s = ""00111"" Output:  4 Explanation:  The longest balanced substring is ""0011"", which has length 4.  Example 3: Input:  s = ""111"" Output:  0 Explanation:  There is no balanced substring except the empty substring, so the answer is 0.   Constraints: 1 <= s.length <= 50 '0' <= s[i] <= '1'"
2810,https://leetcode.com/problems/faulty-keyboard/,Fácil,String,Faulty Keyboard,"Your laptop keyboard is faulty, and whenever you type a character  'i'  on it, it reverses the string that you have written. Typing other characters works as expected. You are given a  0-indexed  string  s , and you type each character of  s  using your faulty keyboard. Return  the final string that will be present on your laptop screen.   Example 1: Input:  s = ""string"" Output:  ""rtsng"" Explanation:   After typing first character, the text on the screen is ""s"". After the second character, the text is ""st"".  After the third character, the text is ""str"". Since the fourth character is an 'i', the text gets reversed and becomes ""rts"". After the fifth character, the text is ""rtsn"".  After the sixth character, the text is ""rtsng"".  Therefore, we return ""rtsng"". Example 2: Input:  s = ""poiinter"" Output:  ""ponter"" Explanation:   After the first character, the text on the screen is ""p"". After the second character, the text is ""po"".  Since the third character you type is an 'i', the text gets reversed and becomes ""op"".  Since the fourth character you type is an 'i', the text gets reversed and becomes ""po"". After the fifth character, the text is ""pon"". After the sixth character, the text is ""pont"".  After the seventh character, the text is ""ponte"".  After the eighth character, the text is ""ponter"".  Therefore, we return ""ponter"".   Constraints: 1 <= s.length <= 100 s  consists of lowercase English letters. s[0] != 'i'"
3114,https://leetcode.com/problems/latest-time-you-can-obtain-after-replacing-characters/,Fácil,String,Latest Time You Can Obtain After Replacing Characters,"You are given a string  s  representing a 12-hour format time where some of the digits (possibly none) are replaced with a  ""?"" . 12-hour times are formatted as  ""HH:MM"" , where  HH  is between  00  and  11 , and  MM  is between  00  and  59 . The earliest 12-hour time is  00:00 , and the latest is  11:59 . You have to replace  all  the  ""?""  characters in  s  with digits such that the time we obtain by the resulting string is a  valid  12-hour format time and is the  latest  possible. Return  the resulting string .   Example 1: Input:   s = ""1?:?4"" Output:   ""11:54"" Explanation:  The latest 12-hour format time we can achieve by replacing  ""?""  characters is  ""11:54"" . Example 2: Input:   s = ""0?:5?"" Output:   ""09:59"" Explanation:  The latest 12-hour format time we can achieve by replacing  ""?""  characters is  ""09:59"" .   Constraints: s.length == 5 s[2]  is equal to the character  "":"" . All characters except  s[2]  are digits or  ""?""  characters. The input is generated such that there is  at least  one time between  ""00:00""  and  ""11:59""  that you can obtain after replacing the  ""?""  characters."
3174,https://leetcode.com/problems/clear-digits/,Fácil,String,Clear Digits,"You are given a string  s . Your task is to remove  all  digits by doing this operation repeatedly: Delete the  first  digit and the  closest   non-digit  character to its  left . Return the resulting string after removing all digits. Note  that the operation  cannot  be performed on a digit that does not have any non-digit character to its left.   Example 1: Input:   s = ""abc"" Output:   ""abc"" Explanation: There is no digit in the string. Example 2: Input:   s = ""cb34"" Output:   """" Explanation: First, we apply the operation on  s[2] , and  s  becomes  ""c4"" . Then we apply the operation on  s[1] , and  s  becomes  """" .   Constraints: 1 <= s.length <= 100 s  consists only of lowercase English letters and digits. The input is generated such that it is possible to delete all digits."
1081,https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/,Média,String,Smallest Subsequence of Distinct Characters,"Given a string  s , return  the  lexicographically smallest   subsequence  of   s   that contains all the distinct characters of   s   exactly once .   Example 1: Input:  s = ""bcabc"" Output:  ""abc"" Example 2: Input:  s = ""cbacdcbc"" Output:  ""acdb""   Constraints: 1 <= s.length <= 1000 s  consists of lowercase English letters.   Note:  This question is the same as 316:  https://leetcode.com/problems/remove-duplicate-letters/"
1190,https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/,Média,String,Reverse Substrings Between Each Pair of Parentheses,"You are given a string  s  that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should  not  contain any brackets.   Example 1: Input:  s = ""(abcd)"" Output:  ""dcba"" Example 2: Input:  s = ""(u(love)i)"" Output:  ""iloveu"" Explanation:  The substring ""love"" is reversed first, then the whole string is reversed. Example 3: Input:  s = ""(ed(et(oc))el)"" Output:  ""leetcode"" Explanation:  First, we reverse the substring ""oc"", then ""etco"", and finally, the whole string.   Constraints: 1 <= s.length <= 2000 s  only contains lower case English characters and parentheses. It is guaranteed that all parentheses are balanced."
1249,https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/,Média,String,Minimum Remove to Make Valid Parentheses,"Given a string  s  of  '('  ,  ')'  and lowercase English characters. Your task is to remove the minimum number of parentheses (  '('  or  ')' , in any positions ) so that the resulting  parentheses string  is valid and return  any  valid string. Formally, a  parentheses string  is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as  AB  ( A  concatenated with  B ), where  A  and  B  are valid strings, or It can be written as  (A) , where  A  is a valid string.   Example 1: Input:  s = ""lee(t(c)o)de)"" Output:  ""lee(t(c)o)de"" Explanation:  ""lee(t(co)de)"" , ""lee(t(c)ode)"" would also be accepted. Example 2: Input:  s = ""a)b(c)d"" Output:  ""ab(c)d"" Example 3: Input:  s = ""))(("" Output:  """" Explanation:  An empty string is also valid.   Constraints: 1 <= s.length <= 10 5 s[i]  is either  '('  ,  ')' , or lowercase English letter."
1871,https://leetcode.com/problems/jump-game-vii/,Média,String,Jump Game VII,"You are given a  0-indexed  binary string  s  and two integers  minJump  and  maxJump . In the beginning, you are standing at index  0 , which is equal to  '0' . You can move from index  i  to index  j  if the following conditions are fulfilled: i + minJump <= j <= min(i + maxJump, s.length - 1) , and s[j] == '0' . Return  true  if you can reach index  s.length - 1  in  s , or  false  otherwise.   Example 1: Input:  s = "" 0 11 0 1 0 "", minJump = 2, maxJump = 3 Output:  true Explanation: In the first step, move from index 0 to index 3.  In the second step, move from index 3 to index 5. Example 2: Input:  s = ""01101110"", minJump = 2, maxJump = 3 Output:  false   Constraints: 2 <= s.length <= 10 5 s[i]  is either  '0'  or  '1' . s[0] == '0' 1 <= minJump <= maxJump < s.length"
2116,https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/,Média,String,Check if a Parentheses String Can Be Valid,"A parentheses string is a  non-empty  string consisting only of  '('  and  ')' . It is valid if  any  of the following conditions is  true : It is  () . It can be written as  AB  ( A  concatenated with  B ), where  A  and  B  are valid parentheses strings. It can be written as  (A) , where  A  is a valid parentheses string. You are given a parentheses string  s  and a string  locked , both of length  n .  locked  is a binary string consisting only of  '0' s and  '1' s. For  each  index  i  of  locked , If  locked[i]  is  '1' , you  cannot  change  s[i] . But if  locked[i]  is  '0' , you  can  change  s[i]  to either  '('  or  ')' . Return  true   if you can make  s  a valid parentheses string . Otherwise, return  false .   Example 1: Input:  s = ""))()))"", locked = ""010100"" Output:  true Explanation:  locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3]. We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid. Example 2: Input:  s = ""()()"", locked = ""0000"" Output:  true Explanation:  We do not need to make any changes because s is already valid. Example 3: Input:  s = "")"", locked = ""0"" Output:  false Explanation:  locked permits us to change s[0].  Changing s[0] to either '(' or ')' will not make s valid. Example 4: Input:  s = ""(((())(((())"", locked = ""111111010111"" Output:  true Explanation:  locked permits us to change s[6] and s[8].  We change s[6] and s[8] to ')' to make s valid.   Constraints: n == s.length == locked.length 1 <= n <= 10 5 s[i]  is either  '('  or  ')' . locked[i]  is either  '0'  or  '1' ."
2645,https://leetcode.com/problems/minimum-additions-to-make-valid-string/,Média,String,Minimum Additions to Make Valid String,"Given a string  word  to which you can insert letters ""a"", ""b"" or ""c"" anywhere and any number of times, return  the minimum number of letters that must be inserted so that  word  becomes  valid . A string is called  valid  if it can be formed by concatenating the string ""abc"" several times.   Example 1: Input:  word = ""b"" Output:  2 Explanation:  Insert the letter ""a"" right before ""b"", and the letter ""c"" right next to ""b"" to obtain the valid string "" a b c "". Example 2: Input:  word = ""aaa"" Output:  6 Explanation:  Insert letters ""b"" and ""c"" next to each ""a"" to obtain the valid string ""a bc a bc a bc "". Example 3: Input:  word = ""abc"" Output:  0 Explanation:  word is already valid. No modifications are needed.    Constraints: 1 <= word.length <= 50 word  consists of letters ""a"", ""b"" and ""c"" only."
2734,https://leetcode.com/problems/lexicographically-smallest-string-after-substring-operation/,Média,String,Lexicographically Smallest String After Substring Operation,"Given a string  s  consisting of lowercase English letters. Perform the following operation: Select any non-empty  substring  then replace every letter of the substring with the preceding letter of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'. Return the  lexicographically smallest  string  after performing the operation .   Example 1: Input:   s = ""cbabc"" Output:   ""baabc"" Explanation: Perform the operation on the substring starting at index 0, and ending at index 1 inclusive. Example 2: Input:   s = ""aa"" Output:   ""az"" Explanation: Perform the operation on the last letter. Example 3: Input:   s = ""acbbc"" Output:   ""abaab"" Explanation: Perform the operation on the substring starting at index 1, and ending at index 4 inclusive. Example 4: Input:   s = ""leetcode"" Output:   ""kddsbncd"" Explanation: Perform the operation on the entire string.   Constraints: 1 <= s.length <= 3 * 10 5 s  consists of lowercase English letters"
32,https://leetcode.com/problems/longest-valid-parentheses/,Difícil,String,Longest Valid Parentheses,"Given a string containing just the characters  '('  and  ')' , return  the length of the longest valid (well-formed) parentheses  substring .   Example 1: Input:  s = ""(()"" Output:  2 Explanation:  The longest valid parentheses substring is ""()"". Example 2: Input:  s = "")()())"" Output:  4 Explanation:  The longest valid parentheses substring is ""()()"". Example 3: Input:  s = """" Output:  0   Constraints: 0 <= s.length <= 3 * 10 4 s[i]  is  '(' , or  ')' ."
591,https://leetcode.com/problems/tag-validator/,Difícil,String,Tag Validator,"Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold: The code must be wrapped in a  valid closed tag . Otherwise, the code is invalid. A  closed tag  (not necessarily valid) has exactly the following format :  <TAG_NAME>TAG_CONTENT</TAG_NAME> . Among them,  <TAG_NAME>  is the start tag, and  </TAG_NAME>  is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is  valid  if and only if the TAG_NAME and TAG_CONTENT are valid. A  valid   TAG_NAME  only contain  upper-case letters , and has length in range [1,9]. Otherwise, the  TAG_NAME  is  invalid . A  valid   TAG_CONTENT  may contain other  valid closed tags ,  cdata  and any characters (see note1)  EXCEPT  unmatched  < , unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the  TAG_CONTENT  is  invalid . A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A  <  is unmatched if you cannot find a subsequent  > . And when you find a  <  or  </ , all the subsequent characters until the next  >  should be parsed as TAG_NAME (not necessarily valid). The cdata has the following format :  <![CDATA[CDATA_CONTENT]]> . The range of  CDATA_CONTENT  is defined as the characters between  <![CDATA[  and the  first subsequent   ]]> . CDATA_CONTENT  may contain  any characters . The function of cdata is to forbid the validator to parse  CDATA_CONTENT , so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as  regular characters .   Example 1: Input:  code = ""<DIV>This is the first line <![CDATA[<div>]]></DIV>"" Output:  true Explanation:   The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true. Example 2: Input:  code = ""<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"" Output:  true Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag ->  ""<DIV>"" end_tag ->  ""</DIV>"" tag_content could also be separated into : text1|cdata|text2. text1 ->  "">>  ![cdata[]] "" cdata ->  ""<![CDATA[<div>]>]]>"" , where the CDATA_CONTENT is  ""<div>]>"" text2 ->  ""]]>>]"" The reason why start_tag is NOT  ""<DIV>>>""  is because of the rule 6. The reason why cdata is NOT  ""<![CDATA[<div>]>]]>]]>""  is because of the rule 7. Example 3: Input:  code = ""<A>  <B> </A>   </B>"" Output:  false Explanation:  Unbalanced. If ""<A>"" is closed, then ""<B>"" must be unmatched, and vice versa.   Constraints: 1 <= code.length <= 500 code  consists of English letters, digits,  '<' ,  '>' ,  '/' ,  '!' ,  '[' ,  ']' ,  '.' , and  ' ' ."
639,https://leetcode.com/problems/decode-ways-ii/,Difícil,String,Decode Ways II,"A message containing letters from  A-Z  can be  encoded  into numbers using the following mapping: 'A' -> ""1"" 'B' -> ""2"" ... 'Z' -> ""26"" To  decode  an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example,  ""11106""  can be mapped into: ""AAJF""  with the grouping  (1 1 10 6) ""KJF""  with the grouping  (11 10 6) Note that the grouping  (1 11 06)  is invalid because  ""06""  cannot be mapped into  'F'  since  ""6""  is different from  ""06"" . In addition  to the mapping above, an encoded message may contain the  '*'  character, which can represent any digit from  '1'  to  '9'  ( '0'  is excluded). For example, the encoded message  ""1*""  may represent any of the encoded messages  ""11"" ,  ""12"" ,  ""13"" ,  ""14"" ,  ""15"" ,  ""16"" ,  ""17"" ,  ""18"" , or  ""19"" . Decoding  ""1*""  is equivalent to decoding  any  of the encoded messages it can represent. Given a string  s  consisting of digits and  '*'  characters, return  the  number  of ways to  decode  it . Since the answer may be very large, return it  modulo   10 9  + 7 .   Example 1: Input:  s = ""*"" Output:  9 Explanation:  The encoded message can represent any of the encoded messages ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", or ""9"". Each of these can be decoded to the strings ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", and ""I"" respectively. Hence, there are a total of 9 ways to decode ""*"". Example 2: Input:  s = ""1*"" Output:  18 Explanation:  The encoded message can represent any of the encoded messages ""11"", ""12"", ""13"", ""14"", ""15"", ""16"", ""17"", ""18"", or ""19"". Each of these encoded messages have 2 ways to be decoded (e.g. ""11"" can be decoded to ""AA"" or ""K""). Hence, there are a total of 9 * 2 = 18 ways to decode ""1*"". Example 3: Input:  s = ""2*"" Output:  15 Explanation:  The encoded message can represent any of the encoded messages ""21"", ""22"", ""23"", ""24"", ""25"", ""26"", ""27"", ""28"", or ""29"". ""21"", ""22"", ""23"", ""24"", ""25"", and ""26"" have 2 ways of being decoded, but ""27"", ""28"", and ""29"" only have 1 way. Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode ""2*"".   Constraints: 1 <= s.length <= 10 5 s[i]  is a digit or  '*' ."
1312,https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/,Difícil,String,Minimum Insertion Steps to Make a String Palindrome,"Given a string  s . In one step you can insert any character at any index of the string. Return  the minimum number of steps  to make  s  palindrome. A  Palindrome String  is one that reads the same backward as well as forward.   Example 1: Input:  s = ""zzazz"" Output:  0 Explanation:  The string ""zzazz"" is already palindrome we do not need any insertions. Example 2: Input:  s = ""mbadm"" Output:  2 Explanation:  String can be ""mbdadbm"" or ""mdbabdm"". Example 3: Input:  s = ""leetcode"" Output:  5 Explanation:  Inserting 5 characters the string becomes ""leetcodocteel"".   Constraints: 1 <= s.length <= 500 s  consists of lowercase English letters."
1392,https://leetcode.com/problems/longest-happy-prefix/,Difícil,String,Longest Happy Prefix,"A string is called a  happy prefix  if is a  non-empty  prefix which is also a suffix (excluding itself). Given a string  s , return  the  longest happy prefix  of   s . Return an empty string  """"  if no such prefix exists.   Example 1: Input:  s = ""level"" Output:  ""l"" Explanation:  s contains 4 prefix excluding itself (""l"", ""le"", ""lev"", ""leve""), and suffix (""l"", ""el"", ""vel"", ""evel""). The largest prefix which is also suffix is given by ""l"". Example 2: Input:  s = ""ababab"" Output:  ""abab"" Explanation:  ""abab"" is the largest prefix which is also suffix. They can overlap in the original string.   Constraints: 1 <= s.length <= 10 5 s  contains only lowercase English letters."
1745,https://leetcode.com/problems/palindrome-partitioning-iv/,Difícil,String,Palindrome Partitioning IV,"Given a string  s , return  true   if it is possible to split the string   s   into three  non-empty  palindromic substrings. Otherwise, return  false .​​​​​ A string is said to be palindrome if it the same string when reversed.   Example 1: Input:  s = ""abcbdd"" Output:  true Explanation:  ""abcbdd"" = ""a"" + ""bcb"" + ""dd"", and all three substrings are palindromes. Example 2: Input:  s = ""bcbddxy"" Output:  false Explanation:  s cannot be split into 3 palindromes.   Constraints: 3 <= s.length <= 2000 s ​​​​​​ consists only of lowercase English letters."
1977,https://leetcode.com/problems/number-of-ways-to-separate-numbers/,Difícil,String,Number of Ways to Separate Numbers,"You wrote down many  positive  integers in a string called  num . However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was  non-decreasing  and that  no  integer had leading zeros. Return  the  number of possible lists of integers  that you could have written down to get the string  num . Since the answer may be large, return it  modulo   10 9  + 7 .   Example 1: Input:  num = ""327"" Output:  2 Explanation:  You could have written down the numbers: 3, 27 327 Example 2: Input:  num = ""094"" Output:  0 Explanation:  No numbers can have leading zeros and all numbers must be positive. Example 3: Input:  num = ""0"" Output:  0 Explanation:  No numbers can have leading zeros and all numbers must be positive.   Constraints: 1 <= num.length <= 3500 num  consists of digits  '0'  through  '9' ."
2478,https://leetcode.com/problems/number-of-beautiful-partitions/,Difícil,String,Number of Beautiful Partitions,"You are given a string  s  that consists of the digits  '1'  to  '9'  and two integers  k  and  minLength . A partition of  s  is called  beautiful  if: s  is partitioned into  k  non-intersecting substrings. Each substring has a length of  at least   minLength . Each substring starts with a  prime  digit and ends with a  non-prime  digit. Prime digits are  '2' ,  '3' ,  '5' , and  '7' , and the rest of the digits are non-prime. Return  the number of  beautiful  partitions of  s . Since the answer may be very large, return it  modulo   10 9  + 7 . A  substring  is a contiguous sequence of characters within a string.   Example 1: Input:  s = ""23542185131"", k = 3, minLength = 2 Output:  3 Explanation:  There exists three ways to create a beautiful partition: ""2354 | 218 | 5131"" ""2354 | 21851 | 31"" ""2354218 | 51 | 31"" Example 2: Input:  s = ""23542185131"", k = 3, minLength = 3 Output:  1 Explanation:  There exists one way to create a beautiful partition: ""2354 | 218 | 5131"". Example 3: Input:  s = ""3312958"", k = 3, minLength = 1 Output:  1 Explanation:  There exists one way to create a beautiful partition: ""331 | 29 | 58"".   Constraints: 1 <= k, minLength <= s.length <= 1000 s  consists of the digits  '1'  to  '9' ."
110,https://leetcode.com/problems/balanced-binary-tree/,Fácil,Tree,Balanced Binary Tree,"Given a binary tree, determine if it is  height-balanced .   Example 1: Input:  root = [3,9,20,null,null,15,7] Output:  true Example 2: Input:  root = [1,2,2,3,3,null,null,4,4] Output:  false Example 3: Input:  root = [] Output:  true   Constraints: The number of nodes in the tree is in the range  [0, 5000] . -10 4  <= Node.val <= 10 4"
404,https://leetcode.com/problems/sum-of-left-leaves/,Fácil,Tree,Sum of Left Leaves,"Given the  root  of a binary tree, return  the sum of all left leaves. A  leaf  is a node with no children. A  left leaf  is a leaf that is the left child of another node.   Example 1: Input:  root = [3,9,20,null,null,15,7] Output:  24 Explanation:  There are two left leaves in the binary tree, with values 9 and 15 respectively. Example 2: Input:  root = [1] Output:  0   Constraints: The number of nodes in the tree is in the range  [1, 1000] . -1000 <= Node.val <= 1000"
637,https://leetcode.com/problems/average-of-levels-in-binary-tree/,Fácil,Tree,Average of Levels in Binary Tree,"Given the  root  of a binary tree, return  the average value of the nodes on each level in the form of an array . Answers within  10 -5  of the actual answer will be accepted.   Example 1: Input:  root = [3,9,20,null,null,15,7] Output:  [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2: Input:  root = [3,9,20,15,7] Output:  [3.00000,14.50000,11.00000]   Constraints: The number of nodes in the tree is in the range  [1, 10 4 ] . -2 31  <= Node.val <= 2 31  - 1"
783,https://leetcode.com/problems/minimum-distance-between-bst-nodes/,Fácil,Tree,Minimum Distance Between BST Nodes,"Given the  root  of a Binary Search Tree (BST), return  the minimum difference between the values of any two different nodes in the tree .   Example 1: Input:  root = [4,2,6,1,3] Output:  1 Example 2: Input:  root = [1,0,48,null,null,12,49] Output:  1   Constraints: The number of nodes in the tree is in the range  [2, 100] . 0 <= Node.val <= 10 5   Note:  This question is the same as 530:  https://leetcode.com/problems/minimum-absolute-difference-in-bst/"
965,https://leetcode.com/problems/univalued-binary-tree/,Fácil,Tree,Univalued Binary Tree,"A binary tree is  uni-valued  if every node in the tree has the same value. Given the  root  of a binary tree, return  true  if the given tree is  uni-valued , or  false  otherwise.   Example 1: Input:  root = [1,1,1,1,1,null,1] Output:  true Example 2: Input:  root = [2,2,2,5,2] Output:  false   Constraints: The number of nodes in the tree is in the range  [1, 100] . 0 <= Node.val < 100"
98,https://leetcode.com/problems/validate-binary-search-tree/,Média,Tree,Validate Binary Search Tree,"Given the  root  of a binary tree,  determine if it is a valid binary search tree (BST) . A  valid BST  is defined as follows: The left  subtree  of a node contains only nodes with keys  less than  the node's key. The right subtree of a node contains only nodes with keys  greater than  the node's key. Both the left and right subtrees must also be binary search trees.   Example 1: Input:  root = [2,1,3] Output:  true Example 2: Input:  root = [5,1,4,null,null,3,6] Output:  false Explanation:  The root node's value is 5 but its right child's value is 4.   Constraints: The number of nodes in the tree is in the range  [1, 10 4 ] . -2 31  <= Node.val <= 2 31  - 1"
102,https://leetcode.com/problems/binary-tree-level-order-traversal/,Média,Tree,Binary Tree Level Order Traversal,"Given the  root  of a binary tree, return  the level order traversal of its nodes' values . (i.e., from left to right, level by level).   Example 1: Input:  root = [3,9,20,null,null,15,7] Output:  [[3],[9,20],[15,7]] Example 2: Input:  root = [1] Output:  [[1]] Example 3: Input:  root = [] Output:  []   Constraints: The number of nodes in the tree is in the range  [0, 2000] . -1000 <= Node.val <= 1000"
103,https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/,Média,Tree,Binary Tree Zigzag Level Order Traversal,"Given the  root  of a binary tree, return  the zigzag level order traversal of its nodes' values . (i.e., from left to right, then right to left for the next level and alternate between).   Example 1: Input:  root = [3,9,20,null,null,15,7] Output:  [[3],[20,9],[15,7]] Example 2: Input:  root = [1] Output:  [[1]] Example 3: Input:  root = [] Output:  []   Constraints: The number of nodes in the tree is in the range  [0, 2000] . -100 <= Node.val <= 100"
538,https://leetcode.com/problems/convert-bst-to-greater-tree/,Média,Tree,Convert BST to Greater Tree,"Given the  root  of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a  binary search tree  is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys  less than  the node's key. The right subtree of a node contains only nodes with keys  greater than  the node's key. Both the left and right subtrees must also be binary search trees.   Example 1: Input:  root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output:  [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input:  root = [0,null,1] Output:  [1,null,1]   Constraints: The number of nodes in the tree is in the range  [0, 10 4 ] . -10 4  <= Node.val <= 10 4 All the values in the tree are  unique . root  is guaranteed to be a valid binary search tree.   Note:  This question is the same as 1038:  https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/"
1038,https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/,Média,Tree,Binary Search Tree to Greater Sum Tree,"Given the  root  of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a  binary search tree  is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys  less than  the node's key. The right subtree of a node contains only nodes with keys  greater than  the node's key. Both the left and right subtrees must also be binary search trees.   Example 1: Input:  root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output:  [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input:  root = [0,null,1] Output:  [1,null,1]   Constraints: The number of nodes in the tree is in the range  [1, 100] . 0 <= Node.val <= 100 All the values in the tree are  unique .   Note:  This question is the same as 538:  https://leetcode.com/problems/convert-bst-to-greater-tree/"
1302,https://leetcode.com/problems/deepest-leaves-sum/,Média,Tree,Deepest Leaves Sum,"Given the  root  of a binary tree, return  the sum of values of its deepest leaves .   Example 1: Input:  root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output:  15 Example 2: Input:  root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] Output:  19   Constraints: The number of nodes in the tree is in the range  [1, 10 4 ] . 1 <= Node.val <= 100"
1339,https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/,Média,Tree,Maximum Product of Splitted Binary Tree,"Given the  root  of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return  the maximum product of the sums of the two subtrees . Since the answer may be too large, return it  modulo   10 9  + 7 . Note  that you need to maximize the answer before taking the mod and not after taking it.   Example 1: Input:  root = [1,2,3,4,5,6] Output:  110 Explanation:  Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Example 2: Input:  root = [1,null,2,3,4,null,null,5,6] Output:  90 Explanation:  Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)   Constraints: The number of nodes in the tree is in the range  [2, 5 * 10 4 ] . 1 <= Node.val <= 10 4"
1609,https://leetcode.com/problems/even-odd-tree/,Média,Tree,Even Odd Tree,"A binary tree is named  Even-Odd  if it meets the following conditions: The root of the binary tree is at level index  0 , its children are at level index  1 , their children are at level index  2 , etc. For every  even-indexed  level, all nodes at the level have  odd  integer values in  strictly increasing  order (from left to right). For every  odd-indexed  level, all nodes at the level have  even  integer values in  strictly decreasing  order (from left to right). Given the  root  of a binary tree,  return  true  if the binary tree is  Even-Odd , otherwise return  false .   Example 1: Input:  root = [1,10,4,3,null,7,9,12,8,6,null,null,2] Output:  true Explanation:  The node values on each level are: Level 0: [1] Level 1: [10,4] Level 2: [3,7,9] Level 3: [12,8,6,2] Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd. Example 2: Input:  root = [5,4,2,3,3,7] Output:  false Explanation:  The node values on each level are: Level 0: [5] Level 1: [4,2] Level 2: [3,3,7] Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd. Example 3: Input:  root = [5,9,1,3,5,7] Output:  false Explanation:  Node values in the level 1 should be even integers.   Constraints: The number of nodes in the tree is in the range  [1, 10 5 ] . 1 <= Node.val <= 10 6"
1719,https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/,Difícil,Tree,Number Of Ways To Reconstruct A Tree,"You are given an array  pairs , where  pairs[i] = [x i , y i ] , and: There are no duplicates. x i  < y i Let  ways  be the number of rooted trees that satisfy the following conditions: The tree consists of nodes whose values appeared in  pairs . A pair  [x i , y i ]  exists in  pairs   if and only if   x i  is an ancestor of  y i  or  y i  is an ancestor of  x i . Note:  the tree does not have to be a binary tree. Two ways are considered to be different if there is at least one node that has different parents in both ways. Return: 0  if  ways == 0 1  if  ways == 1 2  if  ways > 1 A  rooted tree  is a tree that has a single root node, and all edges are oriented to be outgoing from the root. An  ancestor  of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.   Example 1: Input:  pairs = [[1,2],[2,3]] Output:  1 Explanation:  There is exactly one valid rooted tree, which is shown in the above figure. Example 2: Input:  pairs = [[1,2],[2,3],[1,3]] Output:  2 Explanation:  There are multiple valid rooted trees. Three of them are shown in the above figures. Example 3: Input:  pairs = [[1,2],[2,3],[2,4],[1,5]] Output:  0 Explanation:  There are no valid rooted trees.   Constraints: 1 <= pairs.length <= 10 5 1 <= x i  < y i  <= 500 The elements in  pairs  are unique."
557,https://leetcode.com/problems/reverse-words-in-a-string-iii/,Fácil,Two Pointers,Reverse Words in a String III,"Given a string  s , reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.   Example 1: Input:  s = ""Let's take LeetCode contest"" Output:  ""s'teL ekat edoCteeL tsetnoc"" Example 2: Input:  s = ""Mr Ding"" Output:  ""rM gniD""   Constraints: 1 <= s.length <= 5 * 10 4 s  contains printable  ASCII  characters. s  does not contain any leading or trailing spaces. There is  at least one  word in  s . All the words in  s  are separated by a single space."
1332,https://leetcode.com/problems/remove-palindromic-subsequences/,Fácil,Two Pointers,Remove Palindromic Subsequences,"You are given a string  s  consisting  only  of letters  'a'  and  'b' . In a single step you can remove one  palindromic subsequence  from  s . Return  the  minimum  number of steps to make the given string empty . A string is a  subsequence  of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does  not  necessarily need to be contiguous. A string is called  palindrome  if is one that reads the same backward as well as forward.   Example 1: Input:  s = ""ababa"" Output:  1 Explanation:  s is already a palindrome, so its entirety can be removed in a single step. Example 2: Input:  s = ""abb"" Output:  2 Explanation:  "" a bb"" -> "" bb "" -> """".  Remove palindromic subsequence ""a"" then ""bb"". Example 3: Input:  s = ""baabb"" Output:  2 Explanation:  "" baa b b "" -> "" b "" -> """".  Remove palindromic subsequence ""baab"" then ""b"".   Constraints: 1 <= s.length <= 1000 s[i]  is either  'a'  or  'b' ."
2697,https://leetcode.com/problems/lexicographically-smallest-palindrome/,Fácil,Two Pointers,Lexicographically Smallest Palindrome,"You are given a string  s  consisting of  lowercase English letters , and you are allowed to perform operations on it. In one operation, you can  replace  a character in  s  with another lowercase English letter. Your task is to make  s  a  palindrome  with the  minimum   number   of operations  possible. If there are  multiple palindromes  that can be  made using the  minimum  number of operations,  make the  lexicographically smallest  one. A string  a  is lexicographically smaller than a string  b  (of the same length) if in the first position where  a  and  b  differ, string  a  has a letter that appears earlier in the alphabet than the corresponding letter in  b . Return  the resulting palindrome string.   Example 1: Input:  s = ""egcfe"" Output:  ""efcfe"" Explanation:  The minimum number of operations to make ""egcfe"" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is ""efcfe"", by changing 'g'. Example 2: Input:  s = ""abcd"" Output:  ""abba"" Explanation:  The minimum number of operations to make ""abcd"" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is ""abba"". Example 3: Input:  s = ""seven"" Output:  ""neven"" Explanation:  The minimum number of operations to make ""seven"" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is ""neven"".   Constraints: 1 <= s.length <= 1000 s  consists of only lowercase English letters ."
443,https://leetcode.com/problems/string-compression/,Média,Two Pointers,String Compression,"Given an array of characters  chars , compress it using the following algorithm: Begin with an empty string  s . For each group of  consecutive repeating characters  in  chars : If the group's length is  1 , append the character to  s . Otherwise, append the character followed by the group's length. The compressed string  s   should not be returned separately , but instead, be stored  in the input character array  chars . Note that group lengths that are  10  or longer will be split into multiple characters in  chars . After you are done  modifying the input array,  return  the new length of the array . You must write an algorithm that uses only constant extra space.   Example 1: Input:  chars = [""a"",""a"",""b"",""b"",""c"",""c"",""c""] Output:  Return 6, and the first 6 characters of the input array should be: [""a"",""2"",""b"",""2"",""c"",""3""] Explanation:  The groups are ""aa"", ""bb"", and ""ccc"". This compresses to ""a2b2c3"". Example 2: Input:  chars = [""a""] Output:  Return 1, and the first character of the input array should be: [""a""] Explanation:  The only group is ""a"", which remains uncompressed since it's a single character. Example 3: Input:  chars = [""a"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b""] Output:  Return 4, and the first 4 characters of the input array should be: [""a"",""b"",""1"",""2""]. Explanation:  The groups are ""a"" and ""bbbbbbbbbbbb"". This compresses to ""ab12"".   Constraints: 1 <= chars.length <= 2000 chars[i]  is a lowercase English letter, uppercase English letter, digit, or symbol."
1163,https://leetcode.com/problems/last-substring-in-lexicographical-order/,Difícil,Two Pointers,Last Substring in Lexicographical Order,"Given a string  s , return  the last substring of   s   in lexicographical order .   Example 1: Input:  s = ""abab"" Output:  ""bab"" Explanation:  The substrings are [""a"", ""ab"", ""aba"", ""abab"", ""b"", ""ba"", ""bab""]. The lexicographically maximum substring is ""bab"". Example 2: Input:  s = ""leetcode"" Output:  ""tcode""   Constraints: 1 <= s.length <= 4 * 10 5 s  contains only lowercase English letters."
2565,https://leetcode.com/problems/subsequence-with-the-minimum-score/,Difícil,Two Pointers,Subsequence With the Minimum Score,"You are given two strings  s  and  t . You are allowed to remove any number of characters from the string  t . The score of the string is  0  if no characters are removed from the string  t , otherwise: Let  left  be the minimum index among all removed characters. Let  right  be the maximum index among all removed characters. Then the score of the string is  right - left + 1 . Return  the minimum possible score to make  t  a subsequence of  s . A  subsequence  of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,  ""ace""  is a subsequence of  "" a b c d e ""  while  ""aec""  is not).   Example 1: Input:  s = ""abacaba"", t = ""bzaa"" Output:  1 Explanation:  In this example, we remove the character ""z"" at index 1 (0-indexed). The string t becomes ""baa"" which is a subsequence of the string ""abacaba"" and the score is 1 - 1 + 1 = 1. It can be proven that 1 is the minimum score that we can achieve. Example 2: Input:  s = ""cde"", t = ""xyz"" Output:  3 Explanation:  In this example, we remove characters ""x"", ""y"" and ""z"" at indices 0, 1, and 2 (0-indexed). The string t becomes """" which is a subsequence of the string ""cde"" and the score is 2 - 0 + 1 = 3. It can be proven that 3 is the minimum score that we can achieve.   Constraints: 1 <= s.length, t.length <= 10 5 s  and  t  consist of only lowercase English letters."
